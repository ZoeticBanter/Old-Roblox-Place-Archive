<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0">
		<Properties>
			<Ref name="CurrentCamera">RBX1</Ref>
			<double name="DistributedGameTime">0</double>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Camera" referent="RBX1">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-1.8292532</X>
					<Y>6.6118679</Y>
					<Z>8.86100578</Z>
					<R00>0.709024787</R00>
					<R01>0.320145547</R01>
					<R02>-0.628323734</R02>
					<R10>-1.49011612e-008</R10>
					<R11>0.891007364</R11>
					<R12>0.45398894</R12>
					<R20>0.705183566</R20>
					<R21>-0.3218894</R21>
					<R22>0.631746292</R22>
				</CoordinateFrame>
				<CoordinateFrame name="Focus">
					<X>4</X>
					<Y>2.4000001</Y>
					<Z>3</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Camera</string>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX2">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2</X>
					<Y>126</Y>
					<Z>-2</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<string name="ClusterGridV2"></string>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Terrain</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GameRunner</string>
				<ProtectedString name="Source">function _G.GameRunner() script.Jumper.Changed:connect(function(pr,val) if pr == &apos;Source&apos; then local v = script.Jumper.Source; local name = v:gmatch(&quot;--(%a+)&quot;)(); print(&quot;UPDATE &quot;..name); script[name].Value = v; end end) end
--local script = game.Workspace.GameRunner; script.Jumper.Changed:connect(function(pr,val) if pr == &apos;Source&apos; then local v = script.Jumper.Source; local name = v:gmatch(&quot;--(%a+)&quot;)(); print(&quot;UPDATE &quot;..name); script[name].Value = v; end end)
function execute(scriptName)
&#9;local s = script[scriptName].Value
&#9;local f = assert(loadstring(s, scriptName))
&#9;setfenv(f, getfenv(0))
&#9;f()
end

execute &apos;main&apos;
execute &apos;user&apos;
execute &apos;mapprovider&apos;
execute &apos;action&apos;
execute &apos;unit&apos;
execute &apos;alliedroleset&apos;
execute &apos;gameview&apos;
execute &apos;gamestate&apos;

</ProtectedString>
			</Properties>
			<Item class="StringValue" referent="RBX4">
				<Properties>
					<string name="Name">main</string>
					<string name="Value">--main

function class(classname)
&#9;local global_class = {}
&#9;getfenv(0)[classname] = global_class
&#9;return function(ctor, global)
&#9;&#9;if ctor then
&#9;&#9;&#9;getfenv(0)[&apos;Make&apos;..classname] = function(...)
&#9;&#9;&#9;&#9;local instance = {}
&#9;&#9;&#9;&#9;ctor(instance, ...)
&#9;&#9;&#9;&#9;return instance
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if global then
&#9;&#9;&#9;global(global_class)
&#9;&#9;end
&#9;end
end


function iterValues(tb)
&#9;local k = nil
&#9;return function()
&#9;&#9;k = next(tb, k)
&#9;&#9;if k then
&#9;&#9;&#9;return tb[k]
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end
end


function Make(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end


class&apos;Signal&apos;(function(this)
&#9;local mListeners = {}
&#9;function this:fire(...)
&#9;&#9;for f, _ in pairs(mListeners) do
&#9;&#9;&#9;f(...)
&#9;&#9;end
&#9;end
&#9;function this:connect(func)
&#9;&#9;local conn = {}
&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;mListeners[func] = nil
&#9;&#9;end
&#9;&#9;mListeners[func] = conn
&#9;&#9;return conn
&#9;end
end)


class&apos;Disconnecter&apos;(function(this)
&#9;local mConns = {}
&#9;function this:add(conn)
&#9;&#9;mConns[#mConns+1] = conn
&#9;end
&#9;function this:disconnect()
&#9;&#9;for i, c in pairs(mConns) do
&#9;&#9;&#9;c:disconnect()
&#9;&#9;&#9;mConns[i] = nil
&#9;&#9;end
&#9;end
end)


class&apos;Debug&apos;(nil, function(def)
&#9;def.onFatal = MakeSignal()
&#9;def.onLog = MakeSignal()

&#9;local mLog = {}

&#9;function def:fatal(err)
&#9;&#9;def.onFatal:fire(err)
&#9;end
&#9;function def:log(msg)
&#9;&#9;def.onLog:fire(msg)
&#9;end
end)


class&apos;Player&apos;(function(this, Iplayer)
&#9;local mIFace = nil
&#9;local mKeyState = {}
&#9;--
&#9;this.onLeave = MakeSignal()
&#9;this.onChat = MakeSignal()
&#9;--
&#9;this.onMouseButton = MakeSignal()
&#9;this.onKey = MakeSignal()
&#9;this.onTarget = MakeSignal()
&#9;--
&#9;function this:getIPlayer()
&#9;&#9;return Iplayer
&#9;end
&#9;function this:getName()
&#9;&#9;return Iplayer.Name
&#9;end
&#9;--
&#9;function this:getKeyState(key)
&#9;&#9;return mKeyState[key] or false
&#9;end
&#9;function this:getUnitRay()
&#9;&#9;return mIFace.UnitRay.Value
&#9;end
&#9;function this:getTarget()
&#9;&#9;return mIFace.Target.Value
&#9;end
&#9;function this:getHit()
&#9;&#9;return mIFace.Hit.Value
&#9;end
&#9;function this:getIcon()
&#9;&#9;return mIFace.Icon.Value
&#9;end
&#9;function this:setIcon(icon)
&#9;&#9;mIFace.Icon.Value = icon
&#9;end
&#9;function this:setCameraSubject(obj)
&#9;&#9;mIFace.CameraSubject.Value = obj
&#9;end
&#9;function this:setCameraCFrame(at, lookat)
&#9;&#9;mIFace.CameraAt.Value = at
&#9;&#9;mIFace.CameraLook.Value = lookat
&#9;end

&#9;--
&#9;mIFace = Make&apos;ObjectValue&apos;{
&#9;&#9;Name = &apos;MouseInterface&apos;,
&#9;&#9;Parent = Iplayer,
&#9;&#9;--
&#9;&#9;Make&apos;BoolValue&apos;{Name = &apos;RightButton&apos;,},
&#9;&#9;Make&apos;RayValue&apos;{Name = &apos;UnitRay&apos;,},
&#9;&#9;Make&apos;ObjectValue&apos;{Name = &apos;Target&apos;,},
&#9;&#9;Make&apos;IntValue&apos;{Name = &apos;KeyContainer&apos;,},
&#9;&#9;Make&apos;Vector3Value&apos;{Name = &apos;Hit&apos;,},
&#9;&#9;Make&apos;StringValue&apos;{Name = &apos;Icon&apos;},
&#9;&#9;Make&apos;ObjectValue&apos;{Name = &apos;CameraSubject&apos;},
&#9;&#9;Make&apos;Vector3Value&apos;{Name = &apos;CameraAt&apos;},
&#9;&#9;Make&apos;Vector3Value&apos;{Name = &apos;CameraLook&apos;},
&#9;}
&#9;--
&#9;mIFace.RightButton.Changed:connect(function()
&#9;&#9;this.onMouseButton:fire(mIFace.RightButton.Value)
&#9;end)
&#9;mIFace.KeyContainer.ChildAdded:connect(function(ch)
&#9;&#9;local key = ch.Value
&#9;&#9;if ch.Name == &apos;down&apos; then
&#9;&#9;&#9;mKeyState[key] = true
&#9;&#9;&#9;this.onKey:fire(key, true)
&#9;&#9;elseif ch.Name == &apos;up&apos; then
&#9;&#9;&#9;mKeyState[key] = false
&#9;&#9;&#9;this.onKey:fire(key, false)
&#9;&#9;else
&#9;&#9;&#9;Debug:fatal(&quot;Bad key-object passed to MouseInterface&quot;)
&#9;&#9;end
&#9;&#9;ch:Destroy()
&#9;end)
&#9;mIFace.Target.Changed:connect(function()
&#9;&#9;this.onTarget:fire(mIFace.Target.Value)
&#9;end)

&#9;--
&#9;this.Gui = MakeMainGui(this)
&#9;this.onLeave:connect(function()
&#9;&#9;this.Gui:destroy()
&#9;end)
end)


class&apos;PlayerList&apos;(nil, function(def)
&#9;local mPlayers = {}
&#9;--
&#9;def.onAdd = MakeSignal()
&#9;def.onRem = MakeSignal()
&#9;--
&#9;function def:eachPlayer()
&#9;&#9;return iterValues(mPlayers)
&#9;end
&#9;--
&#9;game.Players.ChildAdded:connect(function(Ip)
&#9;&#9;local p = MakePlayer(Ip)
&#9;&#9;mPlayers[Ip] = p
&#9;&#9;def.onAdd:fire(p)
&#9;end) 
&#9;game.Players.ChildRemoved:connect(function(Ip)
&#9;&#9;local p = mPlayers[Ip]
&#9;&#9;mPlayers[Ip] = nil
&#9;&#9;def.onRem:fire(p)
&#9;&#9;p.onLeave:fire()
&#9;end)
end)


class&apos;OriginProvider&apos;(nil, function(def)
&#9;local mOriginList = setmetatable({}, {__mode=&apos;v&apos;})

&#9;function def:requestOrigin()
&#9;&#9;for i = 1, 100 do
&#9;&#9;&#9;if not mOriginList[i] then
&#9;&#9;&#9;&#9;local origin = Vector3.new(1000*i, 0, 0)
&#9;&#9;&#9;&#9;mOriginList[i] = origin
&#9;&#9;&#9;&#9;return origin
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)


class&apos;MatchSettings&apos;(function(this)
&#9;local mSettings = {
&#9;&#9;[MatchSettings.InProgress] =    nil,
&#9;&#9;[MatchSettings.GameLength] =    MatchSettings.GameLength.Default,
&#9;&#9;[MatchSettings.GameSize] =      MatchSettings.GameSize.Default,
&#9;&#9;[MatchSettings.StartingMoney] = MatchSettings.StartingMoney.Default,
&#9;}
&#9;local mPlayers = {}
&#9;local mPlayerCount = 0
&#9;local mQueuedForRemoval = false
&#9;--
&#9;this.onSettingChange = MakeSignal()
&#9;this.onPlayerAdd = MakeSignal()
&#9;this.onPlayerRem = MakeSignal()
&#9;--
&#9;function this:setSetting(setting, value)
&#9;&#9;local oldV = mSettings[setting]
&#9;&#9;mSettings[setting] = value
&#9;&#9;this.onSettingChange:fire(setting, value)
&#9;end
&#9;function this:getSetting(setting)
&#9;&#9;return mSettings[setting]
&#9;end
&#9;function this:addPlayer(p)
&#9;&#9;--turn off any queued for removal counts
&#9;&#9;mQueuedForRemoval = false

&#9;&#9;mPlayerCount = mPlayerCount + 1
&#9;&#9;--setting changed GameSize also fires for number of players, so:
&#9;&#9;this.onSettingChange:fire(MatchSettings.GameSize, 
&#9;&#9;                          this:getSetting(MatchSettings.GameSize))

&#9;&#9;mPlayers[p] = {}
&#9;&#9;mPlayers[p].ListenForLeaveSig = p.onLeave:connect(function()
&#9;&#9;&#9;this:remPlayer(p)
&#9;&#9;end)
&#9;&#9;--
&#9;&#9;if not this:getSetting(MatchSettings.Owner) then
&#9;&#9;&#9;this:setSetting(MatchSettings.Owner, p)
&#9;&#9;end
&#9;end
&#9;function this:remPlayer(p)
&#9;&#9;mPlayerCount = mPlayerCount - 1
&#9;&#9;--setting changed GameSize also fires for number of players, so:
&#9;&#9;this.onSettingChange:fire(MatchSettings.GameSize, 
&#9;&#9;                          this:getSetting(MatchSettings.GameSize))
&#9;&#9;
&#9;&#9;mPlayers[p].ListenForLeaveSig:disconnect()
&#9;&#9;mPlayers[p] = nil
&#9;&#9;if this:getSetting(MatchSettings.Owner) == p then
&#9;&#9;&#9;--the owner left, randomly choose a new owner
&#9;&#9;&#9;local possibleOwners = {}
&#9;&#9;&#9;for newPossibleOwner in this:eachPlayer() do
&#9;&#9;&#9;&#9;players[#players+1] = newPossibleOwner
&#9;&#9;&#9;end
&#9;&#9;&#9;if #possibleOwners &gt; 0 then
&#9;&#9;&#9;&#9;--randomly pick from posibilities
&#9;&#9;&#9;&#9;local newOwner = possibleOwners[math.random(1, #possibleOwners)]
&#9;&#9;&#9;&#9;this:setSetting(MatchSettings.Owner, newOwner)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--no-one left, nil the owner
&#9;&#9;&#9;&#9;this:setSetting(MatchSettings.Owner, nil)

&#9;&#9;&#9;&#9;--also, set a count to remove this from the lobby if no-one joins soon
&#9;&#9;&#9;&#9;mQueuedForRemoval = true
&#9;&#9;&#9;&#9;wait(3)
&#9;&#9;&#9;&#9;if mQueuedForRemoval then --if still queued, remove
&#9;&#9;&#9;&#9;&#9;Lobby:remMatch(this)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;---
&#9;function this:eachPlayer()
&#9;&#9;return iterValues(mPlayers)
&#9;end
&#9;function this:getPlayerCount()
&#9;&#9;return mPlayerCount
&#9;end
end, function(def)
&#9;def.GameLength = {
&#9;&#9;Short = {},
&#9;&#9;Medium = {},
&#9;&#9;Long = {},
&#9;&#9;UntilWon = {},
&#9;}
&#9;def.GameLength.Default = def.GameLength.Medium
&#9;--
&#9;def.GameSize = {
&#9;&#9;Small = {
&#9;&#9;&#9;PlayerCount = 2,
&#9;&#9;&#9;BoardSize = 64,
&#9;&#9;},
&#9;&#9;Medium = {
&#9;&#9;&#9;PlayerCount = 4,
&#9;&#9;&#9;BoardSize = 64,
&#9;&#9;},
&#9;&#9;Large = {
&#9;&#9;&#9;PlayerCount = 6,
&#9;&#9;&#9;BoardSize = 128
&#9;&#9;},
&#9;}
&#9;def.GameSize.Default = def.GameSize.Medium
&#9;--
&#9;def.StartingMoney = {
&#9;&#9;Poor = {},
&#9;&#9;Normal = {},
&#9;&#9;Rich = {},
&#9;}
&#9;def.StartingMoney.Default = def.StartingMoney.Normal
&#9;--
&#9;def.Owner = {}
&#9;def.InProgress = {}
end)


class&apos;Lobby&apos;(nil, function(def)
&#9;local mMatchList = {}
&#9;--
&#9;def.onAdd = MakeSignal()
&#9;def.onRem = MakeSignal()
&#9;--
&#9;function def:addMatch(settings)
&#9;&#9;mMatchList[settings] = true
&#9;&#9;def.onAdd:fire(settings)
&#9;end
&#9;function def:remMatch(settings)
&#9;&#9;mMatchList[settings] = nil
&#9;&#9;def.onRem:fire(settings)
&#9;end
&#9;function def:eachMatch()
&#9;&#9;return iterValues(mMatchList)
&#9;end
end)</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX5">
				<Properties>
					<string name="Name">user</string>
					<string name="Value">--user

class&apos;MainGui_Menu&apos;(function(this, parent)
&#9;this.onEnterLobby = MakeSignal()
&#9;this.onEnterHelp = MakeSignal()
&#9;this.onEnterInfo = MakeSignal()
&#9;--
&#9;local mGui = Make&apos;Frame&apos;{
&#9;&#9;Name = &apos;MainContainer&apos;,
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Visible = false,
&#9;&#9;Parent = parent,
&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;Name = &apos;EnterLobby&apos;,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 128, 32),
&#9;&#9;&#9;Position = UDim2.new(0.5, 0, -64, 16),
&#9;&#9;&#9;Text = &quot;Enter Lobby&quot;,
&#9;&#9;},
&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;Name = &apos;GetHelp&apos;,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 128, 32),
&#9;&#9;&#9;Position = UDim2.new(0.5, 0, -64, 80),
&#9;&#9;&#9;Text = &quot;Get Help!&quot;,
&#9;&#9;},
&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;Name = &apos;GetInfo&apos;,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 128, 32),
&#9;&#9;&#9;Position = UDim2.new(0.5, 0, -64, 144),
&#9;&#9;&#9;Text = &quot;Info about me&quot;,
&#9;&#9;},
&#9;}
&#9;--
&#9;mGui.EnterLobby.MouseButton1Down:connect(function()
&#9;&#9;this.onEnterLobby:fire()
&#9;end)
&#9;mGui.GetHelp.MouseButton1Down:connect(function()
&#9;&#9;this.onEnterHelp:fire()
&#9;end)
&#9;mGui.GetInfo.MouseButton1Down:connect(function()
&#9;&#9;this.onEnterInfo:fire()
&#9;end)
&#9;--
&#9;function this:show()
&#9;&#9;mGui.Visible = true
&#9;end
&#9;function this:hide()
&#9;&#9;mGui.Visible = false
&#9;end
&#9;function this:destroy()

&#9;end
end)


class&apos;MainGui_Lobby&apos;(function(this, parent)
&#9;this.onEnterGameSetup = MakeSignal()
&#9;this.onQuitToMenu = MakeSignal()
&#9;--
&#9;local mGui = Make&apos;Frame&apos;{
&#9;&#9;Name = &apos;MainContainer&apos;,
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Visible = false,
&#9;&#9;Parent = parent,
&#9;&#9;--
&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;RowBegin&apos;,
&#9;&#9;&#9;Position = UDim2.new(0, 0, 10, 10),
&#9;&#9;},
&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;Name = &apos;QuitToMenuButton&apos;,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 128, 32),
&#9;&#9;&#9;Position = UDim2.new(0.5, 1, -42, -64),
&#9;&#9;&#9;Text = &quot;Exit to main menu&quot;,
&#9;&#9;},
&#9;}
&#9;--
&#9;local mPrevRow = {
&#9;&#9;Gui = mGui.RowBegin,
&#9;&#9;Parent = nil,
&#9;&#9;Next = nil,
&#9;}
&#9;local mFirstRow = mPrevRow
&#9;local mMatchToRowMap = {}
&#9;--
&#9;local function updateSetting(row, setting)
&#9;&#9;if setting == MatchSettings.GameSize then
&#9;&#9;&#9;local maxPlayers = row.Match:getSetting(setting).PlayerCount
&#9;&#9;&#9;local players = row.Match:getPlayerCount()
&#9;&#9;&#9;row.Gui.PlayerCount = &quot;(&quot;..players..&quot; / &quot;..maxPlayers..&quot;)&quot;
&#9;&#9;else
&#9;&#9;&#9;assert(false, &apos;unreachable&apos;)
&#9;&#9;end
&#9;end
&#9;local function addMatch(match)
&#9;&#9;--make a new record
&#9;&#9;local record = {}
&#9;&#9;record.Parent = mPrevRow
&#9;&#9;mPrevRow.Next = record
&#9;&#9;mPrevRow = record

&#9;&#9;--initialize record
&#9;&#9;record.Match = match
&#9;&#9;mMatchToRowMap[match] = record

&#9;&#9;--make a gui
&#9;&#9;local row = Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;MatchDisplayRow&apos;,
&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;Position = UDim2.new(0, 0, 20, 0),
&#9;&#9;&#9;Size = UDim2.new(1, 0, -20, 20),
&#9;&#9;&#9;Parent = record.Parent.Gui,
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;Name = &apos;JoinButton&apos;,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 1, 0, 100),
&#9;&#9;&#9;&#9;Text = &quot;JOIN MATCH&quot;
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;Name = &apos;PlayerCount&apos;,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 100, 0),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 1, 0, 100),
&#9;&#9;&#9;},
&#9;&#9;}
&#9;&#9;record.Gui = row

&#9;&#9;--connect up events
&#9;&#9;record.ListenForSettings = match.onSettingChange:connect(function(setting, value)
&#9;&#9;&#9;updateSetting(record, setting)
&#9;&#9;end)
&#9;&#9;record.Gui.JoinButton.MouseButton1Down:connect(function()
&#9;&#9;&#9;this.onEnterGameSetup:fire(match)
&#9;&#9;end)

&#9;&#9;--prompt update of stats
&#9;&#9;updateSetting(record, MatchSettings.GameSize)
&#9;end
&#9;local function remMatch(match)
&#9;&#9;--get the record and remove it from the map
&#9;&#9;local record = mMatchToRowMap[match]
&#9;&#9;mMatchToRowMap[match] = nil

&#9;&#9;--kill the listening function
&#9;&#9;record.ListenForSettings:disconnect()

&#9;&#9;--kill the gui and linked-list node
&#9;&#9;record.Gui:Destroy()
&#9;&#9;if record.Next then
&#9;&#9;&#9;record.Next.Parent = record.Parent
&#9;&#9;&#9;record.Next.Gui.Parent = record.Parent.Gui
&#9;&#9;else
&#9;&#9;&#9;mPrevRow = record.Parent
&#9;&#9;end
&#9;&#9;record.Parent.Next = record.Next

&#9;&#9;--done, the node will be removed eventually by the GC
&#9;end

&#9;local mConns = MakeDisconnecter()
&#9;mConns:add(Lobby.onRem:connect(remMatch))
&#9;mConns:add(Lobby.onAdd:connect(addMatch))
&#9;for match in Lobby:eachMatch() do
&#9;&#9;addMatch(match)
&#9;end
&#9;--
&#9;mGui.QuitToMenuButton.MouseButton1Down:connect(function()
&#9;&#9;this.onQuitToMenu:fire()
&#9;end)
&#9;--
&#9;function this:show()
&#9;&#9;mGui.Visible = true
&#9;end
&#9;function this:hide()
&#9;&#9;mConns:disconnect()
&#9;&#9;--kill list of rows
&#9;&#9;if mFirstRow.Next then
&#9;&#9;&#9;mFirstRow.Next.Gui:Destroy()
&#9;&#9;&#9;mFirstRow.Next = nil
&#9;&#9;end
&#9;&#9;mPrevRow = mFirstRow

&#9;&#9;mGui.Visible = false
&#9;end&#9;
&#9;function this:destroy()
&#9;&#9;mConns:disconnect()
&#9;end
end)


class&apos;MainGui_Help&apos;(function(this, parent)
&#9;this.onQuitToMenu = MakeSignal()
&#9;--
&#9;function this:show()

&#9;end
&#9;function this:hide()

&#9;end
&#9;function this:destroy()

&#9;end
end)


class&apos;MainGui_Info&apos;(function(this, parent)
&#9;this.onQuitToMenu = MakeSignal()
&#9;--
&#9;function this:show()

&#9;end
&#9;function this:hide()

&#9;end
&#9;function this:destroy()

&#9;end
end)


class&apos;MainGui_SetupGame&apos;(function(this, parent, player)
&#9;this.onQuitToLobby = MakeSignal()
&#9;this.onStartMatch = MakeSignal()
&#9;--
&#9;local mCanStartGame = true
&#9;local mCantStartReason = &quot;&quot;
&#9;local mMatch = nil
&#9;--
&#9;local mGui = Make&apos;Frame&apos;{
&#9;&#9;Name = &apos;MainContainer&apos;,
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Visible = false,
&#9;&#9;Parent = parent,
&#9;&#9;Size = UDim2.new(1, 1, 0, 0),
&#9;&#9;--
&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;PlayerListContainer&apos;,
&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;Size = UDim2.new(0, 1, 150, 0),
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;Name = &apos;BasePlayerEntry&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 0, 0, 32),
&#9;&#9;&#9;&#9;Text = &quot;Players:&quot;,
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;Divider&apos;,
&#9;&#9;&#9;Position = UDim2.new(0, 0, 150, 0),
&#9;&#9;&#9;Size = UDim2.new(0, 1, 1, 0),
&#9;&#9;&#9;BorderSizePixel = 0,
&#9;&#9;&#9;BackgroundColor3 = Color3.new(1, 0, 0),
&#9;&#9;},
&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;GameSettingsContainer&apos;,
&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;Size = UDim2.new(0, 1, 350, 0),
&#9;&#9;&#9;Position = UDim2.new(0, 0, 150, 0),
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;&#9;Name = &apos;GameSizeSetting&apos;,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 32),
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;SizeLabel&apos;,
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0.25, 1, 0, 0),
&#9;&#9;&#9;&#9;&#9;Text = &quot;Players: &quot;,
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;SizeSmall&apos;,
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.25, 0, 0, 0),
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0.25, 1, 0, 0),
&#9;&#9;&#9;&#9;&#9;Text = &quot;Small: 2&quot;,
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;SizeMedium&apos;,
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.50, 0, 0, 0),
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0.25, 1, 0, 0),
&#9;&#9;&#9;&#9;&#9;Text = &quot;Medium: 4&quot;,
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;SizeLarge&apos;,
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.75, 0, 0, 0),
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0.25, 0, 0, 0),
&#9;&#9;&#9;&#9;&#9;Text = &quot;Large: 6&quot;,
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;},
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;Name = &apos;ExitToLobbyButton&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 0.5,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 1, 0, -32),
&#9;&#9;&#9;&#9;Size = UDim2.new(0.5, 0, 0, 32),
&#9;&#9;&#9;&#9;Text = &quot;Exit to Lobby&quot;,
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;Name = &apos;StartGameButton&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 0.5,
&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, 1, 0, -32),
&#9;&#9;&#9;&#9;Size = UDim2.new(0.5, 0, 0, 32),
&#9;&#9;&#9;&#9;Text = &quot;&lt;You shouldn&apos;t be reading this&gt;&quot;,
&#9;&#9;&#9;},
&#9;&#9;},
&#9;}

&#9;local mLastPlayerEntry = {
&#9;&#9;Parent = nil,
&#9;&#9;Next = nil,
&#9;&#9;Gui = mGui.PlayerListContainer.BasePlayerEntry,
&#9;}
&#9;local mFirstPlayerEntry = mLastPlayerEntry
&#9;local mPlayerToEntryMap = {}

&#9;--general functions
&#9;local function updateStartGameButton()
&#9;&#9;if mCanStartGame then
&#9;&#9;&#9;--if I&apos;m the onwer, I can start the game
&#9;&#9;&#9;if mMatch:getSetting(MatchSettings.Owner) == player then
&#9;&#9;&#9;&#9;mGui.GameSettingsContainer.StartGameButton.Text =
&#9;&#9;&#9;&#9;&#9;&quot;Start the game&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--otherwise, wait for the owner
&#9;&#9;&#9;&#9;local ownerName = mMatch:getSetting(MatchSettings.Owner):getName()
&#9;&#9;&#9;&#9;mGui.GameSettingsContainer.StartGameButton.Text =
&#9;&#9;&#9;&#9;&#9;&quot;Waiting for &quot;..ownerName..&quot; to start the game&quot;
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;mGui.GameSettingsContainer.StartGameButton.Text =
&#9;&#9;&#9;&#9;mCantStartReason&#9;&#9;&#9;
&#9;&#9;end
&#9;end
&#9;local function updatePlayerListKickButtons()
&#9;&#9;local amOwner = (mMatch:getSetting(MatchSettings.Owner) == player)
&#9;&#9;local entry = mLastPlayerEntry
&#9;&#9;while entry.Parent do
&#9;&#9;&#9;if amOwner and entry.Player ~= player then
&#9;&#9;&#9;&#9;entry.Gui.KickButton.Visible = true
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;entry.Gui.KickButton.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;entry = entry.Parent
&#9;&#9;end
&#9;end
&#9;local function updateSetting(setting, value)
&#9;&#9;if setting == MatchSettings.GameSize then
&#9;&#9;&#9;if mMatch:getPlayerCount() &gt; value.PlayerCount then
&#9;&#9;&#9;&#9;mCanStartGame = false
&#9;&#9;&#9;&#9;mCantStartReason = &quot;Too many players to start!&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mCanStartGame = true
&#9;&#9;&#9;end
&#9;&#9;&#9;updateStartGameButton()
&#9;&#9;&#9;updatePlayerListKickButtons()
&#9;&#9;elseif setting == MatchSettings.Owner then
&#9;&#9;&#9;updateStartGameButton()
&#9;&#9;&#9;updatePlayerListKickButtons()
&#9;&#9;end
&#9;end
&#9;local function setSetting(setting, value)
&#9;&#9;if mMatch:getSetting(MatchSettings.Owner) == player then
&#9;&#9;&#9;mMatch:setSetting(setting, value)
&#9;&#9;end
&#9;end
&#9;local function addPlayer(p)
&#9;&#9;local entry = {
&#9;&#9;&#9;Parent = mLastPlayerEntry,
&#9;&#9;&#9;Next = nil,
&#9;&#9;&#9;Player = p,
&#9;&#9;}
&#9;&#9;mLastPlayerEntry.Next = entry
&#9;&#9;mLastPlayerEntry = entry
&#9;&#9;mPlayerToEntryMap[p] = entry
&#9;&#9;--
&#9;&#9;entry.Gui = Make&apos;TextLabel&apos;{
&#9;&#9;&#9;Name = &apos;PlayerEntryGui&apos;,
&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 32),
&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 32),
&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;Text = p:getName(),
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;TextButton&apos;{
&#9;&#9;&#9;&#9;Name = &apos;KickButton&apos;,
&#9;&#9;&#9;&#9;Position = UDim2.new(1, 0, 8, -40),
&#9;&#9;&#9;&#9;Size = UDim2.new(40, 16),
&#9;&#9;&#9;&#9;Text = &quot;KICK&quot;,
&#9;&#9;&#9;&#9;BackgroundColor3 = Color3.new(1, 0, 0),
&#9;&#9;&#9;},
&#9;&#9;&#9;--
&#9;&#9;}
&#9;&#9;--
&#9;&#9;entry.Gui.Parent = entry.Parent.Gui
&#9;&#9;entry.Gui.KickButton.MouseButton1Down:connect(function()
&#9;&#9;&#9;if mMatch:getSetting(MatchSettings.Owner) == player then
&#9;&#9;&#9;&#9;mMatch:remPlayer(p)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;--
&#9;end
&#9;local function remPlayer(p)
&#9;&#9;local entry = mPlayerToEntryMap[p]
&#9;&#9;mPlayerToEntryMap[p] = nil
&#9;&#9;--
&#9;&#9;entry.Parent.Next = entry.Next
&#9;&#9;if entry.Next then
&#9;&#9;&#9;entry.Next.Parent = entry.Parent
&#9;&#9;&#9;entry.Next.Gui.Parent = entry.Parent.Gui
&#9;&#9;else
&#9;&#9;&#9;--change last
&#9;&#9;&#9;mLastPlayerEntry = entry.Parent
&#9;&#9;end
&#9;&#9;--
&#9;&#9;entry.Gui:Destroy()
&#9;end

&#9;--hook up events
&#9;do
&#9;&#9;local sizes = mGui.GameSettingsContainer.GameSizeSetting
&#9;&#9;sizes.SizeSmall.MouseButton1Down:connect(function()
&#9;&#9;&#9;setSetting(MatchSettings.GameSize, MatchSettings.GameSize.Small)
&#9;&#9;end)
&#9;&#9;sizes.SizeMedium.MouseButton1Down:connect(function()
&#9;&#9;&#9;setSetting(MatchSettings.GameSize, MatchSettings.GameSize.Medium)
&#9;&#9;end)
&#9;&#9;sizes.SizeLarge.MouseButton1Down:connect(function()
&#9;&#9;&#9;setSetting(MatchSettings.GameSize, MatchSettings.GameSize.Large)
&#9;&#9;end)
&#9;end

&#9;local mConns = MakeDisconnecter()

&#9;--add show/hiders
&#9;function this:show(match)
&#9;&#9;mMatch = match
&#9;&#9;mConns:add(match.onPlayerAdd:connect(addPlayer))
&#9;&#9;mConns:add(match.onPlayerRem:connect(remPlayer))
&#9;&#9;mConns:add(match.onSettingChange:connect(updateSetting))
&#9;&#9;for p in mMatch:eachPlayer() do
&#9;&#9;&#9;addPlayer(p)
&#9;&#9;end

&#9;&#9;--update settings to be current
&#9;&#9;updatePlayerListKickButtons()
&#9;&#9;updateSetting(MatchSettings.GameSize, mMatch:getSetting(MatchSettings.GameSize))
&#9;&#9;--
&#9;&#9;mGui.Visible = true
&#9;end
&#9;function this:hide()
&#9;&#9;mConns:disconnect()

&#9;&#9;--kill my list of matches
&#9;&#9;if mFirstPlayerEntry.Next then
&#9;&#9;&#9;mFirstPlayerEntry.Next.Gui:Destroy()
&#9;&#9;&#9;mFirstPlayerEntry.Next = nil
&#9;&#9;end
&#9;&#9;mLastPlayerEntry = mFirstPlayerEntry

&#9;&#9;mGui.Visible = false
&#9;end&#9;
&#9;function this:destroy()
&#9;&#9;mConns:disconnect()
&#9;end&#9;&#9;
end)

class&apos;MainGui&apos;(function(this, player)
&#9;--===================================
&#9;--===================================
&#9;repeat 
&#9;&#9;player:getIPlayer().ChildAdded:wait() 
&#9;until player:getIPlayer():FindFirstChild(&apos;PlayerGui&apos;)
&#9;--
&#9;local mScreenGui = Make&apos;ScreenGui&apos;{
&#9;&#9;Name = &apos;ConquestIV_MainPlayerGui&apos;,
&#9;&#9;Parent = player:getIPlayer().PlayerGui,
&#9;}

&#9;local mToplevelMenuFrame = Make&apos;Frame&apos;{
&#9;&#9;Parent = mScreenGui,
&#9;&#9;Name = &apos;CenteringFrame&apos;,
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Position = UDim2.new(0.5, 0.5, 0, 0),
&#9;&#9;Size = UDim2.new(0, 0, 0, 0),
&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;Name = &apos;ContentPanel&apos;,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 500, 300),
&#9;&#9;&#9;Position = UDim2.new(0, 0, -500, -300),
&#9;&#9;},
&#9;}

&#9;local mContentPanel = mToplevelMenuFrame.ContentPanel
&#9;--
&#9;local mMenuGui = MakeMainGui_Menu(mContentPanel)
&#9;local mLobbyGui = MakeMainGui_Lobby(mContentPanel)
&#9;local mHelpGui = MakeMainGui_Help(mContentPanel)
&#9;local mInfoGui = MakeMainGui_Info(mContentPanel)
&#9;local mSetupGameGui = MakeMainGui_SetupGame(mContentPanel, player)
&#9;--
&#9;--====================================================
&#9;-- Hook up various events
&#9;--
&#9;mMenuGui.onEnterLobby:connect(function()
&#9;&#9;mMenuGui:hide()
&#9;&#9;mLobbyGui:show()
&#9;end)
&#9;mMenuGui.onEnterHelp:connect(function()
&#9;&#9;mMenuGui:hide()
&#9;&#9;mHelpGui:show()
&#9;end)
&#9;mMenuGui.onEnterInfo:connect(function()
&#9;&#9;mMenuGui:hide()
&#9;&#9;mInfoGui:show()
&#9;end)
&#9;--
&#9;mLobbyGui.onEnterGameSetup:connect(function(match)
&#9;&#9;mLobbyGui:hide()
&#9;&#9;mSetupGameGui:show(match)
&#9;end)
&#9;mLobbyGui.onQuitToMenu:connect(function()
&#9;&#9;mLobbyGui:hide()
&#9;&#9;mMenuGui:show()
&#9;end)
&#9;--
&#9;mHelpGui.onQuitToMenu:connect(function()
&#9;&#9;mHelpGui:hide()
&#9;&#9;mLobbyGui:show()
&#9;end)
&#9;--
&#9;mInfoGui.onQuitToMenu:connect(function()
&#9;&#9;mInfoGui:hide()
&#9;&#9;mLobbyGui:show()
&#9;end)
&#9;--
&#9;mSetupGameGui.onQuitToLobby:connect(function()
&#9;&#9;mSetupGameGui:hide()
&#9;&#9;mLobbyGui:show()
&#9;end)
&#9;--
&#9;--=======================================================
&#9;-- And start off the gui interaction
&#9;--
&#9;--mMenuGui:show()
&#9;--for debugging, jump right to a thing
&#9;mToplevelMenuFrame.Visible = false
&#9;local team = MakeTeam(player)
&#9;local settings = MakeMatchSettings()
&#9;local gamestate = MakeGameState(settings, {team})
&#9;local gameview = MakeGameView(player, team, gamestate)

&#9;function this:destroy()
&#9;&#9;mMenuGui:destroy()
&#9;&#9;mLobbyGui:destroy()
&#9;&#9;mHelpGui:destroy()
&#9;&#9;mInfoGui:destroy()
&#9;&#9;mSetupGameGui:destroy()
&#9;&#9;gameview:destroy()
&#9;end
end)</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX6">
				<Properties>
					<string name="Name">mapprovider</string>
					<string name="Value">class&apos;MapProvider&apos;(nil, function(def)
&#9;def.SmallMap1 = {}
&#9;def.SmallMap1.Grid = {
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;__________________________________###########___________________&quot;,
&#9;&#9;&quot;_________________________######################_________________&quot;,
&#9;&#9;&quot;__________________###############################_______________&quot;,
&#9;&#9;&quot;__________############################################__________&quot;,
&#9;&#9;&quot;________#################################################_______&quot;,
&#9;&#9;&quot;__________########O#######################################______&quot;,
&#9;&#9;&quot;__________###############################################_______&quot;,
&#9;&#9;&quot;___________#############################################________&quot;,
&#9;&#9;&quot;___________############################################_________&quot;,
&#9;&#9;&quot;____________###########################################_________&quot;,
&#9;&#9;&quot;____________######################################O####_________&quot;,
&#9;&#9;&quot;____________##########################################__________&quot;,
&#9;&#9;&quot;________________###################################_____________&quot;,
&#9;&#9;&quot;_____________________##################_________________________&quot;,
&#9;&#9;&quot;__________________________######________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,&#9;&#9;&#9;
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;&#9;&quot;________________________________________________________________&quot;,
&#9;}
end)</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX7">
				<Properties>
					<string name="Name">gameview</string>
					<string name="Value">--gameview
--st
class&apos;BoardView&apos;(function(this, player, team, gamestate)
&#9;--
&#9;local mOrigin = OriginProvider:requestOrigin()
&#9;local mSurfaceOffsetFromOrigin = Vector3.new(0, 1, 0)
&#9;--
&#9;local mBoardScale = 1
&#9;local mBoardSize = gamestate:getBoardSize()
&#9;local mBoardContainer = Make&apos;Model&apos;{
&#9;&#9;Name = (&apos;Board_&apos;..player:getName()),
&#9;&#9;Parent = game.Workspace,
&#9;}
&#9;local mBoardTileMap = {}
&#9;local mNodeToConnMap = {}
&#9;--
&#9;local mHeightToBrickColorMap = {
&#9;&#9;[0] = BrickColor.new(Color3.new(0, 0, 1)),
&#9;&#9;[1] = BrickColor.new(Color3.new(0, 1, 0)),
&#9;&#9;[2] = BrickColor.new(Color3.new(0.5, 0, 0.5)),
&#9;}

&#9;--=========  selection parts ==============
&#9;local mSelectionDragPartX = Make&apos;Part&apos;{
&#9;&#9;Name = &apos;SelectionBoundsPart&apos;,
&#9;&#9;Parent = mBoardContainer,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;Anchored = true,
&#9;&#9;BrickColor = BrickColor.new(Color3.new(1, 0, 0)),
&#9;&#9;Transparency = 1,
&#9;}
&#9;local mSelectionDragPartY = mSelectionDragPartX:Clone()
&#9;mSelectionDragPartY.Parent = mBoardContainer
&#9;local mSelectionDragPartW = mSelectionDragPartX:Clone()
&#9;mSelectionDragPartW.Parent = mBoardContainer
&#9;local mSelectionDragPartH = mSelectionDragPartX:Clone()
&#9;mSelectionDragPartH.Parent = mBoardContainer

&#9;local mRectBoundPart = Make&apos;Part&apos;{
&#9;&#9;Name = &apos;BuildingBoundPart&apos;,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;Parent = mBoardContainer,
&#9;&#9;Anchored = true,
&#9;&#9;Transparency = 1,
&#9;}
&#9;--

&#9;local function translatePosToCoord(hit, exact)
&#9;&#9;hit = hit-mOrigin
&#9;&#9;hit = hit/mBoardScale
&#9;&#9;if 
&#9;&#9;&#9;hit.x &gt; 0 and hit.z &gt; 0 and 
&#9;&#9;&#9;hit.x &lt; mBoardSize and 
&#9;&#9;&#9;hit.z &lt; mBoardSize 
&#9;&#9;then
&#9;&#9;&#9;if exact then
&#9;&#9;&#9;&#9;return math.floor(hit.x)+1, math.floor(hit.z)+1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return hit.x+1, hit.z+1
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end
&#9;local function translateCoordToPos(qcx, qcy)
&#9;&#9;return mOrigin+Vector3.new((qcx-1)*mBoardScale, 0, (qcy-1)*mBoardScale)
&#9;end
&#9;local function cleanConnections()
&#9;&#9;for k, conn in pairs(mNodeToConnMap) do
&#9;&#9;&#9;conn:Destroy()
&#9;&#9;&#9;mNodeToConnMap[k] = nil
&#9;&#9;end
&#9;end
&#9;local function updateConnections(qnode)
&#9;&#9;qnode = qnode or gamestate:getRootQnode()
&#9;&#9;if qnode.Leaf then
&#9;&#9;&#9;local qnodePos = translateCoordToPos(qnode.X+qnode.HalfSize, qnode.Y+qnode.HalfSize)
&#9;&#9;&#9;for adj, dist in pairs(qnode.Adjacent) do
&#9;&#9;&#9;&#9;local adjPos = translateCoordToPos(adj.X+adj.HalfSize, adj.Y+adj.HalfSize)
&#9;&#9;&#9;&#9;local jdist = dist*mBoardScale
&#9;&#9;&#9;&#9;local join = Make&apos;Part&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;Connection&apos;,
&#9;&#9;&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;&#9;&#9;CanCollide = false,
&#9;&#9;&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;&#9;&#9;TopSurface = &apos;Smooth&apos;,
&#9;&#9;&#9;&#9;&#9;BottomSurface = &apos;Smooth&apos;,
&#9;&#9;&#9;&#9;&#9;Size = Vector3.new(0.1, 0.1, jdist),
&#9;&#9;&#9;&#9;&#9;BrickColor = BrickColor.new(21),
&#9;&#9;&#9;&#9;&#9;Parent = mBoardContainer,
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;join.CFrame = CFrame.new(qnodePos, adjPos)*CFrame.new(0,1,-jdist/2)
&#9;&#9;&#9;&#9;mNodeToConnMap[#mNodeToConnMap+1] = join
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;updateConnections(qnode.Children[1])
&#9;&#9;&#9;updateConnections(qnode.Children[2])
&#9;&#9;&#9;updateConnections(qnode.Children[3])
&#9;&#9;&#9;updateConnections(qnode.Children[4])
&#9;&#9;end
&#9;end
&#9;local function showQnode(qnode)
&#9;&#9;--print(&quot;Show QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;if mBoardTileMap[qnode] then
&#9;&#9;&#9;local part = mBoardTileMap[qnode]
&#9;&#9;&#9;print(qnode.Height)
&#9;&#9;&#9;part.BrickColor = mHeightToBrickColorMap[qnode.Height]
&#9;&#9;else
&#9;&#9;&#9;local p = Make&apos;Part&apos;{
&#9;&#9;&#9;&#9;Name = (&quot;QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;),
&#9;&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;&#9;CanCollide = false,
&#9;&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;&#9;TopSurface = &apos;Smooth&apos;,
&#9;&#9;&#9;&#9;BottomSurface = &apos;Smooth&apos;,
&#9;&#9;&#9;&#9;BrickColor = mHeightToBrickColorMap[qnode.Height],
&#9;&#9;&#9;&#9;Size = Vector3.new(qnode.Size*mBoardScale, 1, qnode.Size*mBoardScale),
&#9;&#9;&#9;&#9;Parent = mBoardContainer,
&#9;&#9;&#9;}
&#9;&#9;&#9;p.CFrame = CFrame.new(((qnode.X-1)+qnode.HalfSize)*mBoardScale,
&#9;&#9;&#9;                      0.5,
&#9;&#9;&#9;                      ((qnode.Y-1)+qnode.HalfSize)*mBoardScale)
&#9;&#9;&#9;           + mOrigin
&#9;&#9;&#9;mBoardTileMap[qnode] = p
&#9;&#9;end
&#9;end
&#9;local function hideQnode(qnode)
&#9;&#9;--print(&quot;Hide QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;if mBoardTileMap[qnode] then
&#9;&#9;&#9;mBoardTileMap[qnode]:Destroy()
&#9;&#9;&#9;mBoardTileMap[qnode] = nil
&#9;&#9;end
&#9;end
&#9;--show initial nodes
&#9;local function recursiveShow(qnode)
&#9;&#9;if qnode.Leaf then
&#9;&#9;&#9;showQnode(qnode)
&#9;&#9;else
&#9;&#9;&#9;recursiveShow(qnode.Children[1])
&#9;&#9;&#9;recursiveShow(qnode.Children[2])
&#9;&#9;&#9;recursiveShow(qnode.Children[3])
&#9;&#9;&#9;recursiveShow(qnode.Children[4])
&#9;&#9;end
&#9;end
&#9;recursiveShow(gamestate:getRootQnode())
&#9;gamestate.onQnodeShow:connect(showQnode)
&#9;gamestate.onQnodeHide:connect(hideQnode)

&#9;player.onMouseButton:connect(function(st)
&#9;&#9;local hitx, hity = translatePosToCoord(player:getHit(), false) --inexact
&#9;&#9;this.onMouseButton:fire(st, hitx, hity)
&#9;end)

&#9;player:setCameraSubject(nil)
&#9;local boardPos = 
&#9;&#9;CFrame.new(mOrigin+Vector3.new(mBoardSize*mBoardScale/2, 0, mBoardSize*mBoardScale/2))
&#9;player:setCameraCFrame((boardPos*CFrame.Angles(-math.pi/8, 0, 0)*CFrame.new(0, 0, 20)).p,
&#9;                        boardPos.p) 

&#9;--========================================================================
&#9;--========================================================================

&#9;function this:getMouseHit(exact)
&#9;&#9;return translatePosToCoord(player:getHit(), exact)
&#9;end
&#9;this.onMouseButton = MakeSignal()

&#9;function this:refreshConnections(show)
&#9;&#9;cleanConnections()
&#9;&#9;if show then
&#9;&#9;&#9;updateConnections()
&#9;&#9;end&#9;
&#9;end

&#9;function this:getContainer()
&#9;&#9;return mBoardContainer
&#9;end

&#9;function this:coordToPosition(x, y)
&#9;&#9;return translateCoordToPos(x, y)+mSurfaceOffsetFromOrigin
&#9;end

&#9;function this:MakeSelection(entity)
&#9;&#9;local selection = {}
&#9;&#9;local part = Make&apos;Part&apos;{
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Name = &apos;SelectionPart&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.2, 0.2, 1.2),
&#9;&#9;&#9;BrickColor = BrickColor.new(Color3.new(1, 0, 0)),
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Transparency = 0.3,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;}
&#9;&#9;part.Parent = mBoardContainer
&#9;&#9;part.CFrame = CFrame.new(this:coordToPosition(entity.MobileUnit:getPosition()))
&#9;&#9;--
&#9;&#9;local movedCn = entity.MobileUnit.onMove:connect(function(x, y)
&#9;&#9;&#9;part.CFrame = CFrame.new(this:coordToPosition(x, y))
&#9;&#9;end)
&#9;&#9;--
&#9;&#9;function selection:destroy()
&#9;&#9;&#9;movedCn:disconnect()
&#9;&#9;&#9;part:Destroy()
&#9;&#9;end
&#9;&#9;return selection
&#9;end
&#9;--
&#9;function this:setSelectionDrag(x, y, w, h)
&#9;&#9;local p1 = this:coordToPosition(x,   y  )
&#9;&#9;local p2 = this:coordToPosition(x+w, y  )
&#9;&#9;local p3 = this:coordToPosition(x+w, y+h)
&#9;&#9;local p4 = this:coordToPosition(x,   y+h)
&#9;&#9;local d12 = (p1-p2).magnitude
&#9;&#9;local d23 = (p2-p3).magnitude
&#9;&#9;local d34 = (p3-p4).magnitude
&#9;&#9;local d41 = (p4-p1).magnitude
&#9;&#9;--
&#9;&#9;mSelectionDragPartX.Transparency = 0
&#9;&#9;mSelectionDragPartY.Transparency = 0
&#9;&#9;mSelectionDragPartW.Transparency = 0
&#9;&#9;mSelectionDragPartH.Transparency = 0&#9;&#9;
&#9;&#9;--
&#9;&#9;mSelectionDragPartX.Size = Vector3.new(0.1, 0.1, d12)
&#9;&#9;mSelectionDragPartX.CFrame = CFrame.new(p1, p2)*CFrame.new(0, 0, -d12/2)
&#9;&#9;mSelectionDragPartY.Size = Vector3.new(0.1, 0.1, d23)
&#9;&#9;mSelectionDragPartY.CFrame = CFrame.new(p2, p3)*CFrame.new(0, 0, -d23/2)
&#9;&#9;mSelectionDragPartW.Size = Vector3.new(0.1, 0.1, d34)
&#9;&#9;mSelectionDragPartW.CFrame = CFrame.new(p3, p4)*CFrame.new(0, 0, -d34/2)
&#9;&#9;mSelectionDragPartH.Size = Vector3.new(0.1, 0.1, d41)
&#9;&#9;mSelectionDragPartH.CFrame = CFrame.new(p4, p1)*CFrame.new(0, 0, -d41/2)
&#9;end
&#9;function this:clearSelectionDrag()
&#9;&#9;mSelectionDragPartX.Transparency = 1
&#9;&#9;mSelectionDragPartY.Transparency = 1
&#9;&#9;mSelectionDragPartW.Transparency = 1
&#9;&#9;mSelectionDragPartH.Transparency = 1
&#9;end

&#9;function this:showBuildingBounds(x, y, w, h, color3)
&#9;&#9;local pos = this:coordToPosition(x+w/2, y+h/2)
&#9;&#9;w = w*mBoardScale
&#9;&#9;h = h*mBoardScale
&#9;&#9;--
&#9;&#9;mRectBoundPart.Transparency = 0.3
&#9;&#9;mRectBoundPart.Size = Vector3.new(w, 0.2, h)
&#9;&#9;mRectBoundPart.CFrame = CFrame.new(pos)
&#9;&#9;mRectBoundPart.BrickColor = BrickColor.new(color3)
&#9;end
&#9;function this:clearBuildingBounds()
&#9;&#9;mRectBoundPart.Transparency = 1
&#9;end

&#9;function this:destroy()
&#9;&#9;mBoardContainer:Destroy()
&#9;end
end)


class&apos;GameView_RightMenu&apos;(function(this, gameview)
&#9;
&#9;--&#9;
&#9;local function MakeTmpLabel(text)
&#9;&#9;return Make&apos;TextLabel&apos;{
&#9;&#9;&#9;Name = &quot;TmpLabel&quot;,
&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;Text = text,
&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0),
&#9;&#9;}
&#9;end
&#9;local mScreenGui = Make&apos;ScreenGui&apos;{
&#9;&#9;Parent = gameview:getPlayer():getIPlayer().PlayerGui,
&#9;&#9;Name = &quot;RightMenu&quot;,
&#9;}
&#9;local mMainPanel = Make&apos;ImageButton&apos;{
&#9;&#9;Parent = mScreenGui,
&#9;&#9;Name = &quot;MainPanel&quot;,
&#9;&#9;AutoButtonColor = false,
&#9;&#9;Size = UDim2.new(0, 256, 1, 0),
&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;--
&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;Name = &quot;TopPanel&quot;,
&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;Size = UDim2.new(0, 256, 0, 256),
&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;ResourceDisplay&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 256, 0, 32),
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &quot;ResourceCount&quot;,
&#9;&#9;&#9;&#9;&#9;Text = (&apos;$&apos;..gameview:getTeam():getMoney()),
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0),&#9;
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;Minimap&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 32),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 256, 0, 144),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;RepairButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 1, -80),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 128, 0, 32),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Repair&quot;),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;SellButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 128, 1, -80),
&#9;&#9;&#9;&#9;Size =  UDim2.new(0, 128, 0, 32),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Sell&quot;),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;InfastructureButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 1, -48),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 48),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Infastructure&quot;),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;DefenseButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 64, 1, -48),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 48),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Defense&quot;),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;PersonnelButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 128, 1, -48),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 48),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Personnel&quot;),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;VehicleButton&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 192, 1, -48),
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 48),
&#9;&#9;&#9;&#9;MakeTmpLabel(&quot;Vehicle&quot;),
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;Name = &quot;MidPanel&quot;,
&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;Size = UDim2.new(0, 256, 1, -304),
&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 256),
&#9;&#9;&#9;--
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;Power&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 32, 1, 0),
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;ScrollBar&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 32, 1, 0),
&#9;&#9;&#9;&#9;Position = UDim2.new(1, -32, 0, 0),&#9;
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;&#9;Name = &quot;ScrollArea&quot;,
&#9;&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;&#9;Size = UDim2.new(1, -64, 1, 0),
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 32, 0, 0),
&#9;&#9;&#9;&#9;ClipsDescendants = true,
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;Make&apos;Frame&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &quot;ScrollContent&quot;,
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;&#9;BorderSizePixel = 0,
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0),&#9;
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Make&apos;ImageButton&apos;{
&#9;&#9;&#9;Name = &quot;BottomPanel&quot;,
&#9;&#9;&#9;AutoButtonColor = false,
&#9;&#9;&#9;Size = UDim2.new(0, 0, 0, 48),
&#9;&#9;&#9;Position = UDim2.new(0, 0, 1, -48),&#9;
&#9;&#9;&#9;--

&#9;&#9;},
&#9;}
&#9;local mTopPanel = mMainPanel.TopPanel

&#9;local moneyCn = gameview:getTeam().onMoneyChange:connect(function(money)
&#9;&#9;mTopPanel.ResourceDisplay.ResourceCount.Text = (&apos;$&apos;..money)
&#9;end)

&#9;--=================== action view list ==============================
&#9;local mCurrentActionType = Roleset.ActionType.Infastructure
&#9;local mUnselectedButtonColor = mTopPanel.InfastructureButton.BackgroundColor3
&#9;mTopPanel.InfastructureButton.BackgroundColor3 = Color3.new(1, 0, 0)
&#9;local mActionTypeToButtonMap = {
&#9;&#9;[Roleset.ActionType.Infastructure] = mTopPanel.InfastructureButton,
&#9;&#9;[Roleset.ActionType.Defense] =       mTopPanel.DefenseButton,
&#9;&#9;[Roleset.ActionType.Personnel] =     mTopPanel.PersonnelButton,
&#9;&#9;[Roleset.ActionType.Vehicles] =      mTopPanel.VehicleButton,
&#9;}
&#9;--
&#9;local setActionViewType;
&#9;mTopPanel.InfastructureButton.MouseButton1Down:connect(function()
&#9;&#9;setActionViewType(Roleset.ActionType.Infastructure)
&#9;end)
&#9;mTopPanel.DefenseButton.MouseButton1Down:connect(function()
&#9;&#9;setActionViewType(Roleset.ActionType.Defense)
&#9;end)
&#9;mTopPanel.PersonnelButton.MouseButton1Down:connect(function()
&#9;&#9;setActionViewType(Roleset.ActionType.Personnel)
&#9;end)
&#9;mTopPanel.VehicleButton.MouseButton1Down:connect(function()
&#9;&#9;setActionViewType(Roleset.ActionType.Vehicles)
&#9;end)

&#9;--============================
&#9;local function MakeActionView(action)
&#9;&#9;local view = Make&apos;ImageButton&apos;{
&#9;&#9;&#9;Name = (&apos;Action_&apos;..action:getName()),
&#9;&#9;&#9;Size = UDim2.new(0, 96, 0, 64),
&#9;&#9;&#9;Image = action:getImage(),
&#9;&#9;&#9;Parent = mMainPanel.MidPanel.ScrollArea.ScrollContent,
&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;Name = &apos;NameLabel&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;Size = UDim2.new(1, -16, 0, 16),
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 1, -16),
&#9;&#9;&#9;&#9;Text = action:getName(),
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;Name = &apos;CountLabel&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;Size = UDim2.new(0, 16, 0, 16),
&#9;&#9;&#9;&#9;Position = UDim2.new(1, -16, 1, -16),
&#9;&#9;&#9;&#9;Text = &quot;&quot;,
&#9;&#9;&#9;},
&#9;&#9;&#9;Make&apos;TextLabel&apos;{
&#9;&#9;&#9;&#9;Name = &apos;ProgressLabel&apos;,
&#9;&#9;&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0),
&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0),
&#9;&#9;&#9;&#9;Text = &quot;&quot;,&#9;
&#9;&#9;&#9;},
&#9;&#9;}
&#9;&#9;local function updateLook()
&#9;&#9;&#9;--first, is it ready?
&#9;&#9;&#9;if action:isReady() then
&#9;&#9;&#9;&#9;view.ProgressLabel.Text = &quot;READY&quot;
&#9;&#9;&#9;&#9;view.CountLabel.Text = &quot;&quot;
&#9;&#9;&#9;elseif action:getQueued() then
&#9;&#9;&#9;&#9;local qu = action:getQueued()
&#9;&#9;&#9;&#9;if qu == true then
&#9;&#9;&#9;&#9;&#9;view.CountLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;elseif type(qu) == &apos;number&apos; then
&#9;&#9;&#9;&#9;&#9;view.CountLabel.Text = tostring(qu)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;view.ProgressLabel.Text = math.ceil(100*action:getProgress())..&apos;%&apos;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;view.ProgressLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;view.CountLabel.Text = &quot;&quot;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local updatedCn = action.onReady:connect(updateLook)
&#9;&#9;local progressCn = action.onProgress:connect(updateLook)
&#9;&#9;view.MouseButton1Down:connect(function()
&#9;&#9;&#9;if action:isReady() then
&#9;&#9;&#9;&#9;action:use()
&#9;&#9;&#9;elseif action:canEnqueue() then
&#9;&#9;&#9;&#9;action:enqueue()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;view.MouseButton2Down:connect(function()
&#9;&#9;&#9;if action:canDequeue() then
&#9;&#9;&#9;&#9;action:dequeue()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;--follow a similar pattern to before, return an asset and a destuctor
&#9;&#9;return view, function()
&#9;&#9;&#9;updatedCn:disconnect()
&#9;&#9;&#9;progressCn:disconnect()
&#9;&#9;&#9;view:Destroy()
&#9;&#9;end
&#9;end
&#9;--
&#9;local mActionViewMapsByType = {
&#9;&#9;[Roleset.ActionType.Infastructure] = {},
&#9;&#9;[Roleset.ActionType.Defense] =       {},
&#9;&#9;[Roleset.ActionType.Personnel] =     {},
&#9;&#9;[Roleset.ActionType.Vehicles] =      {},
&#9;}
&#9;local function addActionViewsForCurrentType()
&#9;&#9;--note, requires an empty view set to start with, will act oddly and
&#9;&#9;--make overlapping stuff otherwise. Indended to be shared code between
&#9;&#9;--update an available action list, and change current action list.
&#9;&#9;local currentY = 0
&#9;&#9;local leftRight = false
&#9;&#9;local availableActions = gameview:getRoleset():getActions(mCurrentActionType)
&#9;&#9;local theseActionsIn = mActionViewMapsByType[mCurrentActionType]
&#9;&#9;for _, action in pairs(availableActions) do
&#9;&#9;&#9;local view, destructor = MakeActionView(action)
&#9;&#9;&#9;view.Position = UDim2.new(0, (leftRight and 96 or 0), 0, currentY)
&#9;&#9;&#9;theseActionsIn[view] = destructor
&#9;&#9;&#9;if leftRight then
&#9;&#9;&#9;&#9;leftRight = false
&#9;&#9;&#9;&#9;currentY = currentY + 64
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;leftRight = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;setActionViewType = function(type)
&#9;&#9;mActionTypeToButtonMap[mCurrentActionType].BackgroundColor3 = mUnselectedButtonColor
&#9;&#9;mActionTypeToButtonMap[type].BackgroundColor3 = Color3.new(1, 0, 0)
&#9;&#9;
&#9;&#9;--kill old views
&#9;&#9;local oldViews = mActionViewMapsByType[mCurrentActionType]
&#9;&#9;for view, destructor in pairs(oldViews) do
&#9;&#9;&#9;destructor()
&#9;&#9;&#9;oldViews[view] = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;--set current type
&#9;&#9;mCurrentActionType = type

&#9;&#9;--add new views
&#9;&#9;addActionViewsForCurrentType()
&#9;end
&#9;local actionChangeCn = gameview:getRoleset().onAvailableActionChange:connect(function(ty)
&#9;&#9;if mCurrentActionType == ty then
&#9;&#9;&#9;setActionViewType(ty)
&#9;&#9;end
&#9;end)
&#9;setActionViewType(Roleset.ActionType.Infastructure)

&#9;function this:destroy()
&#9;&#9;mScreenGui:Destroy()
&#9;end
end)


class&apos;GameView&apos;(function(this, player, team, gamestate)
&#9;local mBoardView = MakeBoardView(player, team, gamestate)
&#9;local mRoleset; --= TBA
&#9;local mRightMenu; --= TBA, need my API defined below
&#9;--
&#9;local mSavedMouseActions = {}
&#9;local mMouseAction;
&#9;local mMainMouseAction; --= TBA
&#9;--
&#9;local mEntityToViewMap = {}
&#9;local mPartToEntityMap = {}

&#9;--creation of views for added entities
&#9;local function registerEntity(entity)
&#9;&#9;if entity.Displayable then
&#9;&#9;&#9;--todo: get the part list and do stuff with it
&#9;&#9;&#9;local view = entity.Displayable:createView(this)
&#9;&#9;&#9;mEntityToViewMap[entity] = view
&#9;&#9;&#9;for _, part in pairs(view:getPartList()) do
&#9;&#9;&#9;&#9;mPartToEntityMap[part] = entity
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;for entity in gamestate:eachEntity() do
&#9;&#9;registerEntity(entity)
&#9;end
&#9;gamestate.onEntityAdd:connect(function(entity)
&#9;&#9;registerEntity(entity)
&#9;end)
&#9;gamestate.onEntityRem:connect(function(entity)
&#9;&#9;--kill the displayable if there is one
&#9;&#9;if entity.Displayable then
&#9;&#9;&#9;local view = mEntityToViewMap[entity]
&#9;&#9;&#9;mEntityToViewMap[entity] = nil
&#9;&#9;&#9;--
&#9;&#9;&#9;for _, part in pairs(view:getPartList()) do
&#9;&#9;&#9;&#9;mPartToEntityMap[part] = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;view:destroy()
&#9;&#9;end

&#9;&#9;--make sure to deselect it in case we have it selected
&#9;&#9;this:deselectUnit(entity)
&#9;end)

&#9;--============================= public API
&#9;function this:getBoardView()
&#9;&#9;return mBoardView
&#9;end
&#9;function this:getRoleset()
&#9;&#9;return mRoleset
&#9;end
&#9;function this:getGameState()
&#9;&#9;return gamestate
&#9;end
&#9;function this:getTeam()
&#9;&#9;return team
&#9;end
&#9;function this:getPlayer()
&#9;&#9;return player
&#9;end
&#9;--
&#9;function this:popMouseAction()
&#9;&#9;local act = mSavedMouseActions[#mSavedMouseActions]
&#9;&#9;mSavedMouseActions[#mSavedMouseActions] = nil
&#9;&#9;this:setMouseAction(act)
&#9;end
&#9;function this:pushMouseAction(mouseaction)
&#9;&#9;mSavedMouseActions[#mSavedMouseActions+1] = mMouseAction
&#9;&#9;mouseaction.pop = this.popMouseAction
&#9;&#9;this:setMouseAction(mouseaction)
&#9;end
&#9;function this:setMouseAction(mouseaction)
&#9;&#9;if mMouseAction then
&#9;&#9;&#9;mMouseAction:onDeselect()
&#9;&#9;end
&#9;&#9;mMouseAction = mouseaction
&#9;&#9;if mMouseAction then
&#9;&#9;&#9;mMouseAction:onSelect()
&#9;&#9;end
&#9;end
&#9;--

&#9;--===================================
&#9;--now do setup
&#9;mRoleset = MakeRoleset_Allied(this)
&#9;mRightMenu = MakeGameView_RightMenu(this)

&#9;local onClickCn = mBoardView.onMouseButton:connect(function(st, x, y)
&#9;&#9;if mMouseAction and mMouseAction.onMouseButton then
&#9;&#9;&#9;mMouseAction:onMouseButton(st, x, y, mPartToEntityMap[player:getTarget()])
&#9;&#9;end
&#9;end)
&#9;local onKeyCn = player.onKey:connect(function(key, st)
&#9;&#9;if mMouseAction and mMouseAction.onKey then
&#9;&#9;&#9;mMouseAction:onKey(key, st)
&#9;&#9;end
&#9;end)
&#9;local onTargetCn = player.onTarget:connect(function(targ)
&#9;&#9;if mMouseAction and mMouseAction.onMouseTarget then
&#9;&#9;&#9;mMouseAction:onMouseTarget(mPartToEntityMap[targ])
&#9;&#9;end
&#9;end)

&#9;--========== selections stuff =========================
&#9;local mUnitSelection = {} --[entity] = Selection
&#9;local mBeginSelectDragX, mBeginSelectDragY = nil, nil
&#9;local mLastDrag = 0
&#9;--
&#9;function this:selectUnit(entity)
&#9;&#9;if not mUnitSelection[entity] then
&#9;&#9;&#9;mUnitSelection[entity] = mBoardView:MakeSelection(entity)
&#9;&#9;end
&#9;end
&#9;function this:deselectUnit(entity)
&#9;&#9;if mUnitSelection[entity] then
&#9;&#9;&#9;mUnitSelection[entity]:destroy()
&#9;&#9;&#9;mUnitSelection[entity] = nil
&#9;&#9;end
&#9;end


&#9;--============ destructor ===================
&#9;function this:destroy()
&#9;&#9;--unset the mouse action (giving the current action a chance to deselect)
&#9;&#9;this:setMouseAction(nil)

&#9;&#9;--kill the views
&#9;&#9;for ent, view in pairs(mEntityToViewMap) do
&#9;&#9;&#9;view:destroy()
&#9;&#9;&#9;mEntityToViewMap[ent] = nil
&#9;&#9;end

&#9;&#9;--destroy my assets
&#9;&#9;mBoardView:destroy()
&#9;&#9;mRoleset:destroy()
&#9;&#9;mRightMenu:destroy()

&#9;&#9;--kill connections
&#9;&#9;onClickCn:disconnect()
&#9;&#9;onKeyCn:disconnect()
&#9;&#9;onTargetCn:disconnect()
&#9;end


&#9;--setup for debugging
&#9;local unit = MakeUnit_AlliedMCV()
&#9;unit.TeamOwned:setTeam(team)
&#9;gamestate:addEntity(unit)
&#9;unit.MobileUnit:setPosition(15, 15)
&#9;team:creditMoney(5000)
&#9;--
&#9;local oreSpawner = MakeBuilding_GoldMine(40, 15)
&#9;gamestate:addEntity(oreSpawner)

&#9;--make a test mouseaction
&#9;local testMouseAction = {}
&#9;function testMouseAction:onMouseButton(st, x, y)
&#9;&#9;if st then
&#9;&#9;&#9;if x then
&#9;&#9;&#9;&#9;print(&quot;Hit&lt;&quot;..x..&quot;,&quot;..y..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;if player:getKeyState(&apos;r&apos;) then
&#9;&#9;&#9;&#9;&#9;unit.MobileUnit:setDesiredPosition(x, y)
&#9;&#9;&#9;&#9;elseif player:getKeyState(&apos;t&apos;) then

&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;x, y = math.floor(x), math.floor(y)
&#9;&#9;&#9;&#9;&#9;local h = (gamestate:getCell(x, y).Height &gt; 0) and 0 or 1
&#9;&#9;&#9;&#9;&#9;for dx = 0,0 do
&#9;&#9;&#9;&#9;&#9;&#9;for dy = 0,0 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;gamestate:setCell(x+dx, y+dy, nil, h)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;--mBoardView:refreshConnections(true) --true = show them
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function testMouseAction:onKey(key, st)
&#9;&#9;if st and key == &apos;z&apos; then
&#9;&#9;&#9;this:setMouseAction(mMainMouseAction)
&#9;&#9;end
&#9;end
&#9;function testMouseAction:onTarget(entity)
&#9;end
&#9;function testMouseAction:onSelect() end
&#9;function testMouseAction:onDeselect() end


&#9;--make the real mouseaction
&#9;mMainMouseAction = {}
&#9;function mMainMouseAction:onMouseButton(st, x, y, entity)
&#9;&#9;if st then
&#9;&#9;&#9;print(&quot;MainMouseAction Click&quot;)
&#9;&#9;&#9;--movement for now
&#9;&#9;&#9;if player:getKeyState(&apos;r&apos;) then
&#9;&#9;&#9;&#9;for unit, _ in pairs(mUnitSelection) do
&#9;&#9;&#9;&#9;&#9;unit.MobileUnit:setDesiredPosition(x+math.random(-0.5,0.5), 
&#9;&#9;&#9;&#9;&#9;                                   y+math.random(-0.5,0.5))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;--try using an click-effect
&#9;&#9;&#9;if entity and mUnitSelection[entity] and entity.ClickEffect then
&#9;&#9;&#9;&#9;print(&quot;Selected Entity has a click effect&quot;)
&#9;&#9;&#9;&#9;if entity.ClickEffect:canActivate() then
&#9;&#9;&#9;&#9;&#9;entity.ClickEffect:activate()
&#9;&#9;&#9;&#9;&#9;print(&quot;Activated click effect&quot;)
&#9;&#9;&#9;&#9;&#9;--error(&quot;Test&quot;)
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;--retunn now. In fact, not returning now could have bad
&#9;&#9;&#9;&#9;&#9;--consequences, since the entity could have removed itself
&#9;&#9;&#9;&#9;&#9;--out from under this handler, or otherwise edited the state
&#9;&#9;&#9;&#9;&#9;--of the map in an unexpected way.
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--also try using click effects on buildings, they can&apos;t be selected
&#9;&#9;&#9;--so 
&#9;&#9;&#9;if entity and entity.Building and entity.ClickEffect then
&#9;&#9;&#9;&#9;if entity.ClickEffect:canActivate() then
&#9;&#9;&#9;&#9;&#9;entity.ClickEffect:activate()
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--try starting a select drag
&#9;&#9;&#9;mBeginSelectDragX = x
&#9;&#9;&#9;mBeginSelectDragY = y

&#9;&#9;&#9;--deselect current units
&#9;&#9;&#9;for unit, _ in pairs(mUnitSelection) do
&#9;&#9;&#9;&#9;this:deselectUnit(unit)
&#9;&#9;&#9;end

&#9;&#9;&#9;--select the entity under the mouse
&#9;&#9;&#9;if entity and entity.MobileUnit then
&#9;&#9;&#9;&#9;this:selectUnit(entity)
&#9;&#9;&#9;end

&#9;&#9;&#9;--also start a possible drag
&#9;&#9;&#9;local curDrag = mLastDrag
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;local unitsAddedByDragMap = {}
&#9;&#9;&#9;&#9;local lastGoodX, lastGoodY = mBeginSelectDragX, mBeginSelectDragY
&#9;&#9;&#9;&#9;while mLastDrag == curDrag do
&#9;&#9;&#9;&#9;&#9;local mx, my = mBoardView:getMouseHit()
&#9;&#9;&#9;&#9;&#9;mx, my = mx or lastGoodX, my or lastGoodY
&#9;&#9;&#9;&#9;&#9;lastGoodX, lastGoodY = mx, my
&#9;&#9;&#9;&#9;&#9;--print(&quot;Hit:&quot;, player:getHit())
&#9;&#9;&#9;&#9;&#9;local dx = mx-mBeginSelectDragX
&#9;&#9;&#9;&#9;&#9;local dy = my-mBeginSelectDragY
&#9;&#9;&#9;&#9;&#9;if math.abs(dx*dy) &gt; 2 then 
&#9;&#9;&#9;&#9;&#9;&#9;mBoardView:setSelectionDrag(mBeginSelectDragX,
&#9;&#9;&#9;&#9;&#9;&#9;                            mBeginSelectDragY,
&#9;&#9;&#9;&#9;&#9;&#9;                            dx, dy)
&#9;&#9;&#9;&#9;&#9;&#9;local units = 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;gamestate:getAllUnitsInRegion(mBeginSelectDragX,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;                              mBeginSelectDragY,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;                              dx, dy,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;                              team)
&#9;&#9;&#9;&#9;&#9;&#9;local mapOfUnitsInSelection = {}
&#9;&#9;&#9;&#9;&#9;&#9;for _, unit in pairs(units) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mapOfUnitsInSelection[unit] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not mUnitSelection[unit] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;unitsAddedByDragMap[unit] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;this:selectUnit(unit)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;for unitAddedByDrag in pairs(unitsAddedByDragMap) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not mapOfUnitsInSelection[unitAddedByDrag] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;this:deselectUnit(unitAddedByDrag)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;unitsAddedByDragMap[unitAddedByDrag] = nil
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;mBoardView:clearSelectionDrag()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;MainMouseAction Release&quot;)
&#9;&#9;&#9;mBoardView:clearSelectionDrag()
&#9;&#9;&#9;mLastDrag = mLastDrag+1
&#9;&#9;end
&#9;end
&#9;function mMainMouseAction:onKey(key, st)
&#9;&#9;if st and key == &apos;z&apos; then
&#9;&#9;&#9;this:setMouseAction(testMouseAction)
&#9;&#9;end
&#9;end
&#9;function mMainMouseAction:onTarget(entity)

&#9;end
&#9;function mMainMouseAction:onSelect()

&#9;end
&#9;function mMainMouseAction:onDeselect()

&#9;end

&#9;this:setMouseAction(mMainMouseAction)
end)

</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX8">
				<Properties>
					<string name="Name">gamestate</string>
					<string name="Value">--gamestate

class&apos;Effect&apos;(function(this)
&#9;--abstract:
&#9;function this:getView() end&#9;
end)


--[[
========= Interfaces ==========
-------------------------------
Effect:
createView(): EffectView

-------------------------------


-------------------------------
Ticker:
tick(delta, elapsed)

-------------------------------


============ Traits ===========
-------------------------------
Displayable(entity): 
createView(inview: GameView) -&gt; :destroy() / :getPartList()

---
Health(entity): 
getHealth(), 
takeDamage(int: Damage), 
onDeath, 

---
ClickEffect(entity): 
activate()
Icon: string

---
MobileUnit(entity): 
OverLand: bool, OverWater: bool
getPosition(): (x, y, ux, uy), setPosition(x, y, ux, uy)
setDesiredPosition() 
onMove: (tox, toy)

---
TeamOwned(entity):
getTeam(): Team, setTeam(owner: Team)
onTeamChange(): newTeam, oldTeam

---
PowerConsumer:
getPowerConsumed()

---
PowerProducer:
getPowerProduced()

---
Building(entity):
X, Y, W, H


-------------------------------

]]


class&apos;Team&apos;(function(this, player)
&#9;local mAllies = {}

&#9;local mEntityCount = 0
&#9;local mUnitCount = 0
&#9;local mEntityListHead = nil

&#9;this.onEntityAdd = MakeSignal()
&#9;this.onEntityRem = MakeSignal()
&#9;this.onMoneyChange = MakeSignal()

&#9;local mMoney = 0

&#9;--the team&apos;s color
&#9;function this:getTeamColor()
&#9;&#9;return BrickColor.new(21)
&#9;end

&#9;--is a gien player an owner, only one player
&#9;--currently, but could be expanded.
&#9;function this:isOwner(p)
&#9;&#9;return p == player
&#9;end

&#9;--alliance info
&#9;function this:addAlly(team)
&#9;&#9;mAllies[team] = true
&#9;end
&#9;function this:isAlly(team)
&#9;&#9;return mAllies[team] or false
&#9;end

&#9;--add/remove units
&#9;function this:addEntity(entity)
&#9;&#9;--add to counts
&#9;&#9;mEntityCount = mEntityCount+1
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount+1
&#9;&#9;end
&#9;&#9;--add to linked list
&#9;&#9;entity.NextEntity_TeamList = mEntityListHead
&#9;&#9;if mEntityListHead then
&#9;&#9;&#9;mEntityListHead.PrevEntity_TeamList = entity
&#9;&#9;end
&#9;&#9;mEntityListHead = entity
&#9;&#9;--
&#9;&#9;this.onEntityAdd:fire(entity)
&#9;end
&#9;function this:remEntity(entity)
&#9;&#9;--remove from stats
&#9;&#9;mEntityCount = mEntityCount-1
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount-1
&#9;&#9;end
&#9;&#9;--remove from linked list
&#9;&#9;if entity.NextEntity_TeamList then
&#9;&#9;&#9;entity.NextEntity_TeamList.PrevEntity_TeamList = 
&#9;&#9;&#9;&#9;entity.PrevEntity_TeamList
&#9;&#9;end
&#9;&#9;if entity.PrevEntity_TeamList then
&#9;&#9;&#9;entity.PrevEntity_TeamList.NextEntity_TeamList =
&#9;&#9;&#9;&#9;entity.NextEntity_TeamList
&#9;&#9;else
&#9;&#9;&#9;mEntityListHead = entity.NextEntity_TeamList
&#9;&#9;end
&#9;&#9;--
&#9;&#9;this.onEntityRem:fire(entity)
&#9;end

&#9;--getters
&#9;function this:getEntityCount()
&#9;&#9;return mEntityCount
&#9;end
&#9;function this:getUnitCount()
&#9;&#9;return mUnitCount
&#9;end

&#9;--money
&#9;function this:creditMoney(amount)
&#9;&#9;mMoney = mMoney + amount
&#9;&#9;this.onMoneyChange:fire(mMoney)
&#9;end
&#9;function this:debitMoney(amount)
&#9;&#9;if mMoney &gt;= amount then
&#9;&#9;&#9;mMoney = mMoney - amount
&#9;&#9;&#9;this.onMoneyChange:fire(mMoney)
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;function this:getMoney()
&#9;&#9;return mMoney&#9;
&#9;end

&#9;--units
&#9;function this:eachEntity()
&#9;&#9;local curEnt = mEntityListHead
&#9;&#9;return function()
&#9;&#9;&#9;local e = curEnt
&#9;&#9;&#9;curEnt = (curEnt and curEnt.NextEntity_TeamList or nil)
&#9;&#9;&#9;return e
&#9;&#9;end
&#9;end
end)


class&apos;GameState&apos;(function(this, settings, teams)
&#9;--=========================================--
&#9;--==     general game functionality      ==--
&#9;--=========================================--
&#9;local mGameIsWon = false

&#9;--=========================================--
&#9;--==          tick functionality         ==--
&#9;--=========================================--
&#9;local mTickerHead = nil
&#9;function this:addTicker(ticker)
&#9;&#9;ticker.TickAddedTime = tick()
&#9;&#9;ticker.TickNext = mTickerHead
&#9;&#9;if mTickerHead then
&#9;&#9;&#9;mTickerHead.TickPrev = ticker
&#9;&#9;end
&#9;&#9;mTickerHead = ticker
&#9;end
&#9;function this:remTicker(ticker)
&#9;&#9;if ticker.TickNext then
&#9;&#9;&#9;ticker.TickNext.TickPrev = ticker.TickPrev
&#9;&#9;end
&#9;&#9;if ticker.TickPrev then
&#9;&#9;&#9;ticker.TickPrev.TickNext = ticker.TickNext
&#9;&#9;else
&#9;&#9;&#9;mTickerHead = ticker.TickNext
&#9;&#9;end
&#9;end
&#9;local function doTick(dt)
&#9;&#9;local curTime = tick()
&#9;&#9;local ticker = mTickerHead
&#9;&#9;while ticker do
&#9;&#9;&#9;ticker:tick(dt, curTime-ticker.TickAddedTime)
&#9;&#9;&#9;ticker = ticker.TickNext
&#9;&#9;end
&#9;end


&#9;--=========================================--
&#9;--==       general eneity tracking       ==--
&#9;--=========================================--
&#9;local mEntityCount = 0
&#9;local mUnitCount = 0
&#9;local mEntityListHead = nil
&#9;--

&#9;this.onEntityAdd = MakeSignal()
&#9;this.onEntityRem = MakeSignal()


&#9;--=========================================--
&#9;--==          gold ore tracking          ==--
&#9;--=========================================--
&#9;local mGoldTeam = MakeTeam(nil)
&#9;local mAllGoldMap = {}
&#9;local mAllGoldMineMap = {}
&#9;function this:eachGoldMine()
&#9;&#9;return pairs(mAllGoldMineMap)
&#9;end
&#9;function this:eachGold()
&#9;&#9;return pairs(mAllGoldMap)
&#9;end


&#9;--=========================================--
&#9;--==         board functionality         ==--
&#9;--=========================================--
&#9;local mTileMapRaw = {}
&#9;--todo: for debugging, remove
&#9;local mBoardSize = settings:getSetting(MatchSettings.GameSize).BoardSize

&#9;function this:getBoardSize()
&#9;&#9;return mBoardSize
&#9;end

&#9;--init main board data
&#9;for x = 1, mBoardSize do
&#9;&#9;local col = {}
&#9;&#9;mTileMapRaw[x] = col
&#9;&#9;for y = 1, mBoardSize do
&#9;&#9;&#9;local cell = {}
&#9;&#9;&#9;col[y] = cell
&#9;&#9;&#9;--
&#9;&#9;&#9;cell.X = x
&#9;&#9;&#9;cell.Y = y
&#9;&#9;&#9;cell.Height = 0
&#9;&#9;&#9;cell.Ramp = false
&#9;&#9;&#9;cell.Building = nil
&#9;&#9;end
&#9;end
&#9;local EmptyTable = {}
&#9;function this:getCell(x, y)
&#9;&#9;return (mTileMapRaw[x] or EmptyTable)[y]
&#9;end

&#9;--init broad-phase map
&#9;local mBroadPhaseMap = {}
&#9;mBroadPhaseSize = mBoardSize/8
&#9;for x = 1, mBroadPhaseSize do
&#9;&#9;local col = {}
&#9;&#9;mBroadPhaseMap[x] = col
&#9;&#9;for y = 1, mBroadPhaseSize do
&#9;&#9;&#9;local cell = {}
&#9;&#9;&#9;col[y] = cell
&#9;&#9;&#9;--
&#9;&#9;&#9;cell.EntityCount = 0
&#9;&#9;&#9;cell.EntityMap = {}
&#9;&#9;&#9;cell.TeamCount = {}
&#9;&#9;&#9;for _, team in pairs(teams) do
&#9;&#9;&#9;&#9;cell.TeamCount[team] = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function this:getBroadCell(x, y)
&#9;&#9;x = math.floor((x-1)/8)+1
&#9;&#9;y = math.floor((y-1)/8)+1
&#9;&#9;--
&#9;&#9;return mBroadPhaseMap[x][y]
&#9;end
&#9;local function addEntityToBroad(bnode, entity)
&#9;&#9;bnode.EntityMap[entity] = true
&#9;&#9;bnode.EntityCount = bnode.EntityCount+1
&#9;&#9;--team ownership? Add it to the count for that space
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;if not entity.TeamOwned.RegisteredToBroadMap then
&#9;&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap = {}
&#9;&#9;&#9;end
&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap[bnode] = true
&#9;&#9;&#9;bnode.TeamCount[team] = bnode.TeamCount[team] + 1
&#9;&#9;end
&#9;end
&#9;local function remEntityFromBroad(bnode, entity)
&#9;&#9;bnode.EntityMap[entity] = nil
&#9;&#9;bnode.EntityCount = bnode.EntityCount - 1
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap[bnode] = nil
&#9;&#9;&#9;bnode.TeamCount[team] = bnode.TeamCount[team] - 1
&#9;&#9;end
&#9;end

&#9;--init quad-tree
&#9;local mQuadRoot = {
&#9;&#9;Height = 0,
&#9;&#9;Ramp = false,
&#9;&#9;Building = nil,
&#9;&#9;--
&#9;&#9;X = 1, Y = 1,
&#9;&#9;Size = mBoardSize,
&#9;&#9;HalfSize = mBoardSize/2,
&#9;&#9;--
&#9;&#9;Adjacent = {},
&#9;&#9;Parent = nil,
&#9;&#9;Children = nil,
&#9;&#9;Leaf = true,
&#9;&#9;--
&#9;&#9;PathMap = {},
&#9;}
&#9;local mQuadPathGID = 1
&#9;this.onQnodeShow = MakeSignal()
&#9;this.onQnodeHide = MakeSignal()

&#9;local function getQnode(x, y, inNode)
&#9;&#9;if x &gt;= mBoardSize+1 or y &gt;= mBoardSize+1 or x &lt; 1 or y &lt; 1 then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;local nd = inNode or mQuadRoot
&#9;&#9;while not nd.Leaf do
&#9;&#9;&#9;local dx = (x-nd.X)/nd.HalfSize
&#9;&#9;&#9;local dy = (y-nd.Y)/nd.HalfSize
&#9;&#9;&#9;if dx &lt; 1 then
&#9;&#9;&#9;&#9;if dy &lt; 1 then
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[1]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[3]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if dy &lt; 1 then
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[2]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[4]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return nd
&#9;end
&#9;local function eachAdjacentQnode(qnode, f)
&#9;&#9;local mx = qnode.X
&#9;&#9;local my = qnode.Y
&#9;&#9;local size = qnode.Size
&#9;&#9;--now patch in the new connections
&#9;&#9;for d = 0, size do
&#9;&#9;&#9;local adj
&#9;&#9;&#9;--top
&#9;&#9;&#9;adj = getQnode(mx+d-1, my-1)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--bottom
&#9;&#9;&#9;adj = getQnode(mx+d, my+size)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--left
&#9;&#9;&#9;adj = getQnode(mx-1, my+d)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--right
&#9;&#9;&#9;adj = getQnode(mx+size, my+d-1)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;end
&#9;end

&#9;--(actually accepts cells or qnodes, they have identical 
&#9;-- members for the purposes of this function)
&#9;local function isQnodeCompatible(qnodea, qnodeb)
&#9;&#9;if (qnodea.Height==0) ~= (qnodeb.Height==0) then
&#9;&#9;&#9;--if one is water and the other is not (both are water is fine)
&#9;&#9;&#9;return false
&#9;&#9;elseif qnodea.Building or qnodeb.Building then
&#9;&#9;&#9;--one is obstructed
&#9;&#9;&#9;return false
&#9;&#9;else
&#9;&#9;&#9;--compare heights
&#9;&#9;&#9;if qnodea.Height == qnodeb.Height then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;elseif qnodea.Ramp and qnodeb.Ramp then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local function invalidateQnodePaths(qnode)
&#9;&#9;local count = 0
&#9;&#9;for path, _ in pairs(qnode.PathMap) do
&#9;&#9;&#9;count = count+1
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;--print(&quot;Invalidate &quot;..count..&quot; paths for Qnode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;end
&#9;local function clearQnodeAdjacent(qnode)
&#9;&#9;for adj, dist in pairs(qnode.Adjacent) do
&#9;&#9;&#9;adj.Adjacent[qnode] = nil
&#9;&#9;&#9;qnode.Adjacent[adj] = nil
&#9;&#9;end
&#9;end
&#9;local function assignQnodeAdjacent(qnode)
&#9;&#9;eachAdjacentQnode(qnode, function(nd)
&#9;&#9;&#9;if isQnodeCompatible(qnode, nd) then
&#9;&#9;&#9;&#9;local dx = ((nd.X+nd.HalfSize)-(qnode.X+qnode.HalfSize))
&#9;&#9;&#9;&#9;local dy = ((nd.Y+nd.HalfSize)-(qnode.Y+qnode.HalfSize))
&#9;&#9;&#9;&#9;local shouldMakeCon = true
&#9;&#9;&#9;&#9;if math.abs(dx) == math.abs(dy) then
&#9;&#9;&#9;&#9;&#9;--it&apos;s a diagonal. Diagonals need to be checked that they are
&#9;&#9;&#9;&#9;&#9;--not obstructed on both sides by non-passable squares
&#9;&#9;&#9;&#9;&#9;local ux = ((dx&gt;0) and 1 or -1)
&#9;&#9;&#9;&#9;&#9;local uy = ((dy&gt;0) and 1 or -1)
&#9;&#9;&#9;&#9;&#9;local hs = qnode.HalfSize&#9;
&#9;&#9;&#9;&#9;&#9;--print(&quot;Between Qnode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;&gt; and Adj&lt;&quot;..
&#9;&#9;&#9;&#9;&#9;--                        nd.X..&quot;,&quot;..nd.Y..&quot;&gt;, u=&lt;&quot;..ux..&quot;,&quot;..uy..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;--print(&quot;Get Adj1 &lt;&quot;..(math.floor(qnode.X+hs + ux*hs - uy*0.2))..&quot;,&quot;..
&#9;&#9;&#9;&#9;&#9;--                    (math.floor(qnode.Y+hs + uy*hs + ux*0.2))..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;local adj1 = mTileMapRaw[math.floor(qnode.X+hs + ux*hs - uy*0.2)]
&#9;&#9;&#9;&#9;&#9;                        [math.floor(qnode.Y+hs + uy*hs + ux*0.2)]
&#9;&#9;&#9;&#9;&#9;--print(&quot;Get Adj2 &lt;&quot;..(math.floor(qnode.X+hs + ux*hs + uy*0.2))..&quot;,&quot;..
&#9;&#9;&#9;&#9;&#9;--                    (math.floor(qnode.Y+hs + uy*hs - ux*0.2))..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;local adj2 = mTileMapRaw[math.floor(qnode.X+hs + ux*hs + uy*0.2)]
&#9;&#9;&#9;&#9;&#9;                        [math.floor(qnode.Y+hs + uy*hs - ux*0.2)]
&#9;&#9;&#9;&#9;&#9;if not (isQnodeCompatible(qnode, adj1) or isQnodeCompatible(qnode, adj2)) then
&#9;&#9;&#9;&#9;&#9;&#9;shouldMakeCon = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if shouldMakeCon then
&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;qnode.Adjacent[nd] = dist
&#9;&#9;&#9;&#9;&#9;nd.Adjacent[qnode] = dist
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
&#9;local function splitQnode(qnode)
&#9;&#9;--must be larger than size 1
&#9;&#9;if qnode.Size &gt; 1 then
&#9;&#9;&#9;--print(&quot;SPLIT QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;&#9;local mx, my = qnode.X, qnode.Y
&#9;&#9;&#9;local hs = qnode.HalfSize
&#9;&#9;&#9;local c1 = {X = mx,    Y = my}
&#9;&#9;&#9;local c2 = {X = mx+hs, Y = my}
&#9;&#9;&#9;local c3 = {X = mx,    Y = my+hs}
&#9;&#9;&#9;local c4 = {X = mx+hs, Y = my+hs}
&#9;&#9;&#9;local children = {c1, c2, c3, c4}
&#9;&#9;&#9;for _, ch in pairs(children) do
&#9;&#9;&#9;&#9;ch.Height = qnode.Height
&#9;&#9;&#9;&#9;ch.Ramp = qnode.Ramp
&#9;&#9;&#9;&#9;ch.Building = qnode.Building
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.Size = hs
&#9;&#9;&#9;&#9;ch.HalfSize = hs/2
&#9;&#9;&#9;&#9;--X/Y assigned specially above
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.Adjacent = {}
&#9;&#9;&#9;&#9;ch.Parent = qnode
&#9;&#9;&#9;&#9;ch.Children = nil
&#9;&#9;&#9;&#9;ch.Leaf = true
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.PathMap = {}
&#9;&#9;&#9;end
&#9;&#9;&#9;--now make those nodes the children 
&#9;&#9;&#9;--of the node being split
&#9;&#9;&#9;qnode.Children = children
&#9;&#9;&#9;qnode.Leaf = false --no longer a leaf

&#9;&#9;&#9;--invalidate paths
&#9;&#9;&#9;invalidateQnodePaths(qnode)

&#9;&#9;&#9;--kill all of node&apos;s existing adjacent connections
&#9;&#9;&#9;clearQnodeAdjacent(qnode)

&#9;&#9;&#9;--assign new connections for nodes
&#9;&#9;&#9;for _, ch in pairs(children) do
&#9;&#9;&#9;&#9;assignQnodeAdjacent(ch)
&#9;&#9;&#9;end

&#9;&#9;&#9;--call events
&#9;&#9;&#9;this.onQnodeHide:fire(qnode)
&#9;&#9;&#9;this.onQnodeShow:fire(c1)
&#9;&#9;&#9;this.onQnodeShow:fire(c2)
&#9;&#9;&#9;this.onQnodeShow:fire(c3)
&#9;&#9;&#9;this.onQnodeShow:fire(c4)
&#9;&#9;end
&#9;end
&#9;local function trymergeQnode(qnode)
&#9;&#9;if not qnode.Parent then return nil end
&#9;&#9;--
&#9;&#9;local par = qnode.Parent
&#9;&#9;local allParentChildrenMap = {}
&#9;&#9;local canMerge = true
&#9;&#9;for _, ch in pairs(par.Children) do
&#9;&#9;&#9;allParentChildrenMap[ch] = true
&#9;&#9;&#9;if (ch.Leaf) and
&#9;&#9;&#9;   (qnode.Building and true) == (ch.Building and true) and 
&#9;&#9;&#9;   (qnode.Height == ch.Height) and
&#9;&#9;&#9;   (qnode.Ramp == ch.Ramp)
&#9;&#9;&#9;then
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;canMerge = false&#9;
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if canMerge then
&#9;&#9;&#9;--print(&quot;MERGE QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;&#9;par.Height = qnode.Height
&#9;&#9;&#9;par.Ramp = qnode.Ramp
&#9;&#9;&#9;par.Building = qnode.Building
&#9;&#9;&#9;--
&#9;&#9;&#9;--fix up adjacents
&#9;&#9;&#9;for ch, _ in pairs(allParentChildrenMap) do
&#9;&#9;&#9;&#9;for adj, dist in pairs(ch.Adjacent) do
&#9;&#9;&#9;&#9;&#9;if not allParentChildrenMap[adj] then
&#9;&#9;&#9;&#9;&#9;&#9;--this is not one of the child nodes, but an adjacent one
&#9;&#9;&#9;&#9;&#9;&#9;--to the parent, so connect it to the parent
&#9;&#9;&#9;&#9;&#9;&#9;adj.Adjacent[ch] = nil
&#9;&#9;&#9;&#9;&#9;&#9;local dx = (par.X+par.HalfSize)-(adj.X+adj.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dy = (par.Y+par.HalfSize)-(adj.Y+adj.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;&#9;adj.Adjacent[par] = dist
&#9;&#9;&#9;&#9;&#9;&#9;par.Adjacent[adj] = dist
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local ch = par.Children
&#9;&#9;&#9;--change the parent to a leaf
&#9;&#9;&#9;par.Children = nil
&#9;&#9;&#9;par.Leaf = true
&#9;&#9;&#9;this.onQnodeHide:fire(ch[1])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[2])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[3])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[4])
&#9;&#9;&#9;--
&#9;&#9;&#9;invalidateQnodePaths(ch[1])
&#9;&#9;&#9;invalidateQnodePaths(ch[2])
&#9;&#9;&#9;invalidateQnodePaths(ch[3])
&#9;&#9;&#9;invalidateQnodePaths(ch[4])
&#9;&#9;&#9;--
&#9;&#9;&#9;this.onQnodeShow:fire(par)

&#9;&#9;&#9;--and finally return the merged node
&#9;&#9;&#9;return par
&#9;&#9;end
&#9;&#9;return nil
&#9;end
&#9;--now, with the init done, define the set function for a tile
&#9;function this:setCell(x, y, building, h, ramp)
&#9;&#9;if not mTileMapRaw[x] or not mTileMapRaw[x][y] then return end

&#9;&#9;--first off, do the easy set of the flat-array cell
&#9;&#9;local cell = mTileMapRaw[x][y]
&#9;&#9;--set possibly unspecified arguments
&#9;&#9;h = h or cell.Height
&#9;&#9;ramp = ramp or cell.Ramp

&#9;&#9;--set values in flat-cell
&#9;&#9;cell.Building = building
&#9;&#9;cell.Height = h
&#9;&#9;cell.Ramp = ramp

&#9;&#9;--get the node
&#9;&#9;local nd = getQnode(x, y)

&#9;&#9;--might need to break
&#9;&#9;if (nd.Building and true) ~= (building and true) or nd.Height ~= h or nd.Ramp ~= ramp then
&#9;&#9;&#9;--get the leaf. It has to be size 1, since this whole node
&#9;&#9;&#9;--is not the type in question.
&#9;&#9;&#9;while nd.Size &gt; 1 do
&#9;&#9;&#9;&#9;splitQnode(nd)
&#9;&#9;&#9;&#9;nd = getQnode(x, y, nd)
&#9;&#9;&#9;end

&#9;&#9;&#9;--set the leaf stats
&#9;&#9;&#9;nd.Height = h
&#9;&#9;&#9;nd.Ramp = ramp
&#9;&#9;&#9;nd.Building = building

&#9;&#9;&#9;--then, update the connections for the new type of node
&#9;&#9;&#9;clearQnodeAdjacent(nd)
&#9;&#9;&#9;assignQnodeAdjacent(nd)

&#9;&#9;&#9;--and invalidate th paths
&#9;&#9;&#9;invalidateQnodePaths(nd)

&#9;&#9;&#9;--now, update diagonal links at the corners of this square. The
&#9;&#9;&#9;--change may have obstructed them, even though they don&apos;t involve
&#9;&#9;&#9;--the square itself:
&#9;&#9;&#9;--A 1 2 B
&#9;&#9;&#9;--8|&#175;&#175;&#175;|3 Connections to check: 2-3, 4-5, 6-7, 8-1
&#9;&#9;&#9;--7|___|4
&#9;&#9;&#9;--D 6 5 C
&#9;&#9;&#9;local sA = getQnode(nd.X-1,         nd.Y-1)
&#9;&#9;&#9;local s1 = getQnode(nd.X,           nd.Y-1)
&#9;&#9;&#9;local s2 = getQnode(nd.X+nd.Size-1, nd.Y-1)
&#9;&#9;&#9;local sB = getQnode(nd.X+nd.Size,   nd.Y-1)
&#9;&#9;&#9;local s3 = getQnode(nd.X+nd.Size,   nd.Y)
&#9;&#9;&#9;local s4 = getQnode(nd.X+nd.Size,   nd.Y+nd.Size-1)
&#9;&#9;&#9;local sC = getQnode(nd.X+nd.Size,   nd.Y+nd.Size)
&#9;&#9;&#9;local s5 = getQnode(nd.X+nd.Size-1, nd.Y+nd.Size)
&#9;&#9;&#9;local s6 = getQnode(nd.X,           nd.Y+nd.Size)
&#9;&#9;&#9;local sD = getQnode(nd.X-1,         nd.Y+nd.Size)
&#9;&#9;&#9;local s7 = getQnode(nd.X-1,         nd.Y+nd.Size-1)
&#9;&#9;&#9;local s8 = getQnode(nd.X-1,         nd.Y)
&#9;&#9;&#9;local function verifyLink(a, b, corner)
&#9;&#9;&#9;&#9;if isQnodeCompatible(a, b) and 
&#9;&#9;&#9;&#9;   (isQnodeCompatible(a, corner) or isQnodeCompatible(a, nd))
&#9;&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;&#9;if not a.Adjacent[b] then
&#9;&#9;&#9;&#9;&#9;&#9;local dx = (a.X+a.HalfSize) - (b.X+b.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dy = (a.Y+a.HalfSize) - (b.Y+b.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;&#9;a.Adjacent[b] = dist
&#9;&#9;&#9;&#9;&#9;&#9;b.Adjacent[a] = dist
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(a)
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(b)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if a.Adjacent[b] then
&#9;&#9;&#9;&#9;&#9;&#9;a.Adjacent[b] = nil
&#9;&#9;&#9;&#9;&#9;&#9;b.Adjacent[a] = nil
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(a)
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(b)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end
&#9;&#9;&#9;if s2 and s3 and s2~=sB and s3~=sB then verifyLink(s2, s3, sB) end
&#9;&#9;&#9;if s4 and s5 and s4~=sC and s5~=sC then verifyLink(s4, s5, sC) end
&#9;&#9;&#9;if s6 and s7 and s6~=sD and s7~=sD then verifyLink(s6, s7, sD) end
&#9;&#9;&#9;if s8 and s1 and s8~=sA and s1~=sA then verifyLink(s8, s1, sA) end 
&#9;&#9;&#9;--
&#9;&#9;&#9;this.onQnodeShow:fire(nd)

&#9;&#9;&#9;--do a recursive merge
&#9;&#9;&#9;while nd do
&#9;&#9;&#9;&#9;nd = trymergeQnode(nd)
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;end
&#9;function this:getRootQnode()
&#9;&#9;return mQuadRoot
&#9;end
&#9;function this:getQnode(x, y)
&#9;&#9;return getQnode(x, y)
&#9;end

&#9;--set map cells:
&#9;do
&#9;&#9;local mapDat = MapProvider.SmallMap1.Grid
&#9;&#9;for y = 1, mBoardSize do
&#9;&#9;&#9;local line = mapDat[y]
&#9;&#9;&#9;for x = 1, mBoardSize do
&#9;&#9;&#9;&#9;local sqVal = line:sub(x,x)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local height = 0
&#9;&#9;&#9;&#9;local ramp = false
&#9;&#9;&#9;&#9;if sqVal == &apos;_&apos; then
&#9;&#9;&#9;&#9;&#9;height = 0
&#9;&#9;&#9;&#9;elseif sqVal == &apos;#&apos; then
&#9;&#9;&#9;&#9;&#9;height = 1
&#9;&#9;&#9;&#9;elseif sqVal == &apos;O&apos; then
&#9;&#9;&#9;&#9;&#9;height = 1
&#9;&#9;&#9;&#9;&#9;--todo: spawn is here
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;this:setCell(x, y, nil, height, ramp)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end



&#9;--=========================================--
&#9;--==  pathfinding code for mobile units  ==--
&#9;--=========================================--
&#9;local mInvalidPathMap = {} --paths that need validating
&#9;local function updatePaths(dt)
&#9;&#9;for path, _ in pairs(mInvalidPathMap) do
&#9;&#9;&#9;path:validate()
&#9;&#9;end
&#9;end
&#9;local function requestMobile(entity)
&#9;&#9;local path = {}

&#9;&#9;--start out not valid, and added to the invalid paths list
&#9;&#9;local mIsValid = false
&#9;&#9;mInvalidPathMap[path] = true

&#9;&#9;--current position
&#9;&#9;local mX = 1
&#9;&#9;local mY = 1
&#9;&#9;local mUX = 1
&#9;&#9;local mUY = 0
&#9;&#9;local mDesiredX = 1
&#9;&#9;local mDesiredY = 1
&#9;&#9;local mCurrentBroadCell = nil --TBA. below

&#9;&#9;--deferred movement, how much does the unit need to &quot;catch up&quot; by
&#9;&#9;--when moveBy&apos;d when a this path is ready for use.
&#9;&#9;local mDeferredDistance = 0

&#9;&#9;--current path data
&#9;&#9;local mHasMovementToDo = false
&#9;&#9;local mPathStopVector = {}
&#9;&#9;--pathstop = {
&#9;&#9;-- X, Y,        --start position 
&#9;&#9;-- UX, UY,      --direction
&#9;&#9;-- D,           --length
&#9;&#9;-- Qnodes = {}  --which qnodes this section is going through, so that
&#9;&#9;--              --when a path stop is completed the path can be removed
&#9;&#9;--              --from it&apos;s qnodes&apos; paths to invalidate lists.
&#9;&#9;--}
&#9;&#9;local mCurrentPathStop = 0
&#9;&#9;local mDistanceIntoCurrentPathStop = 0

&#9;&#9;--add the entity to the node it&apos;s on, and the broad-node it&apos;s in
&#9;&#9;do
&#9;&#9;&#9;local broadCell = this:getBroadCell(mX, mY)
&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;mCurrentBroadCell = broadCell
&#9;&#9;end

&#9;&#9;local function setPosition(x, y, ux, uy)
&#9;&#9;&#9;ux, uy = (ux or mUX), (uy or mUY)
&#9;&#9;&#9;mX, mY = x, y
&#9;&#9;&#9;mUX, mUY = ux, uy
&#9;&#9;&#9;local broadCell = this:getBroadCell(mX, mY)
&#9;&#9;&#9;if broadCell ~= mCurrentBroadCell then
&#9;&#9;&#9;&#9;remEntityFromBroad(mCurrentBroadCell, entity)
&#9;&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;&#9;mCurrentBroadCell = broadCell
&#9;&#9;&#9;end
&#9;&#9;&#9;entity.MobileUnit.onMove:fire(x, y, ux, uy)
&#9;&#9;end
&#9;&#9;--the public API can only teleport units, not make them move
&#9;&#9;--along paths through the board, so setPositon sets both true
&#9;&#9;--AND desired positions, and invalidates any current movement.
&#9;&#9;function path:setPosition(x, y, ux, uy)
&#9;&#9;&#9;mDesiredX = x
&#9;&#9;&#9;mDesiredY = y
&#9;&#9;&#9;setPosition(x, y, ux, uy)
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;function path:getPosition()
&#9;&#9;&#9;return mX, mY, mUX, mUY
&#9;&#9;end
&#9;&#9;function path:getDirection()
&#9;&#9;&#9;return mUX, mUY
&#9;&#9;end
&#9;&#9;function path:setDesiredPosition(x, y)
&#9;&#9;&#9;mDesiredX, mDesiredY = x, y
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;function path:getDesiredPosition()
&#9;&#9;&#9;return mDesiredX, mDesiredY
&#9;&#9;end
&#9;&#9;function path:moveBy(distance)
&#9;&#9;&#9;if not mIsValid then
&#9;&#9;&#9;&#9;mDeferredDistance = mDeferredDistance + distance
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--do move
&#9;&#9;&#9;&#9;distance = distance + mDeferredDistance
&#9;&#9;&#9;&#9;mDeferredDistance = 0
&#9;&#9;&#9;&#9;while mHasMovementToDo and distance &gt; 0 do
&#9;&#9;&#9;&#9;&#9;local curStop = mPathStopVector[mCurrentPathStop]
&#9;&#9;&#9;&#9;&#9;local distLeftInStop = curStop.D-mDistanceIntoCurrentPathStop
&#9;&#9;&#9;&#9;&#9;if distLeftInStop &gt; distance then
&#9;&#9;&#9;&#9;&#9;&#9;--can&apos;t finish this stop this round, use up all dist left
&#9;&#9;&#9;&#9;&#9;&#9;local offs = mDistanceIntoCurrentPathStop + distance
&#9;&#9;&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = offs
&#9;&#9;&#9;&#9;&#9;&#9;setPosition(curStop.X+curStop.UX*offs, curStop.Y+curStop.UY*offs,
&#9;&#9;&#9;&#9;&#9;&#9;            curStop.UX,                curStop.UY)
&#9;&#9;&#9;&#9;&#9;&#9;distance = 0
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--I can finish this node, advance to the next
&#9;&#9;&#9;&#9;&#9;&#9;distance = distance - distLeftInStop
&#9;&#9;&#9;&#9;&#9;&#9;mCurrentPathStop = mCurrentPathStop+1
&#9;&#9;&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0

&#9;&#9;&#9;&#9;&#9;&#9;--if this is the final node, then we need to do more work
&#9;&#9;&#9;&#9;&#9;&#9;if not mPathStopVector[mCurrentPathStop] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--done moving
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--free the pathstop vector
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mPathStopVector = nil --I&apos;ve already removed myself from the 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;                      --qnodes in htere, don&apos;t need it anymore
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--make sure I&apos;m positioned correctly for the final stop
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setPosition(curStop.X+curStop.UX*curStop.D, curStop.Y+curStop.UY*curStop.D,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;            curStop.UX,                     curStop.UY)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--just for good measure, make set x=desiredx, y=dsiredy
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--in theory these should not be equal already, but due to
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--floating point inaccuracy they may be slightly off, and
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--the code is best using x==desiredx/y to check if there is movement
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--to be done.
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setPosition(mDesiredX, mDesiredY)
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;--remove path from old cur-stop&apos;s Qnodes now that
&#9;&#9;&#9;&#9;&#9;&#9;--we&apos;re done with it.
&#9;&#9;&#9;&#9;&#9;&#9;for inx, qnode in pairs(curStop.Qnodes) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;qnode.PathMap[path] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:invalidate()
&#9;&#9;&#9;--print(&quot;Path Invalidated&quot;)
&#9;&#9;&#9;if mIsValid then
&#9;&#9;&#9;&#9;mIsValid = false
&#9;&#9;&#9;&#9;mInvalidPathMap[path] = true
&#9;&#9;&#9;&#9;if mPathStopVector then
&#9;&#9;&#9;&#9;&#9;for _, stop in pairs(mPathStopVector) do
&#9;&#9;&#9;&#9;&#9;&#9;for _, qnode in pairs(stop.Qnodes) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;qnode.PathMap[path] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:validate()
&#9;&#9;&#9;--print(&quot;Path Validated&quot;)
&#9;&#9;&#9;--not invalid anymore
&#9;&#9;&#9;mInvalidPathMap[path] = nil
&#9;&#9;&#9;mIsValid = true

&#9;&#9;&#9;--first check for the case where we&apos;re already where we need to be
&#9;&#9;&#9;if mX == mDesiredX and mY == mDesiredY then
&#9;&#9;&#9;&#9;--nothing to do
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;local from = getQnode(mX, mY)
&#9;&#9;&#9;local to = getQnode(mDesiredX, mDesiredY)
&#9;&#9;&#9;if not from or not to then
&#9;&#9;&#9;&#9;print(&quot;Can&apos;t move: pos&lt;&quot;..mX..&quot;,&quot;..mY..&quot;&gt; desired=&lt;&quot;..mDesiredX..&quot;,&quot;..mDesiredY..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;--the trivial case for movement within a single qnode
&#9;&#9;&#9;if from == to then
&#9;&#9;&#9;&#9;local ux = mDesiredX-mX
&#9;&#9;&#9;&#9;local uy = mDesiredY-mY
&#9;&#9;&#9;&#9;local len = math.sqrt(ux*ux + uy*uy)
&#9;&#9;&#9;&#9;ux, uy = ux/len, uy/len
&#9;&#9;&#9;&#9;mPathStopVector = {{
&#9;&#9;&#9;&#9;&#9;X = mX, Y = mY,
&#9;&#9;&#9;&#9;&#9;UX = ux, UY = uy,
&#9;&#9;&#9;&#9;&#9;D = len,
&#9;&#9;&#9;&#9;&#9;Qnodes = {},
&#9;&#9;&#9;&#9;}}
&#9;&#9;&#9;&#9;mCurrentPathStop = 1
&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0
&#9;&#9;&#9;&#9;mHasMovementToDo = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;--================= 
&#9;&#9;&#9;--     do A*
&#9;&#9;&#9;local openSet = {[from] = true}
&#9;&#9;&#9;--
&#9;&#9;&#9;local mPathfindGID = mQuadPathGID
&#9;&#9;&#9;mQuadPathGID = mQuadPathGID+1
&#9;&#9;&#9;--
&#9;&#9;&#9;local function distFromGoal(qnode)
&#9;&#9;&#9;&#9;local dx = (qnode.X+qnode.HalfSize)-(to.X+to.HalfSize)
&#9;&#9;&#9;&#9;local dy = (qnode.Y+qnode.HalfSize)-(to.Y+to.HalfSize)
&#9;&#9;&#9;&#9;return math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;to.CameFrom = nil
&#9;&#9;&#9;from.GScore = 0
&#9;&#9;&#9;from.HScore = distFromGoal(from)
&#9;&#9;&#9;from.FScore = from.HScore
&#9;&#9;&#9;from.LastOpenedId = mPathfindGID
&#9;&#9;&#9;--
&#9;&#9;&#9;local nodeNext = next(openSet)
&#9;&#9;&#9;while nodeNext do
&#9;&#9;&#9;&#9;--get the node with the lowest fscore
&#9;&#9;&#9;&#9;local lowestNode = nodeNext
&#9;&#9;&#9;&#9;for qnode, _ in pairs(openSet) do
&#9;&#9;&#9;&#9;&#9;if qnode.HScore &lt; lowestNode.HScore then
&#9;&#9;&#9;&#9;&#9;&#9;lowestNode = qnode
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--did we get to the target?
&#9;&#9;&#9;&#9;if lowestNode == to then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--close the current node
&#9;&#9;&#9;&#9;openSet[lowestNode] = nil
&#9;&#9;&#9;&#9;lowestNode.LastClosedId = mPathfindGID

&#9;&#9;&#9;&#9;--find new adjacents
&#9;&#9;&#9;&#9;for adj, dist in pairs(lowestNode.Adjacent) do
&#9;&#9;&#9;&#9;&#9;if adj.LastClosedId ~= mPathfindGID and adj.Height == from.Height then
&#9;&#9;&#9;&#9;&#9;&#9;local newgscore = lowestNode.GScore + dist
&#9;&#9;&#9;&#9;&#9;&#9;local newscoreIsBetter = false
&#9;&#9;&#9;&#9;&#9;&#9;if adj.LastOpenedId ~= mPathfindGID then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.LastOpenedId = mPathfindGID
&#9;&#9;&#9;&#9;&#9;&#9;&#9;openSet[adj] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = true
&#9;&#9;&#9;&#9;&#9;&#9;elseif newgscore &lt; adj.GScore then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = true
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if newscoreIsBetter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.CameFrom = lowestNode
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.GScore = newgscore
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.HScore = distFromGoal(adj)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.FScore = adj.GScore + adj.HScore
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;nodeNext = next(openSet)
&#9;&#9;&#9;end
&#9;&#9;&#9;--now, reconstruct the path
&#9;&#9;&#9;if to.CameFrom then
&#9;&#9;&#9;&#9;--first, flatten the linked-path into an array of nodes
&#9;&#9;&#9;&#9;local nodeArray = {}
&#9;&#9;&#9;&#9;local nd = to
&#9;&#9;&#9;&#9;while nd ~= from do
&#9;&#9;&#9;&#9;&#9;nodeArray[#nodeArray+1] = nd
&#9;&#9;&#9;&#9;&#9;nd = nd.CameFrom 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;nodeArray[#nodeArray+1] = from

&#9;&#9;&#9;&#9;--now, the array is in reverse order, build the stop vector
&#9;&#9;&#9;&#9;mPathStopVector = {}
&#9;&#9;&#9;&#9;for i = #nodeArray, 2, -1 do
&#9;&#9;&#9;&#9;&#9;local qat = nodeArray[i]
&#9;&#9;&#9;&#9;&#9;local qto = nodeArray[i-1]
&#9;&#9;&#9;&#9;&#9;local pathStop = {}
&#9;&#9;&#9;&#9;&#9;local atx, aty;
&#9;&#9;&#9;&#9;&#9;local tox, toy;
&#9;&#9;&#9;&#9;&#9;if qat == from then
&#9;&#9;&#9;&#9;&#9;&#9;atx, aty = mX, mY
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;atx, aty = qat.X+qat.HalfSize, qat.Y+qat.HalfSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if qto == to then
&#9;&#9;&#9;&#9;&#9;&#9;tox, toy = mDesiredX, mDesiredY
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;tox, toy = qto.X+qto.HalfSize, qto.Y+qto.HalfSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local dx = tox-atx
&#9;&#9;&#9;&#9;&#9;local dy = toy-aty
&#9;&#9;&#9;&#9;&#9;local len = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;pathStop.X = atx
&#9;&#9;&#9;&#9;&#9;pathStop.Y = aty
&#9;&#9;&#9;&#9;&#9;pathStop.UX = dx/len
&#9;&#9;&#9;&#9;&#9;pathStop.UY = dy/len
&#9;&#9;&#9;&#9;&#9;pathStop.D = len
&#9;&#9;&#9;&#9;&#9;pathStop.Qnodes = {qat}
&#9;&#9;&#9;&#9;&#9;qat.PathMap[path] = true
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;mPathStopVector[#mPathStopVector+1] = pathStop
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--the last node also cares about invalidation as a result of the to node, 
&#9;&#9;&#9;&#9;--not just the from node.
&#9;&#9;&#9;&#9;do
&#9;&#9;&#9;&#9;&#9;local qnodes = mPathStopVector[#mPathStopVector]
&#9;&#9;&#9;&#9;&#9;qnodes[#qnodes+1] = to
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--and finally put the path up for traversal
&#9;&#9;&#9;&#9;mHasMovementToDo = true
&#9;&#9;&#9;&#9;mCurrentPathStop = 1
&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:destroy()
&#9;&#9;&#9;--remove from the broad-phase, and the invalid map if I&apos;m there
&#9;&#9;&#9;remEntityFromBroad(mCurrentBroadCell, entity)

&#9;&#9;&#9;--also, remove from the paths to be validated (may or may not be
&#9;&#9;&#9;--currently int he map, doesn&apos;t matter which)
&#9;&#9;&#9;mInvalidPathMap[path] = nil
&#9;&#9;end


&#9;&#9;return path
&#9;end


&#9;--=========================================--
&#9;--==    the main add entity function     ==--
&#9;--=========================================--
&#9;function this:addEntity(entity)
&#9;&#9;--first things first, add it to the list of entities
&#9;&#9;entity.NextEntity_MainList = mEntityListHead
&#9;&#9;if mEntityListHead then
&#9;&#9;&#9;mEntityListHead.PrevEntity_MainList = entity
&#9;&#9;end
&#9;&#9;mEntityListHead = entity
&#9;&#9;mEntityCount = mEntityCount + 1

&#9;&#9;--assign it this gamestate
&#9;&#9;entity.GameState = this

&#9;&#9;--ticker, add it
&#9;&#9;if entity.Ticker then
&#9;&#9;&#9;this:addTicker(entity.Ticker)
&#9;&#9;end

&#9;&#9;--now, go through traits
&#9;&#9;if entity.Health then
&#9;&#9;&#9;--automatically remove units with health when they die
&#9;&#9;&#9;entity.Health.onDeath:connect(function()
&#9;&#9;&#9;&#9;this:remEntity(entity)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;--mobileunit
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;--add to the unit count
&#9;&#9;&#9;mUnitCount = mUnitCount + 1

&#9;&#9;&#9;--add a Mobile to the unit
&#9;&#9;&#9;entity.MobileUnit.Mobile = requestMobile(entity)
&#9;&#9;end

&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;--set ownership
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;team:addEntity(entity)

&#9;&#9;&#9;--listen for team changes
&#9;&#9;&#9;entity.TeamOwned.onTeamChange:connect(function(team, oldTeam)
&#9;&#9;&#9;&#9;--change ownership
&#9;&#9;&#9;&#9;oldTeam:remEntity(entity)
&#9;&#9;&#9;&#9;team:addEntity(entity)

&#9;&#9;&#9;&#9;--also, if I&apos;m a building need to update the
&#9;&#9;&#9;&#9;--entries in RegisteredToBroadMap
&#9;&#9;&#9;&#9;if entity.Building then
&#9;&#9;&#9;&#9;&#9;for broadCell, _ in pairs(entity.RegisteredToBroadMap) do
&#9;&#9;&#9;&#9;&#9;&#9;broadCell.TeamCount[oldTeam] = broadCell.TeamCount[oldTeam] - 1
&#9;&#9;&#9;&#9;&#9;&#9;broadCell.TeamCount[team] = broadCell.TeamCount[team] + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;if entity.Building then
&#9;&#9;&#9;--add the building to the grid
&#9;&#9;&#9;local building = entity.Building
&#9;&#9;&#9;local broadCellsAddedTo = {}
&#9;&#9;&#9;for dx = 1, building.W do
&#9;&#9;&#9;&#9;for dy = 1, building.H do
&#9;&#9;&#9;&#9;&#9;local x, y = building.X+dx-1, building.Y+dy-1
&#9;&#9;&#9;&#9;&#9;this:setCell(x, y, building)
&#9;&#9;&#9;&#9;&#9;local broadCell = this:getBroadCell(x, y)
&#9;&#9;&#9;&#9;&#9;if not broadCellsAddedTo[broadCell] then
&#9;&#9;&#9;&#9;&#9;&#9;broadCellsAddedTo[broadCell] = true
&#9;&#9;&#9;&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if entity.Class == &apos;GoldOre&apos; then
&#9;&#9;&#9;--special handling for gold ore
&#9;&#9;&#9;mAllGoldMap[entity] = true
&#9;&#9;elseif entity.Class == &apos;GoldMine&apos; then
&#9;&#9;&#9;--special handling for gold mine
&#9;&#9;&#9;mAllGoldMineMap[entity] = true
&#9;&#9;end

&#9;&#9;this.onEntityAdd:fire(entity)
&#9;end
&#9;function this:remEntity(entity)
&#9;&#9;--remove from main entity list
&#9;&#9;if entity.NextEntity_MainList then
&#9;&#9;&#9;entity.NextEntity_MainList.PrevEntity_MainList = entity.PrevEntity_MainList
&#9;&#9;end
&#9;&#9;if entity.PrevEntity_MainList then
&#9;&#9;&#9;entity.PrevEntity_MainList.NextEntity_MainList = entity.NextEntity_MainList
&#9;&#9;else
&#9;&#9;&#9;mEntityListHead = entity.NextEntity_MainList
&#9;&#9;end
&#9;&#9;mEntityCount = mEntityCount - 1

&#9;&#9;--ticker, rem it
&#9;&#9;if entity.Ticker then
&#9;&#9;&#9;this:remTicker(entity.Ticker)
&#9;&#9;end

&#9;&#9;--mobile unit, remove from unit count
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount - 1

&#9;&#9;&#9;--also, destory the mobile
&#9;&#9;&#9;entity.MobileUnit.Mobile:destroy()
&#9;&#9;end

&#9;&#9;--team owned, edit team counts
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;team:remEntity(entity)
&#9;&#9;end

&#9;&#9;--building? Remove from the game grid
&#9;&#9;if entity.Building then
&#9;&#9;&#9;local building = entity.Building
&#9;&#9;&#9;local broadCellsRemovedFrom = {}
&#9;&#9;&#9;for dx = 1, building.W do
&#9;&#9;&#9;&#9;for dy = 1, building.H do
&#9;&#9;&#9;&#9;&#9;local x, y = building.X+dx-1, building.Y+dy-1
&#9;&#9;&#9;&#9;&#9;this:setCell(x, y, nil) --get rid of the building
&#9;&#9;&#9;&#9;&#9;local broadCell = this:getBroadCell(x, y)
&#9;&#9;&#9;&#9;&#9;if not broadCellsRemovedFrom[broadCell] then
&#9;&#9;&#9;&#9;&#9;&#9;broadCellsRemovedFrom[broadCell] = true
&#9;&#9;&#9;&#9;&#9;&#9;remEntityFromBroad(broadCell, entity)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if entity.Class == &apos;GoldOre&apos; then
&#9;&#9;&#9;--special handling for gold ore
&#9;&#9;&#9;mAllGoldMap[entity] = nil
&#9;&#9;elseif entity.Class == &apos;GoldMine&apos; then
&#9;&#9;&#9;--special handling for gold mine
&#9;&#9;&#9;mAllGoldMineMap[entity] = nil
&#9;&#9;end

&#9;&#9;--call the signal, _BEFORE_ destorying the entity, just in case it&apos;s still
&#9;&#9;--needed for some cleanup.
&#9;&#9;this.onEntityRem:fire(entity)

&#9;&#9;--okay, all good. Fire the destructor of the thing removed
&#9;&#9;entity:destroy()
&#9;&#9;--print(&quot;Destroy Entity&lt;&quot;..entity.Class..&quot;&gt; Completed&quot;)
&#9;end
&#9;function this:eachEntity()
&#9;&#9;local curEnt = mEntityListHead
&#9;&#9;return function()
&#9;&#9;&#9;local e = curEnt
&#9;&#9;&#9;curEnt = (curEnt and curEnt.NextEntity_MainList or nil)
&#9;&#9;&#9;return e
&#9;&#9;end
&#9;end

&#9;------------------------------------------------------------------
&#9;-- utility functions for use by units / buildings / UI
&#9;local EmptyTable = {}
&#9;function this:isRectFree(x, y, w, h, unitToIgnore)
&#9;&#9;for px = x, x+w-1 do
&#9;&#9;&#9;for py = y, y+h-1 do
&#9;&#9;&#9;&#9;local cell = this:getCell(px, py)
&#9;&#9;&#9;&#9;if not cell or cell.Building ~= nil or cell.Height == 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Cell:&quot;, cell)
&#9;&#9;&#9;&#9;&#9;--if cell then
&#9;&#9;&#9;&#9;&#9;--&#9;print(&quot;=&gt; Building:&quot;, cell.Building, &quot;Height:&quot;, cell.Height)
&#9;&#9;&#9;&#9;&#9;--end
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return true
&#9;end

&#9;function this:getAllUnitsInRegion(x, y, w, h, team)
&#9;&#9;local unitList = {}
&#9;&#9;--
&#9;&#9;--print(&quot;GetUnitsIn&lt;&quot;..x..&quot;,&quot;..y..&quot;,&quot;..w..&quot;,&quot;..h..&quot;&gt; =&gt;&quot;)
&#9;&#9;if w &lt; 0 then x = x+w; w = -w; end
&#9;&#9;if h &lt; 0 then y = y+h; h = -h; end
&#9;&#9;--print(&quot;GetUnitsIn&lt;&quot;..x..&quot;,&quot;..y..&quot;,&quot;..w..&quot;,&quot;..h..&quot;&gt;&quot;)
&#9;&#9;local bx1 = math.floor((x-1)/8)+1
&#9;&#9;local by1 = math.floor((y-1)/8)+1
&#9;&#9;local bx2 = math.floor((x+w-1)/8)+1
&#9;&#9;local by2 = math.floor((y+h-1)/8)+1
&#9;&#9;--
&#9;&#9;for bx = bx1, bx2 do
&#9;&#9;&#9;for by = by1, by2 do
&#9;&#9;&#9;&#9;if not mBroadPhaseMap[bx] then
&#9;&#9;&#9;&#9;&#9;print(bx, by)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local broadNode = mBroadPhaseMap[bx][by]
&#9;&#9;&#9;&#9;for entity, _ in pairs(broadNode.EntityMap) do
&#9;&#9;&#9;&#9;&#9;if not team or (entity.MobileUnit and 
&#9;&#9;&#9;&#9;&#9;&#9;            entity.TeamOwned and
&#9;&#9;&#9;&#9;&#9;&#9;            entity.TeamOwned:getTeam() == team) 
&#9;&#9;&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;&#9;&#9;local px, py = entity.MobileUnit:getPosition()
&#9;&#9;&#9;&#9;&#9;&#9;if px &gt;= x and py &gt;= y and px &lt;= x+w and py &lt;= y+h then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unitList[#unitList+1] = entity
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;          
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--print(&quot;Got &quot;..(#unitList)..&quot; units&quot;)
&#9;&#9;--
&#9;&#9;return unitList
&#9;end

&#9;function this:findFreeSpaceByBuilding(entity, onWater)
&#9;&#9;if onWater == nil then onWater = false end
&#9;&#9;local b = entity.Building
&#9;&#9;for xp = b.X-1, b.X+b.W do
&#9;&#9;&#9;for yp = b.Y-1, b.Y+b.H do
&#9;&#9;&#9;&#9;local cell = this:getCell(xp, yp)
&#9;&#9;&#9;&#9;if cell and (cell.Height == 0) == onWater and not cell.Building then
&#9;&#9;&#9;&#9;&#9;return xp+0.5, yp+0.5
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return nil
&#9;end


&#9;------------------------------------------------------------------

&#9;Spawn(function()
&#9;&#9;local lastTime = tick()
&#9;&#9;while not mGameIsWon do
&#9;&#9;&#9;local currentTime = tick()
&#9;&#9;&#9;local dt = currentTime-lastTime
&#9;&#9;&#9;--

&#9;&#9;&#9;updatePaths(dt)
&#9;&#9;&#9;doTick(dt)

&#9;&#9;&#9;--
&#9;&#9;&#9;lastTime = currentTime
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;end)
end)











</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX9">
				<Properties>
					<string name="Name">Value</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX10">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Jumper</string>
					<ProtectedString name="Source">--gamestate

class&apos;Effect&apos;(function(this)
&#9;--abstract:
&#9;function this:getView() end&#9;
end)


--[[
========= Interfaces ==========
-------------------------------
Effect:
createView(): EffectView

-------------------------------


-------------------------------
Ticker:
tick(delta, elapsed)

-------------------------------


============ Traits ===========
-------------------------------
Displayable(entity): 
createView(inview: GameView) -&gt; :destroy() / :getPartList()

---
Health(entity): 
getHealth(), 
takeDamage(int: Damage), 
onDeath, 

---
ClickEffect(entity): 
activate()
Icon: string

---
MobileUnit(entity): 
OverLand: bool, OverWater: bool
getPosition(): (x, y, ux, uy), setPosition(x, y, ux, uy)
setDesiredPosition() 
onMove: (tox, toy)

---
TeamOwned(entity):
getTeam(): Team, setTeam(owner: Team)
onTeamChange(): newTeam, oldTeam

---
PowerConsumer:
getPowerConsumed()

---
PowerProducer:
getPowerProduced()

---
Building(entity):
X, Y, W, H


-------------------------------

]]


class&apos;Team&apos;(function(this, player)
&#9;local mAllies = {}

&#9;local mEntityCount = 0
&#9;local mUnitCount = 0
&#9;local mEntityListHead = nil

&#9;this.onEntityAdd = MakeSignal()
&#9;this.onEntityRem = MakeSignal()
&#9;this.onMoneyChange = MakeSignal()

&#9;local mMoney = 0

&#9;--the team&apos;s color
&#9;function this:getTeamColor()
&#9;&#9;return BrickColor.new(21)
&#9;end

&#9;--is a gien player an owner, only one player
&#9;--currently, but could be expanded.
&#9;function this:isOwner(p)
&#9;&#9;return p == player
&#9;end

&#9;--alliance info
&#9;function this:addAlly(team)
&#9;&#9;mAllies[team] = true
&#9;end
&#9;function this:isAlly(team)
&#9;&#9;return mAllies[team] or false
&#9;end

&#9;--add/remove units
&#9;function this:addEntity(entity)
&#9;&#9;--add to counts
&#9;&#9;mEntityCount = mEntityCount+1
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount+1
&#9;&#9;end
&#9;&#9;--add to linked list
&#9;&#9;entity.NextEntity_TeamList = mEntityListHead
&#9;&#9;if mEntityListHead then
&#9;&#9;&#9;mEntityListHead.PrevEntity_TeamList = entity
&#9;&#9;end
&#9;&#9;mEntityListHead = entity
&#9;&#9;--
&#9;&#9;this.onEntityAdd:fire(entity)
&#9;end
&#9;function this:remEntity(entity)
&#9;&#9;--remove from stats
&#9;&#9;mEntityCount = mEntityCount-1
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount-1
&#9;&#9;end
&#9;&#9;--remove from linked list
&#9;&#9;if entity.NextEntity_TeamList then
&#9;&#9;&#9;entity.NextEntity_TeamList.PrevEntity_TeamList = 
&#9;&#9;&#9;&#9;entity.PrevEntity_TeamList
&#9;&#9;end
&#9;&#9;if entity.PrevEntity_TeamList then
&#9;&#9;&#9;entity.PrevEntity_TeamList.NextEntity_TeamList =
&#9;&#9;&#9;&#9;entity.NextEntity_TeamList
&#9;&#9;else
&#9;&#9;&#9;mEntityListHead = entity.NextEntity_TeamList
&#9;&#9;end
&#9;&#9;--
&#9;&#9;this.onEntityRem:fire(entity)
&#9;end

&#9;--getters
&#9;function this:getEntityCount()
&#9;&#9;return mEntityCount
&#9;end
&#9;function this:getUnitCount()
&#9;&#9;return mUnitCount
&#9;end

&#9;--money
&#9;function this:creditMoney(amount)
&#9;&#9;mMoney = mMoney + amount
&#9;&#9;this.onMoneyChange:fire(mMoney)
&#9;end
&#9;function this:debitMoney(amount)
&#9;&#9;if mMoney &gt;= amount then
&#9;&#9;&#9;mMoney = mMoney - amount
&#9;&#9;&#9;this.onMoneyChange:fire(mMoney)
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;function this:getMoney()
&#9;&#9;return mMoney&#9;
&#9;end

&#9;--units
&#9;function this:eachEntity()
&#9;&#9;local curEnt = mEntityListHead
&#9;&#9;return function()
&#9;&#9;&#9;local e = curEnt
&#9;&#9;&#9;curEnt = (curEnt and curEnt.NextEntity_TeamList or nil)
&#9;&#9;&#9;return e
&#9;&#9;end
&#9;end
end)


class&apos;GameState&apos;(function(this, settings, teams)
&#9;--=========================================--
&#9;--==     general game functionality      ==--
&#9;--=========================================--
&#9;local mGameIsWon = false

&#9;--=========================================--
&#9;--==          tick functionality         ==--
&#9;--=========================================--
&#9;local mTickerHead = nil
&#9;function this:addTicker(ticker)
&#9;&#9;ticker.TickAddedTime = tick()
&#9;&#9;ticker.TickNext = mTickerHead
&#9;&#9;if mTickerHead then
&#9;&#9;&#9;mTickerHead.TickPrev = ticker
&#9;&#9;end
&#9;&#9;mTickerHead = ticker
&#9;end
&#9;function this:remTicker(ticker)
&#9;&#9;if ticker.TickNext then
&#9;&#9;&#9;ticker.TickNext.TickPrev = ticker.TickPrev
&#9;&#9;end
&#9;&#9;if ticker.TickPrev then
&#9;&#9;&#9;ticker.TickPrev.TickNext = ticker.TickNext
&#9;&#9;else
&#9;&#9;&#9;mTickerHead = ticker.TickNext
&#9;&#9;end
&#9;end
&#9;local function doTick(dt)
&#9;&#9;local curTime = tick()
&#9;&#9;local ticker = mTickerHead
&#9;&#9;while ticker do
&#9;&#9;&#9;ticker:tick(dt, curTime-ticker.TickAddedTime)
&#9;&#9;&#9;ticker = ticker.TickNext
&#9;&#9;end
&#9;end


&#9;--=========================================--
&#9;--==       general eneity tracking       ==--
&#9;--=========================================--
&#9;local mEntityCount = 0
&#9;local mUnitCount = 0
&#9;local mEntityListHead = nil
&#9;--

&#9;this.onEntityAdd = MakeSignal()
&#9;this.onEntityRem = MakeSignal()


&#9;--=========================================--
&#9;--==          gold ore tracking          ==--
&#9;--=========================================--
&#9;local mGoldTeam = MakeTeam(nil)
&#9;local mAllGoldMap = {}
&#9;local mAllGoldMineMap = {}
&#9;function this:eachGoldMine()
&#9;&#9;return pairs(mAllGoldMineMap)
&#9;end
&#9;function this:eachGold()
&#9;&#9;return pairs(mAllGoldMap)
&#9;end


&#9;--=========================================--
&#9;--==         board functionality         ==--
&#9;--=========================================--
&#9;local mTileMapRaw = {}
&#9;--todo: for debugging, remove
&#9;local mBoardSize = settings:getSetting(MatchSettings.GameSize).BoardSize

&#9;function this:getBoardSize()
&#9;&#9;return mBoardSize
&#9;end

&#9;--init main board data
&#9;for x = 1, mBoardSize do
&#9;&#9;local col = {}
&#9;&#9;mTileMapRaw[x] = col
&#9;&#9;for y = 1, mBoardSize do
&#9;&#9;&#9;local cell = {}
&#9;&#9;&#9;col[y] = cell
&#9;&#9;&#9;--
&#9;&#9;&#9;cell.X = x
&#9;&#9;&#9;cell.Y = y
&#9;&#9;&#9;cell.Height = 0
&#9;&#9;&#9;cell.Ramp = false
&#9;&#9;&#9;cell.Building = nil
&#9;&#9;end
&#9;end
&#9;local EmptyTable = {}
&#9;function this:getCell(x, y)
&#9;&#9;return (mTileMapRaw[x] or EmptyTable)[y]
&#9;end

&#9;--init broad-phase map
&#9;local mBroadPhaseMap = {}
&#9;mBroadPhaseSize = mBoardSize/8
&#9;for x = 1, mBroadPhaseSize do
&#9;&#9;local col = {}
&#9;&#9;mBroadPhaseMap[x] = col
&#9;&#9;for y = 1, mBroadPhaseSize do
&#9;&#9;&#9;local cell = {}
&#9;&#9;&#9;col[y] = cell
&#9;&#9;&#9;--
&#9;&#9;&#9;cell.EntityCount = 0
&#9;&#9;&#9;cell.EntityMap = {}
&#9;&#9;&#9;cell.TeamCount = {}
&#9;&#9;&#9;for _, team in pairs(teams) do
&#9;&#9;&#9;&#9;cell.TeamCount[team] = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function this:getBroadCell(x, y)
&#9;&#9;x = math.floor((x-1)/8)+1
&#9;&#9;y = math.floor((y-1)/8)+1
&#9;&#9;--
&#9;&#9;return mBroadPhaseMap[x][y]
&#9;end
&#9;local function addEntityToBroad(bnode, entity)
&#9;&#9;bnode.EntityMap[entity] = true
&#9;&#9;bnode.EntityCount = bnode.EntityCount+1
&#9;&#9;--team ownership? Add it to the count for that space
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;if not entity.TeamOwned.RegisteredToBroadMap then
&#9;&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap = {}
&#9;&#9;&#9;end
&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap[bnode] = true
&#9;&#9;&#9;bnode.TeamCount[team] = bnode.TeamCount[team] + 1
&#9;&#9;end
&#9;end
&#9;local function remEntityFromBroad(bnode, entity)
&#9;&#9;bnode.EntityMap[entity] = nil
&#9;&#9;bnode.EntityCount = bnode.EntityCount - 1
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;entity.TeamOwned.RegisteredToBroadMap[bnode] = nil
&#9;&#9;&#9;bnode.TeamCount[team] = bnode.TeamCount[team] - 1
&#9;&#9;end
&#9;end

&#9;--init quad-tree
&#9;local mQuadRoot = {
&#9;&#9;Height = 0,
&#9;&#9;Ramp = false,
&#9;&#9;Building = nil,
&#9;&#9;--
&#9;&#9;X = 1, Y = 1,
&#9;&#9;Size = mBoardSize,
&#9;&#9;HalfSize = mBoardSize/2,
&#9;&#9;--
&#9;&#9;Adjacent = {},
&#9;&#9;Parent = nil,
&#9;&#9;Children = nil,
&#9;&#9;Leaf = true,
&#9;&#9;--
&#9;&#9;PathMap = {},
&#9;}
&#9;local mQuadPathGID = 1
&#9;this.onQnodeShow = MakeSignal()
&#9;this.onQnodeHide = MakeSignal()

&#9;local function getQnode(x, y, inNode)
&#9;&#9;if x &gt;= mBoardSize+1 or y &gt;= mBoardSize+1 or x &lt; 1 or y &lt; 1 then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;local nd = inNode or mQuadRoot
&#9;&#9;while not nd.Leaf do
&#9;&#9;&#9;local dx = (x-nd.X)/nd.HalfSize
&#9;&#9;&#9;local dy = (y-nd.Y)/nd.HalfSize
&#9;&#9;&#9;if dx &lt; 1 then
&#9;&#9;&#9;&#9;if dy &lt; 1 then
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[1]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[3]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if dy &lt; 1 then
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[2]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;nd = nd.Children[4]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return nd
&#9;end
&#9;local function eachAdjacentQnode(qnode, f)
&#9;&#9;local mx = qnode.X
&#9;&#9;local my = qnode.Y
&#9;&#9;local size = qnode.Size
&#9;&#9;--now patch in the new connections
&#9;&#9;for d = 0, size do
&#9;&#9;&#9;local adj
&#9;&#9;&#9;--top
&#9;&#9;&#9;adj = getQnode(mx+d-1, my-1)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--bottom
&#9;&#9;&#9;adj = getQnode(mx+d, my+size)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--left
&#9;&#9;&#9;adj = getQnode(mx-1, my+d)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;&#9;--right
&#9;&#9;&#9;adj = getQnode(mx+size, my+d-1)
&#9;&#9;&#9;if adj then f(adj) end
&#9;&#9;end
&#9;end

&#9;--(actually accepts cells or qnodes, they have identical 
&#9;-- members for the purposes of this function)
&#9;local function isQnodeCompatible(qnodea, qnodeb)
&#9;&#9;if (qnodea.Height==0) ~= (qnodeb.Height==0) then
&#9;&#9;&#9;--if one is water and the other is not (both are water is fine)
&#9;&#9;&#9;return false
&#9;&#9;elseif qnodea.Building or qnodeb.Building then
&#9;&#9;&#9;--one is obstructed
&#9;&#9;&#9;return false
&#9;&#9;else
&#9;&#9;&#9;--compare heights
&#9;&#9;&#9;if qnodea.Height == qnodeb.Height then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;elseif qnodea.Ramp and qnodeb.Ramp then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local function invalidateQnodePaths(qnode)
&#9;&#9;local count = 0
&#9;&#9;for path, _ in pairs(qnode.PathMap) do
&#9;&#9;&#9;count = count+1
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;--print(&quot;Invalidate &quot;..count..&quot; paths for Qnode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;end
&#9;local function clearQnodeAdjacent(qnode)
&#9;&#9;for adj, dist in pairs(qnode.Adjacent) do
&#9;&#9;&#9;adj.Adjacent[qnode] = nil
&#9;&#9;&#9;qnode.Adjacent[adj] = nil
&#9;&#9;end
&#9;end
&#9;local function assignQnodeAdjacent(qnode)
&#9;&#9;eachAdjacentQnode(qnode, function(nd)
&#9;&#9;&#9;if isQnodeCompatible(qnode, nd) then
&#9;&#9;&#9;&#9;local dx = ((nd.X+nd.HalfSize)-(qnode.X+qnode.HalfSize))
&#9;&#9;&#9;&#9;local dy = ((nd.Y+nd.HalfSize)-(qnode.Y+qnode.HalfSize))
&#9;&#9;&#9;&#9;local shouldMakeCon = true
&#9;&#9;&#9;&#9;if math.abs(dx) == math.abs(dy) then
&#9;&#9;&#9;&#9;&#9;--it&apos;s a diagonal. Diagonals need to be checked that they are
&#9;&#9;&#9;&#9;&#9;--not obstructed on both sides by non-passable squares
&#9;&#9;&#9;&#9;&#9;local ux = ((dx&gt;0) and 1 or -1)
&#9;&#9;&#9;&#9;&#9;local uy = ((dy&gt;0) and 1 or -1)
&#9;&#9;&#9;&#9;&#9;local hs = qnode.HalfSize&#9;
&#9;&#9;&#9;&#9;&#9;--print(&quot;Between Qnode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;&gt; and Adj&lt;&quot;..
&#9;&#9;&#9;&#9;&#9;--                        nd.X..&quot;,&quot;..nd.Y..&quot;&gt;, u=&lt;&quot;..ux..&quot;,&quot;..uy..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;--print(&quot;Get Adj1 &lt;&quot;..(math.floor(qnode.X+hs + ux*hs - uy*0.2))..&quot;,&quot;..
&#9;&#9;&#9;&#9;&#9;--                    (math.floor(qnode.Y+hs + uy*hs + ux*0.2))..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;local adj1 = mTileMapRaw[math.floor(qnode.X+hs + ux*hs - uy*0.2)]
&#9;&#9;&#9;&#9;&#9;                        [math.floor(qnode.Y+hs + uy*hs + ux*0.2)]
&#9;&#9;&#9;&#9;&#9;--print(&quot;Get Adj2 &lt;&quot;..(math.floor(qnode.X+hs + ux*hs + uy*0.2))..&quot;,&quot;..
&#9;&#9;&#9;&#9;&#9;--                    (math.floor(qnode.Y+hs + uy*hs - ux*0.2))..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;local adj2 = mTileMapRaw[math.floor(qnode.X+hs + ux*hs + uy*0.2)]
&#9;&#9;&#9;&#9;&#9;                        [math.floor(qnode.Y+hs + uy*hs - ux*0.2)]
&#9;&#9;&#9;&#9;&#9;if not (isQnodeCompatible(qnode, adj1) or isQnodeCompatible(qnode, adj2)) then
&#9;&#9;&#9;&#9;&#9;&#9;shouldMakeCon = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if shouldMakeCon then
&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;qnode.Adjacent[nd] = dist
&#9;&#9;&#9;&#9;&#9;nd.Adjacent[qnode] = dist
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
&#9;local function splitQnode(qnode)
&#9;&#9;--must be larger than size 1
&#9;&#9;if qnode.Size &gt; 1 then
&#9;&#9;&#9;--print(&quot;SPLIT QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;&#9;local mx, my = qnode.X, qnode.Y
&#9;&#9;&#9;local hs = qnode.HalfSize
&#9;&#9;&#9;local c1 = {X = mx,    Y = my}
&#9;&#9;&#9;local c2 = {X = mx+hs, Y = my}
&#9;&#9;&#9;local c3 = {X = mx,    Y = my+hs}
&#9;&#9;&#9;local c4 = {X = mx+hs, Y = my+hs}
&#9;&#9;&#9;local children = {c1, c2, c3, c4}
&#9;&#9;&#9;for _, ch in pairs(children) do
&#9;&#9;&#9;&#9;ch.Height = qnode.Height
&#9;&#9;&#9;&#9;ch.Ramp = qnode.Ramp
&#9;&#9;&#9;&#9;ch.Building = qnode.Building
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.Size = hs
&#9;&#9;&#9;&#9;ch.HalfSize = hs/2
&#9;&#9;&#9;&#9;--X/Y assigned specially above
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.Adjacent = {}
&#9;&#9;&#9;&#9;ch.Parent = qnode
&#9;&#9;&#9;&#9;ch.Children = nil
&#9;&#9;&#9;&#9;ch.Leaf = true
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;ch.PathMap = {}
&#9;&#9;&#9;end
&#9;&#9;&#9;--now make those nodes the children 
&#9;&#9;&#9;--of the node being split
&#9;&#9;&#9;qnode.Children = children
&#9;&#9;&#9;qnode.Leaf = false --no longer a leaf

&#9;&#9;&#9;--invalidate paths
&#9;&#9;&#9;invalidateQnodePaths(qnode)

&#9;&#9;&#9;--kill all of node&apos;s existing adjacent connections
&#9;&#9;&#9;clearQnodeAdjacent(qnode)

&#9;&#9;&#9;--assign new connections for nodes
&#9;&#9;&#9;for _, ch in pairs(children) do
&#9;&#9;&#9;&#9;assignQnodeAdjacent(ch)
&#9;&#9;&#9;end

&#9;&#9;&#9;--call events
&#9;&#9;&#9;this.onQnodeHide:fire(qnode)
&#9;&#9;&#9;this.onQnodeShow:fire(c1)
&#9;&#9;&#9;this.onQnodeShow:fire(c2)
&#9;&#9;&#9;this.onQnodeShow:fire(c3)
&#9;&#9;&#9;this.onQnodeShow:fire(c4)
&#9;&#9;end
&#9;end
&#9;local function trymergeQnode(qnode)
&#9;&#9;if not qnode.Parent then return nil end
&#9;&#9;--
&#9;&#9;local par = qnode.Parent
&#9;&#9;local allParentChildrenMap = {}
&#9;&#9;local canMerge = true
&#9;&#9;for _, ch in pairs(par.Children) do
&#9;&#9;&#9;allParentChildrenMap[ch] = true
&#9;&#9;&#9;if (ch.Leaf) and
&#9;&#9;&#9;   (qnode.Building and true) == (ch.Building and true) and 
&#9;&#9;&#9;   (qnode.Height == ch.Height) and
&#9;&#9;&#9;   (qnode.Ramp == ch.Ramp)
&#9;&#9;&#9;then
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;canMerge = false&#9;
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if canMerge then
&#9;&#9;&#9;--print(&quot;MERGE QNode&lt;&quot;..qnode.X..&quot;,&quot;..qnode.Y..&quot;,&quot;..qnode.Size..&quot;&gt;&quot;)
&#9;&#9;&#9;par.Height = qnode.Height
&#9;&#9;&#9;par.Ramp = qnode.Ramp
&#9;&#9;&#9;par.Building = qnode.Building
&#9;&#9;&#9;--
&#9;&#9;&#9;--fix up adjacents
&#9;&#9;&#9;for ch, _ in pairs(allParentChildrenMap) do
&#9;&#9;&#9;&#9;for adj, dist in pairs(ch.Adjacent) do
&#9;&#9;&#9;&#9;&#9;if not allParentChildrenMap[adj] then
&#9;&#9;&#9;&#9;&#9;&#9;--this is not one of the child nodes, but an adjacent one
&#9;&#9;&#9;&#9;&#9;&#9;--to the parent, so connect it to the parent
&#9;&#9;&#9;&#9;&#9;&#9;adj.Adjacent[ch] = nil
&#9;&#9;&#9;&#9;&#9;&#9;local dx = (par.X+par.HalfSize)-(adj.X+adj.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dy = (par.Y+par.HalfSize)-(adj.Y+adj.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;&#9;adj.Adjacent[par] = dist
&#9;&#9;&#9;&#9;&#9;&#9;par.Adjacent[adj] = dist
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local ch = par.Children
&#9;&#9;&#9;--change the parent to a leaf
&#9;&#9;&#9;par.Children = nil
&#9;&#9;&#9;par.Leaf = true
&#9;&#9;&#9;this.onQnodeHide:fire(ch[1])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[2])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[3])
&#9;&#9;&#9;this.onQnodeHide:fire(ch[4])
&#9;&#9;&#9;--
&#9;&#9;&#9;invalidateQnodePaths(ch[1])
&#9;&#9;&#9;invalidateQnodePaths(ch[2])
&#9;&#9;&#9;invalidateQnodePaths(ch[3])
&#9;&#9;&#9;invalidateQnodePaths(ch[4])
&#9;&#9;&#9;--
&#9;&#9;&#9;this.onQnodeShow:fire(par)

&#9;&#9;&#9;--and finally return the merged node
&#9;&#9;&#9;return par
&#9;&#9;end
&#9;&#9;return nil
&#9;end
&#9;--now, with the init done, define the set function for a tile
&#9;function this:setCell(x, y, building, h, ramp)
&#9;&#9;if not mTileMapRaw[x] or not mTileMapRaw[x][y] then return end

&#9;&#9;--first off, do the easy set of the flat-array cell
&#9;&#9;local cell = mTileMapRaw[x][y]
&#9;&#9;--set possibly unspecified arguments
&#9;&#9;h = h or cell.Height
&#9;&#9;ramp = ramp or cell.Ramp

&#9;&#9;--set values in flat-cell
&#9;&#9;cell.Building = building
&#9;&#9;cell.Height = h
&#9;&#9;cell.Ramp = ramp

&#9;&#9;--get the node
&#9;&#9;local nd = getQnode(x, y)

&#9;&#9;--might need to break
&#9;&#9;if (nd.Building and true) ~= (building and true) or nd.Height ~= h or nd.Ramp ~= ramp then
&#9;&#9;&#9;--get the leaf. It has to be size 1, since this whole node
&#9;&#9;&#9;--is not the type in question.
&#9;&#9;&#9;while nd.Size &gt; 1 do
&#9;&#9;&#9;&#9;splitQnode(nd)
&#9;&#9;&#9;&#9;nd = getQnode(x, y, nd)
&#9;&#9;&#9;end

&#9;&#9;&#9;--set the leaf stats
&#9;&#9;&#9;nd.Height = h
&#9;&#9;&#9;nd.Ramp = ramp
&#9;&#9;&#9;nd.Building = building

&#9;&#9;&#9;--then, update the connections for the new type of node
&#9;&#9;&#9;clearQnodeAdjacent(nd)
&#9;&#9;&#9;assignQnodeAdjacent(nd)

&#9;&#9;&#9;--and invalidate th paths
&#9;&#9;&#9;invalidateQnodePaths(nd)

&#9;&#9;&#9;--now, update diagonal links at the corners of this square. The
&#9;&#9;&#9;--change may have obstructed them, even though they don&apos;t involve
&#9;&#9;&#9;--the square itself:
&#9;&#9;&#9;--A 1 2 B
&#9;&#9;&#9;--8|&#175;&#175;&#175;|3 Connections to check: 2-3, 4-5, 6-7, 8-1
&#9;&#9;&#9;--7|___|4
&#9;&#9;&#9;--D 6 5 C
&#9;&#9;&#9;local sA = getQnode(nd.X-1,         nd.Y-1)
&#9;&#9;&#9;local s1 = getQnode(nd.X,           nd.Y-1)
&#9;&#9;&#9;local s2 = getQnode(nd.X+nd.Size-1, nd.Y-1)
&#9;&#9;&#9;local sB = getQnode(nd.X+nd.Size,   nd.Y-1)
&#9;&#9;&#9;local s3 = getQnode(nd.X+nd.Size,   nd.Y)
&#9;&#9;&#9;local s4 = getQnode(nd.X+nd.Size,   nd.Y+nd.Size-1)
&#9;&#9;&#9;local sC = getQnode(nd.X+nd.Size,   nd.Y+nd.Size)
&#9;&#9;&#9;local s5 = getQnode(nd.X+nd.Size-1, nd.Y+nd.Size)
&#9;&#9;&#9;local s6 = getQnode(nd.X,           nd.Y+nd.Size)
&#9;&#9;&#9;local sD = getQnode(nd.X-1,         nd.Y+nd.Size)
&#9;&#9;&#9;local s7 = getQnode(nd.X-1,         nd.Y+nd.Size-1)
&#9;&#9;&#9;local s8 = getQnode(nd.X-1,         nd.Y)
&#9;&#9;&#9;local function verifyLink(a, b, corner)
&#9;&#9;&#9;&#9;if isQnodeCompatible(a, b) and 
&#9;&#9;&#9;&#9;   (isQnodeCompatible(a, corner) or isQnodeCompatible(a, nd))
&#9;&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;&#9;if not a.Adjacent[b] then
&#9;&#9;&#9;&#9;&#9;&#9;local dx = (a.X+a.HalfSize) - (b.X+b.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dy = (a.Y+a.HalfSize) - (b.Y+b.HalfSize)
&#9;&#9;&#9;&#9;&#9;&#9;local dist = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;&#9;a.Adjacent[b] = dist
&#9;&#9;&#9;&#9;&#9;&#9;b.Adjacent[a] = dist
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(a)
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(b)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if a.Adjacent[b] then
&#9;&#9;&#9;&#9;&#9;&#9;a.Adjacent[b] = nil
&#9;&#9;&#9;&#9;&#9;&#9;b.Adjacent[a] = nil
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(a)
&#9;&#9;&#9;&#9;&#9;&#9;invalidateQnodePaths(b)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end
&#9;&#9;&#9;if s2 and s3 and s2~=sB and s3~=sB then verifyLink(s2, s3, sB) end
&#9;&#9;&#9;if s4 and s5 and s4~=sC and s5~=sC then verifyLink(s4, s5, sC) end
&#9;&#9;&#9;if s6 and s7 and s6~=sD and s7~=sD then verifyLink(s6, s7, sD) end
&#9;&#9;&#9;if s8 and s1 and s8~=sA and s1~=sA then verifyLink(s8, s1, sA) end 
&#9;&#9;&#9;--
&#9;&#9;&#9;this.onQnodeShow:fire(nd)

&#9;&#9;&#9;--do a recursive merge
&#9;&#9;&#9;while nd do
&#9;&#9;&#9;&#9;nd = trymergeQnode(nd)
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;end
&#9;function this:getRootQnode()
&#9;&#9;return mQuadRoot
&#9;end
&#9;function this:getQnode(x, y)
&#9;&#9;return getQnode(x, y)
&#9;end

&#9;--set map cells:
&#9;do
&#9;&#9;local mapDat = MapProvider.SmallMap1.Grid
&#9;&#9;for y = 1, mBoardSize do
&#9;&#9;&#9;local line = mapDat[y]
&#9;&#9;&#9;for x = 1, mBoardSize do
&#9;&#9;&#9;&#9;local sqVal = line:sub(x,x)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local height = 0
&#9;&#9;&#9;&#9;local ramp = false
&#9;&#9;&#9;&#9;if sqVal == &apos;_&apos; then
&#9;&#9;&#9;&#9;&#9;height = 0
&#9;&#9;&#9;&#9;elseif sqVal == &apos;#&apos; then
&#9;&#9;&#9;&#9;&#9;height = 1
&#9;&#9;&#9;&#9;elseif sqVal == &apos;O&apos; then
&#9;&#9;&#9;&#9;&#9;height = 1
&#9;&#9;&#9;&#9;&#9;--todo: spawn is here
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;this:setCell(x, y, nil, height, ramp)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end



&#9;--=========================================--
&#9;--==  pathfinding code for mobile units  ==--
&#9;--=========================================--
&#9;local mInvalidPathMap = {} --paths that need validating
&#9;local function updatePaths(dt)
&#9;&#9;for path, _ in pairs(mInvalidPathMap) do
&#9;&#9;&#9;path:validate()
&#9;&#9;end
&#9;end
&#9;local function requestMobile(entity)
&#9;&#9;local path = {}

&#9;&#9;--start out not valid, and added to the invalid paths list
&#9;&#9;local mIsValid = false
&#9;&#9;mInvalidPathMap[path] = true

&#9;&#9;--current position
&#9;&#9;local mX = 1
&#9;&#9;local mY = 1
&#9;&#9;local mUX = 1
&#9;&#9;local mUY = 0
&#9;&#9;local mDesiredX = 1
&#9;&#9;local mDesiredY = 1
&#9;&#9;local mCurrentBroadCell = nil --TBA. below

&#9;&#9;--deferred movement, how much does the unit need to &quot;catch up&quot; by
&#9;&#9;--when moveBy&apos;d when a this path is ready for use.
&#9;&#9;local mDeferredDistance = 0

&#9;&#9;--current path data
&#9;&#9;local mHasMovementToDo = false
&#9;&#9;local mPathStopVector = {}
&#9;&#9;--pathstop = {
&#9;&#9;-- X, Y,        --start position 
&#9;&#9;-- UX, UY,      --direction
&#9;&#9;-- D,           --length
&#9;&#9;-- Qnodes = {}  --which qnodes this section is going through, so that
&#9;&#9;--              --when a path stop is completed the path can be removed
&#9;&#9;--              --from it&apos;s qnodes&apos; paths to invalidate lists.
&#9;&#9;--}
&#9;&#9;local mCurrentPathStop = 0
&#9;&#9;local mDistanceIntoCurrentPathStop = 0

&#9;&#9;--add the entity to the node it&apos;s on, and the broad-node it&apos;s in
&#9;&#9;do
&#9;&#9;&#9;local broadCell = this:getBroadCell(mX, mY)
&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;mCurrentBroadCell = broadCell
&#9;&#9;end

&#9;&#9;local function setPosition(x, y, ux, uy)
&#9;&#9;&#9;ux, uy = (ux or mUX), (uy or mUY)
&#9;&#9;&#9;mX, mY = x, y
&#9;&#9;&#9;mUX, mUY = ux, uy
&#9;&#9;&#9;local broadCell = this:getBroadCell(mX, mY)
&#9;&#9;&#9;if broadCell ~= mCurrentBroadCell then
&#9;&#9;&#9;&#9;remEntityFromBroad(mCurrentBroadCell, entity)
&#9;&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;&#9;mCurrentBroadCell = broadCell
&#9;&#9;&#9;end
&#9;&#9;&#9;entity.MobileUnit.onMove:fire(x, y, ux, uy)
&#9;&#9;end
&#9;&#9;--the public API can only teleport units, not make them move
&#9;&#9;--along paths through the board, so setPositon sets both true
&#9;&#9;--AND desired positions, and invalidates any current movement.
&#9;&#9;function path:setPosition(x, y, ux, uy)
&#9;&#9;&#9;mDesiredX = x
&#9;&#9;&#9;mDesiredY = y
&#9;&#9;&#9;setPosition(x, y, ux, uy)
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;function path:getPosition()
&#9;&#9;&#9;return mX, mY, mUX, mUY
&#9;&#9;end
&#9;&#9;function path:getDirection()
&#9;&#9;&#9;return mUX, mUY
&#9;&#9;end
&#9;&#9;function path:setDesiredPosition(x, y)
&#9;&#9;&#9;mDesiredX, mDesiredY = x, y
&#9;&#9;&#9;path:invalidate()
&#9;&#9;end
&#9;&#9;function path:getDesiredPosition()
&#9;&#9;&#9;return mDesiredX, mDesiredY
&#9;&#9;end
&#9;&#9;function path:moveBy(distance)
&#9;&#9;&#9;if not mIsValid then
&#9;&#9;&#9;&#9;mDeferredDistance = mDeferredDistance + distance
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--do move
&#9;&#9;&#9;&#9;distance = distance + mDeferredDistance
&#9;&#9;&#9;&#9;mDeferredDistance = 0
&#9;&#9;&#9;&#9;while mHasMovementToDo and distance &gt; 0 do
&#9;&#9;&#9;&#9;&#9;local curStop = mPathStopVector[mCurrentPathStop]
&#9;&#9;&#9;&#9;&#9;local distLeftInStop = curStop.D-mDistanceIntoCurrentPathStop
&#9;&#9;&#9;&#9;&#9;if distLeftInStop &gt; distance then
&#9;&#9;&#9;&#9;&#9;&#9;--can&apos;t finish this stop this round, use up all dist left
&#9;&#9;&#9;&#9;&#9;&#9;local offs = mDistanceIntoCurrentPathStop + distance
&#9;&#9;&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = offs
&#9;&#9;&#9;&#9;&#9;&#9;setPosition(curStop.X+curStop.UX*offs, curStop.Y+curStop.UY*offs,
&#9;&#9;&#9;&#9;&#9;&#9;            curStop.UX,                curStop.UY)
&#9;&#9;&#9;&#9;&#9;&#9;distance = 0
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--I can finish this node, advance to the next
&#9;&#9;&#9;&#9;&#9;&#9;distance = distance - distLeftInStop
&#9;&#9;&#9;&#9;&#9;&#9;mCurrentPathStop = mCurrentPathStop+1
&#9;&#9;&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0

&#9;&#9;&#9;&#9;&#9;&#9;--if this is the final node, then we need to do more work
&#9;&#9;&#9;&#9;&#9;&#9;if not mPathStopVector[mCurrentPathStop] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--done moving
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--free the pathstop vector
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mPathStopVector = nil --I&apos;ve already removed myself from the 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;                      --qnodes in htere, don&apos;t need it anymore
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--make sure I&apos;m positioned correctly for the final stop
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setPosition(curStop.X+curStop.UX*curStop.D, curStop.Y+curStop.UY*curStop.D,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;            curStop.UX,                     curStop.UY)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--just for good measure, make set x=desiredx, y=dsiredy
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--in theory these should not be equal already, but due to
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--floating point inaccuracy they may be slightly off, and
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--the code is best using x==desiredx/y to check if there is movement
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--to be done.
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setPosition(mDesiredX, mDesiredY)
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;--remove path from old cur-stop&apos;s Qnodes now that
&#9;&#9;&#9;&#9;&#9;&#9;--we&apos;re done with it.
&#9;&#9;&#9;&#9;&#9;&#9;for inx, qnode in pairs(curStop.Qnodes) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;qnode.PathMap[path] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:invalidate()
&#9;&#9;&#9;--print(&quot;Path Invalidated&quot;)
&#9;&#9;&#9;if mIsValid then
&#9;&#9;&#9;&#9;mIsValid = false
&#9;&#9;&#9;&#9;mInvalidPathMap[path] = true
&#9;&#9;&#9;&#9;if mPathStopVector then
&#9;&#9;&#9;&#9;&#9;for _, stop in pairs(mPathStopVector) do
&#9;&#9;&#9;&#9;&#9;&#9;for _, qnode in pairs(stop.Qnodes) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;qnode.PathMap[path] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:validate()
&#9;&#9;&#9;--print(&quot;Path Validated&quot;)
&#9;&#9;&#9;--not invalid anymore
&#9;&#9;&#9;mInvalidPathMap[path] = nil
&#9;&#9;&#9;mIsValid = true

&#9;&#9;&#9;--first check for the case where we&apos;re already where we need to be
&#9;&#9;&#9;if mX == mDesiredX and mY == mDesiredY then
&#9;&#9;&#9;&#9;--nothing to do
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;local from = getQnode(mX, mY)
&#9;&#9;&#9;local to = getQnode(mDesiredX, mDesiredY)
&#9;&#9;&#9;if not from or not to then
&#9;&#9;&#9;&#9;print(&quot;Can&apos;t move: pos&lt;&quot;..mX..&quot;,&quot;..mY..&quot;&gt; desired=&lt;&quot;..mDesiredX..&quot;,&quot;..mDesiredY..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;--the trivial case for movement within a single qnode
&#9;&#9;&#9;if from == to then
&#9;&#9;&#9;&#9;local ux = mDesiredX-mX
&#9;&#9;&#9;&#9;local uy = mDesiredY-mY
&#9;&#9;&#9;&#9;local len = math.sqrt(ux*ux + uy*uy)
&#9;&#9;&#9;&#9;ux, uy = ux/len, uy/len
&#9;&#9;&#9;&#9;mPathStopVector = {{
&#9;&#9;&#9;&#9;&#9;X = mX, Y = mY,
&#9;&#9;&#9;&#9;&#9;UX = ux, UY = uy,
&#9;&#9;&#9;&#9;&#9;D = len,
&#9;&#9;&#9;&#9;&#9;Qnodes = {},
&#9;&#9;&#9;&#9;}}
&#9;&#9;&#9;&#9;mCurrentPathStop = 1
&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0
&#9;&#9;&#9;&#9;mHasMovementToDo = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;--================= 
&#9;&#9;&#9;--     do A*
&#9;&#9;&#9;local openSet = {[from] = true}
&#9;&#9;&#9;--
&#9;&#9;&#9;local mPathfindGID = mQuadPathGID
&#9;&#9;&#9;mQuadPathGID = mQuadPathGID+1
&#9;&#9;&#9;--
&#9;&#9;&#9;local function distFromGoal(qnode)
&#9;&#9;&#9;&#9;local dx = (qnode.X+qnode.HalfSize)-(to.X+to.HalfSize)
&#9;&#9;&#9;&#9;local dy = (qnode.Y+qnode.HalfSize)-(to.Y+to.HalfSize)
&#9;&#9;&#9;&#9;return math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;to.CameFrom = nil
&#9;&#9;&#9;from.GScore = 0
&#9;&#9;&#9;from.HScore = distFromGoal(from)
&#9;&#9;&#9;from.FScore = from.HScore
&#9;&#9;&#9;from.LastOpenedId = mPathfindGID
&#9;&#9;&#9;--
&#9;&#9;&#9;local nodeNext = next(openSet)
&#9;&#9;&#9;while nodeNext do
&#9;&#9;&#9;&#9;--get the node with the lowest fscore
&#9;&#9;&#9;&#9;local lowestNode = nodeNext
&#9;&#9;&#9;&#9;for qnode, _ in pairs(openSet) do
&#9;&#9;&#9;&#9;&#9;if qnode.HScore &lt; lowestNode.HScore then
&#9;&#9;&#9;&#9;&#9;&#9;lowestNode = qnode
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--did we get to the target?
&#9;&#9;&#9;&#9;if lowestNode == to then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--close the current node
&#9;&#9;&#9;&#9;openSet[lowestNode] = nil
&#9;&#9;&#9;&#9;lowestNode.LastClosedId = mPathfindGID

&#9;&#9;&#9;&#9;--find new adjacents
&#9;&#9;&#9;&#9;for adj, dist in pairs(lowestNode.Adjacent) do
&#9;&#9;&#9;&#9;&#9;if adj.LastClosedId ~= mPathfindGID and adj.Height == from.Height then
&#9;&#9;&#9;&#9;&#9;&#9;local newgscore = lowestNode.GScore + dist
&#9;&#9;&#9;&#9;&#9;&#9;local newscoreIsBetter = false
&#9;&#9;&#9;&#9;&#9;&#9;if adj.LastOpenedId ~= mPathfindGID then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.LastOpenedId = mPathfindGID
&#9;&#9;&#9;&#9;&#9;&#9;&#9;openSet[adj] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = true
&#9;&#9;&#9;&#9;&#9;&#9;elseif newgscore &lt; adj.GScore then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = true
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newscoreIsBetter = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if newscoreIsBetter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.CameFrom = lowestNode
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.GScore = newgscore
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.HScore = distFromGoal(adj)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;adj.FScore = adj.GScore + adj.HScore
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;nodeNext = next(openSet)
&#9;&#9;&#9;end
&#9;&#9;&#9;--now, reconstruct the path
&#9;&#9;&#9;if to.CameFrom then
&#9;&#9;&#9;&#9;--first, flatten the linked-path into an array of nodes
&#9;&#9;&#9;&#9;local nodeArray = {}
&#9;&#9;&#9;&#9;local nd = to
&#9;&#9;&#9;&#9;while nd ~= from do
&#9;&#9;&#9;&#9;&#9;nodeArray[#nodeArray+1] = nd
&#9;&#9;&#9;&#9;&#9;nd = nd.CameFrom 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;nodeArray[#nodeArray+1] = from

&#9;&#9;&#9;&#9;--now, the array is in reverse order, build the stop vector
&#9;&#9;&#9;&#9;mPathStopVector = {}
&#9;&#9;&#9;&#9;for i = #nodeArray, 2, -1 do
&#9;&#9;&#9;&#9;&#9;local qat = nodeArray[i]
&#9;&#9;&#9;&#9;&#9;local qto = nodeArray[i-1]
&#9;&#9;&#9;&#9;&#9;local pathStop = {}
&#9;&#9;&#9;&#9;&#9;local atx, aty;
&#9;&#9;&#9;&#9;&#9;local tox, toy;
&#9;&#9;&#9;&#9;&#9;if qat == from then
&#9;&#9;&#9;&#9;&#9;&#9;atx, aty = mX, mY
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;atx, aty = qat.X+qat.HalfSize, qat.Y+qat.HalfSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if qto == to then
&#9;&#9;&#9;&#9;&#9;&#9;tox, toy = mDesiredX, mDesiredY
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;tox, toy = qto.X+qto.HalfSize, qto.Y+qto.HalfSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local dx = tox-atx
&#9;&#9;&#9;&#9;&#9;local dy = toy-aty
&#9;&#9;&#9;&#9;&#9;local len = math.sqrt(dx*dx + dy*dy)
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;pathStop.X = atx
&#9;&#9;&#9;&#9;&#9;pathStop.Y = aty
&#9;&#9;&#9;&#9;&#9;pathStop.UX = dx/len
&#9;&#9;&#9;&#9;&#9;pathStop.UY = dy/len
&#9;&#9;&#9;&#9;&#9;pathStop.D = len
&#9;&#9;&#9;&#9;&#9;pathStop.Qnodes = {qat}
&#9;&#9;&#9;&#9;&#9;qat.PathMap[path] = true
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;mPathStopVector[#mPathStopVector+1] = pathStop
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--the last node also cares about invalidation as a result of the to node, 
&#9;&#9;&#9;&#9;--not just the from node.
&#9;&#9;&#9;&#9;do
&#9;&#9;&#9;&#9;&#9;local qnodes = mPathStopVector[#mPathStopVector]
&#9;&#9;&#9;&#9;&#9;qnodes[#qnodes+1] = to
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--and finally put the path up for traversal
&#9;&#9;&#9;&#9;mHasMovementToDo = true
&#9;&#9;&#9;&#9;mCurrentPathStop = 1
&#9;&#9;&#9;&#9;mDistanceIntoCurrentPathStop = 0
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mHasMovementToDo = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function path:destroy()
&#9;&#9;&#9;--remove from the broad-phase, and the invalid map if I&apos;m there
&#9;&#9;&#9;remEntityFromBroad(mCurrentBroadCell, entity)

&#9;&#9;&#9;--also, remove from the paths to be validated (may or may not be
&#9;&#9;&#9;--currently int he map, doesn&apos;t matter which)
&#9;&#9;&#9;mInvalidPathMap[path] = nil
&#9;&#9;end


&#9;&#9;return path
&#9;end


&#9;--=========================================--
&#9;--==    the main add entity function     ==--
&#9;--=========================================--
&#9;function this:addEntity(entity)
&#9;&#9;--first things first, add it to the list of entities
&#9;&#9;entity.NextEntity_MainList = mEntityListHead
&#9;&#9;if mEntityListHead then
&#9;&#9;&#9;mEntityListHead.PrevEntity_MainList = entity
&#9;&#9;end
&#9;&#9;mEntityListHead = entity
&#9;&#9;mEntityCount = mEntityCount + 1

&#9;&#9;--assign it this gamestate
&#9;&#9;entity.GameState = this

&#9;&#9;--ticker, add it
&#9;&#9;if entity.Ticker then
&#9;&#9;&#9;this:addTicker(entity.Ticker)
&#9;&#9;end

&#9;&#9;--now, go through traits
&#9;&#9;if entity.Health then
&#9;&#9;&#9;--automatically remove units with health when they die
&#9;&#9;&#9;entity.Health.onDeath:connect(function()
&#9;&#9;&#9;&#9;this:remEntity(entity)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;--mobileunit
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;--add to the unit count
&#9;&#9;&#9;mUnitCount = mUnitCount + 1

&#9;&#9;&#9;--add a Mobile to the unit
&#9;&#9;&#9;entity.MobileUnit.Mobile = requestMobile(entity)
&#9;&#9;end

&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;--set ownership
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;team:addEntity(entity)

&#9;&#9;&#9;--listen for team changes
&#9;&#9;&#9;entity.TeamOwned.onTeamChange:connect(function(team, oldTeam)
&#9;&#9;&#9;&#9;--change ownership
&#9;&#9;&#9;&#9;oldTeam:remEntity(entity)
&#9;&#9;&#9;&#9;team:addEntity(entity)

&#9;&#9;&#9;&#9;--also, if I&apos;m a building need to update the
&#9;&#9;&#9;&#9;--entries in RegisteredToBroadMap
&#9;&#9;&#9;&#9;if entity.Building then
&#9;&#9;&#9;&#9;&#9;for broadCell, _ in pairs(entity.RegisteredToBroadMap) do
&#9;&#9;&#9;&#9;&#9;&#9;broadCell.TeamCount[oldTeam] = broadCell.TeamCount[oldTeam] - 1
&#9;&#9;&#9;&#9;&#9;&#9;broadCell.TeamCount[team] = broadCell.TeamCount[team] + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;if entity.Building then
&#9;&#9;&#9;--add the building to the grid
&#9;&#9;&#9;local building = entity.Building
&#9;&#9;&#9;local broadCellsAddedTo = {}
&#9;&#9;&#9;for dx = 1, building.W do
&#9;&#9;&#9;&#9;for dy = 1, building.H do
&#9;&#9;&#9;&#9;&#9;local x, y = building.X+dx-1, building.Y+dy-1
&#9;&#9;&#9;&#9;&#9;this:setCell(x, y, building)
&#9;&#9;&#9;&#9;&#9;local broadCell = this:getBroadCell(x, y)
&#9;&#9;&#9;&#9;&#9;if not broadCellsAddedTo[broadCell] then
&#9;&#9;&#9;&#9;&#9;&#9;broadCellsAddedTo[broadCell] = true
&#9;&#9;&#9;&#9;&#9;&#9;addEntityToBroad(broadCell, entity)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if entity.Class == &apos;GoldOre&apos; then
&#9;&#9;&#9;--special handling for gold ore
&#9;&#9;&#9;mAllGoldMap[entity] = true
&#9;&#9;elseif entity.Class == &apos;GoldMine&apos; then
&#9;&#9;&#9;--special handling for gold mine
&#9;&#9;&#9;mAllGoldMineMap[entity] = true
&#9;&#9;end

&#9;&#9;this.onEntityAdd:fire(entity)
&#9;end
&#9;function this:remEntity(entity)
&#9;&#9;--remove from main entity list
&#9;&#9;if entity.NextEntity_MainList then
&#9;&#9;&#9;entity.NextEntity_MainList.PrevEntity_MainList = entity.PrevEntity_MainList
&#9;&#9;end
&#9;&#9;if entity.PrevEntity_MainList then
&#9;&#9;&#9;entity.PrevEntity_MainList.NextEntity_MainList = entity.NextEntity_MainList
&#9;&#9;else
&#9;&#9;&#9;mEntityListHead = entity.NextEntity_MainList
&#9;&#9;end
&#9;&#9;mEntityCount = mEntityCount - 1

&#9;&#9;--ticker, rem it
&#9;&#9;if entity.Ticker then
&#9;&#9;&#9;this:remTicker(entity.Ticker)
&#9;&#9;end

&#9;&#9;--mobile unit, remove from unit count
&#9;&#9;if entity.MobileUnit then
&#9;&#9;&#9;mUnitCount = mUnitCount - 1

&#9;&#9;&#9;--also, destory the mobile
&#9;&#9;&#9;entity.MobileUnit.Mobile:destroy()
&#9;&#9;end

&#9;&#9;--team owned, edit team counts
&#9;&#9;if entity.TeamOwned then
&#9;&#9;&#9;local team = entity.TeamOwned:getTeam()
&#9;&#9;&#9;team:remEntity(entity)
&#9;&#9;end

&#9;&#9;--building? Remove from the game grid
&#9;&#9;if entity.Building then
&#9;&#9;&#9;local building = entity.Building
&#9;&#9;&#9;local broadCellsRemovedFrom = {}
&#9;&#9;&#9;for dx = 1, building.W do
&#9;&#9;&#9;&#9;for dy = 1, building.H do
&#9;&#9;&#9;&#9;&#9;local x, y = building.X+dx-1, building.Y+dy-1
&#9;&#9;&#9;&#9;&#9;this:setCell(x, y, nil) --get rid of the building
&#9;&#9;&#9;&#9;&#9;local broadCell = this:getBroadCell(x, y)
&#9;&#9;&#9;&#9;&#9;if not broadCellsRemovedFrom[broadCell] then
&#9;&#9;&#9;&#9;&#9;&#9;broadCellsRemovedFrom[broadCell] = true
&#9;&#9;&#9;&#9;&#9;&#9;remEntityFromBroad(broadCell, entity)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if entity.Class == &apos;GoldOre&apos; then
&#9;&#9;&#9;--special handling for gold ore
&#9;&#9;&#9;mAllGoldMap[entity] = nil
&#9;&#9;elseif entity.Class == &apos;GoldMine&apos; then
&#9;&#9;&#9;--special handling for gold mine
&#9;&#9;&#9;mAllGoldMineMap[entity] = nil
&#9;&#9;end

&#9;&#9;--call the signal, _BEFORE_ destorying the entity, just in case it&apos;s still
&#9;&#9;--needed for some cleanup.
&#9;&#9;this.onEntityRem:fire(entity)

&#9;&#9;--okay, all good. Fire the destructor of the thing removed
&#9;&#9;entity:destroy()
&#9;&#9;--print(&quot;Destroy Entity&lt;&quot;..entity.Class..&quot;&gt; Completed&quot;)
&#9;end
&#9;function this:eachEntity()
&#9;&#9;local curEnt = mEntityListHead
&#9;&#9;return function()
&#9;&#9;&#9;local e = curEnt
&#9;&#9;&#9;curEnt = (curEnt and curEnt.NextEntity_MainList or nil)
&#9;&#9;&#9;return e
&#9;&#9;end
&#9;end

&#9;------------------------------------------------------------------
&#9;-- utility functions for use by units / buildings / UI
&#9;local EmptyTable = {}
&#9;function this:isRectFree(x, y, w, h, unitToIgnore)
&#9;&#9;for px = x, x+w-1 do
&#9;&#9;&#9;for py = y, y+h-1 do
&#9;&#9;&#9;&#9;local cell = this:getCell(px, py)
&#9;&#9;&#9;&#9;if not cell or cell.Building ~= nil or cell.Height == 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Cell:&quot;, cell)
&#9;&#9;&#9;&#9;&#9;--if cell then
&#9;&#9;&#9;&#9;&#9;--&#9;print(&quot;=&gt; Building:&quot;, cell.Building, &quot;Height:&quot;, cell.Height)
&#9;&#9;&#9;&#9;&#9;--end
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return true
&#9;end

&#9;function this:getAllUnitsInRegion(x, y, w, h, team)
&#9;&#9;local unitList = {}
&#9;&#9;--
&#9;&#9;--print(&quot;GetUnitsIn&lt;&quot;..x..&quot;,&quot;..y..&quot;,&quot;..w..&quot;,&quot;..h..&quot;&gt; =&gt;&quot;)
&#9;&#9;if w &lt; 0 then x = x+w; w = -w; end
&#9;&#9;if h &lt; 0 then y = y+h; h = -h; end
&#9;&#9;--print(&quot;GetUnitsIn&lt;&quot;..x..&quot;,&quot;..y..&quot;,&quot;..w..&quot;,&quot;..h..&quot;&gt;&quot;)
&#9;&#9;local bx1 = math.floor((x-1)/8)+1
&#9;&#9;local by1 = math.floor((y-1)/8)+1
&#9;&#9;local bx2 = math.floor((x+w-1)/8)+1
&#9;&#9;local by2 = math.floor((y+h-1)/8)+1
&#9;&#9;--
&#9;&#9;for bx = bx1, bx2 do
&#9;&#9;&#9;for by = by1, by2 do
&#9;&#9;&#9;&#9;if not mBroadPhaseMap[bx] then
&#9;&#9;&#9;&#9;&#9;print(bx, by)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local broadNode = mBroadPhaseMap[bx][by]
&#9;&#9;&#9;&#9;for entity, _ in pairs(broadNode.EntityMap) do
&#9;&#9;&#9;&#9;&#9;if not team or (entity.MobileUnit and 
&#9;&#9;&#9;&#9;&#9;&#9;            entity.TeamOwned and
&#9;&#9;&#9;&#9;&#9;&#9;            entity.TeamOwned:getTeam() == team) 
&#9;&#9;&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;&#9;&#9;local px, py = entity.MobileUnit:getPosition()
&#9;&#9;&#9;&#9;&#9;&#9;if px &gt;= x and py &gt;= y and px &lt;= x+w and py &lt;= y+h then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unitList[#unitList+1] = entity
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;          
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--print(&quot;Got &quot;..(#unitList)..&quot; units&quot;)
&#9;&#9;--
&#9;&#9;return unitList
&#9;end

&#9;function this:findFreeSpaceByBuilding(entity, onWater)
&#9;&#9;if onWater == nil then onWater = false end
&#9;&#9;local b = entity.Building
&#9;&#9;for xp = b.X-1, b.X+b.W do
&#9;&#9;&#9;for yp = b.Y-1, b.Y+b.H do
&#9;&#9;&#9;&#9;local cell = this:getCell(xp, yp)
&#9;&#9;&#9;&#9;if cell and (cell.Height == 0) == onWater and not cell.Building then
&#9;&#9;&#9;&#9;&#9;return xp+0.5, yp+0.5
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return nil
&#9;end


&#9;------------------------------------------------------------------

&#9;Spawn(function()
&#9;&#9;local lastTime = tick()
&#9;&#9;while not mGameIsWon do
&#9;&#9;&#9;local currentTime = tick()
&#9;&#9;&#9;local dt = currentTime-lastTime
&#9;&#9;&#9;--

&#9;&#9;&#9;updatePaths(dt)
&#9;&#9;&#9;doTick(dt)

&#9;&#9;&#9;--
&#9;&#9;&#9;lastTime = currentTime
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;end)
end)











</ProtectedString>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX11">
				<Properties>
					<string name="Name">unit</string>
					<string name="Value">--unit

class&apos;Trait_Health&apos;(function(this, entity, maxHealth)
&#9;local mHealth = maxHealth

&#9;this.onDeath = MakeSignal()

&#9;function this:takeDamage(amount)
&#9;&#9;mHealth = math.max(0, mHealth-amount)
&#9;&#9;if mHealth &lt;= 0 then
&#9;&#9;&#9;this.onDeath:fire()
&#9;&#9;end
&#9;end
&#9;function this:getHealth()
&#9;&#9;return mHealth
&#9;end
&#9;function this:destroy() end
end)



class&apos;Trait_MobileUnit&apos;(function(this, entity, speed, overland, overwater)
&#9;this.onMove = MakeSignal()
&#9;this.OverLand = ((overland==nil) and true or overland)
&#9;this.OverWater = ((overwater==nil) and false or overwater)

&#9;function this:getPosition()
&#9;&#9;return this.Mobile:getPosition()
&#9;end
&#9;function this:setPosition(x, y, ux, uy)
&#9;&#9;this.Mobile:setPosition(x, y, ux, uy)
&#9;end
&#9;function this:setDesiredPosition(x, y)
&#9;&#9;this.Mobile:setDesiredPosition(x, y)
&#9;end
&#9;function this:getDesiredPosition()
&#9;&#9;print(this.Mobile)
&#9;&#9;return this.Mobile:getDesiredPosition()
&#9;end
&#9;function this:tick(dt)
&#9;&#9;--print(&quot;Move unit by: &quot;, dt*speed)
&#9;&#9;this.Mobile:moveBy(dt*speed)
&#9;end
&#9;function this:distanceToPosition(x, y)
&#9;&#9;local mx, my = this:getPosition()
&#9;&#9;local dx, dy = x-mx, y-my
&#9;&#9;return math.sqrt(dx*dx+dy*dy)
&#9;end
&#9;function this:distanceToUnit(mobile)
&#9;&#9;return this:distanceToPosition(mobile:getPosition())
&#9;end
&#9;function this:distanceToBuilding(building)
&#9;&#9;local bx, by = building.X+building.W/2, building.Y+building.H/2
&#9;&#9;local mx, my = this:getPosition()
&#9;&#9;local dx, dy = math.abs(bx-mx), math.abs(by-my)
&#9;&#9;dx, dy = math.max(0, dx-building.W/2), math.max(dy-building.H/2)
&#9;&#9;return math.sqrt(dx*dx, dy*dy)
&#9;end
&#9;function this:setSpeed(s)
&#9;&#9;speed = s
&#9;end
&#9;function this:destroy() end
end)



class&apos;Trait_Displayable&apos;(function(this, entity, viewFactory)
&#9;local mViewList = {}
&#9;function this:createView(gameview)
&#9;&#9;local destroyFunc, partList = viewFactory(entity, gameview)
&#9;&#9;mViewList[destroyFunc] = true
&#9;&#9;local view = {}
&#9;&#9;function view:destroy()
&#9;&#9;&#9;destroyFunc()
&#9;&#9;&#9;mViewList[destroyFunc] = nil
&#9;&#9;end
&#9;&#9;function view:getPartList()
&#9;&#9;&#9;return partList
&#9;&#9;end
&#9;&#9;return view
&#9;end
&#9;function this:destroy()
&#9;&#9;for destroyFunc, _ in pairs(mViewList) do
&#9;&#9;&#9;destroyFunc()
&#9;&#9;end
&#9;end
end)


class&apos;Trait_Ticker&apos;(function(this, handler)
&#9;function this:tick(dt)
&#9;&#9;handler(dt)
&#9;end
&#9;function this:destroy() end
end)


class&apos;Trait_ClickEffect&apos;(function(this, entity, hoverCursor, canActivate, handler)
&#9;this.Icon = hoverCursor
&#9;function this:activate()
&#9;&#9;handler()
&#9;end
&#9;function this:canActivate()
&#9;&#9;return canActivate()
&#9;end
&#9;function this:destroy() end
end)


class&apos;Trait_TeamOwned&apos;(function(this, entity)
&#9;local mTeam;
&#9;this.onTeamChange = MakeSignal()
&#9;--
&#9;function this:setTeam(team)
&#9;&#9;local oldTeam = mTeam
&#9;&#9;mTeam = team
&#9;&#9;this.onTeamChange:fire(team, oldTeam)
&#9;end
&#9;function this:getTeam()
&#9;&#9;return mTeam
&#9;end
&#9;function this:destroy() end
end)


class&apos;Trait_PowerProducer&apos;(function(this, entity, produces)
&#9;function this:getPowerProduced() return produces end
&#9;function this:destroy() end
end)


class&apos;Trait_PowerConsumer&apos;(function(this, entity, consumes)
&#9;function this:getPowerConsumed() return consumes end
&#9;function this:destroy() end
end)


class&apos;Trait_Building&apos;(function(this, entity, x, y, w, h)
&#9;this.X, this.Y = x, y
&#9;this.W, this.H = w, h
&#9;function this:destroy() end
end)


class&apos;TestUnit&apos;(function(this)
&#9;this.Health = MakeTrait_Health(this, 100)
&#9;this.MobileUnit = MakeTrait_MobileUnit(this, 2, true, false)
&#9;this.Displayable = MakeTrait_Displayable(this, function(entity, gameview)
&#9;&#9;local bview = gameview:getBoardView()
&#9;&#9;--
&#9;&#9;local ch = Make&apos;Model&apos;{
&#9;&#9;&#9;Name = &apos;TestUnit&apos;,
&#9;&#9;&#9;Parent = bview:getContainer(),
&#9;&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;&#9;Name = &apos;Body&apos;,
&#9;&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;&#9;Size = Vector3.new(0.7, 0.7, 0.7),
&#9;&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;&#9;CanCollide = false,
&#9;&#9;&#9;&#9;BrickColor = BrickColor.new(Color3.new(0,0,0)),
&#9;&#9;&#9;},
&#9;&#9;}
&#9;&#9;local cn = this.MobileUnit.onMove:connect(function(x, y, ux, uy)
&#9;&#9;&#9;local pos = bview:coordToPosition(x, y)+Vector3.new(0,0.35,0)
&#9;&#9;&#9;ch.Body.CFrame = CFrame.new(pos, pos+Vector3.new(ux, 0, uy))
&#9;&#9;end)
&#9;&#9;return function()
&#9;&#9;&#9;cn:disconnect()
&#9;&#9;&#9;ch:Destroy()
&#9;&#9;end, {ch.Body}
&#9;end)
&#9;this.Ticker = MakeTrait_Ticker(function(dt)
&#9;&#9;this.MobileUnit:tick(dt)
&#9;end)

&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.MobileUnit:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.Ticker:destroy()
&#9;end
end)


class&apos;Roleset&apos;(nil, function(def)
&#9;def.ActionType = {
&#9;&#9;Infastructure = {},
&#9;&#9;Defense = {},
&#9;&#9;Personnel = {},
&#9;&#9;Vehicles = {},
&#9;}
end)</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX12">
				<Properties>
					<string name="Name">alliedroleset</string>
					<string name="Value">--alliedroleset

local function MoveModel(model, primaryPart, newCF)
&#9;local inv = primaryPart.CFrame:inverse()
&#9;for _, part in pairs(model:GetChildren()) do
&#9;&#9;if part ~= primaryPart then
&#9;&#9;&#9;part.CFrame = newCF*(inv*part.CFrame)
&#9;&#9;end
&#9;end
&#9;primaryPart.CFrame = newCF
end




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function GoldOre_ViewFactory(entity, gameview)
&#9;--print(&quot;Make GoldOre view&quot;)
&#9;local boardview = gameview:getBoardView()
&#9;local mGoldParts = {}

&#9;local goldModel = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;GoldOre&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Transparency = 1,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.1,0.1,0.1),
&#9;&#9;&#9;Anchored = true,
&#9;&#9;},
&#9;}
&#9;
&#9;--print(&quot;GoldModel in: &quot;, goldModel.Parent)
&#9;for i = 1, 10 do
&#9;&#9;local x = math.random(-5,5)/10
&#9;&#9;local y = math.random(-5,5)/10
&#9;&#9;--
&#9;&#9;local gold = Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Material = &apos;Foil&apos;,
&#9;&#9;&#9;Size = Vector3.new(math.random(2,4)/10, 0.2, math.random(2,4)/10),
&#9;&#9;&#9;CFrame = CFrame.new(x, 0, y),
&#9;&#9;&#9;BrickColor = BrickColor.new(1005),
&#9;&#9;}
&#9;&#9;gold.Parent = goldModel
&#9;&#9;mGoldParts[#mGoldParts+1] = gold
&#9;end
&#9;local mFirstVisibleGold = 1
&#9;local movedCn = entity.MobileUnit.onMove:connect(function(x, y)
&#9;&#9;local pos = boardview:coordToPosition(x+0.5, y+0.5)
&#9;&#9;MoveModel(goldModel, goldModel.Base, CFrame.new(pos))
&#9;end)
&#9;local minedCn = entity.onMined:connect(function(oreLeft, change)
&#9;&#9;if change &lt; 0 then
&#9;&#9;&#9;for i = 1, math.abs(change) do
&#9;&#9;&#9;&#9;mGoldParts[mFirstVisibleGold].Transparency = 1
&#9;&#9;&#9;&#9;mFirstVisibleGold = mFirstVisibleGold+1
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;for i = 1, change do
&#9;&#9;&#9;&#9;mFirstVisibleGold = mFirstVisibleGold-1
&#9;&#9;&#9;&#9;mGoldParts[mFirstVisibleGold].Transparency = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;return function()
&#9;&#9;error(&quot;Destroyed goldview&quot;)
&#9;&#9;goldModel:Destroy()
&#9;&#9;minedCn:disconnect()
&#9;&#9;movedCn:disconnect()
&#9;end, goldModel:GetChildren()
end
class&apos;Entity_GoldOre&apos;(function(this, creatorMine)
&#9;this.MobileUnit = MakeTrait_MobileUnit(this, 0, false, false)
&#9;this.Displayable = MakeTrait_Displayable(this, GoldOre_ViewFactory)
&#9;this.Class = &apos;GoldOre&apos;
&#9;
&#9;--gold manipulation functions
&#9;local mOreLeft = 10
&#9;function this:getOre()
&#9;&#9;return mOreLeft
&#9;end
&#9;function this:addOre(n)
&#9;&#9;mOreLeft = mOreLeft+n
&#9;&#9;this.onMined:fire(mOreLeft, n)
&#9;end
&#9;function this:remOre(n)
&#9;&#9;mOreLeft = mOreLeft-n
&#9;&#9;this.onMined:fire(mOreLeft, -n)
&#9;end
&#9;function this:getMine()
&#9;&#9;return creatorMine
&#9;end
&#9;this.onMined = MakeSignal()

&#9;--
&#9;function this:destroy()
&#9;&#9;this.MobileUnit:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function GoldMine_ViewFactory(entity, gameview)
&#9;return function()

&#9;end, {}
end
class&apos;Building_GoldMine&apos;(function(this, x, y)
&#9;this.Building = MakeTrait_Building(this, x, y, 1, 1)
&#9;this.Displayable = MakeTrait_Displayable(this, GoldMine_ViewFactory)
&#9;this.Class = &apos;GoldMine&apos;

&#9;local mOreList = {}
&#9;local mTotalOre = 0
&#9;local mOreSpawned = false
&#9;local mTimeSinceLastOreMine = 0
&#9;this.Ticker = MakeTrait_Ticker(function(dt)
&#9;&#9;if mOreSpawned then
&#9;&#9;&#9;mTimeSinceLastOreMine = mTimeSinceLastOreMine+dt
&#9;&#9;&#9;if mTimeSinceLastOreMine &gt; 10.0 then
&#9;&#9;&#9;&#9;mTimeSinceLastOreMine = 0
&#9;&#9;&#9;&#9;for _, ore in pairs(mOreList) do
&#9;&#9;&#9;&#9;&#9;if ore.Entity:getOre() &lt; 10 then
&#9;&#9;&#9;&#9;&#9;&#9;ore.Entity:addOre(math.min(5, 10-ore.Entity:getOre()))
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;mOreSpawned = true
&#9;&#9;&#9;for xp = x-2, x+2 do
&#9;&#9;&#9;&#9;for yp = y-2, y+2 do
&#9;&#9;&#9;&#9;&#9;local cell = this.GameState:getCell(xp, yp)
&#9;&#9;&#9;&#9;&#9;if cell and cell.Height &gt; 0 and not cell.Building then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Spawn ore at &lt;&quot;..xp..&quot;,&quot;..yp..&quot;&gt;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;local ore = MakeEntity_GoldOre(this)
&#9;&#9;&#9;&#9;&#9;&#9;this.GameState:addEntity(ore)
&#9;&#9;&#9;&#9;&#9;&#9;ore.MobileUnit:setPosition(xp, yp)
&#9;&#9;&#9;&#9;&#9;&#9;mOreList[#mOreList+1] = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Entity = ore,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MinedCn = ore.onMined:connect(function(left, change)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mTotalOre = mTotalOre+change
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end),
&#9;&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;&#9;&#9;mTotalOre = mTotalOre + 10
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;function this:eachOre()
&#9;&#9;local i = 0
&#9;&#9;return function()
&#9;&#9;&#9;i = i+1
&#9;&#9;&#9;return mOreList[i].Entity
&#9;&#9;end
&#9;end
&#9;function this:getTotalOre()
&#9;&#9;return mTotalOre
&#9;end

&#9;function this:destroy()
&#9;&#9;this.Building:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.Ticker:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedMCV_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local unit = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedMCV&apos;,
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 0.8, 1.2),
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 0.6, 1.6),
&#9;&#9;&#9;Position = Vector3.new(0, -0.1, -0.6),
&#9;&#9;&#9;Make&apos;SpecialMesh&apos;{MeshType=&apos;Head&apos;,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.3, 0.6, 0.3),
&#9;&#9;&#9;Position = Vector3.new(0, 0.1, -0.6),
&#9;&#9;&#9;Make&apos;SpecialMesh&apos;{MeshType=&apos;Head&apos;,},
&#9;&#9;}
&#9;}
&#9;unit.Parent = boardview:getContainer()
&#9;--
&#9;local moveCn = entity.MobileUnit.onMove:connect(function(x, y, ux, uy)
&#9;&#9;local pos = boardview:coordToPosition(x, y)+Vector3.new(0, 0.4, 0)
&#9;&#9;MoveModel(unit, unit.Base, CFrame.new(pos, pos+Vector3.new(ux, 0, uy)))
&#9;end)
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(base:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;unit:Destroy()
&#9;&#9;moveCn:disconnect()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, unit:GetChildren()&#9;
end
class&apos;Unit_AlliedMCV&apos;(function(this)
&#9;this.Health = MakeTrait_Health(this, 100)
&#9;this.MobileUnit = MakeTrait_MobileUnit(this, 2, true, false)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedMCV_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)

&#9;--deploy MCV into base effect
&#9;this.ClickEffect = MakeTrait_ClickEffect(this, &quot;&quot;, function()
&#9;&#9;local x, y = this.MobileUnit:getPosition()
&#9;&#9;x, y = math.floor(x-1.5), math.floor(y-1.5)
&#9;&#9;return this.GameState:isRectFree(x, y, 4, 4, this)
&#9;end, function()
&#9;&#9;--position to create at
&#9;&#9;local x, y = this.MobileUnit:getPosition()
&#9;&#9;x, y = math.floor(x), math.floor(y)

&#9;&#9;--add the unpacked scv
&#9;&#9;local base = MakeBuilding_AlliedBase(x-2, y-2)
&#9;&#9;base.TeamOwned:setTeam(this.TeamOwned:getTeam())
&#9;&#9;this.GameState:addEntity(base)

&#9;&#9;--remove this not that we have the unpacked one
&#9;&#9;this.GameState:remEntity(this)
&#9;end)
&#9;this.Ticker = MakeTrait_Ticker(function(dt)
&#9;&#9;this.MobileUnit:tick(dt)
&#9;end)
&#9;this.Class = &apos;MCV&apos;
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.MobileUnit:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.ClickEffect:destroy()
&#9;&#9;this.Ticker:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
-------------------------------------_----_---_-------_---_----------------------
---------------------  /| |  |  &#175;|&#175; |_ |&#175;\   |_)  /| |_` |_` --------------------
--------------------- /&#175;| |_ |_ _|_ |_ |_/   |_) /&#175;|  _| |_, --------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedBase_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local base = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedBase&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(3.26, 0.55, 1.81),
&#9;&#9;&#9;Position = Vector3.new(0.1609, 0.475, -0.8751),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;BlockMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Size = Vector3.new(4, 0.2, 4),
&#9;&#9;&#9;Position = Vector3.new(0, 0, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),&#9;&#9;
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.36, 0.2, 1.11),
&#9;&#9;&#9;Position = Vector3.new(-1.626, 0.345, -1.068),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;BlockMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.02, 0.55, 1.11),
&#9;&#9;&#9;Position = Vector3.new(1.124, 1.1, -0.6615),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.02, 0.55, 1.11),
&#9;&#9;&#9;Position = Vector3.new(-0.01029, 1.019, -0.6615),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.97, 1.08, 1.60),
&#9;&#9;&#9;Position = Vector3.new(0.7765, 0.74, 0.8431),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;BlockMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.6, 1.97, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0.7765, 1.284, 0.8431, 0, -1, 0, -1, 0, 0, 0, 0, -1),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;},
&#9;}
&#9;--
&#9;local bld = entity.Building
&#9;local pos = boardview:coordToPosition(bld.X+bld.W/2, bld.Y+bld.H/2)
&#9;MoveModel(base, base.Base, CFrame.new(pos))
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(base:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;base:Destroy()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, base:GetChildren()
end
class&apos;Building_AlliedBase&apos;(function(this, x, y)
&#9;this.Health = MakeTrait_Health(this, 125)
&#9;this.Building = MakeTrait_Building(this, x, y, 4, 4)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedBase_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.ClickEffect = MakeTrait_ClickEffect(this, &quot;&quot;, function()
&#9;&#9;return true
&#9;end, function()
&#9;&#9;local mcv = MakeUnit_AlliedMCV()
&#9;&#9;mcv.TeamOwned:setTeam(this.TeamOwned:getTeam())
&#9;&#9;this.GameState:addEntity(mcv)
&#9;&#9;mcv.MobileUnit:setPosition(x+1.5, y+1.5)
&#9;&#9;this.GameState:remEntity(this)
&#9;end)
&#9;this.Class = &apos;Base&apos;
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.Building:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.ClickEffect:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
----------------------------------  /&#175;` &#175;|&#175;  ------------------------------------
----------------------------------  |_7 _|_  ------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedGI_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()&#9;
&#9;--
&#9;local unit = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedGI&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Body&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.7, 0.6, 0.7),
&#9;&#9;&#9;Position = Vector3.new(0, 0.7, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.1,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.3, 0.3, 0.3),
&#9;&#9;&#9;Position = Vector3.new(0, 1.15, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.1},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.5, 0.4, 0.5),
&#9;&#9;&#9;Position = Vector3.new(0, 0.2, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Fortify&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1, 0.5, 1),
&#9;&#9;&#9;Position = Vector3.new(0, 0.25, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(141),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.25,},
&#9;&#9;&#9;Transparency = 1,
&#9;&#9;},
&#9;}
&#9;--
&#9;local moveCn = entity.MobileUnit.onMove:connect(function(x, y, ux, uy)
&#9;&#9;local pos = boardview:coordToPosition(x, y)+Vector3.new(0, 0.7, 0)
&#9;&#9;MoveModel(unit, unit.Body, CFrame.new(pos, pos+Vector3.new(ux, 0, uy)))
&#9;end)
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(base:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;local deployCn = entity.onDeploy:connect(function(state)
&#9;&#9;if state then
&#9;&#9;&#9;unit.Fortify.Transparency = 0
&#9;&#9;else
&#9;&#9;&#9;unit.Fortify.Transparency = 1
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;unit:Destroy()
&#9;&#9;moveCn:disconnect()
&#9;&#9;teamChangeCn:disconnect()
&#9;&#9;deployCn:disconnect()
&#9;end, unit:GetChildren()&#9;
end
class&apos;Unit_AlliedGI&apos;(function(this)
&#9;local isDeployed = false
&#9;this.onDeploy = MakeSignal()
&#9;--
&#9;this.Health = MakeTrait_Health(this, 100)
&#9;this.MobileUnit = MakeTrait_MobileUnit(this, 1, true, false)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedGI_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.ClickEffect = MakeTrait_ClickEffect(this, &quot;&quot;, function()
&#9;&#9;return true
&#9;end, function()
&#9;&#9;if isDeployed then
&#9;&#9;&#9;isDeployed = false
&#9;&#9;&#9;this.MobileUnit:setSpeed(1)
&#9;&#9;else
&#9;&#9;&#9;isDeployed = true
&#9;&#9;&#9;this.MobileUnit:setSpeed(0)
&#9;&#9;end
&#9;&#9;this.onDeploy:fire(isDeployed)
&#9;end)
&#9;this.Ticker = MakeTrait_Ticker(function(dt)
&#9;&#9;this.MobileUnit:tick(dt)
&#9;end)
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.MobileUnit:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.ClickEffect:destroy()
&#9;&#9;this.Ticker:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
-------------------------_--------------------------__---------------------------
----------------------- |_)  /| |&#175;) |&#175;)  /| /&#175;` |/ |_  --------------------------
----------------------- |_) |&#175;| |&#175;\ |&#175;\ |&#175;| \_, |\ __| --------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedBarracks_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local barracks = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedBarracks&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(2, 0.2, 3),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.5, 2.4, 1.5),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(153),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.2, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, -1.2, 1, 0, 0, 0, 0, 1, 0, -1, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.2, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.2, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, 1.2, 1, 0, 0, 0, 0, 1, 0, -1, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1, 0.2, 1),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, 1.3, 1, 0, 0, 0, 0, 1, 0, -1, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;}
&#9;--
&#9;local bld = entity.Building
&#9;local pos = boardview:coordToPosition(bld.X+bld.W/2, bld.Y+bld.H/2)
&#9;MoveModel(barracks, barracks.Base, CFrame.new(pos))
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(barracks:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;barracks:Destroy()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, barracks:GetChildren()&#9;
end
class&apos;Building_AlliedBarracks&apos;(function(this, x, y)
&#9;this.Health = MakeTrait_Health(this, 500)
&#9;this.Building = MakeTrait_Building(this, x, y, 2, 3)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedBarracks_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.PowerConsumer = MakeTrait_PowerConsumer(10)
&#9;this.Class = &apos;Barracks&apos;
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.Building:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.PowerConsumer:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
function AlliedPowerPlant_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local powerp = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedPowerPlant&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(2, 0.2, 2),
&#9;&#9;&#9;Position = Vector3.new(),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.6, 1.6),
&#9;&#9;&#9;Position = Vector3.new(0, 0.1, 0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.3,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(0.5, 1, 0.5),
&#9;&#9;&#9;Position = Vector3.new(-0.2, 1.1, 0.136),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.1,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(0.4, 1.4, 0.4),
&#9;&#9;&#9;Position = Vector3.new(0.132, 1.3, 0.118),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(0.5, 0.6, 0.5),
&#9;&#9;&#9;Position = Vector3.new(0, 0.9, -0.2),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;Size = Vector3.new(1.2, 0.6, 1.2),
&#9;&#9;&#9;Position = Vector3.new(0, 0.4, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.1,},
&#9;&#9;},
&#9;}
&#9;--
&#9;local bld = entity.Building
&#9;local pos = boardview:coordToPosition(bld.X+bld.W/2, bld.Y+bld.H/2)
&#9;MoveModel(powerp, powerp.Base, CFrame.new(pos))
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(powerp:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;powerp:Destroy()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, powerp:GetChildren()&#9;
end
class&apos;Building_AlliedPowerPlant&apos;(function(this, x, y)
&#9;this.Health = MakeTrait_Health(this, 750)
&#9;this.Building = MakeTrait_Building(this, x, y, 2, 2)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedPowerPlant_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.PowerProducer = MakeTrait_PowerProducer(200)
&#9;this.Class = &apos;PowerPlant&apos;
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.Building:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.PowerProducer:destroy()
&#9;end&#9;
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedOreRefinery_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local ore = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedOreRefinery&apos;,
&#9;&#9;Parent = boardview:getContainer(),
&#9;&#9;--
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(3, 0.2, 4),
&#9;&#9;&#9;CFrame = CFrame.new(),
&#9;&#9;&#9;BrickColor = BrickColor.new(199)
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.6, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0.6, 0.1, -1.0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.3,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.6, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(-0.6, 0.1, -1.0),
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.3,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.6, 0.6, 1.6),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.1, 1.0),
&#9;&#9;&#9;BrickColor = BrickColor.new(1005),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.3,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.8, 1.2, 0.8),
&#9;&#9;&#9;CFrame = CFrame.new(-0.6, 0.9, -1),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.8, 1.2, 0.8),
&#9;&#9;&#9;CFrame = CFrame.new(0.6, 0.9, -1),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.8, 2, 0.8),
&#9;&#9;&#9;CFrame = CFrame.new(-0.6, 0.15, 0, 1, 0, 0, 0, 0, -1, 0, 1, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.8, 2, 0.8),
&#9;&#9;&#9;CFrame = CFrame.new(0.6, 0.15, 0, 1, 0, 0, 0, 0, -1, 0, 1, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;Make&apos;CylinderMesh&apos;{Bevel=0.05,},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.2, 0.8, 2),
&#9;&#9;&#9;CFrame = CFrame.new(0, 0.15, 0),
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;TopSurface = &apos;Smooth&apos;,
&#9;&#9;},
&#9;}
&#9;--
&#9;local bld = entity.Building
&#9;local pos = boardview:coordToPosition(bld.X+bld.W/2, bld.Y+bld.H/2)
&#9;MoveModel(ore, ore.Base, CFrame.new(pos))
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(ore:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;ore:Destroy()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, ore:GetChildren()&#9;
end
class&apos;Building_AlliedOreRefinery&apos;(function(this, x, y)
&#9;this.Health = MakeTrait_Health(this, 1000)
&#9;this.Building = MakeTrait_Building(this, x, y, 3, 4)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedOreRefinery_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.PowerProducer = MakeTrait_PowerConsumer(50)
&#9;this.Class = &apos;OreRefinery&apos;
&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.Building:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.PowerConsumer:destroy()
&#9;end&#9;
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
local function AlliedChronoMiner_ViewFactory(entity, gameview)
&#9;local boardview = gameview:getBoardView()
&#9;local teamOwned = entity.TeamOwned
&#9;local teamColor = teamOwned:getTeam():getTeamColor()
&#9;--
&#9;local unit = Make&apos;Model&apos;{
&#9;&#9;Name = &apos;AlliedChronoMiner&apos;,
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Base&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = BrickColor.new(199),
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 0.8, 1.2),
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Part&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = BrickColor.new(1027),
&#9;&#9;&#9;Transparency = 0.1,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 0.6, 1.6),
&#9;&#9;&#9;Position = Vector3.new(0, -0.1, -0.6),
&#9;&#9;&#9;Make&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshType=&apos;FileMesh&apos;, 
&#9;&#9;&#9;&#9;MeshId=&apos;http://www.roblox.com/asset/?id=1529453&apos;,
&#9;&#9;&#9;&#9;Scale=Vector3.new(1.8, 1, 1.8)
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Make&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;Color&apos;,
&#9;&#9;&#9;Anchored = true,
&#9;&#9;&#9;BrickColor = teamColor,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.3, 0.6, 0.3),
&#9;&#9;&#9;Position = Vector3.new(0, 0.1, -0.6),
&#9;&#9;&#9;Make&apos;SpecialMesh&apos;{MeshType=&apos;Head&apos;,},
&#9;&#9;}
&#9;}
&#9;unit.Parent = boardview:getContainer()
&#9;--
&#9;local moveCn = entity.MobileUnit.onMove:connect(function(x, y, ux, uy)
&#9;&#9;local pos = boardview:coordToPosition(x, y)+Vector3.new(0, 0.4, 0)
&#9;&#9;MoveModel(unit, unit.Base, CFrame.new(pos, pos+Vector3.new(ux, 0, uy)))
&#9;end)
&#9;--
&#9;local teamChangeCn = entity.TeamOwned.onTeamChange:connect(function(team)
&#9;&#9;local newColor = team:getTeamColor()
&#9;&#9;for _, ch in pairs(base:GetChildren()) do
&#9;&#9;&#9;if ch.Name == &apos;Color&apos; then
&#9;&#9;&#9;&#9;ch.BrickColor = newColor
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--
&#9;return function()
&#9;&#9;unit:Destroy()
&#9;&#9;moveCn:disconnect()
&#9;&#9;teamChangeCn:disconnect()
&#9;end, unit:GetChildren()&#9;
end
class&apos;Unit_AlliedChronoMiner&apos;(function(this)
&#9;local mOreQuantity = 0
&#9;--
&#9;this.Health = MakeTrait_Health(this, 1000)
&#9;this.MobileUnit = MakeTrait_MobileUnit(this, 1, true, false)
&#9;this.Displayable = MakeTrait_Displayable(this, AlliedChronoMiner_ViewFactory)
&#9;this.TeamOwned = MakeTrait_TeamOwned(this)
&#9;this.Class = &apos;ChronoMiner&apos;
&#9;--

&#9;local mOreLoad = 0
&#9;local mCurrentOre = nil
&#9;local mCurrentMine = nil
&#9;local mCurrentRefinery = nil
&#9;local mIsEnrouteToRefinery = false
&#9;local mTimeSinceLastAction = 0
&#9;this.Ticker = MakeTrait_Ticker(function(dt)
&#9;&#9;this.MobileUnit:tick(dt)
&#9;&#9;--
&#9;&#9;mTimeSinceLastAction = mTimeSinceLastAction+dt
&#9;&#9;--
&#9;&#9;if mCurrentOre and mOreLoad &lt; 5 then
&#9;&#9;&#9;print(&quot;Has Ore To Mine&quot;)
&#9;&#9;&#9;local heading = mCurrentOre.MobileUnit:distanceToPosition(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;this.MobileUnit:getDesiredPosition())
&#9;&#9;&#9;if heading &lt; 0.5 then
&#9;&#9;&#9;&#9;--moving to ore
&#9;&#9;&#9;&#9;if mTimeSinceLastAction &gt; 1 then
&#9;&#9;&#9;&#9;&#9;--if I&apos;m near it mine from it
&#9;&#9;&#9;&#9;&#9;local oreLeft = mCurrentOre:getOre()
&#9;&#9;&#9;&#9;&#9;local dist = this.MobileUnit:distanceToUnit(mCurrentOre.MobileUnit)
&#9;&#9;&#9;&#9;&#9;if oreLeft &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;if dist &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Mine Ore&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mCurrentOre:remOre(1)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mOreLoad = mOreLoad+1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mTimeSinceLastAction = 0
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;mCurrentOre = nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif heading &lt; 5 then
&#9;&#9;&#9;&#9;--moving somewhere within the current mine
&#9;&#9;&#9;&#9;mCurrentOre = nil
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--moving to some other mine
&#9;&#9;&#9;&#9;mCurrentOre = nil
&#9;&#9;&#9;&#9;mCurrentMine = nil&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end

&#9;&#9;elseif mCurrentRefinery and mIsEnrouteToRefinery then
&#9;&#9;&#9;print(&quot;Enroute to Refinery&quot;)
&#9;&#9;&#9;--if I&apos;m near enough dump to it
&#9;&#9;&#9;local dist = this.MobileUnit:distanceToBuilding(mCurrentRefinery.Building)
&#9;&#9;&#9;if dist &lt; 0.5 then
&#9;&#9;&#9;&#9;local toDeposit = mOreLoad*200
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;while toDeposit &gt; 0 do
&#9;&#9;&#9;&#9;&#9;&#9;local toAdd = math.min(toDeposit, 50)
&#9;&#9;&#9;&#9;&#9;&#9;toDeposit = toDeposit-toAdd
&#9;&#9;&#9;&#9;&#9;&#9;this.TeamOwned:getTeam():creditMoney(toAdd)
&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;mOreLoad = 0
&#9;&#9;&#9;&#9;mIsEnrouteToRefinery = false
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--need to decide what to do
&#9;&#9;&#9;if mOreLoad &lt; 5 then
&#9;&#9;&#9;&#9;if mCurrentMine then
&#9;&#9;&#9;&#9;&#9;--does the current mine have any gold?
&#9;&#9;&#9;&#9;&#9;if mCurrentMine:getTotalOre() &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Look for ore in current mine&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;--try to find a gold patch at the current mine
&#9;&#9;&#9;&#9;&#9;&#9;for ore in mCurrentMine:eachOre() do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ore:getOre() &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mCurrentOre = ore
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;this.MobileUnit:setDesiredPosition(ore.MobileUnit:getPosition())
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--no ore at current patch, nothig to do
&#9;&#9;&#9;&#9;&#9;&#9;--todo: maybe try a different patch
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Current Mine ran out of ore&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Find a mine&quot;)
&#9;&#9;&#9;&#9;&#9;--no current mine, try to find one:
&#9;&#9;&#9;&#9;&#9;--do a search of the entities on the current broad node
&#9;&#9;&#9;&#9;&#9;--for a gold ore
&#9;&#9;&#9;&#9;&#9;local cell = this.GameState:getBroadCell(this.MobileUnit:getPosition())
&#9;&#9;&#9;&#9;&#9;for entity, _ in pairs(cell.EntityMap) do
&#9;&#9;&#9;&#9;&#9;&#9;if entity.Class == &apos;GoldOre&apos; and entity:getMine():getTotalOre() &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mCurrentMine = entity:getMine()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Head to refinery&quot;)
&#9;&#9;&#9;&#9;--I&apos;m full, I need to return to refinery
&#9;&#9;&#9;&#9;if mCurrentRefinery then
&#9;&#9;&#9;&#9;&#9;--I have a refinery, go there
&#9;&#9;&#9;&#9;&#9;local x, y = this.GameState:findFreeSpaceByBuilding(mCurrentRefinery)
&#9;&#9;&#9;&#9;&#9;if x then
&#9;&#9;&#9;&#9;&#9;&#9;this.MobileUnit:setDesiredPosition(x, y)
&#9;&#9;&#9;&#9;&#9;&#9;mIsEnrouteToRefinery = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--I have no current refinery, find the closest
&#9;&#9;&#9;&#9;&#9;local nearestRefinery = nil
&#9;&#9;&#9;&#9;&#9;local nearestDistance = math.huge
&#9;&#9;&#9;&#9;&#9;for entity in this.TeamOwned:getTeam():eachEntity() do
&#9;&#9;&#9;&#9;&#9;&#9;if entity.Class == &apos;OreRefinery&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local dist = this.MobileUnit:distanceToBuilding(entity.Building)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if dist &lt; nearestDistance then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;nearestDistance = dist
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;nearestRefinery = entity
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;--did I find one?
&#9;&#9;&#9;&#9;&#9;if nearestRefinery then
&#9;&#9;&#9;&#9;&#9;&#9;mCurrentRefinery = nearestRefinery
&#9;&#9;&#9;&#9;&#9;&#9;--note: the next call to tick will actually go to this refinery
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;--deploy to send the miner back to the ore refinery
&#9;this.ClickEffect = MakeTrait_ClickEffect(this, &quot;&quot;, function()
&#9;&#9;return true
&#9;end, function()
&#9;&#9;
&#9;end)

&#9;--
&#9;function this:destroy()
&#9;&#9;this.Health:destroy()
&#9;&#9;this.MobileUnit:destroy()
&#9;&#9;this.Displayable:destroy()
&#9;&#9;this.TeamOwned:destroy()
&#9;&#9;this.ClickEffect:destroy()
&#9;&#9;this.Ticker:destroy()
&#9;end
end)




---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
class&apos;Roleset_Allied&apos;(function(this, gameview)
&#9;local mTeam = gameview:getTeam()
&#9;--
&#9;local mBaseCount = 0
&#9;local mBarracksCount = 0
&#9;local mBarracksMap = {}
&#9;--
&#9;local mOreRefineryCount = 0
&#9;local mOreRefineryMap = {}
&#9;--
&#9;this.onAvailableActionChange = MakeSignal()
&#9;--&#9;
&#9;local mAllActionList = {}
&#9;local function addAction(action)
&#9;&#9;mAllActionList[#mAllActionList+1] = action
&#9;end

&#9;--some getters that are needed by the actions I&apos;m constructing next
&#9;function this:getTeam()
&#9;&#9;return mTeam
&#9;end
&#9;function this:getGameView()
&#9;&#9;return gameview
&#9;end

&#9;--====== main dump of actions ============
&#9;--======== (constructed later) ===========
&#9;local mActionBuildBarracks =
&#9;&#9;MakeAction_MakeBuilding(this, &quot;&quot;, &quot;Barracks&quot;, 500, 
&#9;&#9;&#9;MakeMouseAction_PlaceBuilding(gameview, MakeBuilding_AlliedBarracks, 2, 3))
&#9;local mActionBuildPowerPlant =
&#9;&#9;MakeAction_MakeBuilding(this, &quot;&quot;, &quot;Power Plant&quot;, 500, 
&#9;&#9;&#9;MakeMouseAction_PlaceBuilding(gameview, MakeBuilding_AlliedPowerPlant, 2, 2))
&#9;local mActionBuildOreRefinery =
&#9;&#9;MakeAction_MakeBuilding(this, &quot;&quot;, &quot;Ore Refinery&quot;, 2000, 
&#9;&#9;&#9;MakeMouseAction_PlaceBuilding(gameview, MakeBuilding_AlliedOreRefinery, 3, 4))
&#9;local mActionMakeGI =
&#9;&#9;MakeAction_MakeUnit(this, &quot;&quot;, &quot;GI&quot;, 150, function()
&#9;&#9;&#9;if mBarracksCount &gt; 0 then
&#9;&#9;&#9;&#9;local barracks, _ = next(mBarracksMap)
&#9;&#9;&#9;&#9;local x, y = gameview:getGameState():findFreeSpaceByBuilding(barracks)
&#9;&#9;&#9;&#9;if x then
&#9;&#9;&#9;&#9;&#9;local gi = MakeUnit_AlliedGI()
&#9;&#9;&#9;&#9;&#9;gi.TeamOwned:setTeam(mTeam)
&#9;&#9;&#9;&#9;&#9;gameview:getGameState():addEntity(gi)
&#9;&#9;&#9;&#9;&#9;gi.MobileUnit:setPosition(x, y)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;local mActionMakeChronoMiner =
&#9;&#9;MakeAction_MakeUnit(this, &quot;&quot;, &quot;ChronoMiner&quot;, 1400, function()
&#9;&#9;&#9;if mOreRefineryCount &gt; 0 then
&#9;&#9;&#9;&#9;local orerefinery, _ = next(mOreRefineryMap)
&#9;&#9;&#9;&#9;local x, y = gameview:getGameState():findFreeSpaceByBuilding(orerefinery)
&#9;&#9;&#9;&#9;if x then
&#9;&#9;&#9;&#9;&#9;local miner = MakeUnit_AlliedChronoMiner()
&#9;&#9;&#9;&#9;&#9;miner.TeamOwned:setTeam(mTeam)
&#9;&#9;&#9;&#9;&#9;gameview:getGameState():addEntity(miner)
&#9;&#9;&#9;&#9;&#9;miner.MobileUnit:setPosition(x, y)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;--========================================
&#9;addAction(mActionBuildBarracks)
&#9;addAction(mActionBuildPowerPlant)
&#9;addAction(mActionBuildOreRefinery)
&#9;addAction(mActionMakeGI)
&#9;addAction(mActionMakeChronoMiner)
&#9;--========================================

&#9;--
&#9;function this:getActions(actiontype)
&#9;&#9;if actiontype == Roleset.ActionType.Infastructure then
&#9;&#9;&#9;local actions = {}
&#9;&#9;&#9;if mBaseCount &gt; 0 then
&#9;&#9;&#9;&#9;actions[#actions+1] = mActionBuildBarracks
&#9;&#9;&#9;&#9;actions[#actions+1] = mActionBuildPowerPlant
&#9;&#9;&#9;&#9;actions[#actions+1] = mActionBuildOreRefinery
&#9;&#9;&#9;end
&#9;&#9;&#9;return actions

&#9;&#9;elseif actiontype == Roleset.ActionType.Vehicles then
&#9;&#9;&#9;local actions = {}
&#9;&#9;&#9;if mOreRefineryCount &gt; 0 then
&#9;&#9;&#9;&#9;actions[#actions+1] = mActionMakeChronoMiner
&#9;&#9;&#9;end
&#9;&#9;&#9;return actions

&#9;&#9;elseif actiontype == Roleset.ActionType.Personnel then
&#9;&#9;&#9;local actions = {}
&#9;&#9;&#9;if mBarracksCount &gt; 0 then
&#9;&#9;&#9;&#9;actions[#actions+1] = mActionMakeGI
&#9;&#9;&#9;end
&#9;&#9;&#9;return actions

&#9;&#9;elseif actiontype == Roleset.ActionType.Defense then
&#9;&#9;&#9;return {}

&#9;&#9;end
&#9;end
&#9;--
&#9;function this:tick(dt)
&#9;&#9;for _, action in pairs(mAllActionList) do
&#9;&#9;&#9;action:tick(dt)
&#9;&#9;end
&#9;end
&#9;--make the game tick this
&#9;gameview:getGameState():addTicker(this)

&#9;--events
&#9;local addEntCn = mTeam.onEntityAdd:connect(function(entity)
&#9;&#9;if entity.Class == &apos;Base&apos; then
&#9;&#9;&#9;mBaseCount = mBaseCount + 1
&#9;&#9;&#9;if mBaseCount == 1 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Infastructure)
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Defense)
&#9;&#9;&#9;end
&#9;&#9;elseif entity.Class == &apos;Barracks&apos; then
&#9;&#9;&#9;mBarracksCount = mBarracksCount + 1
&#9;&#9;&#9;mBarracksMap[entity] = true
&#9;&#9;&#9;if mBarracksCount == 1 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Personnel)
&#9;&#9;&#9;end
&#9;&#9;elseif entity.Class == &apos;OreRefinery&apos; then
&#9;&#9;&#9;mOreRefineryCount = mOreRefineryCount + 1
&#9;&#9;&#9;mOreRefineryMap[entity] = true
&#9;&#9;&#9;if mOreRefineryCount == 1 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Vehicles)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local remEntCn = mTeam.onEntityRem:connect(function(entity)
&#9;&#9;if entity.Class == &apos;Base&apos; then
&#9;&#9;&#9;mBaseCount = mBaseCount - 1
&#9;&#9;&#9;if mBaseCount == 0 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Infastructure)
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Defense)
&#9;&#9;&#9;end
&#9;&#9;elseif entity.Class == &apos;Barracks&apos; then
&#9;&#9;&#9;mBarracksCount = mBarracksCount - 1
&#9;&#9;&#9;mBarracksMap[entity] = nil
&#9;&#9;&#9;if mBarracksCount == 0 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Personnel)
&#9;&#9;&#9;end
&#9;&#9;elseif entity.Class == &apos;OreRefinery&apos; then
&#9;&#9;&#9;mOreRefineryCount = mOreRefineryCount - 1
&#9;&#9;&#9;mOreRefineryMap[entity] = nil
&#9;&#9;&#9;if mOreRefineryCount == 0 then
&#9;&#9;&#9;&#9;this.onAvailableActionChange:fire(Roleset.ActionType.Vehicles)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;--destroy
&#9;function this:destroy()
&#9;&#9;addEntCn:disconnect()
&#9;&#9;remEntCn:disconnect()
&#9;&#9;--don&apos;t tick this anymore
&#9;&#9;gameview:getGameState():remTicker(this)
&#9;end
end)</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX13">
				<Properties>
					<string name="Name">action</string>
					<string name="Value">--action

function MakeAction_Base(this, image, name)
&#9;this.onReady = MakeSignal()
&#9;this.onProgress = MakeSignal()

&#9;function this:getImage()
&#9;&#9;return image
&#9;end
&#9;function this:getName()
&#9;&#9;return name
&#9;end
end


class&apos;Action_MakeUnit&apos;(function(this, roleset, image, name, cost, oncomplete)
&#9;MakeAction_Base(this, image, name)
&#9;--
&#9;local mUnitsToMake = 0
&#9;local mSpent = 0
&#9;local mTeam = roleset:getTeam()

&#9;function this:canEnqueue() return true; end
&#9;function this:isReady() return false; end
&#9;function this:use() 
&#9;&#9;Debug:fatal(&quot;Can&apos;t use() a MakeUnit action&quot;)
&#9;end
&#9;function this:enqueue()
&#9;&#9;mUnitsToMake = mUnitsToMake + 1
&#9;end
&#9;function this:canDequeue()
&#9;&#9;return mUnitsToMake &gt; 0
&#9;end
&#9;function this:dequeue()
&#9;&#9;mUnitsToMake = mUnitsToMake - 1
&#9;&#9;if mUnitsToMake == 0 then
&#9;&#9;&#9;mTeam:creditMoney(mSpent)
&#9;&#9;end
&#9;end
&#9;function this:getQueued()
&#9;&#9;if mUnitsToMake &gt; 0 then
&#9;&#9;&#9;return mUnitsToMake
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;function this:getProgress() return mSpent/cost; end
&#9;--
&#9;function this:tick(dt)
&#9;&#9;local maxSpend = math.min(math.ceil(dt*200), mTeam:getMoney())
&#9;&#9;local leftToSpend = maxSpend
&#9;&#9;local spentSome = false
&#9;&#9;while mUnitsToMake &gt; 0 and leftToSpend &gt; 0 do
&#9;&#9;&#9;local surplus = mSpent+leftToSpend-cost
&#9;&#9;&#9;if surplus &gt;= 0 then
&#9;&#9;&#9;&#9;leftToSpend = surplus
&#9;&#9;&#9;&#9;mUnitsToMake = mUnitsToMake - 1
&#9;&#9;&#9;&#9;mSpent = 0
&#9;&#9;&#9;&#9;oncomplete()
&#9;&#9;&#9;&#9;this.onReady:fire()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;spentSome = true
&#9;&#9;&#9;&#9;mSpent = mSpent + leftToSpend
&#9;&#9;&#9;&#9;leftToSpend = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if spentSome then
&#9;&#9;&#9;this.onProgress:fire(mSpent/cost)
&#9;&#9;end
&#9;&#9;mTeam:debitMoney(maxSpend-leftToSpend)
&#9;end
end)
class&apos;Action_MakeBuilding&apos;(function(this, roleset, image, name, cost, mouseAction)
&#9;MakeAction_Base(this, image, name)
&#9;--
&#9;local mQueued = false
&#9;local mReady = false
&#9;local mSpent = 0
&#9;local mTeam = roleset:getTeam()
&#9;--
&#9;function this:canEnqueue() return not mQueued; end
&#9;function this:isReady() return mReady; end
&#9;function this:use()
&#9;&#9;mReady = false
&#9;&#9;roleset:getGameView():pushMouseAction(mouseAction)
&#9;&#9;this.onProgress:fire(0)
&#9;end
&#9;function this:canDequeue()
&#9;&#9;return mQueued
&#9;end
&#9;function this:enqueue()
&#9;&#9;mQueued = true
&#9;end
&#9;function this:dequeue()
&#9;&#9;mTeam:creditMoney(mSpent)
&#9;&#9;mQueued = false
&#9;end
&#9;function this:getQueued() return mQueued or mReady; end
&#9;function this:getProgress() return mSpent/cost; end
&#9;--
&#9;function this:tick(dt)
&#9;&#9;local maxSpend = math.min(math.ceil(dt*200), mTeam:getMoney())
&#9;&#9;if mQueued then
&#9;&#9;&#9;local leftToGo = cost-mSpent
&#9;&#9;&#9;if leftToGo &lt;= maxSpend then
&#9;&#9;&#9;&#9;mTeam:debitMoney(leftToGo)
&#9;&#9;&#9;&#9;mSpent = 0
&#9;&#9;&#9;&#9;mReady = true
&#9;&#9;&#9;&#9;mQueued = false
&#9;&#9;&#9;&#9;this.onReady:fire()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mSpent = mSpent + maxSpend
&#9;&#9;&#9;&#9;mTeam:debitMoney(maxSpend)
&#9;&#9;&#9;&#9;this.onProgress:fire(mSpent/cost)
&#9;&#9;&#9;end

&#9;&#9;end
&#9;end
end)
class&apos;Action_Research&apos;(function(this, roleset, image, name, cost, oncomplete)
&#9;MakeAction_Base(this, image, name)
&#9;--
&#9;local mSpent = 0
&#9;local mTeam = roleset:getTeam()
&#9;local mInProgress = false
&#9;--
&#9;function this:canEnqueue() return not mInProgress; end
&#9;function this:canDequeue() return mInProgress; end
&#9;function this:enqueue() mInProgress = true; end
&#9;function this:dequeue()
&#9;&#9;if mSpent &gt; 0 then
&#9;&#9;&#9;mTeam:creditMoney(mSpent)
&#9;&#9;&#9;mSpent = 0
&#9;&#9;end
&#9;&#9;mInProgress = false
&#9;end
&#9;function this:isReady() return false; end
&#9;function this:use()
&#9;&#9;Debug:fatal(&quot;Can&apos;t use research action&quot;)
&#9;end
&#9;function this:getQueued() return mInProgress; end
&#9;function this:getProgress() return mSpent/cost; end
&#9;--
&#9;function this:tick(dt)
&#9;&#9;if mInProgress then
&#9;&#9;&#9;local maxSpend = math.min(math.ceil(dt*200), mTeam:getMoney())
&#9;&#9;&#9;local surplus = mSpent+maxSpend-cost
&#9;&#9;&#9;if surplus &gt;= 0 then
&#9;&#9;&#9;&#9;mTeam:debitMoney(cost-mSpent)
&#9;&#9;&#9;&#9;mSpent = 0
&#9;&#9;&#9;&#9;mInProgress = false
&#9;&#9;&#9;&#9;oncomplete()
&#9;&#9;&#9;&#9;this.onReady:fire()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mTeam:debitMoney(maxSpend)
&#9;&#9;&#9;&#9;mSpent = mSpent+maxSpend
&#9;&#9;&#9;&#9;this.onProgress:fire(mSpent/cost)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)
class&apos;Action_Recharge&apos;(function(this, roleset, image, name, rechargetime, mouseAction)
&#9;MakeAction_Base(this, image, name)
&#9;--
&#9;local mTimeSpent = 0
&#9;local mReady = false
&#9;local mTeam = roleset:getTeam()
&#9;local mRunning = false
&#9;--
&#9;function this:canEnqueue() return false; end
&#9;function this:canDequeue() return false; end
&#9;function this:isReady() return mReady; end
&#9;function this:use()
&#9;&#9;mReady = false
&#9;&#9;roleset:getGameView():pushMouseAction(mouseAction)
&#9;end
&#9;function this:getQueued() return mRunning; end
&#9;function this:getProgress() return mTimeSpent/rechargetime end
&#9;--
&#9;function this:setRunning(state)
&#9;&#9;if state then
&#9;&#9;&#9;mRunning = true
&#9;&#9;else
&#9;&#9;&#9;mRunning = false
&#9;&#9;&#9;mReady = false
&#9;&#9;&#9;mTimeSpent = 0
&#9;&#9;end
&#9;end
&#9;--
&#9;function this:tick(dt)
&#9;&#9;if mRunning and not mReady then
&#9;&#9;&#9;mTimeSpent = mTimeSpent + dt
&#9;&#9;&#9;if mTimeSpent &gt; rechargetime then
&#9;&#9;&#9;&#9;mTimeSpent = 0
&#9;&#9;&#9;&#9;mReady = true
&#9;&#9;&#9;&#9;this.onReady:fire()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;this.onProgress:fire()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)


class&apos;MouseAction_PlaceBuilding&apos;(function(this, gameview, buildingFactory, w, h)
&#9;local function isTargetFree()
&#9;&#9;local x, y = gameview:getBoardView():getMouseHit()
&#9;&#9;if x then
&#9;&#9;&#9;x, y = math.floor(x-w/2), math.floor(y-h/2)
&#9;&#9;&#9;return gameview:getGameState():isRectFree(x, y, w, h, nil), x, y
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;---------
&#9;function this:onSelect()
&#9;&#9;gameview:getGameState():addTicker(this)
&#9;end
&#9;function this:onDeselect()
&#9;&#9;gameview:getGameState():remTicker(this)
&#9;&#9;gameview:getBoardView():clearBuildingBounds()
&#9;end
&#9;----------
&#9;function this:tick(dt)
&#9;&#9;local isFree, x, y = isTargetFree()
&#9;&#9;if isFree then
&#9;&#9;&#9;gameview:getBoardView():showBuildingBounds(x, y, w, h, Color3.new(0, 1, 0))
&#9;&#9;elseif x then
&#9;&#9;&#9;gameview:getBoardView():showBuildingBounds(x, y, w, h, Color3.new(1, 0, 0))
&#9;&#9;else
&#9;&#9;&#9;gameview:getBoardView():clearBuildingBounds()
&#9;&#9;end
&#9;end
&#9;----------
&#9;function this:onMouseButton()
&#9;&#9;local isFree, x, y = isTargetFree()
&#9;&#9;if isFree then
&#9;&#9;&#9;local buildingEntity = buildingFactory(x, y)
&#9;&#9;&#9;buildingEntity.TeamOwned:setTeam(gameview:getTeam())
&#9;&#9;&#9;gameview:getGameState():addEntity(buildingEntity)
&#9;&#9;&#9;this:pop() --end placement UI
&#9;&#9;end
&#9;end
end)</string>
				</Properties>
			</Item>
		</Item>
		<Item class="SpawnLocation" referent="RBX14">
			<Properties>
				<bool name="AllowTeamChangeOnTouch">false</bool>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-1.39999998</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<int name="Duration">10</int>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">SpawnLocation</string>
				<bool name="Neutral">true</bool>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int name="TeamColor">194</int>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>12</X>
					<Y>1</Y>
					<Z>12</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX15">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">AlliedBarracks</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Part" referent="RBX16">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">153</int>
					<CoordinateFrame name="CFrame">
						<X>3.19999981</X>
						<Y>0.799999952</Y>
						<Z>-0.200000003</Z>
						<R00>1</R00>
						<R01>-0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>-0</R11>
						<R12>1</R12>
						<R20>0</R20>
						<R21>-1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">1072</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.5</X>
						<Y>2.4000001</Y>
						<Z>1.5</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX17">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>3.25</X>
						<Y>0.850075364</Y>
						<Z>1.09999979</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1.00000024</R12>
						<R20>0</R20>
						<R21>-1.00000024</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.200000003</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX18">
					<Properties>
						<float name="Bevel">0</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX19">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>3.25</X>
						<Y>0.749999881</Y>
						<Z>-0.199830174</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1.00000012</R11>
						<R12>6.29872084e-005</R12>
						<R20>0</R20>
						<R21>-6.29872084e-005</R21>
						<R22>1.00000012</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Base</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>0.200000003</Y>
						<Z>3</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX20">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>3.25</X>
						<Y>0.849924207</Y>
						<Z>-1.39988828</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1.00000024</R12>
						<R20>0</R20>
						<R21>-1.00000024</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.200000003</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX21">
					<Properties>
						<float name="Bevel">0</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX22">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>3.25</X>
						<Y>0.850075364</Y>
						<Z>1.00011313</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1.00000024</R12>
						<R20>0</R20>
						<R21>-1.00000024</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.200000003</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX23">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX24">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>3.25</X>
						<Y>0.849999785</Y>
						<Z>-0.199886799</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1.00000024</R12>
						<R20>0</R20>
						<R21>-1.00000024</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.200000003</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX25">
					<Properties>
						<float name="Bevel">0</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX26">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">AlliedPowerPlant</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Part" referent="RBX27">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.200000912</Y>
						<Z>-2.5999999</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Base</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>0.200000003</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX28">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.300002128</Y>
						<Z>-2.5999999</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.600000024</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX29">
					<Properties>
						<float name="Bevel">0.300000012</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX30">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.20127249</X>
						<Y>1.30000019</Y>
						<Z>-2.46408939</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>1</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX31">
					<Properties>
						<float name="Bevel">0.100000001</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX32">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.53212595</X>
						<Y>1.50000048</Y>
						<Z>-2.48141932</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.400000006</X>
						<Y>1.39999986</Y>
						<Z>0.400000006</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX33">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX34">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.600000024</Y>
						<Z>-2.60000014</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.20000005</X>
						<Y>0.600000024</Y>
						<Z>1.20000005</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX35">
					<Properties>
						<float name="Bevel">0.100000001</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX36">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>1.10000026</Y>
						<Z>-2.80000019</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>0.600000024</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX37">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX38">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">AlliedOreRefinery</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Part" referent="RBX39">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>3.79999995</X>
						<Y>1.19999862</Y>
						<Z>2.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.800000012</X>
						<Y>1.20000005</Y>
						<Z>0.800000012</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX40">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX41">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>3.79999995</X>
						<Y>0.45000121</Y>
						<Z>3.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>-4.37113883e-008</R11>
						<R12>-1</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>-4.37113883e-008</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.800000012</X>
						<Y>2.00000024</Y>
						<Z>0.800000012</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX42">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX43">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>3.79999995</X>
						<Y>0.400000781</Y>
						<Z>2.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.600000024</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX44">
					<Properties>
						<float name="Bevel">0.300000012</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX45">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.300000787</Y>
						<Z>3.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Base</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>3</X>
						<Y>0.200000003</Y>
						<Z>4</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX46">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.45000121</Y>
						<Z>3.39999986</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.19999957</X>
						<Y>0.800000012</Y>
						<Z>1.99999928</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX47">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">1005</int>
					<CoordinateFrame name="CFrame">
						<X>4.4000001</X>
						<Y>0.400000006</Y>
						<Z>4.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.20000005</X>
						<Y>0.600000024</Y>
						<Z>1.20000005</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX48">
					<Properties>
						<float name="Bevel">0.300000012</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX49">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>5</X>
						<Y>0.450001448</Y>
						<Z>3.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>-1</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.800000012</X>
						<Y>2.00000024</Y>
						<Z>0.800000012</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX50">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX51">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">21</int>
					<CoordinateFrame name="CFrame">
						<X>5.00000048</X>
						<Y>0.400001019</Y>
						<Z>2.39999986</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Color</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.60000002</X>
						<Y>0.600000024</Y>
						<Z>1.60000002</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX52">
					<Properties>
						<float name="Bevel">0.300000012</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX53">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>5</X>
						<Y>1.19999933</Y>
						<Z>2.4000001</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.800000012</X>
						<Y>1.20000005</Y>
						<Z>0.800000012</Z>
					</Vector3>
				</Properties>
				<Item class="CylinderMesh" referent="RBX54">
					<Properties>
						<float name="Bevel">0.0500000007</float>
						<float name="Bevel Roundness">0</float>
						<float name="Bulge">0</float>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX55">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">AnimEdit_Save</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX56">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">1005</int>
				<CoordinateFrame name="CFrame">
					<X>1.04999995</X>
					<Y>1.45009446</Y>
					<Z>2.40016365</Z>
					<R00>-1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>-1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">1072</token>
				<string name="Name">Gygax</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.400000006</X>
					<Y>0.300000012</Y>
					<Z>0.200000003</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX57">
		<Properties>
			<string name="Name">StarterPack</string>
		</Properties>
		<Item class="HopperBin" referent="RBX58">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">GameTool</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="Script" referent="RBX59">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">replicator</string>
					<ProtectedString name="Source">local Tool = script.Parent
local Player = Tool.Parent.Parent
local Selected = false

function prettyDigit(n)
&#9;local neg = (n &lt; 0)
&#9;if neg then n = math.abs(n) end
&#9;local dec = math.floor(n)
&#9;local frac = n-dec
&#9;--
&#9;local s = tostring(dec)
&#9;s = (neg and &quot;-&quot; or &quot; &quot;)..string.rep(&quot; &quot;, 3-#s)..s
&#9;local fs = tostring(math.floor(frac*100))
&#9;s = s..&quot;.&quot;..fs..string.rep(&quot; &quot;, 2-#fs)
&#9;return s
end
function prettyPrint(vec)
&#9;return &quot;&lt;&quot;..prettyDigit(vec.x)..&quot;,&quot;
&#9;          ..prettyDigit(vec.y)..&quot;,&quot;
&#9;          ..prettyDigit(vec.z)..&quot;&gt;&quot;
end

Tool.Selected:connect(function(mouse)
&#9;local IFace = Player.MouseInterface
&#9;--
&#9;Player.Character.Parent = nil
&#9;Player.Character = nil
&#9;Selected = true
&#9;--
&#9;mouse.Button1Down:connect(function()
&#9;&#9;IFace.RightButton.Value = true
&#9;end)
&#9;mouse.Button1Up:connect(function()
&#9;&#9;IFace.RightButton.Value = false
&#9;end)
&#9;--
&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;key = key:lower()
&#9;&#9;local kv = Instance.new(&quot;StringValue&quot;)
&#9;&#9;kv.Value = key
&#9;&#9;kv.Name = &quot;down&quot;
&#9;&#9;kv.Parent = IFace.KeyContainer
&#9;end)
&#9;mouse.KeyUp:connect(function(key)
&#9;&#9;key = key:lower()
&#9;&#9;local kv = Instance.new(&quot;StringValue&quot;)
&#9;&#9;kv.Value = key
&#9;&#9;kv.Name = &quot;up&quot;
&#9;&#9;kv.Parent = IFace.KeyContainer
&#9;end)
&#9;--
&#9;IFace.Icon.Changed:connect(function()
&#9;&#9;mouse.Icon = IFace.Icon.Value
&#9;end)
&#9;mouse.Icon = IFace.Icon.Value
&#9;--
&#9;IFace.CameraSubject.Changed:connect(function()
&#9;&#9;game.Workspace.CurrentCamera.CameraSubject = IFace.CameraSubject.Value
&#9;end)
&#9;IFace.CameraLook.Changed:connect(function()
&#9;&#9;game.Workspace.CurrentCamera.Focus = CFrame.new(IFace.CameraLook.Value)
&#9;&#9;game.Workspace.CurrentCamera.CoordinateFrame = 
&#9;&#9;&#9;CFrame.new(IFace.CameraAt.Value, IFace.CameraLook.Value)
&#9;end)
&#9;local cam = game.Workspace.CurrentCamera
&#9;cam.CameraType = &apos;Fixed&apos;
&#9;cam.CameraSubject = IFace.CameraSubject.Value
&#9;cam.Focus = CFrame.new(IFace.CameraLook.Value)
&#9;cam.CoordinateFrame = CFrame.new(IFace.CameraAt.Value, IFace.CameraLook.Value)
&#9;--
&#9;local lastCamPos = cam.Focus.p
&#9;local oldCoord = cam.CoordinateFrame
&#9;local function sign(n)
&#9;&#9;if n &gt; 0 then
&#9;&#9;&#9;return 1
&#9;&#9;elseif n &lt; 0 then
&#9;&#9;&#9;return -1
&#9;&#9;else
&#9;&#9;&#9;return 0
&#9;&#9;end
&#9;end
&#9;local function zeroFloor(n)
&#9;&#9;if n &gt; 0 then
&#9;&#9;&#9;return math.floor(n)
&#9;&#9;elseif n &lt; 0 then
&#9;&#9;&#9;return -math.floor(-n)
&#9;&#9;else
&#9;&#9;&#9;return 0
&#9;&#9;end
&#9;end
&#9;while Selected do
&#9;&#9;--replicate continuous properties
&#9;&#9;IFace.Target.Value = mouse.Target
&#9;&#9;IFace.Hit.Value = mouse.Hit.p
&#9;&#9;IFace.UnitRay.Value = mouse.UnitRay

&#9;&#9;local viewRotation = (cam.CoordinateFrame-cam.CoordinateFrame.p)
&#9;&#9;local newCamPos = cam.Focus.p
&#9;&#9;local moveDir = (newCamPos-lastCamPos)
&#9;&#9;moveDir = viewRotation:toObjectSpace(CFrame.new(moveDir)).p
&#9;&#9;--
&#9;&#9;local camLook = cam.CoordinateFrame.lookVector
&#9;&#9;local camLookXZ = Vector3.new(camLook.x, 0, camLook.z).unit
&#9;&#9;local camLookPerp = Vector3.new(-camLookXZ.z, 0, camLookXZ.x)
&#9;&#9;--
&#9;&#9;--if moveDir.magnitude &gt; 0 then
&#9;&#9;--&#9;print(prettyPrint(moveDir))
&#9;&#9;--end
&#9;&#9;local savedPos = newCamPos
&#9;&#9;--
&#9;&#9;local moveZ;
&#9;&#9;if moveDir.magnitude &gt; 0 then
&#9;&#9;&#9;if moveDir.z &lt;= -6 then
&#9;&#9;&#9;&#9;moveZ = 1
&#9;&#9;&#9;elseif moveDir.z &gt;= -4 then
&#9;&#9;&#9;&#9;moveZ = -1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;moveZ = 0
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;moveZ = 0
&#9;&#9;end
&#9;&#9;local moveX;
&#9;&#9;if math.abs(moveDir.x) &gt; 1.5 then
&#9;&#9;&#9;moveX = sign(moveDir.x)
&#9;&#9;else
&#9;&#9;&#9;moveX = 0
&#9;&#9;end
&#9;&#9;--
&#9;&#9;--print(prettyDigit(moveZ))
&#9;&#9;--
&#9;&#9;newCamPos = lastCamPos + camLookXZ*moveZ + camLookPerp*moveX
&#9;&#9;newCamPos = Vector3.new(newCamPos.x, 10, newCamPos.z)
&#9;&#9;cam.Focus = CFrame.new(newCamPos)
&#9;&#9;--
&#9;&#9;local newCamDir = Vector3.new(camLookXZ.x, -1, camLookXZ.z).unit
&#9;&#9;cam.CoordinateFrame = CFrame.new(newCamPos-newCamDir*15, newCamPos)

&#9;&#9;lastCamPos = newCamPos
&#9;&#9;oldCoord = cam.CoordinateFrame
&#9;&#9;
&#9;&#9;wait()
&#9;end
end)

Tool.Deselected:connect(function()
&#9;Selected = false
end)</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterGui" referent="RBX60">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ShowDevelopmentGui">true</bool>
		</Properties>
		<Item class="ScreenGui" referent="RBX61">
			<Properties>
				<string name="Name">ScreenGui</string>
			</Properties>
			<Item class="ImageButton" referent="RBX62">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><null></null></Content>
					<bool name="Modal">false</bool>
					<string name="Name">ImageButton</string>
					<UDim2 name="Position">
						<XS>1</XS>
						<XO>-256</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>256</XO>
						<YS>0</YS>
						<YO>640</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX63">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">10</float>
			<float name="DopplerScale">1</float>
			<string name="Name">Soundscape</string>
			<float name="RolloffScale">1</float>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX64">
		<Properties>
			<string name="Name">CollectionService</string>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX65">
		<Properties>
			<string name="Name">PhysicsService</string>
		</Properties>
	</Item>
	<Item class="BadgeService" referent="RBX66">
		<Properties>
			<string name="Name">BadgeService</string>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX67">
		<Properties>
			<string name="Name">Geometry</string>
		</Properties>
	</Item>
	<Item class="RenderHooksService" referent="RBX68">
		<Properties>
			<string name="Name">RenderHooksService</string>
		</Properties>
	</Item>
	<Item class="SocialService" referent="RBX69">
		<Properties>
			<string name="Name">SocialService</string>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX70">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX71">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ScriptInformationProvider" referent="RBX72">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX73">
		<Properties>
			<string name="Name">CookiesService</string>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX74">
		<Properties>
			<string name="Name">Teleport Service</string>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX75">
		<Properties>
			<string name="Name">Players</string>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX76">
		<Properties>
			<string name="Name">Selection</string>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX77">
		<Properties>
			<Color3 name="Ambient">4286611584</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">4278190080</Color3>
			<Color3 name="ColorShift_Top">4278190080</Color3>
			<Color3 name="FogColor">4290822336</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<string name="Name">Lighting</string>
			<Color3 name="ShadowColor">4289967032</Color3>
			<string name="TimeOfDay">12:00:00</string>
		</Properties>
		<Item class="Sky" referent="RBX78">
			<Properties>
				<bool name="CelestialBodiesShown">true</bool>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<Content name="SkyboxDn"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<Content name="SkyboxFt"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<Content name="SkyboxLf"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<Content name="SkyboxRt"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<Content name="SkyboxUp"><url>http://www.roblox.com/asset/?id=37516014</url></Content>
				<int name="StarCount">3000</int>
			</Properties>
		</Item>
	</Item>
	<Item class="ChangeHistoryService" referent="RBX79">
		<Properties>
			<string name="Name">ChangeHistoryService</string>
		</Properties>
	</Item>
</roblox>