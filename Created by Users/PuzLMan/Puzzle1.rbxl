<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0">
		<Properties>
			<Ref name="CurrentCamera">RBX1</Ref>
			<double name="DistributedGameTime">0</double>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Camera" referent="RBX1">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>1404.43604</X>
					<Y>1597.88062</Y>
					<Z>-503.968536</Z>
					<R00>0.688048124</R00>
					<R01>0.242176473</R01>
					<R02>-0.684061706</R02>
					<R10>-1.49011612e-08</R10>
					<R11>0.942668676</R11>
					<R12>0.33373034</R12>
					<R20>0.725665092</R20>
					<R21>-0.229622513</R21>
					<R22>0.648601353</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>1405.8042</X>
					<Y>1597.21313</Y>
					<Z>-505.265778</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Camera</string>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX2">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2</X>
					<Y>126</Y>
					<Z>-2</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<string name="ClusterGridV2"></string>
				<float name="Elasticity">0.300000012</float>
				<float name="Friction">0.5</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Terrain</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">StarterLevelScript</string>
				<ProtectedString name="Source">local LEVELS_TO_CHOOSE_FROM = 3 -- they&apos;ll always have 3 levels they haven&apos;t passed yet to choose from

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local levelModel = WaitForChild(game.Lighting, &quot;Levels&quot;)
local levelStartPadPrototype = WaitForChild(game.Lighting, &quot;LevelStartPad&quot;)
local levelsLoadedTag = WaitForChild(game.Lighting, &quot;FinishedLoading&quot;)
local startLevel = WaitForChild(workspace, &quot;StarterLevel&quot;)
local startLevelSpawn = WaitForChild(startLevel, &quot;StarterLevelSpawnLocation&quot;)

local laserContainer = WaitForChild(workspace, &quot;LaserContainer&quot;)
local draggingModel = WaitForChild(workspace, &quot;DraggingModel&quot;)

--draggingModel.AncestryChanged:connect(function() draggingModel.Parent = workspace end) -- force this model to not be removed by stupid &quot;fall off screen&quot; code

local levelsBeaten = {}
local numLevelsBeaten = 0 -- start this at 0

local levelTeleporters = {}
local currentLevel = nil

--wait(2) -- for levels to populate inside this table...
local levels = levelModel:GetChildren()

local startLevelWelds = startLevelSpawn:GetChildren()


function levelSort(levelOne, levelTwo)
&#9;return levelOne.Name &lt; levelTwo.Name
end

table.sort(levels, levelSort)

function restoreStartLevelWelds()
&#9;for i = 1, #startLevelWelds do
&#9;&#9;startLevelWelds[i].Parent = startLevelSpawn
&#9;end
end

function teleportCharactersToStart()
&#9;local players = game.Players:GetPlayers()
&#9;for _, player in pairs(players) do
&#9;&#9;local character = player.Character
&#9;&#9;if character then
&#9;&#9;&#9;character:TranslateBy(startLevelSpawn.CFrame.p - character:GetModelCFrame().p)
&#9;&#9;end
&#9;end
end

function returnToStartLevel()
&#9;if currentLevel then currentLevel.Parent = nil currentLevel = nil startLevel.Parent = workspace restoreStartLevelWelds() teleportCharactersToStart() end
&#9;laserContainer:ClearAllChildren()
end

function onCharacterAdded(character)
&#9;local humanoid = WaitForChild(character, &quot;Humanoid&quot;)
&#9;humanoid.Died:connect(returnToStartLevel)
end

function onPlayerAdded(player)
&#9;player.CharacterAdded:connect(onCharacterAdded)
&#9;if player.Character then onCharacterAdded(player.Character) end
end

game.Players.PlayerAdded:connect(onPlayerAdded)
for _, player in pairs(game.Players:GetPlayers()) do
&#9;onPlayerAdded(player)
end

function beatLevel(touchingPart, whichNum, star)
&#9;if not touchingPart or not touchingPart.Parent then return end
&#9;if not touchingPart.Parent:FindFirstChild(&quot;Humanoid&quot;) and ((not touchingPart.Parent.Parent) or not touchingPart.Parent.Parent:FindFirstChild(&quot;Humanoid&quot;)) then return end

&#9;local spike = star:FindFirstChild(&quot;Spike&quot;)
&#9;local successStar = star:Clone()
&#9;if spike then
&#9;&#9;local bodyAngularVelocity = spike:FindFirstChild(&quot;BodyAngularVelocity&quot;)
&#9;&#9;local floatForce = spike:FindFirstChild(&quot;FloatForce&quot;)
&#9;&#9;if bodyAngularVelocity then bodyAngularVelocity.angularvelocity = Vector3.new(0, 15, 0) end -- speed up
&#9;&#9;if floatForce then floatForce.force = Vector3.new(0, 400, 0) end  -- and shoot upwards
&#9;end
&#9;if not levelsBeaten[whichNum] then
&#9;&#9;levelsBeaten[whichNum] = true
&#9;&#9;numLevelsBeaten = numLevelsBeaten + 1
&#9;&#9;--levelTeleporters[whichNum].BrickColor = BrickColor.new(&quot;Black&quot;)

&#9;&#9;-- just gray out decal a bit to show it&apos;s been beaten
&#9;&#9;WaitForChild(levelTeleporters[whichNum], &quot;Decal&quot;).Transparency = .5

&#9;&#9;-- also add a spinning success-star above the teleporter also; more gratifying
&#9;&#9;successStar:TranslateBy(levelTeleporters[whichNum].CFrame.p - successStar:GetModelCFrame().p + Vector3.new(0, 2, 0))
&#9;&#9;successStar.Parent = startLevel

&#9;&#9;addTeleporters()
&#9;end

&#9;wait(3) -- to give them a little time to appreciate getting the star

&#9;returnToStartLevel()
end

function teleportTo(whichNum, hitPart)
&#9;if currentLevel then return end

&#9;local hitChar = hitPart.Parent
&#9;if not hitChar or not hitChar:FindFirstChild(&quot;Torso&quot;) then return end

&#9;local nextLevel = levels[whichNum]:Clone()
&#9;startLevel.Parent = nil
&#9;nextLevel.Parent = workspace
&#9;nextLevel:MakeJoints() -- fix rotating turnstiles to use manualwelds to avoid this :(

&#9;currentLevel = nextLevel

&#9;local spawnLoc = WaitForChild(nextLevel, &quot;SpawnLocation&quot;)
&#9;local charTorso = hitChar:FindFirstChild(&quot;Torso&quot;)
&#9;if charTorso then charTorso.CFrame = spawnLoc.CFrame + Vector3.new(0, 3, 0) end

&#9;local endStar = WaitForChild(nextLevel, &quot;Star&quot;)
&#9;for _, starPart in pairs(endStar:GetChildren()) do
&#9;&#9;starPart.Touched:connect(function(touchingPart) beatLevel(touchingPart, whichNum, endStar) end)
&#9;end
end

function addTeleporters()
&#9;while #levelTeleporters &lt; numLevelsBeaten + LEVELS_TO_CHOOSE_FROM and #levelTeleporters &lt; #levels do
&#9;&#9;local whichNum = #levelTeleporters -- 0-indexed in placement mapping
&#9;&#9;local newTeleporter = levelStartPadPrototype:Clone()
&#9;&#9;newTeleporter.CFrame = CFrame.new(Vector3.new(10*(whichNum%10) - 45, 2, (whichNum - (whichNum%10)) - 45))
&#9;&#9;newTeleporter.Parent = startLevel
&#9;&#9;whichNum = whichNum + 1 -- 1-indexed in arrays and tables
&#9;&#9;newTeleporter.Touched:connect(function(hitPart) teleportTo(whichNum, hitPart) end)
&#9;&#9;table.insert(levelTeleporters, newTeleporter)
&#9;end
end

addTeleporters()

-- this is REALLY awful that I have to do this, but if I do this from an event, the parent setting won&apos;t replicate
while true do
&#9;if not draggingModel.Parent then draggingModel.Parent = workspace end
&#9;wait(1)
end
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX4">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LaserContainer</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX5">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LoadLevels</string>
				<ProtectedString name="Source">local PUZZLE_SET_USER_ID = 34150989 -- PuzLMan
local PUZZLE_SET_NAME = &quot;Starting Puzzles&quot; -- for starters

-- insertAsset(game:GetService(&quot;InsertService&quot;):GetCollection(838607)[2].AssetId), loads level2 into the workspace

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end


local mySets = game:GetService(&quot;InsertService&quot;):GetUserSets(PUZZLE_SET_USER_ID)
local myPuzzleSet = nil

local levelModel = Instance.new(&quot;Model&quot;)
levelModel.Name = &quot;Levels&quot;

local levelStartPad = WaitForChild(game.Lighting, &quot;LevelStartPad&quot;)
local levelStartPadDecal = WaitForChild(levelStartPad, &quot;Decal&quot;)

levelModel.Parent = game.Lighting

function loadSet(puzzleSet)
&#9;for i = 1, #puzzleSet do
&#9;&#9;if i == 1 then
&#9;&#9;&#9;for key, value in pairs(puzzleSet[i]) do
&#9;&#9;&#9;&#9;print(&quot;key:&quot; , key , &quot;value:&quot; , value)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;-- Going to pcall this function because it is deprecated, and I don&apos;t know how long it will be supported
&#9;&#9;pcall(function() game:GetService(&quot;InsertService&quot;):ApproveAssetId(puzzleSet[i].AssetId) end)
&#9;&#9;local newLevel = game:GetService(&quot;InsertService&quot;):LoadAsset(puzzleSet[i].AssetId):GetChildren()[1]
&#9;&#9;newLevel.Name = puzzleSet[i].Name

&#9;&#9;local assetId = Instance.new(&apos;IntValue&apos;)
&#9;&#9;assetId.Value = puzzleSet[i].AssetId
&#9;&#9;assetId.Name = &apos;AssetId&apos;
&#9;&#9;while newLevel:FindFirstChild(&apos;AssetId&apos;) do
&#9;&#9;&#9;newLevel.AssetId:Destroy()
&#9;&#9;end
&#9;&#9;assetId.Parent = newLevel
&#9;&#9;
&#9;&#9;local assetVersionId = Instance.new(&apos;IntValue&apos;)
&#9;&#9;assetVersionId.Value = puzzleSet[i].AssetVersionId
&#9;&#9;assetVersionId.Name = &apos;AssetVersionId&apos;
&#9;&#9;while newLevel:FindFirstChild(&apos;AssetVersionId&apos;) do
&#9;&#9;&#9;newLevel.AssetVersionId:Destroy()
&#9;&#9;end
&#9;&#9;assetVersionId.Parent = newLevel

&#9;&#9;
&#9;&#9;newLevel.Parent = levelModel
&#9;end
end

function loadPuzzleSet()
&#9;for i = 1, #mySets do
&#9;&#9;if mySets[i].Name == PUZZLE_SET_NAME then
&#9;&#9;&#9;loadSet(game:GetService(&quot;InsertService&quot;):GetCollection(mySets[i].CategoryId))
&#9;&#9;&#9;levelStartPadDecal.Texture = &quot;http://www.roblox.com/asset/?id=&quot; .. tostring(mySets[i].ImageAssetId)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
end

loadPuzzleSet()

local finishedLoadingTag = Instance.new(&quot;BoolValue&quot;)
finishedLoadingTag.Name = &quot;FinishedLoading&quot;
finishedLoadingTag.Parent = game.Lighting


</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX6">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">DraggingModel</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX7">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LevelChangeScript</string>
				<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local PlayersService = Game:GetService(&apos;Players&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)

local LevelModel

local CurrentLevel = WaitForChild(script, &apos;CurrentLevel&apos;)
if not CurrentLevel then
&#9;CurrentLevel = Instance.new(&apos;ObjectValue&apos;)
&#9;CurrentLevel.Name = &apos;CurrentLevel&apos;
&#9;CurrentLevel.Parent = script
end

local RequestedLevel = WaitForChild(script, &apos;RequestedLevel&apos;)

local LevelPointers = WaitForChild(script, &apos;LevelPointers&apos;)

local DraggingModel = WaitForChild(workspace, &quot;DraggingModel&quot;)

local GameClock = WaitForChild(Workspace, &apos;GameClock&apos;)
local ClockStart = WaitForChild(GameClock, &apos;Start&apos;)
local ClockStop = WaitForChild(GameClock, &apos;Stop&apos;)
local ClockTime = WaitForChild(GameClock, &apos;Time&apos;)
local ClockGetSeconds = WaitForChild(GameClock, &apos;GetSeconds&apos;)

local CompleteLevelCallback = nil

-- Easy tree traversal, infinite loops on cycles
local function BFS(model, functor, ...)
&#9;local queue = {}
&#9;table.insert(queue, model)
&#9;while #queue &gt; 0 do
&#9;&#9;local currNode = table.remove(queue, 1)
&#9;&#9;-- replace currNode with prefab
&#9;&#9;local result = functor(currNode, ...)
&#9;&#9;if result then
&#9;&#9;&#9;return result
&#9;&#9;end
&#9;&#9;for _, child in pairs(currNode:GetChildren()) do
&#9;&#9;&#9;table.insert(queue, child)&#9;&#9;&#9;&#9;
&#9;&#9;end
&#9;end
end

local function RecursivelyAnchorModelHelper(model, anchorTable)
&#9;if model == nil then return end
&#9;if model:IsA(&apos;BasePart&apos;) then
&#9;&#9;if not model.Anchored then
&#9;&#9;&#9;model.Anchored = true
&#9;&#9;&#9;table.insert(anchorTable, model)
&#9;&#9;end
&#9;end
&#9;for _, child in pairs(model:GetChildren()) do
&#9;&#9;RecursivelyAnchorModelHelper(child, anchorTable)
&#9;end
end

local function RecursivelyAnchorModel(model)
&#9;local anchorTable = {}
&#9;RecursivelyAnchorModelHelper(model, anchorTable)
&#9;return anchorTable
end

local function RestoreAnchorProperties(anchorTable)
&#9;for _, part in pairs(anchorTable) do
&#9;&#9;if part then
&#9;&#9;&#9;part.Anchored = false
&#9;&#9;end
&#9;end
end

function FindDescendent(model, name)
&#9;return BFS(model, function(currNode) if currNode.Name == name then return currNode end end)
end

function SpawnPlayers(level)
&#9;local spawnLoc = WaitForChild(level, &quot;SpawnLocation&quot;) --FindDescendent(level, &apos;SpawnLocation&apos;)
&#9;if spawnLoc then
&#9;&#9;local players = PlayersService:GetPlayers()
&#9;&#9;for _, player in pairs(players) do
&#9;&#9;&#9;player:LoadCharacter()
&#9;&#9;&#9;local character = player.Character
&#9;&#9;&#9;if character then
&#9;&#9;&#9;&#9;character:TranslateBy((spawnLoc.CFrame.p + Vector3.new(0, 3, 0)) - character:GetModelCFrame().p)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;print(&quot;Level&quot; , level.Name , &quot;has no SpawnLocation! Add one or the player will not spawn at the proper location.&quot;)
&#9;end
end

function BeatLevel(touchingPart, whichNum, spike)
&#9;print(&quot;Beat Level&quot;)
&#9;if CurrentLevel then
&#9;&#9;local completionValue = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;completionValue.Value = true
&#9;&#9;completionValue.Name = &apos;Completed&apos;
&#9;&#9;local theLevelPointer = LevelPointers:FindFirstChild(CurrentLevel.Value.Name)
&#9;&#9;if theLevelPointer then
&#9;&#9;&#9;if not theLevelPointer:FindFirstChild(&apos;Completed&apos;) then
&#9;&#9;&#9;&#9;completionValue.Parent = theLevelPointer
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;The level already has a completed flag&quot;)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Unable to find created level&quot;)
&#9;&#9;end
&#9;end
&#9;ClockStop:Invoke()
&#9;if spike then
&#9;&#9;local bodyAngularVelocity = spike:FindFirstChild(&quot;BodyAngularVelocity&quot;)
&#9;&#9;local floatForce = spike:FindFirstChild(&quot;FloatForce&quot;)
&#9;&#9;if bodyAngularVelocity then bodyAngularVelocity.angularvelocity = Vector3.new(0, 15, 0) end -- speed up
&#9;&#9;if spike:FindFirstChild(&apos;BodyVelocity&apos;) then spike.BodyVelocity:Destroy() end -- hack
&#9;&#9;if floatForce then floatForce.force = Vector3.new(0, 400, 0) end  -- and shoot upwards
&#9;end
&#9;wait(2.5) -- to give them a little time to appreciate getting the star
end

function ListenToCompletion(level)
&#9;local fired = false
&#9;local completedEvent = level:FindFirstChild(&apos;LevelCompleted&apos;)
&#9;if not completedEvent then
&#9;&#9;completedEvent = Instance.new(&apos;BindableEvent&apos;)
&#9;&#9;completedEvent.Name = &apos;LevelCompleted&apos;
&#9;&#9;completedEvent.Parent = level
&#9;end
&#9;if CompleteLevelCallback then
&#9;&#9;CompleteLevelCallback:disconnect()
&#9;&#9;CompleteLevelCallback = nil
&#9;end
&#9;CompleteLevelCallback = completedEvent.Event:connect(function()
&#9;&#9;print(&quot;Completed level:&quot; , level.Name)
&#9;&#9;local bv = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;bv.Name = &apos;Completion&apos;
&#9;&#9;bv.Value = true
&#9;&#9;bv.Parent = completedEvent
&#9;&#9;CompleteLevelCallback:disconnect()
&#9;&#9;return level.Name
&#9;end)

&#9;local endStar = WaitForChild(level, &quot;Star&quot;)
&#9;for _, starPart in pairs(endStar:GetChildren()) do
&#9;&#9;starPart.Touched:connect(function(touchingPart)
&#9;&#9;&#9;if not fired and touchingPart and touchingPart.Parent and touchingPart.Parent:FindFirstChild(&apos;Humanoid&apos;) then
&#9;&#9;&#9;&#9;BeatLevel(touchingPart, whichNum, endStar.Spike) completedEvent:Fire() fired = true
&#9;&#9;&#9;end end)
&#9;end

end

function UnloadLevel(level)
&#9;if level then
&#9;&#9;level:Destroy()
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;player.Character = nil
&#9;&#9;end
&#9;end
&#9;if CompleteLevelCallback then
&#9;&#9;CompleteLevelCallback:disconnect()
&#9;&#9;CompleteLevelCallback = nil
&#9;end
&#9;-- also clear out the current dragging model
&#9;DraggingModel:ClearAllChildren()
end

local Loading = false

function LoadLevel(level)
&#9;if Loading then return false end
&#9;Loading = true
&#9;if not level then print(&quot;Level is nil&quot;) return end
&#9;UnloadLevel(CurrentLevel.Value)
&#9;local levelClone = level:Clone()
&#9;CurrentLevel.Value = levelClone
&#9;--wait(1)
&#9;local anchorTable = RecursivelyAnchorModel(levelClone)
&#9;levelClone.Parent = Workspace
&#9;--wait(1)
&#9;--BFS(levelClone, function(currNode) if currNode:IsA(&apos;Model&apos;) then currNode:MakeJoints() end end)
&#9;levelClone:MakeJoints()
&#9;--wait(1)
&#9;RestoreAnchorProperties(anchorTable)
&#9;ListenToCompletion(levelClone)
&#9;SpawnPlayers(levelClone)
&#9;ClockTime.Value = 0
&#9;ClockStart:Invoke()
&#9;Loading = false
&#9;return true
end


RequestedLevel.Changed:connect(function(levelPointer)
&#9;if levelPointer and levelPointer.Value then
&#9;&#9;LoadLevel(levelPointer.Value)
&#9;&#9;RequestedLevel.Value = nil
&#9;end
end)

function AddLevel(level)
&#9;--local levelNum = string.gmatch(level.Name, &quot;Level(%d+)&quot;)(1)
&#9;if not LevelPointers:FindFirstChild(level.Name)  then
&#9;&#9;local levelValue = Instance.new(&apos;ObjectValue&apos;)
&#9;&#9;levelValue.Name = level.Name
&#9;&#9;levelValue.Value = level
&#9;&#9;levelValue.Parent = LevelPointers
&#9;end
end

LevelModel = WaitForChild(LightingService, &apos;Levels&apos;)

print(&quot;LevelModel loaded&quot;)

for _, child in pairs(LevelModel:GetChildren()) do
&#9;AddLevel(child)
end
LevelModel.ChildAdded:connect(function(child) AddLevel(child) end)


-- this is REALLY awful that I have to do this, but if I do this from an event, the parent setting won&apos;t replicate
while true do
&#9;if not DraggingModel.Parent then DraggingModel.Parent = workspace end
&#9;wait(.125)
end
</ProtectedString>
			</Properties>
			<Item class="Model" referent="RBX8">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">LevelPointers</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX9">
				<Properties>
					<string name="Name">CurrentLevel</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX10">
				<Properties>
					<string name="Name">RequestedLevel</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX11">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GameClock</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local TimeObject = WaitForChild(script, &apos;Time&apos;)
local Start = WaitForChild(script, &apos;Start&apos;)
local Stop = WaitForChild(script, &apos;Stop&apos;)
local GetSeconds = WaitForChild(script, &apos;GetSeconds&apos;)

local LastTime = 0
local Running = false
local CountingDown = false

--------------------------
--| Bindable Functions |--
--------------------------

-- Start: Starts the clock
Start.OnInvoke = function(countDown)
&#9;if countDown ~= nil then
&#9;&#9;CountingDown = countDown
&#9;end
&#9;LastTime = tick()
&#9;Running = true
end

-- Stop: Stops the clock
Stop.OnInvoke = function()
&#9;Running = false
end

GetSeconds.OnInvoke = function()
&#9;return TimeObject.Value
end

------------------
--| Clock Loop |--
------------------

while true do
&#9;if Running and TimeObject.Value &gt;= 0 then -- Change TimeObject&apos;s Value by how much time has passed
&#9;&#9;local now = tick()
&#9;&#9;local deltaTime = now - LastTime
&#9;&#9;if CountingDown then
&#9;&#9;&#9;TimeObject.Value = TimeObject.Value - deltaTime
&#9;&#9;else
&#9;&#9;&#9;TimeObject.Value = TimeObject.Value + deltaTime
&#9;&#9;end
&#9;&#9;LastTime = now
&#9;end
&#9;wait(0.05)
end
</ProtectedString>
			</Properties>
			<Item class="NumberValue" referent="RBX12">
				<Properties>
					<string name="Name">Time</string>
					<double name="Value">0</double>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX13">
				<Properties>
					<string name="Name">Start</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX14">
				<Properties>
					<string name="Name">Stop</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX15">
				<Properties>
					<string name="Name">GetSeconds</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX16">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RemoveWaitForCharacter</string>
				<ProtectedString name="Source">function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

game.Players.PlayerAdded:connect(function(newPlayer)
&#9;newPlayer:LoadCharacter()
&#9;while not newPlayer.Character do wait() end
&#9;while not newPlayer.Character:FindFirstChild(&quot;Torso&quot;) do wait() end
&#9;newPlayer.Character.Torso.Anchored = true
&#9;local leaderstats = Instance.new(&apos;Model&apos;)
&#9;leaderstats.Name = &apos;leaderstats&apos;
&#9;local crashValue = Instance.new(&apos;ObjectValue&apos;)
&#9;crashValue.Parent = leaderstats
&#9;leaderstats.Parent = newPlayer
&#9;WaitForChild(script, &apos;SetCameraScript&apos;):Clone().Parent = newPlayer.Backpack
&#9;wait(3)
&#9;newPlayer.Character = nil
&#9;WaitForChild(script, &apos;HelpLevelSelectGui&apos;):Clone().Parent = newPlayer.PlayerGui
end)
</ProtectedString>
			</Properties>
			<Item class="ScreenGui" referent="RBX17">
				<Properties>
					<string name="Name">HelpLevelSelectGui</string>
				</Properties>
				<Item class="Frame" referent="RBX18">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-250</XO>
							<YS>0</YS>
							<YO>210</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>500</XO>
							<YS>0</YS>
							<YO>300</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX19">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=13890047</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-64</XO>
								<YS>0</YS>
								<YO>-130</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX20">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">TextLabel</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-175</XO>
								<YS>0.5</YS>
								<YO>-15</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>350</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Tap on a name above to select a level.</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX21">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">1</token>
								<token name="FontSize">7</token>
								<string name="Name">TextLabel</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Reselect a level to reset it.</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX22">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">7</token>
									<string name="Name">TextLabel</string>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>40</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">You cannot choose grayed out levels.</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX23">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SetCameraScript</string>
					<ProtectedString name="Source">while wait() do
&#9;Workspace.Camera.CameraType = &apos;Scriptable&apos;
&#9;Workspace.Camera.CoordinateFrame = CFrame.new(Vector3.new(0, 500, 0), Vector3.new(0, 5000, 0))
end

</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX24">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>1437.5</X>
					<Y>1563.90002</Y>
					<Z>-614.5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>15</X>
					<Y>7.19999981</Y>
					<Z>17</Z>
				</Vector3>
			</Properties>
			<Item class="BillboardGui" referent="RBX25">
				<Properties>
					<bool name="Active">true</bool>
					<Ref name="Adornee">RBX24</Ref>
					<bool name="AlwaysOnTop">true</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">BillboardGui</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>5</XO>
						<YS>0</YS>
						<YO>5</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>8</X>
						<Y>3.5999999</Y>
						<Z>8</Z>
					</Vector3>
				</Properties>
				<Item class="ImageButton" referent="RBX26">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4278190080</Color3>
						<float name="BackgroundTransparency">0.300000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=59103214</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">Rotate</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-32</XO>
							<YS>0</YS>
							<YO>-32</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX27">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0.300000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX28">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Model</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Part" referent="RBX29">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>1437.5</X>
						<Y>1571.09998</Y>
						<Z>-542.5</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>15</X>
						<Y>7.19999981</Y>
						<Z>17</Z>
					</Vector3>
				</Properties>
				<Item class="BillboardGui" referent="RBX30">
					<Properties>
						<bool name="Active">true</bool>
						<Ref name="Adornee">RBX28</Ref>
						<bool name="AlwaysOnTop">true</bool>
						<bool name="Enabled">true</bool>
						<Vector3 name="ExtentsOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<string name="Name">BillboardGui</string>
						<Ref name="PlayerToHideFrom">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>5</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<Vector2 name="SizeOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector3 name="StudsOffset">
							<X>7.5</X>
							<Y>7.79998779</Y>
							<Z>8.5</Z>
						</Vector3>
					</Properties>
					<Item class="ImageButton" referent="RBX31">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">0.300000012</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=59103214</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Rotate</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-32</XO>
								<YS>0</YS>
								<YO>-32</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX32">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0.300000012</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Frame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Part" referent="RBX33">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>1433</X>
						<Y>1578.90002</Y>
						<Z>-546</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Part</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>8.39999962</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX34">
		<Properties>
			<string name="Name">StarterPack</string>
		</Properties>
		<Item class="LocalScript" referent="RBX35">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DisableClickToWalk</string>
				<ProtectedString name="Source">-- quick-and-dirty script to disable the green button of ickiness :D
local player = script.Parent.Parent

local character = nil
while not character do wait() character = player.Character end

local humanoid = nil
while not humanoid do wait() humanoid = character:FindFirstChild(&quot;Humanoid&quot;) end

humanoid:SetClickToWalkEnabled(false)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Tool" referent="RBX36">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Minimize</string>
				<Content name="TextureId"><null></null></Content>
				<string name="ToolTip"></string>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX37">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MinimizeBP</string>
				<ProtectedString name="Source">function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local Backpack = script.Parent

local tool = WaitForChild(Backpack, &apos;Minimize&apos;)
wait(1.5)
tool:Destroy()
wait()
while Backpack:FindFirstChild(&apos;Minimize&apos;) do
&#9;Backpack:FindFirstChild(&apos;Minimize&apos;):Destroy()
end
</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX38">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DragScript2</string>
				<ProtectedString name="Source">local INTERACTION_RADIUS = 30
local WALKING_SPEED = 16

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

function WaitForDescendant(ancestor, child)
&#9;while not ancestor:FindFirstChild(child, true) do ancestor.DescendantAdded:wait() end
&#9;return ancestor:FindFirstChild(child, true)
end


local player = script.Parent.Parent

local playerMouse = nil
while not playerMouse do wait() playerMouse = player:GetMouse() end

local draggingObjects = nil
local draggableObjects = {}
local oldDraggingObjectParents = {}

local dragGridIndicator = WaitForChild(script, &quot;DragMesh&quot;)
local dragGridMesh = WaitForChild(dragGridIndicator, &quot;BlockMesh&quot;)

local arrowBillboard = WaitForChild(script, &quot;ArrowBillboard&quot;)
arrowBillboard.Adornee = nil

local moveGui = WaitForChild(script, &quot;MoveGui&quot;)
local moveGuiFrame = WaitForChild(moveGui, &quot;Frame&quot;)

local CurrentCameraCFrame = WaitForChild(moveGui, &quot;CurrentCameraCFrame&quot;)
local DragToLocation = WaitForChild(moveGui, &quot;DragToLocation&quot;)

local interactionHint = Instance.new(&quot;Hint&quot;)
local dragText = &quot;Click once on a nearby wooden structure to drag it!&quot;
local stopDragText = &quot;You are dragging something.  Click on it to stop dragging!&quot;
interactionHint.Text = dragText

local draggingModel = WaitForDescendant(workspace, &quot;DraggingModel&quot;)

local character = nil
while not character do wait() character = player.Character end

local humanoid = nil
while not humanoid do wait() humanoid = character:FindFirstChild(&quot;Humanoid&quot;) end

local torso = nil
while not torso do wait() torso = character:FindFirstChild(&quot;Torso&quot;) end

local weldTable = {} -- table to store all of the weld connections in the entire level; sadly, this is the most efficient way to do it

local camera = workspace.CurrentCamera
local engineDragger = Instance.new(&quot;Dragger&quot;)

function showDraggingGui()
&#9;interactionHint.Text = stopDragText
&#9;arrowBillboard.Adornee = draggingModel
&#9;arrowBillboard.Parent = player.PlayerGui
&#9;moveGui.Parent = player.PlayerGui
&#9;moveGuiFrame.Visible = true
end

function hideDraggingGui()
&#9;interactionHint.Text = dragText
&#9;arrowBillboard.Adornee = nil
&#9;moveGuiFrame.Visible = false
end

function tableEquals(tableA, tableB)
&#9;for k,v in pairs(tableA) do
&#9;&#9;if tableB[k] ~= v then return false end
&#9;end
&#9;for k,v in pairs(tableB) do
&#9;&#9;if tableA[k] ~= v then return false end
&#9;end
&#9;return true
end

function getConnectedObjects(part, connectedParts)
&#9;if connectedParts[part] then return end -- no repeats

&#9;connectedParts[part] = true
&#9;local connections = weldTable[part]
&#9;if connections then
&#9;&#9;for connectedPart, _ in pairs(connections) do
&#9;&#9;&#9;getConnectedObjects(connectedPart, connectedParts)
&#9;&#9;end
&#9;end
end

function addDragGridIndicator()
&#9;dragGridIndicator.CFrame = CFrame.new(draggingModel:GetModelCFrame().p)
&#9;local firstExtent = draggingModel:GetModelCFrame():pointToWorldSpace(draggingModel:GetModelSize()/2)
&#9;local secondExtent = draggingModel:GetModelCFrame():pointToWorldSpace(-draggingModel:GetModelSize()/2)
&#9;if firstExtent.Y &lt; secondExtent.Y then 
&#9;&#9;dragGridIndicator.CFrame = dragGridIndicator.CFrame + Vector3.new(0, firstExtent.Y - dragGridIndicator.CFrame.p.Y + .2, 0)
&#9;else
&#9;&#9;dragGridIndicator.CFrame = dragGridIndicator.CFrame + Vector3.new(0, secondExtent.Y - dragGridIndicator.CFrame.p.Y + .2, 0)
&#9;end

&#9;local xSize = math.abs(firstExtent.X - secondExtent.X) + 20
&#9;local zSize = math.abs(firstExtent.Z - secondExtent.Z) + 20

&#9;-- resize the block mesh to fit the xz size of the model
&#9;dragGridMesh.Scale = Vector3.new(xSize, .1, zSize)
&#9;dragGridMesh.Parent = dragGridIndicator

&#9;-- hook it up to the model with a weld
&#9;local dragGridWeld = Instance.new(&quot;ManualWeld&quot;)
&#9;dragGridWeld.Part0 = draggingModel:GetChildren()[1] -- at least one child is assumed
&#9;dragGridWeld.Part1 = dragGridIndicator
&#9;dragGridWeld.C0 = CFrame.new()
&#9;dragGridWeld.C1 = dragGridIndicator.CFrame:inverse() * draggingModel:GetChildren()[1].CFrame
&#9;dragGridWeld.Name = &quot;DragWeld&quot;
&#9;dragGridWeld.Parent = dragGridIndicator

--&#9;dragGridIndicator.Parent = draggingModel
end

function removeDragGridIndicator()
&#9;dragGridIndicator.Parent = nil

&#9;local dragGridWeld = dragGridIndicator:FindFirstChild(&quot;DragWeld&quot;)
&#9;if dragGridWeld then dragGridWeld:Remove() end

end

function startDragging(selectedObjects)
&#9;draggingObjects = selectedObjects
&#9;oldDraggingObjectParents = {}&#9;&#9;

&#9;-- move to the dragger model
&#9;for draggingObject, _ in pairs(draggingObjects) do
&#9;&#9;oldDraggingObjectParents[draggingObject] = draggingObject.Parent
&#9;&#9;draggingObject.Parent = draggingModel
&#9;end
&#9;
&#9;-- also add the grid indicator
&#9;addDragGridIndicator()

&#9;--torso.Anchored = true
&#9;--humanoid.WalkSpeed = 0

&#9;showDraggingGui()
end

function stopDragging()
&#9;for _, draggingObject in pairs(draggingModel:GetChildren()) do
&#9;&#9;draggingObject.Parent = oldDraggingObjectParents[draggingObject]
&#9;end
&#9;--torso.Anchored = false
&#9;hideDraggingGui()
&#9;removeDragGridIndicator()

&#9;--humanoid.WalkSpeed = WALKING_SPEED
&#9;draggingObjects = nil
end

function toggleDrag(part)
&#9;local selectedObjects = {}
&#9;getConnectedObjects(part, selectedObjects)

&#9;if not draggingObjects then
&#9;&#9;startDragging(selectedObjects)
&#9;elseif tableEquals(selectedObjects, draggingObjects) then
&#9;&#9;--stopDragging()
&#9;else
&#9;&#9;-- switch from one model to the next
&#9;&#9;stopDragging()
&#9;&#9;startDragging(selectedObjects)
&#9;end
end

function addClickDetector(part)
&#9;local newClickDetector = Instance.new(&quot;ClickDetector&quot;)
&#9;newClickDetector.MaxActivationDistance = INTERACTION_RADIUS
&#9;newClickDetector.MouseClick:connect(function() toggleDrag(part) end)
&#9;newClickDetector.Parent = part
end

function stabilizeObject(part)
&#9;if not part:FindFirstChild(&quot;TorqueStabilizer&quot;) then
&#9;&#9;local rStabilizer = Instance.new(&quot;BodyGyro&quot;)
&#9;&#9;rStabilizer.P = 600000
&#9;&#9;rStabilizer.maxTorque = rStabilizer.P * Vector3.new(1, 1, 1)
&#9;&#9;rStabilizer.cframe = part.CFrame
&#9;&#9;rStabilizer.Name = &quot;TorqueStabilizer&quot;
&#9;&#9;rStabilizer.Parent = part
&#9;end

--[[
&#9;local pStabilizer = Instance.new(&quot;BodyPosition&quot;)
&#9;pStabilizer.P = 600000
&#9;pStabilizer.maxForce = pStabilizer.P * Vector3.new(1, 0, 1)
&#9;pStabilizer.position = part.CFrame.p
&#9;pStabilizer.Name = &quot;PositionStabilizer&quot;
&#9;pStabilizer.Parent = part]]

&#9;part.Anchored = false
end

function checkForDraggable(object)
&#9;if object:IsA(&quot;BasePart&quot;) and (object.BrickColor.Name == &quot;Deep orange&quot; or object.BrickColor.Name == &quot;Bright blue&quot;) and not draggableObjects[object] and not object.Parent:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;draggableObjects[object] = true
--&#9;&#9;addClickDetector(object)
&#9;&#9;stabilizeObject(object)
&#9;end
end

function populateDraggableTable(object)
&#9;checkForDraggable(object)

&#9;local children = object:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;populateDraggableTable(children[i])
&#9;end
end

function addToWeldTable(part0, part1)
&#9;if not weldTable[part0] then
&#9;&#9;weldTable[part0] = {}
&#9;end

&#9;if (weldTable[part0][part1]) then weldTable[part0][part1] = weldTable[part0][part1] + 1
&#9;else weldTable[part0][part1] = 1 end
end

function removeFromWeldTable(part0, part1)
&#9;if not weldTable[part0] then return end
&#9;if (weldTable[part0][part1]) then 
&#9;&#9;weldTable[part0][part1] = weldTable[part0][part1] - 1 
&#9;&#9;if (weldTable[part0][part1]) == 0 then
&#9;&#9;&#9;weldTable[part0][part1] = nil
&#9;&#9;end
&#9;end
end

function checkForWeldAdded(object)
&#9;if (object:IsA(&quot;Weld&quot;) or object:IsA(&quot;ManualWeld&quot;)) and object.Name ~= &quot;DragWeld&quot; then
&#9;&#9;while not (object.Part0 and object.Part1) do&#9;wait() end

&#9;&#9;addToWeldTable(object.Part0, object.Part1)
&#9;&#9;addToWeldTable(object.Part1, object.Part0)
&#9;end
end

function checkForWeldRemoved(object)
&#9;if object:IsA(&quot;Weld&quot;) or object:IsA(&quot;ManualWeld&quot;) then
&#9;&#9;while not (object.Part0 and object.Part1) do&#9;wait() end
&#9;&#9;removeFromWeldTable(object.Part0, object.Part1)
&#9;&#9;removeFromWeldTable(object.Part1, object.Part0)
&#9;end
end

function populateWeldTable(object)
&#9;checkForWeldAdded(object)

&#9;local children = object:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;populateWeldTable(children[i])
&#9;end
end

function checkForStarterLevel(descendant)
&#9;if descendant.Name == &quot;StarterLevel&quot; then
&#9;&#9;-- we just cleared the old level and teleported back home, so all dragging/rotation operations are now null and void
&#9;&#9;stopDragging()
&#9;end
end

populateWeldTable(workspace)
populateDraggableTable(workspace)

workspace.DescendantRemoving:connect(checkForWeldRemoved)
workspace.DescendantAdded:connect(function(descendant) checkForWeldAdded(descendant) checkForDraggable(descendant) checkForStarterLevel(descendant) end)

-- now that everything&apos;s hooked up, let&apos;s show the interaction hint (if we do this earlier it fails because we do weird things on PlayerLoad)
--interactionHint.Parent = WaitForChild(player, &quot;PlayerGui&quot;)

local mouseDragPoller = nil
local keepAlives = {}
local mouseDownTime = 0
local engineDragging = false

local dragCenterOffset = nil
function mouseDragPoll(keepAlives, thisCoroutine)
&#9;camera.CameraType = &quot;Scriptable&quot;
&#9;dragCenterOffset = nil
&#9;while keepAlives[thisCoroutine] do
&#9;&#9;-- use mouse X,Y updates for dragging

&#9;&#9;if playerMouse.Target then  -- don&apos;t pick the sky!
&#9;&#9;&#9;if not dragCenterOffset then dragCenterOffset = (playerMouse.Hit.p - draggingModel:GetModelCFrame().p)*Vector3.new(1, 0, 1)
&#9;&#9;&#9;else DragToLocation.Value = playerMouse.Hit.p*Vector3.new(1, 0, 1) - dragCenterOffset end
&#9;&#9;&#9;--elseif engineDragging then engineDragger:MouseMove(playerMouse.UnitRay) end  -- SWITCH WITH ABOVE TO TOGGLE ENGINE DRAGGING
&#9;&#9;end
&#9;&#9;wait(.01)
&#9;end

&#9;-- allow camera to be moved again
&#9;camera.CameraType = &quot;Custom&quot;
&#9;dragCenterOffset = nil
end

function onMouseDown()
&#9;playerMouse.TargetFilter = nil
&#9;local hitPart = playerMouse.Target
&#9;local hitPosition = playerMouse.Hit.p
&#9;if hitPart and draggableObjects[hitPart] then
&#9;&#9;-- hook it up to the draggah
&#9;&#9;toggleDrag(hitPart)
&#9;&#9;playerMouse.TargetFilter = draggingModel

&#9;&#9;if not engineDragging then
&#9;&#9;-- and start polling for mouse moves
&#9;&#9;-- COMMENT/UNCOMMENT BELOW TWO LINES TO TOGGLE ENGINE DRAGGING
&#9;&#9;&#9;engineDragging = true
&#9;&#9;&#9;--engineDragger:MouseDown(hitPart, hitPosition - hitPart.Position, workspace.DraggingModel:GetChildren())&#9;

&#9;&#9;&#9;mouseDownTime = tick()
&#9;&#9;&#9;mouseDragPoller = coroutine.create(mouseDragPoll)
&#9;&#9;&#9;keepAlives[mouseDragPoller] = true
&#9;&#9;&#9;coroutine.resume(mouseDragPoller, keepAlives, mouseDragPoller)
&#9;&#9;end
&#9;else
&#9;&#9;stopDragging()
&#9;end
end

function onMouseUp()
&#9;-- stop the dragging coroutine, if it&apos;s going
&#9;if mouseDragPoller then keepAlives[mouseDragPoller] = nil mouseDragPoller = nil end
&#9;if engineDragging then
&#9;&#9;--engineDragger:MouseUp()
&#9;&#9;engineDragging = false
&#9;end
end

playerMouse.Button1Up:connect(onMouseUp)
playerMouse.Button1Down:connect(onMouseDown)

-- because we&apos;re doing all the CFrame-setting server-side (out of dPhysics necessity) yet we need the local camera coordinate frame, we need to poll regularly and pass it along
while true do
&#9;CurrentCameraCFrame.Value = workspace.CurrentCamera.CoordinateFrame
&#9;wait(.2)
end
</ProtectedString>
			</Properties>
			<Item class="BillboardGui" referent="RBX39">
				<Properties>
					<bool name="Active">false</bool>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">false</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">ArrowBillboard</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>10</XS>
						<XO>0</XO>
						<YS>10</YS>
						<YO>0</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>10</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="ImageLabel" referent="RBX40">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=40172628</url></Content>
						<string name="Name">ImageLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX41">
				<Properties>
					<string name="Name">MoveGui</string>
				</Properties>
				<Item class="Frame" referent="RBX42">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>-20</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextButton" referent="RBX43">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">6</token>
							<bool name="Modal">false</bool>
							<string name="Name">Rotate</string>
							<UDim2 name="Position">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.824999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">Rotate</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX44">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Up</string>
							<UDim2 name="Position">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.75</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">^</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX45">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Right</string>
							<UDim2 name="Position">
								<XS>0.524999976</XS>
								<XO>0</XO>
								<YS>0.824999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">&gt;</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX46">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Left</string>
							<UDim2 name="Position">
								<XS>0.375</XS>
								<XO>0</XO>
								<YS>0.824999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">&lt;</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX47">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Down</string>
							<UDim2 name="Position">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">v</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Script" referent="RBX48">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ServerDragScript</string>
						<ProtectedString name="Source">local DRAG_SPEED = 4
local DRAG_PRECISION = .125
local STEP_PRECISION = .25

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local moveGui = script.Parent
local moveGuiFrame = WaitForChild(moveGui, &quot;Frame&quot;)
local DragToLocation = WaitForChild(moveGui, &quot;DragToLocation&quot;)

local draggingModel = WaitForChild(workspace, &quot;DraggingModel&quot;)
local CurrentCameraCFrame = WaitForChild(moveGui, &quot;CurrentCameraCFrame&quot;)

function vectorMin(vecA, vecB)
&#9;return Vector3.new(math.min(vecA.X, vecB.X), math.min(vecA.Y, vecB.Y), math.min(vecA.Z, vecB.Z))
end

function vectorMax(vecA, vecB)
&#9;return Vector3.new(math.max(vecA.X, vecB.X), math.max(vecA.Y, vecB.Y), math.max(vecA.Z, vecB.Z))
end

function calculateExtents(partCFrame, partSize)
&#9;local boundingVectorA = partCFrame:pointToWorldSpace(partSize/2)
&#9;local boundingVectorB = partCFrame:pointToWorldSpace(-partSize/2)
&#9;return vectorMin(boundingVectorA, boundingVectorB), vectorMax(boundingVectorA, boundingVectorB)
end

function recursiveCentroidHelper(model, centroidSoFar, numPartsSoFar)
&#9;local modelChildren = model:GetChildren()
&#9;for i = 1, #modelChildren do
&#9;&#9;if modelChildren[i]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;centroidSoFar = centroidSoFar + modelChildren[i].CFrame.p
&#9;&#9;&#9;numPartsSoFar = numPartsSoFar + 1
&#9;&#9;end
&#9;&#9;centroidSoFar, numPartsSoFar = recursiveCentroidHelper(modelChildren[i], centroidSoFar, numPartsSoFar)
&#9;end
&#9;return centroidSoFar, numPartsSoFar
end

function calculateCentroid(model)
&#9;-- below line should work, but doesn&apos;t because we don&apos;t always invalidate the model CFrame when we should
&#9;-- model:GetModelCFrame().p

&#9;-- so instead, just step thru
&#9;local centroid = Vector3.new(0, 0, 0)
&#9;local numParts = 0

&#9;centroid, numParts = recursiveCentroidHelper(model, centroid, numParts)

&#9;if numParts &gt; 0 then centroid = centroid / numParts end
&#9;return centroid
end

local DRAG_DIRECTIONS = {UP = Vector3.new(0, 0, -1), DOWN = Vector3.new(0, 0, 1), LEFT = Vector3.new(-1, 0, 0), RIGHT = Vector3.new(1, 0, 0)}
local FUDGE_VECTOR = Vector3.new(.2, .2, .2)

function tryAbsoluteDrag(absoluteDir, dragDistance)
&#9;local objectsToMove = draggingModel:GetChildren()  -- effectively &quot;lock&quot; the objects we want to drag&#9;
&#9;local movementVector = absoluteDir * dragDistance

&#9;-- check here to see if dragging is ok&#9;
&#9;for i = 1, #objectsToMove do
&#9;&#9;local minExtents, maxExtents = calculateExtents(objectsToMove[i].CFrame + movementVector, objectsToMove[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then return false end -- don&apos;t continue with drag if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end

&#9;-- if ok, then just translate the CFrames
&#9;for i = 1, #objectsToMove do
&#9;&#9;objectsToMove[i].CFrame = objectsToMove[i].CFrame + movementVector
&#9;end

&#9;return true
end

function iterativeAbsoluteDrag(absoluteDir, stepSize)
&#9;local dragDistance = stepSize
&#9;while dragDistance &gt;= DRAG_PRECISION and not tryAbsoluteDrag(absoluteDir, dragDistance) do dragDistance = dragDistance / 2 end
end

function tryRelativeDrag(relativeDir)
&#9;local camFrame = CurrentCameraCFrame.Value

&#9;local indicatedDir = camFrame:vectorToWorldSpace(relativeDir)

&#9;-- match this with closest direction in absolute xz-plane
&#9;local bestMatchAmount = -10  -- less than -1,1 range of dot-products
&#9;local bestAbsoluteDir = nil
&#9;for _, absoluteDir in pairs(DRAG_DIRECTIONS) do
&#9;&#9;local matchAmount = absoluteDir:Dot(indicatedDir)
&#9;&#9;if matchAmount &gt; bestMatchAmount then
&#9;&#9;&#9;bestMatchAmount = matchAmount
&#9;&#9;&#9;bestAbsoluteDir = absoluteDir
&#9;&#9;end
&#9;end

&#9;iterativeAbsoluteDrag(bestAbsoluteDir, DRAG_SPEED)
end

-- returns cframe rotated 90-degrees about absolute y-axis at point
function rotateY(cframe, point)
&#9;return (CFrame.Angles(0, math.pi/2, 0) * (cframe - point)) + point
end


function tryRotate()
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local objectsToRotate = draggingModel:GetChildren() -- effectively &quot;lock&quot; the objects we want to rotate

&#9;-- check here to see if the rotation is ok
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local newCFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;&#9;local minExtents, maxExtents = calculateExtents(newCFrame, objectsToRotate[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then return false end -- don&apos;t continue with rotation if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end
&#9;
&#9;-- temporarily remove stabilizers and then re-add them with updated CFrames as well
&#9;local stabilizerParents = {}
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local stabilizer = objectsToRotate[i]:FindFirstChild(&quot;TorqueStabilizer&quot;)
&#9;&#9;if stabilizer then
&#9;&#9;&#9;stabilizerParents[stabilizer] = stabilizer.Parent
&#9;&#9;&#9;stabilizer.Parent = nil
&#9;&#9;end
&#9;end

&#9;-- if ok, then just transform the CFrames
&#9;for i = 1, #objectsToRotate do
&#9;&#9;objectsToRotate[i].CFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;end

&#9;-- and re-add the stabilizers with updated CFrames
&#9;for stabilizer, stabilizerParent in pairs(stabilizerParents) do
&#9;&#9;stabilizer.cframe = rotateY(stabilizer.cframe, centroid)
&#9;&#9;stabilizer.Parent = stabilizerParent
&#9;end

&#9;return true
end

function onRotate()
&#9;tryRotate()
end

function onDown()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;DOWN&quot;])
end

function onUp()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;UP&quot;])
end

function onLeft()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;LEFT&quot;])
end

function onRight()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;RIGHT&quot;])
end

function stepTowardsPoint(targetPoint)
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local dragStepSize = DRAG_SPEED
&#9;if centroid.Z &gt; targetPoint.Z - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, -1), dragStepSize)
&#9;elseif centroid.Z &lt; targetPoint.Z + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, 1), dragStepSize)
&#9;end
&#9;dragStepSize = DRAG_SPEED
&#9;if centroid.X &gt; targetPoint.X - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(-1, 0, 0), dragStepSize)
&#9;elseif centroid.X &lt; targetPoint.X + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(1, 0, 0), dragStepSize)
&#9;end
end

function onDrag(targetPoint)
&#9;if targetPoint.Y ~= 0 then return end
&#9;local moveTries = (targetPoint - draggingModel:GetModelCFrame().p).magnitude / DRAG_SPEED
&#9;for i = 1, moveTries do
&#9;&#9;stepTowardsPoint(targetPoint)
&#9;end
end

WaitForChild(moveGuiFrame, &quot;Rotate&quot;).MouseButton1Click:connect(onRotate)
WaitForChild(moveGuiFrame, &quot;Left&quot;).MouseButton1Click:connect(onLeft)
WaitForChild(moveGuiFrame, &quot;Right&quot;).MouseButton1Click:connect(onRight)
WaitForChild(moveGuiFrame, &quot;Up&quot;).MouseButton1Click:connect(onUp)
WaitForChild(moveGuiFrame, &quot;Down&quot;).MouseButton1Click:connect(onDown)

DragToLocation.Changed:connect(onDrag)
</ProtectedString>
					</Properties>
				</Item>
				<Item class="CFrameValue" referent="RBX49">
					<Properties>
						<string name="Name">CurrentCameraCFrame</string>
						<CoordinateFrame name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
					</Properties>
				</Item>
				<Item class="Vector3Value" referent="RBX50">
					<Properties>
						<string name="Name">DragToLocation</string>
						<Vector3 name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX51">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>3.29999995</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">DragMesh</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.200000003</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Texture" referent="RBX52">
					<Properties>
						<token name="Face">4</token>
						<string name="Name">TextureB</string>
						<float name="Shiny">20</float>
						<float name="Specular">0</float>
						<float name="StudsPerTileU">2</float>
						<float name="StudsPerTileV">8</float>
						<Content name="Texture"><url>http://www.roblox.com/asset/?id=90927957</url></Content>
						<float name="Transparency">0.300000012</float>
					</Properties>
				</Item>
				<Item class="Texture" referent="RBX53">
					<Properties>
						<token name="Face">1</token>
						<string name="Name">TextureA</string>
						<float name="Shiny">20</float>
						<float name="Specular">0</float>
						<float name="StudsPerTileU">8</float>
						<float name="StudsPerTileV">8</float>
						<Content name="Texture"><url>http://www.roblox.com/asset/?id=90927957</url></Content>
						<float name="Transparency">0.300000012</float>
					</Properties>
				</Item>
				<Item class="SpecialMesh" referent="RBX54">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><null></null></Content>
						<token name="MeshType">6</token>
						<string name="Name">BlockMesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>20</X>
							<Y>0.100000001</Y>
							<Z>20</Z>
						</Vector3>
						<Content name="TextureId"><null></null></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX55">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DragScript3</string>
				<ProtectedString name="Source">local INTERACTION_RADIUS = 30
local WALKING_SPEED = 16

local SELECTION_BOX_GLOW_SPEED = 3.5


function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

function WaitForDescendant(ancestor, child)
&#9;while not ancestor:FindFirstChild(child, true) do ancestor.DescendantAdded:wait() end
&#9;return ancestor:FindFirstChild(child, true)
end

local DEBUG = false

local AUTO_ROTATE_ENABLED = true
local MINIMUM_VIEWING_ANGLE = math.rad(20)
local ROTATE_RADS_PER_SEC = math.rad(30)
local CurrentCameraRepeater = nil


local DebugRay = Instance.new(&apos;Part&apos;)
DebugRay.TopSurface = &quot;Smooth&quot;
DebugRay.BottomSurface = &quot;Smooth&quot;
DebugRay.BrickColor = BrickColor.new(&quot;Really red&quot;)
DebugRay.Size = Vector3.new(1,1,10)
DebugRay.FormFactor = &quot;Custom&quot;
DebugRay.CanCollide = false
DebugRay.Transparency = 0.8
DebugRay.Anchored = true

local StartDragSound = WaitForChild(script, &apos;StartDrag&apos;)
local StopDragSound = WaitForChild(script, &apos;StopDrag&apos;)

local DebugPlane = DebugRay:Clone()
DebugPlane.Size = Vector3.new(32, 0.2, 32)
DebugPlane.Name = &apos;DebugPlane&apos;



local player = script.Parent.Parent

local playerMouse = nil
while not playerMouse do wait() playerMouse = player:GetMouse() end

local draggingObjects = nil
local draggableObjects = {}
local oldDraggingObjectParents = {}

local dragGridIndicator = WaitForChild(script, &quot;DragMesh&quot;)
local dragGridMesh = WaitForChild(dragGridIndicator, &quot;BlockMesh&quot;)

local arrowBillboard = WaitForChild(script, &quot;ArrowBillboard&quot;)
arrowBillboard.Adornee = nil

local moveGui = WaitForChild(script, &quot;MoveGui&quot;)
local moveGuiFrame = WaitForChild(moveGui, &quot;Frame&quot;)

local dragSelectionBox = WaitForChild(moveGui, &quot;DragSelectionBox&quot;)
local selectionBoxTimeParam = -math.pi/2

local CurrentCameraCFrame = WaitForChild(moveGui, &quot;CurrentCameraCFrame&quot;)
local DragToLocation = WaitForChild(moveGui, &quot;DragToLocation&quot;)

local interactionHint = Instance.new(&quot;Hint&quot;)
local dragText = &quot;Click once on a nearby wooden structure to drag it!&quot;
local stopDragText = &quot;You are dragging something.  Click on it to stop dragging!&quot;
interactionHint.Text = dragText

local draggingModel = WaitForDescendant(workspace, &quot;DraggingModel&quot;)

local character = nil
while not character do wait() character = player.Character end

local humanoid = nil
while not humanoid do wait() humanoid = character:FindFirstChild(&quot;Humanoid&quot;) end

local torso = nil
while not torso do wait() torso = character:FindFirstChild(&quot;Torso&quot;) end

local weldTable = {} -- table to store all of the weld connections in the entire level; sadly, this is the most efficient way to do it

local camera = workspace.CurrentCamera
local engineDragger = Instance.new(&quot;Dragger&quot;)

local DEBUG_PRINT = true
function DebugPrint(...)
&#9;if DEBUG_PRINT then
&#9;&#9;print(...)
&#9;end
end

----- This is some of Mark&apos;s nifty convenience codes ---
local function class(name)
&#9;local def = {}
&#9;_G[name] = def
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;_G[&apos;Make&apos;..name] = nctor
&#9;&#9;getfenv(0)[&apos;Make&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

-- repeater, usefull for loops which need to be cancelable --
class&apos;Repeater&apos;(function(this, f)
&#9;local mFlag = true
&#9;Spawn(function()
&#9;&#9;while mFlag do
&#9;&#9;&#9;if f() then break end
&#9;&#9;&#9;wait()
&#9;&#9;end&#9;
&#9;end)
&#9;function this.halt()
&#9;&#9;mFlag = false
&#9;end
end)
-------------------

function showDraggingGui()
&#9;interactionHint.Text = stopDragText
&#9;arrowBillboard.Adornee = draggingModel
&#9;--arrowBillboard.Parent = player.PlayerGui
&#9;moveGui.Parent = player.PlayerGui
&#9;moveGuiFrame.Visible = true
end

function hideDraggingGui()
&#9;interactionHint.Text = dragText
&#9;arrowBillboard.Adornee = nil
&#9;moveGuiFrame.Visible = false
end

function tableEquals(tableA, tableB)
&#9;for k,v in pairs(tableA) do
&#9;&#9;if tableB[k] ~= v then return false end
&#9;end
&#9;for k,v in pairs(tableB) do
&#9;&#9;if tableA[k] ~= v then return false end
&#9;end
&#9;return true
end

function getConnectedObjects(part, connectedParts)
&#9;if connectedParts[part] then return end -- no repeats

&#9;connectedParts[part] = true
&#9;local connections = weldTable[part]
&#9;if connections then
&#9;&#9;for connectedPart, _ in pairs(connections) do
&#9;&#9;&#9;getConnectedObjects(connectedPart, connectedParts)
&#9;&#9;end
&#9;end
end

function addDragGridIndicator()
&#9;dragGridIndicator.CFrame = CFrame.new(draggingModel:GetModelCFrame().p)
&#9;local firstExtent = draggingModel:GetModelCFrame():pointToWorldSpace(draggingModel:GetModelSize()/2)
&#9;local secondExtent = draggingModel:GetModelCFrame():pointToWorldSpace(-draggingModel:GetModelSize()/2)
&#9;if firstExtent.Y &lt; secondExtent.Y then 
&#9;&#9;dragGridIndicator.CFrame = dragGridIndicator.CFrame + Vector3.new(0, firstExtent.Y - dragGridIndicator.CFrame.p.Y + .2, 0)
&#9;else
&#9;&#9;dragGridIndicator.CFrame = dragGridIndicator.CFrame + Vector3.new(0, secondExtent.Y - dragGridIndicator.CFrame.p.Y + .2, 0)
&#9;end

&#9;local xSize = math.abs(firstExtent.X - secondExtent.X) + 20
&#9;local zSize = math.abs(firstExtent.Z - secondExtent.Z) + 20

&#9;-- resize the block mesh to fit the xz size of the model
&#9;dragGridMesh.Scale = Vector3.new(xSize, .1, zSize)
&#9;dragGridMesh.Parent = dragGridIndicator

&#9;-- hook it up to the model with a weld
&#9;local dragGridWeld = Instance.new(&quot;ManualWeld&quot;)
&#9;dragGridWeld.Part0 = draggingModel:GetChildren()[1] -- at least one child is assumed
&#9;dragGridWeld.Part1 = dragGridIndicator
&#9;dragGridWeld.C0 = CFrame.new()
&#9;dragGridWeld.C1 = dragGridIndicator.CFrame:inverse() * draggingModel:GetChildren()[1].CFrame
&#9;dragGridWeld.Name = &quot;DragWeld&quot;
&#9;dragGridWeld.Parent = dragGridIndicator

--&#9;dragGridIndicator.Parent = draggingModel
end

function removeDragGridIndicator()
&#9;dragGridIndicator.Parent = nil

&#9;local dragGridWeld = dragGridIndicator:FindFirstChild(&quot;DragWeld&quot;)
&#9;if dragGridWeld then dragGridWeld:Remove() end

end

function addDragIndicatorBox()
&#9;selectionBoxTimeParam = -(math.pi/2) / SELECTION_BOX_GLOW_SPEED
&#9;dragSelectionBox.Adornee = draggingModel
end

function removeDragIndicatorBox()
&#9;dragSelectionBox.Adornee = nil
end

function startDragging(selectedObjects)
&#9;draggingObjects = selectedObjects
&#9;oldDraggingObjectParents = {}&#9;&#9;

&#9;-- move to the dragger model
&#9;for draggingObject, _ in pairs(draggingObjects) do
&#9;&#9;oldDraggingObjectParents[draggingObject] = draggingObject.Parent
&#9;&#9;draggingObject.Parent = draggingModel
&#9;end
&#9;
&#9;-- also add the grid indicator
&#9;addDragIndicatorBox()

&#9;--torso.Anchored = true
&#9;--humanoid.WalkSpeed = 0

&#9;showDraggingGui()
end

function stopDragging()
&#9;for _, draggingObject in pairs(draggingModel:GetChildren()) do
&#9;&#9;draggingObject.Parent = oldDraggingObjectParents[draggingObject]
&#9;end
&#9;--torso.Anchored = false
&#9;hideDraggingGui()
&#9;removeDragIndicatorBox()

&#9;--humanoid.WalkSpeed = WALKING_SPEED
&#9;draggingObjects = nil
end

function toggleDrag(part)
&#9;local selectedObjects = {}
&#9;getConnectedObjects(part, selectedObjects)

&#9;if not draggingObjects then
&#9;&#9;startDragging(selectedObjects)
&#9;elseif tableEquals(selectedObjects, draggingObjects) then
&#9;&#9;--stopDragging()
&#9;else
&#9;&#9;-- switch from one model to the next
&#9;&#9;stopDragging()
&#9;&#9;startDragging(selectedObjects)
&#9;end
end

function addClickDetector(part)
&#9;local newClickDetector = Instance.new(&quot;ClickDetector&quot;)
&#9;newClickDetector.MaxActivationDistance = INTERACTION_RADIUS
&#9;newClickDetector.MouseClick:connect(function() toggleDrag(part) end)
&#9;newClickDetector.Parent = part
end

function stabilizeObject(part)
&#9;if not part:FindFirstChild(&quot;TorqueStabilizer&quot;) then
&#9;&#9;local rStabilizer = Instance.new(&quot;BodyGyro&quot;)
&#9;&#9;rStabilizer.P = 600000
&#9;&#9;rStabilizer.maxTorque = rStabilizer.P * Vector3.new(1, 1, 1)
&#9;&#9;rStabilizer.cframe = part.CFrame
&#9;&#9;rStabilizer.Name = &quot;TorqueStabilizer&quot;
&#9;&#9;rStabilizer.Parent = part
&#9;end

--[[
&#9;local pStabilizer = Instance.new(&quot;BodyPosition&quot;)
&#9;pStabilizer.P = 600000
&#9;pStabilizer.maxForce = pStabilizer.P * Vector3.new(1, 0, 1)
&#9;pStabilizer.position = part.CFrame.p
&#9;pStabilizer.Name = &quot;PositionStabilizer&quot;
&#9;pStabilizer.Parent = part]]

&#9;part.Anchored = false
end

function checkForDraggable(object)
&#9;if object:IsA(&quot;BasePart&quot;) and (object.BrickColor.Name == &quot;Deep orange&quot; or object.BrickColor.Name == &quot;Bright blue&quot;) and not draggableObjects[object] and not object.Parent:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;draggableObjects[object] = true
--&#9;&#9;addClickDetector(object)
&#9;&#9;stabilizeObject(object)
&#9;end
end

function populateDraggableTable(object)
&#9;checkForDraggable(object)

&#9;local children = object:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;populateDraggableTable(children[i])
&#9;end
end

function addToWeldTable(part0, part1)
&#9;if not weldTable[part0] then
&#9;&#9;weldTable[part0] = {}
&#9;end

&#9;if (weldTable[part0][part1]) then weldTable[part0][part1] = weldTable[part0][part1] + 1
&#9;else weldTable[part0][part1] = 1 end
end

function removeFromWeldTable(part0, part1)
&#9;if not weldTable[part0] then return end
&#9;if (weldTable[part0][part1]) then 
&#9;&#9;weldTable[part0][part1] = weldTable[part0][part1] - 1 
&#9;&#9;if (weldTable[part0][part1]) == 0 then
&#9;&#9;&#9;weldTable[part0][part1] = nil
&#9;&#9;end
&#9;end
end

function checkForWeldAdded(object)
&#9;if (object:IsA(&quot;Weld&quot;) or object:IsA(&quot;ManualWeld&quot;)) and object.Name ~= &quot;DragWeld&quot; then
&#9;&#9;while not (object.Part0 and object.Part1) do&#9;wait() end

&#9;&#9;addToWeldTable(object.Part0, object.Part1)
&#9;&#9;addToWeldTable(object.Part1, object.Part0)
&#9;end
end

function checkForWeldRemoved(object)
&#9;if object:IsA(&quot;Weld&quot;) or object:IsA(&quot;ManualWeld&quot;) then
&#9;&#9;while not (object.Part0 and object.Part1) do&#9;wait() end
&#9;&#9;removeFromWeldTable(object.Part0, object.Part1)
&#9;&#9;removeFromWeldTable(object.Part1, object.Part0)
&#9;end
end

function populateWeldTable(object)
&#9;checkForWeldAdded(object)

&#9;local children = object:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;populateWeldTable(children[i])
&#9;end
end

function checkForStarterLevel(descendant)
&#9;if descendant.Name == &quot;StarterLevel&quot; then
&#9;&#9;-- we just cleared the old level and teleported back home, so all dragging/rotation operations are now null and void
&#9;&#9;stopDragging()
&#9;end
end



-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function RayPlaneIntersection(ray, planeNormal, planeDistanceFromOrigin)
&#9;if not ray then
&#9;&#9;print(&quot;RayPlaneIntersection: ray is nil&quot;)
&#9;&#9;return
&#9;end
&#9;if not planeNormal then
&#9;&#9;print(&quot;RayPlaneIntersection: planeNormal is nil&quot;)
&#9;&#9;return
&#9;end
&#9;if not planeDistanceFromOrigin then
&#9;&#9;print(&quot;RayPlaneIntersection: planeDistanceFromOrigin is nil&quot;)
&#9;&#9;return
&#9;end
&#9;-- if XZ-plane then planeNormal is always 0,1,0
&#9;planeNormal = planeNormal.unit
&#9;ray = ray.Unit
&#9;-- compute Pn (dot) Rd = Vd and check if Vd == 0 then we know ray is parallel to plane
&#9;local Vd = planeNormal:Dot(ray.Direction)
&#9;
&#9;-- can increase this a little bit to account for imprecision or very close angles to zero
&#9;if Vd == 0 then -- parallel, no intersection
&#9;&#9;return nil
&#9;end

&#9;local V0 = -(planeNormal:Dot(ray.Origin) + planeDistanceFromOrigin)
&#9;local t = V0 / Vd
&#9;if t &lt; 0 then --plane is behind ray origin, and thus there is no intersection
&#9;&#9;return nil
&#9;end
&#9;
&#9;local intersection = Vector3.new(ray.Origin.X + ray.Direction.X * t,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ray.Origin.Y + ray.Direction.Y * t,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ray.Origin.Z + ray.Direction.Z * t)
&#9;if DEBUG then
&#9;&#9;local length = (intersection - ray.Origin).magnitude
&#9;&#9;--DebugRay.Parent = Workspace
&#9;&#9;DebugRay.Size = Vector3.new(1,1,1)
&#9;&#9;DebugRay.CFrame = CFrame.new(intersection) + Vector3.new(0, 0.51, 0)
&#9;&#9;--DebugRay.Size = Vector3.new(1,1,length)
&#9;&#9;--DebugRay.CFrame = CFrame.new(ray.Origin + (intersection - ray.Origin) / 2, intersection)
&#9;end
&#9;return intersection
end

populateWeldTable(workspace)
populateDraggableTable(workspace)

workspace.DescendantRemoving:connect(checkForWeldRemoved)
workspace.DescendantAdded:connect(function(descendant) checkForWeldAdded(descendant) checkForDraggable(descendant) checkForStarterLevel(descendant) end)

-- now that everything&apos;s hooked up, let&apos;s show the interaction hint (if we do this earlier it fails because we do weird things on PlayerLoad)
--interactionHint.Parent = WaitForChild(player, &quot;PlayerGui&quot;)

local mouseDragPoller = nil
local keepAlives = {}
local mouseDownTime = 0
local engineDragging = false

local planeDistanceFromOrigin = 0


--[[ http://stackoverflow.com/questions/11470978/implementing-a-complex-rotation-based-camera
Notation: A is the point we want to rotate around, C is the original camera location, M is the original camera rotation matrix that maps global coordinates to the camera&apos;s local viewport.

Make a note of the local coordinates of A, which are equal to A&apos; = M-1 &#215; (A - C).
Rotate the camera like you would in normal &quot;eye rotation&quot; mode. Update the view matrix M so that it is modified to M2 and C remains unchanged.
Now we would like to find C2 such that A&apos; = M2-1 &#215; (A - C2).
This is easily done by the equation C2 = A - M2 &#215; A&apos;.
Voil&#224;, the camera has been rotated and because the local coordinates of A are unchanged, A remains at the same location and the same scale and distance.
As an added bonus, the rotation behavior is now consistent between &quot;eye rotation&quot; and &quot;point rotation&quot; mode.
]]
function rotateCamera(dragPoint, percent)
&#9;local aPrime = camera.CoordinateFrame:vectorToObjectSpace( (dragPoint - camera.CoordinateFrame.p) )
&#9;local M2 = camera.CoordinateFrame * CFrame.Angles(percent, 0, 0)
&#9;local C2 = dragPoint - M2:vectorToWorldSpace(aPrime)
&#9;local resultCFrame = (M2 - M2.p) + C2
&#9;camera.CoordinateFrame = resultCFrame
end

local CameraPercentFinished = 0

-- @params up is -1 to make camera rotate up, 1 to make it rotate down
function slowlyRotateCamera(dragPoint, up, rotationNeeded, duration)
&#9;local angleAboveThePlane = math.acos((camera.CoordinateFrame.p - dragPoint).unit:Dot(((camera.CoordinateFrame.p - dragPoint) * Vector3.new(1,0,1)).unit))
&#9;if camera.CoordinateFrame.p.Y &lt; dragPoint.Y then
&#9;&#9;angleAboveThePlane = -angleAboveThePlane
&#9;end
&#9;local rotationNeeded = rotationNeeded or math.max(MINIMUM_VIEWING_ANGLE - angleAboveThePlane, 0)
&#9;duration = duration or (rotationNeeded / ROTATE_RADS_PER_SEC)
&#9;if rotationNeeded &gt; 0 then
&#9;&#9;if CurrentCameraRepeater then
&#9;&#9;&#9;CurrentCameraRepeater.halt()
&#9;&#9;&#9;CurrentCameraRepeater = nil
&#9;&#9;end
&#9;&#9;--DebugPrint(&quot;Slowly rotate called. Rotation Needed:&quot; , rotationNeeded , &quot;duration:&quot; , duration , &quot;angleAbovePlane:&quot; , angleAboveThePlane)
&#9;&#9;CameraPercentFinished = 0
&#9;&#9;local startTime = tick()
&#9;&#9;local lastTick = startTime
&#9;&#9;--wait()
&#9;&#9;CurrentCameraRepeater = MakeRepeater(function()
&#9;&#9;&#9;--wait()
&#9;&#9;&#9;local currTick = tick()
&#9;&#9;&#9;local endTime = startTime + duration
&#9;&#9;&#9;local timeThisStep = currTick - lastTick - math.max(currTick - endTime, 0)
&#9;&#9;&#9;print(timeThisStep)
&#9;&#9;&#9;-- Incase CurrTick is passed how far we wanted to go
&#9;&#9;&#9;--if currTick &gt; endTime then
&#9;&#9;&#9;--&#9;timeThisStep = (currTick - lastTick) - (currTick - endTime)
&#9;&#9;&#9;--&#9;print(timeThisStep)
&#9;&#9;&#9;--end
&#9;&#9;&#9;rotateCamera(dragPoint, ((up * (timeThisStep)) / duration) * rotationNeeded)
&#9;&#9;&#9;CameraPercentFinished = ((lastTick + timeThisStep) - startTime) / duration
&#9;&#9;&#9;lastTick = currTick
&#9;&#9;&#9;return currTick - startTime &gt;= duration
&#9;&#9;end)
&#9;end
&#9;return rotationNeeded, duration
end

function slowlyRotateBack(originalPos)
&#9;if CurrentCameraRepeater then
&#9;&#9;CurrentCameraRepeater.halt()
&#9;&#9;CurrentCameraRepeater = nil
&#9;end
&#9;local startTime = tick()
&#9;local lerpTime = 0.5
&#9;local endTime = startTime + lerpTime
&#9;local focusPoint = DragToLocation.Value
&#9;local startCameraPoint = camera.CoordinateFrame.p
&#9;if focusPoint then
&#9;&#9;CurrentCameraRepeater = MakeRepeater(function()
&#9;&#9;&#9;local alpha = 1 - (math.max(0, endTime - tick()) / lerpTime)
&#9;&#9;&#9;camera.CoordinateFrame = CFrame.new(startCameraPoint:Lerp(originalPos, alpha), focusPoint)
&#9;&#9;&#9;return alpha == 1
&#9;&#9;end)
&#9;end
&#9;return lerpTime
end

local YOffset = nil
local dragCenterOffset = nil
function mouseDragPoll(keepAlives, thisCoroutine)
&#9;
&#9;local orignalCameraCFrame = camera.CoordinateFrame
&#9;camera.CameraType = &quot;Scriptable&quot;
&#9;humanoid.WalkSpeed = 0
&#9;dragCenterOffset = nil
&#9;ToggleRotateButton(false)
&#9;local rotatedBy
&#9;local origDragPoint
&#9;while keepAlives[thisCoroutine] do
&#9;&#9;--DebugPrint(&quot;Mouse X:&quot; , playerMouse.X , &quot; Y:&quot; , playerMouse.Y)
&#9;&#9;-- use mouse X,Y updates for dragging
&#9;&#9;if playerMouse.Target then  -- don&apos;t pick the sky!
&#9;&#9;&#9;-- we only need to calculate the YOffset when we start dragging
&#9;&#9;&#9;-- but we have to put it in here because earlier the dragging model might not be done yet?
&#9;&#9;&#9;if not YOffset then
&#9;&#9;&#9;&#9;YOffset = draggingModel:GetModelCFrame().p.Y - playerMouse.Hit.p.Y
&#9;&#9;&#9;&#9;-- Restore camera afterwards?
&#9;&#9;&#9;&#9;if AUTO_ROTATE_ENABLED then
&#9;&#9;&#9;&#9;&#9;origDragPoint = playerMouse.Hit.p
&#9;&#9;&#9;&#9;&#9;rotatedBy = slowlyRotateCamera(origDragPoint, -1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if YOffset and draggingModel and playerMouse then
&#9;&#9;&#9;local mouseRay = playerMouse.UnitRay
&#9;&#9;&#9;local modelCFrame = draggingModel:GetModelCFrame()
&#9;&#9;&#9;-- using negative position?
&#9;&#9;&#9;planeDistanceFromOrigin = -(modelCFrame.p.Y - YOffset)
&#9;&#9;&#9;-- We just picked so set up the offset from the model centroid on the XZ-plane to the spot where we picked
&#9;&#9;&#9;if not dragCenterOffset and modelCFrame and modelCFrame.p ~= nil and mouseRay ~= nil then
&#9;&#9;&#9;&#9;local intersection = RayPlaneIntersection(mouseRay, Vector3.new(0,1,0), planeDistanceFromOrigin)
&#9;&#9;&#9;&#9;if intersection then
&#9;&#9;&#9;&#9;&#9;dragCenterOffset = (intersection - modelCFrame.p) * Vector3.new(1,0,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local intersectionPoint
&#9;&#9;&#9;if mouseRay ~= nil then
&#9;&#9;&#9;&#9;intersectionPoint = RayPlaneIntersection(mouseRay, Vector3.new(0,1,0), planeDistanceFromOrigin)
&#9;&#9;&#9;end
&#9;&#9;&#9;if intersectionPoint then
&#9;&#9;&#9;&#9;if dragCenterOffset then
&#9;&#9;&#9;&#9;&#9;if DEBUG then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Intersection Point:&quot; , intersectionPoint)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;DragToLocation.Value = intersectionPoint * Vector3.new(1, 0, 1) - dragCenterOffset
&#9;&#9;&#9;&#9;&#9;if DEBUG then
&#9;&#9;&#9;&#9;&#9;&#9;--DebugPlane.Parent = Workspace
&#9;&#9;&#9;&#9;&#9;&#9;DebugPlane.CFrame = CFrame.new(intersectionPoint)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;dragCenterOffset is nil&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Intersection Point is nil&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(.01)
&#9;end

&#9;if StopDragSound then
&#9;&#9;StopDragSound:Play()
&#9;end
&#9;if rotatedBy and origDragPoint then
&#9;&#9;print(&quot;Camera percent done:&quot; , CameraPercentFinished)
&#9;&#9;local _, dur = slowlyRotateCamera(origDragPoint, 1, rotatedBy * CameraPercentFinished)
&#9;&#9;wait(dur)
&#9;end
&#9;--wait(slowlyRotateBack(orignalCameraCFrame.p) + 0.05)
&#9;ToggleRotateButton(true)
&#9;-- allow camera to be moved again
&#9;camera.CameraType = &quot;Custom&quot;
&#9;humanoid.WalkSpeed = WALKING_SPEED
&#9;dragCenterOffset = nil
&#9;YOffset = nil
end

function ToggleRotateButton(on)
&#9;local moveGui = player.PlayerGui:FindFirstChild(&apos;MoveGui&apos;)
&#9;if moveGui then
&#9;&#9;moveGuiFrame = moveGui:FindFirstChild(&apos;Frame&apos;)
&#9;&#9;if moveGuiFrame then
&#9;&#9;&#9;rotateButton = moveGuiFrame:FindFirstChild(&apos;Rotate&apos;)
&#9;&#9;&#9;if rotateButton then
&#9;&#9;&#9;&#9;rotateButton.Visible = on
&#9;&#9;&#9;&#9;rotateButton.Active = on
&#9;&#9;&#9;&#9;moveGui.Active = on
&#9;&#9;&#9;&#9;moveGui.Enabled = on
&#9;&#9;&#9;&#9;moveGuiFrame.Active = on
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end


function onMouseDown()
&#9;playerMouse.TargetFilter = nil
&#9;local hitPart = playerMouse.Target
&#9;local hitPosition = playerMouse.Hit.p
&#9;if hitPart and draggableObjects[hitPart] then
&#9;&#9;-- hook it up to the draggah
&#9;&#9;toggleDrag(hitPart)
&#9;&#9;--playerMouse.TargetFilter = draggingModel
&#9;&#9;playerMouse.TargetFilter = DebugPlane


&#9;&#9;if not engineDragging then
&#9;&#9;-- and start polling for mouse moves
&#9;&#9;-- COMMENT/UNCOMMENT BELOW TWO LINES TO TOGGLE ENGINE DRAGGING
&#9;&#9;&#9;engineDragging = true
&#9;&#9;&#9;--engineDragger:MouseDown(hitPart, hitPosition - hitPart.Position, workspace.DraggingModel:GetChildren())&#9;
&#9;&#9;&#9;if StartDragSound then
&#9;&#9;&#9;&#9;StartDragSound:Play()
&#9;&#9;&#9;end
&#9;&#9;&#9;mouseDownTime = tick()
&#9;&#9;&#9;mouseDragPoller = coroutine.create(mouseDragPoll)
&#9;&#9;&#9;keepAlives[mouseDragPoller] = true
&#9;&#9;&#9;coroutine.resume(mouseDragPoller, keepAlives, mouseDragPoller)
&#9;&#9;end
&#9;else
&#9;&#9;--wait(0.15)
&#9;&#9;stopDragging()
&#9;end
end


function onMouseUp()
&#9;-- stop the dragging coroutine, if it&apos;s going
&#9;if mouseDragPoller then keepAlives[mouseDragPoller] = nil mouseDragPoller = nil end
&#9;if engineDragging then
&#9;&#9;--engineDragger:MouseUp()
&#9;&#9;engineDragging = false
&#9;end
end

playerMouse.Button1Up:connect(onMouseUp)
playerMouse.Button1Down:connect(onMouseDown)

function dragSelectionBoxGlow()
&#9;local timeIncrement
&#9;while true do
&#9;&#9;dragSelectionBox.Transparency = .4 + .4 * math.sin(selectionBoxTimeParam * SELECTION_BOX_GLOW_SPEED)
&#9;&#9;timeIncrement = wait(.1)
&#9;&#9;selectionBoxTimeParam = selectionBoxTimeParam + timeIncrement
&#9;end
end

coroutine.resume(coroutine.create(dragSelectionBoxGlow))

-- because we&apos;re doing all the CFrame-setting server-side (out of dPhysics necessity) yet we need the local camera coordinate frame, we need to poll regularly and pass it along
while true do
&#9;CurrentCameraCFrame.Value = workspace.CurrentCamera.CoordinateFrame
&#9;wait(.2)
end
</ProtectedString>
			</Properties>
			<Item class="BillboardGui" referent="RBX56">
				<Properties>
					<bool name="Active">false</bool>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">false</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">ArrowBillboard</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>10</XS>
						<XO>0</XO>
						<YS>10</YS>
						<YO>0</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>10</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="ImageLabel" referent="RBX57">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=40172628</url></Content>
						<string name="Name">ImageLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX58">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>3.29999995</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">DragMesh</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.200000003</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Texture" referent="RBX59">
					<Properties>
						<token name="Face">4</token>
						<string name="Name">TextureB</string>
						<float name="Shiny">20</float>
						<float name="Specular">0</float>
						<float name="StudsPerTileU">2</float>
						<float name="StudsPerTileV">8</float>
						<Content name="Texture"><url>http://www.roblox.com/asset/?id=90927957</url></Content>
						<float name="Transparency">0.300000012</float>
					</Properties>
				</Item>
				<Item class="Texture" referent="RBX60">
					<Properties>
						<token name="Face">1</token>
						<string name="Name">TextureA</string>
						<float name="Shiny">20</float>
						<float name="Specular">0</float>
						<float name="StudsPerTileU">8</float>
						<float name="StudsPerTileV">8</float>
						<Content name="Texture"><url>http://www.roblox.com/asset/?id=90927957</url></Content>
						<float name="Transparency">0.300000012</float>
					</Properties>
				</Item>
				<Item class="SpecialMesh" referent="RBX61">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><null></null></Content>
						<token name="MeshType">6</token>
						<string name="Name">BlockMesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>20</X>
							<Y>0.100000001</Y>
							<Z>20</Z>
						</Vector3>
						<Content name="TextureId"><null></null></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX62">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">StartDrag</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=99666816</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX63">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">StopDrag</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=99666917</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="BillboardGui" referent="RBX64">
				<Properties>
					<bool name="Active">true</bool>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">true</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<string name="Name">MoveGui</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>96</XO>
						<YS>0</YS>
						<YO>96</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="CFrameValue" referent="RBX65">
					<Properties>
						<string name="Name">CurrentCameraCFrame</string>
						<CoordinateFrame name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
					</Properties>
				</Item>
				<Item class="Vector3Value" referent="RBX66">
					<Properties>
						<string name="Name">DragToLocation</string>
						<Vector3 name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX67">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ServerDragScript</string>
						<ProtectedString name="Source">local DRAG_SPEED = 4
local DRAG_PRECISION = .125
local STEP_PRECISION = .25

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local DRAG_ERROR_COLOR = BrickColor.new(&apos;Really black&apos;)
local DRAG_ERROR_TIME = 0.4
local LastDragErrorTime = tick()
local PreviousSelectionBoxColor = BrickColor.new(&apos;Hot pink&apos;)

local LastSuccessfulDragTime = tick()
local SUCCESSFUL_DRAG_TIMEOUT = 0.15
local SUCCESSFUL_DRAG_THRESHOLD = 0.15

local moveGui = script.Parent
local moveGuiFrame = WaitForChild(moveGui, &quot;Frame&quot;)
local DragToLocation = WaitForChild(moveGui, &quot;DragToLocation&quot;)
local DragSelectionBox = WaitForChild(moveGui, &quot;DragSelectionBox&quot;)

local draggingModel = WaitForChild(workspace, &quot;DraggingModel&quot;)
local CurrentCameraCFrame = WaitForChild(moveGui, &quot;CurrentCameraCFrame&quot;)


local CantDragSound = WaitForChild(script, &apos;CantDrag&apos;)
local LastCantDragTime = tick()
local SoundDuration = 0.6

function vectorMin(vecA, vecB)
&#9;return Vector3.new(math.min(vecA.X, vecB.X), math.min(vecA.Y, vecB.Y), math.min(vecA.Z, vecB.Z))
end

function vectorMax(vecA, vecB)
&#9;return Vector3.new(math.max(vecA.X, vecB.X), math.max(vecA.Y, vecB.Y), math.max(vecA.Z, vecB.Z))
end

function calculateExtents(partCFrame, partSize)
&#9;local boundingVectorA = partCFrame:pointToWorldSpace(partSize/2)
&#9;local boundingVectorB = partCFrame:pointToWorldSpace(-partSize/2)
&#9;return vectorMin(boundingVectorA, boundingVectorB), vectorMax(boundingVectorA, boundingVectorB)
end

function recursiveCentroidHelper(model, centroidSoFar, numPartsSoFar)
&#9;local modelChildren = model:GetChildren()
&#9;for i = 1, #modelChildren do
&#9;&#9;if modelChildren[i]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;centroidSoFar = centroidSoFar + modelChildren[i].CFrame.p
&#9;&#9;&#9;numPartsSoFar = numPartsSoFar + 1
&#9;&#9;end
&#9;&#9;centroidSoFar, numPartsSoFar = recursiveCentroidHelper(modelChildren[i], centroidSoFar, numPartsSoFar)
&#9;end
&#9;return centroidSoFar, numPartsSoFar
end

function calculateCentroid(model)
&#9;-- below line should work, but doesn&apos;t because we don&apos;t always invalidate the model CFrame when we should
&#9;-- model:GetModelCFrame().p

&#9;-- so instead, just step thru
&#9;local centroid = Vector3.new(0, 0, 0)
&#9;local numParts = 0

&#9;centroid, numParts = recursiveCentroidHelper(model, centroid, numParts)

&#9;if numParts &gt; 0 then centroid = centroid / numParts end
&#9;return centroid
end

function playCantDragSound()
&#9;if tick() - LastSuccessfulDragTime &gt; SUCCESSFUL_DRAG_TIMEOUT then
&#9;&#9;local posixTime = tick()
&#9;&#9;if CantDragSound and (posixTime - LastCantDragTime) &gt; SoundDuration then
&#9;&#9;&#9;CantDragSound:Play()
&#9;&#9;&#9;LastCantDragTime = posixTime
&#9;&#9;end
&#9;end
end

function playRotateErrorSound()
&#9;playCantDragSound()
end

function DisplayDragError()
&#9;if tick() - LastSuccessfulDragTime &gt; SUCCESSFUL_DRAG_TIMEOUT then
&#9;&#9;local currTime = tick()
&#9;&#9;DragSelectionBox.Color = DRAG_ERROR_COLOR
&#9;&#9;LastDragErrorTime = currTime
&#9;&#9;wait(DRAG_ERROR_TIME)
&#9;&#9;if currTime == LastDragErrorTime then
&#9;&#9;&#9;DragSelectionBox.Color = PreviousSelectionBoxColor
&#9;&#9;end
&#9;end
end

local DRAG_DIRECTIONS = {UP = Vector3.new(0, 0, -1), DOWN = Vector3.new(0, 0, 1), LEFT = Vector3.new(-1, 0, 0), RIGHT = Vector3.new(1, 0, 0)}
local FUDGE_VECTOR = Vector3.new(.2, .2, .2)

function tryAbsoluteDrag(absoluteDir, dragDistance)
&#9;local objectsToMove = draggingModel:GetChildren()  -- effectively &quot;lock&quot; the objects we want to drag&#9;
&#9;local movementVector = absoluteDir * dragDistance

&#9;-- check here to see if dragging is ok&#9;
&#9;for i = 1, #objectsToMove do
&#9;&#9;local minExtents, maxExtents = calculateExtents(objectsToMove[i].CFrame + movementVector, objectsToMove[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then playCantDragSound() Spawn(DisplayDragError) return false end -- don&apos;t continue with drag if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end

&#9;-- if ok, then just translate the CFrames
&#9;for i = 1, #objectsToMove do
&#9;&#9;objectsToMove[i].CFrame = objectsToMove[i].CFrame + movementVector
&#9;end
&#9;if movementVector.magnitude &gt; SUCCESSFUL_DRAG_THRESHOLD then
&#9;&#9;LastSuccessfulDragTime = tick()
&#9;&#9;if (tick() - LastDragErrorTime) &gt; 0.15 then
&#9;&#9;&#9;DragSelectionBox.Color = PreviousSelectionBoxColor
&#9;&#9;end
&#9;&#9;--Delay(math.max(0, 0.15 - (tick() - LastDragErrorTime)), function() DragSelectionBox.Color = PreviousSelectionBoxColor end)
&#9;end
&#9;return true
end

function iterativeAbsoluteDrag(absoluteDir, stepSize)
&#9;local dragDistance = stepSize
&#9;while dragDistance &gt;= DRAG_PRECISION and not tryAbsoluteDrag(absoluteDir, dragDistance) do dragDistance = dragDistance / 2 end
end

function tryRelativeDrag(relativeDir)
&#9;local camFrame = CurrentCameraCFrame.Value

&#9;local indicatedDir = camFrame:vectorToWorldSpace(relativeDir)

&#9;-- match this with closest direction in absolute xz-plane
&#9;local bestMatchAmount = -10  -- less than -1,1 range of dot-products
&#9;local bestAbsoluteDir = nil
&#9;for _, absoluteDir in pairs(DRAG_DIRECTIONS) do
&#9;&#9;local matchAmount = absoluteDir:Dot(indicatedDir)
&#9;&#9;if matchAmount &gt; bestMatchAmount then
&#9;&#9;&#9;bestMatchAmount = matchAmount
&#9;&#9;&#9;bestAbsoluteDir = absoluteDir
&#9;&#9;end
&#9;end

&#9;iterativeAbsoluteDrag(bestAbsoluteDir, DRAG_SPEED)
end

-- returns cframe rotated 90-degrees about absolute y-axis at point
function rotateY(cframe, point)
&#9;return (CFrame.Angles(0, -math.pi/2, 0) * (cframe - point)) + point
end


function tryRotate()
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local objectsToRotate = draggingModel:GetChildren() -- effectively &quot;lock&quot; the objects we want to rotate

&#9;-- check here to see if the rotation is ok
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local newCFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;&#9;local minExtents, maxExtents = calculateExtents(newCFrame, objectsToRotate[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then return false end -- don&apos;t continue with rotation if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end
&#9;
&#9;-- temporarily remove stabilizers and then re-add them with updated CFrames as well
&#9;local stabilizerParents = {}
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local stabilizer = objectsToRotate[i]:FindFirstChild(&quot;TorqueStabilizer&quot;)
&#9;&#9;if stabilizer then
&#9;&#9;&#9;stabilizerParents[stabilizer] = stabilizer.Parent
&#9;&#9;&#9;stabilizer.Parent = nil
&#9;&#9;end
&#9;end

&#9;-- if ok, then just transform the CFrames
&#9;for i = 1, #objectsToRotate do
&#9;&#9;objectsToRotate[i].CFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;end

&#9;-- and re-add the stabilizers with updated CFrames
&#9;for stabilizer, stabilizerParent in pairs(stabilizerParents) do
&#9;&#9;stabilizer.cframe = rotateY(stabilizer.cframe, centroid)
&#9;&#9;stabilizer.Parent = stabilizerParent
&#9;end

&#9;return true
end

function onRotate()
&#9;if not tryRotate() then playRotateErrorSound() DisplayDragError() end
end

function onDown()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;DOWN&quot;])
end

function onUp()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;UP&quot;])
end

function onLeft()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;LEFT&quot;])
end

function onRight()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;RIGHT&quot;])
end

function stepTowardsPoint(targetPoint)
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local dragStepSize = DRAG_SPEED
&#9;if centroid.Z &gt; targetPoint.Z - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, -1), dragStepSize)
&#9;elseif centroid.Z &lt; targetPoint.Z + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, 1), dragStepSize)
&#9;end
&#9;dragStepSize = DRAG_SPEED
&#9;if centroid.X &gt; targetPoint.X - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(-1, 0, 0), dragStepSize)
&#9;elseif centroid.X &lt; targetPoint.X + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(1, 0, 0), dragStepSize)
&#9;end
end

function onDrag(targetPoint)
&#9;if targetPoint.Y ~= 0 then return end
&#9;--moveGui.Adornee = draggingModel
&#9;--moveGui.StudsOffset = draggingModel:GetModelSize() / 2
&#9;local moveTries = (targetPoint - draggingModel:GetModelCFrame().p).magnitude / DRAG_SPEED
&#9;for i = 1, moveTries do
&#9;&#9;stepTowardsPoint(targetPoint)
&#9;end
end

WaitForChild(moveGuiFrame, &quot;Rotate&quot;).MouseButton1Click:connect(onRotate)
WaitForChild(moveGuiFrame, &quot;Left&quot;).MouseButton1Click:connect(onLeft)
WaitForChild(moveGuiFrame, &quot;Right&quot;).MouseButton1Click:connect(onRight)
WaitForChild(moveGuiFrame, &quot;Up&quot;).MouseButton1Click:connect(onUp)
WaitForChild(moveGuiFrame, &quot;Down&quot;).MouseButton1Click:connect(onDown)

DragToLocation.Changed:connect(onDrag)
</ProtectedString>
					</Properties>
					<Item class="Sound" referent="RBX68">
						<Properties>
							<bool name="Looped">false</bool>
							<string name="Name">CantDrag</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=99666774</url></Content>
							<float name="Volume">1</float>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX69">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextButton" referent="RBX70">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Up</string>
							<UDim2 name="Position">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.75</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">^</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX71">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Right</string>
							<UDim2 name="Position">
								<XS>0.524999976</XS>
								<XO>0</XO>
								<YS>0.824999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">&gt;</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX72">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Left</string>
							<UDim2 name="Position">
								<XS>0.375</XS>
								<XO>0</XO>
								<YS>0.824999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">&lt;</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX73">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">8</token>
							<bool name="Modal">false</bool>
							<string name="Name">Down</string>
							<UDim2 name="Position">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.0700000003</XS>
								<XO>0</XO>
								<YS>0.0700000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text">v</string>
							<Color3 name="TextColor3">4292269782</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX74">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">0.300000012</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=59103214</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Rotate</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
				</Item>
				<Item class="SelectionBox" referent="RBX75">
					<Properties>
						<Ref name="Adornee">null</Ref>
						<int name="Color">1032</int>
						<string name="Name">DragSelectionBox</string>
						<float name="Transparency">0.5</float>
						<bool name="Visible">true</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX76">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PuzzleCam</string>
				<ProtectedString name="Source">local Player = script.Parent.Parent
Player.CameraMode = &quot;NoOcclusions&quot;
Player.CharacterAdded:connect(function(char) print(&quot;!!!CHARACTER ADDED!!!!&quot;) end)
local SpecialPartsToAlwaysSee = {}

local PartsToTransparify = {}
local StoredTransparencies = {}
local PTTCopy = {}

local Camera = workspace.CurrentCamera

function isSpecial(hitPart)
&#9;if (not hitPart) or hitPart == workspace then return false end

&#9;if SpecialPartsToAlwaysSee[hitPart] then return true
&#9;else return isSpecial(hitPart.Parent) end
end

function castRay(rayStart, rayEnd)
&#9;local myRay = Ray.new(rayStart, rayEnd - rayStart)

&#9;PartsToTransparify = {}
&#9;PTTCopy = {}
&#9;local hitPart = workspace:FindPartOnRay(myRay)

&#9;while hitPart and not isSpecial(hitPart) do
&#9;&#9;table.insert(PartsToTransparify, hitPart)
&#9;&#9;PTTCopy[hitPart] = hitPart
&#9;&#9;if not StoredTransparencies[hitPart] then StoredTransparencies[hitPart] = hitPart.Transparency hitPart.Transparency = 1-((1-hitPart.Transparency)*.6) end

&#9;&#9;hitPart = workspace:FindPartOnRayWithIgnoreList(myRay, PartsToTransparify)
&#9;end

&#9;for part, _ in pairs(StoredTransparencies) do
&#9;&#9;if not PTTCopy[part] then
&#9;&#9;&#9;part.Transparency = StoredTransparencies[part]
&#9;&#9;&#9;StoredTransparencies[part] = nil
&#9;&#9;end
&#9;end
end

Player.CameraMode = &quot;Classic&quot;
wait(5) -- derp
local Character = Player.Character
Player.CameraMode = &quot;NoOcclusions&quot;
--local Torso = Character:FindFirstChild(&quot;Torso&quot;)
--local Head = Character:FindFirstChild(&quot;Head&quot;)
--table.insert(SpecialPartsToAlwaysSee, Torso)
--table.insert(SpecialPartsToAlwaysSee, Head)
--table.insert(SpecialPartsToAlwaysSee, Character)
SpecialPartsToAlwaysSee[Character] = true

while true do
&#9;for specialPart, _ in pairs(SpecialPartsToAlwaysSee) do
&#9;&#9;if specialPart:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;castRay(Camera.CoordinateFrame.p, specialPart.CFrame.p)
&#9;&#9;else
&#9;&#9;&#9;-- is a model
&#9;&#9;&#9;castRay(Camera.CoordinateFrame.p, specialPart:GetModelCFrame().p)
&#9;&#9;end
&#9;end
&#9;wait(.01)
end
</ProtectedString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterGui" referent="RBX77">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ShowDevelopmentGui">true</bool>
		</Properties>
		<Item class="ScreenGui" referent="RBX78">
			<Properties>
				<string name="Name">LevelSelectionGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX79">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiScript</string>
					<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DEBUG_PRINT = false
local DEBUG_MODE = true

local BUTTON_WIDTH = 85
local MARGIN_SIZE = 15



local LightingService = Game:GetService(&apos;Lighting&apos;)
local LevelsModel = WaitForChild(LightingService, &apos;Levels&apos;)


local ScreenGui = script.Parent
local ScreenFrame = WaitForChild(ScreenGui, &apos;LevelSelectFrame&apos;)
local BackgroundFrame = WaitForChild(ScreenFrame, &apos;Background&apos;)

local WinGui = WaitForChild(ScreenGui.Parent, &apos;WinGui&apos;)
local WinFrame = WaitForChild(WinGui, &apos;WinFrame&apos;)
local NextLevelButton = WaitForChild(WinFrame, &apos;NextLevel&apos;)
local ReplayButton = WaitForChild(WinFrame, &apos;Replay&apos;)

local LevelChangeScript = WaitForChild(Workspace, &apos;LevelChangeScript&apos;)
local CurrentLevel = WaitForChild(LevelChangeScript, &apos;CurrentLevel&apos;)
local RequestedLevel = WaitForChild(LevelChangeScript, &apos;RequestedLevel&apos;)
local LevelPointers = WaitForChild(LevelChangeScript, &apos;LevelPointers&apos;)

local NonButtonCount = #ScreenFrame:GetChildren()

local DotGuiElements = {}


local QUESTION_MARK_URL = &quot;http://www.roblox.com/asset/?id=99877840&quot;

--[[
local GUI_ORDER = {
&#9;[&quot;Ladder&quot;] = 1,
&#9;[&quot;Ramps&quot;] = 2,
&#9;[&quot;Rebridge&quot;] = 3,
&#9;[&quot;Swing&quot;] = 4,
&#9;[&quot;Tram&quot;] = 5,
&#9;[&quot;Button1&quot;] = 6,
&#9;[&quot;Shift1&quot;] = 7,
&#9;[&quot;Shuffle1&quot;] = 8,
&#9;[&quot;Crevice3&quot;] = 9,
&#9;[&quot;NoDrag1&quot;] = 10
}
--]]
local GUI_ORDER = {
&#9;[&quot;Ladder&quot;] = 6,
&#9;[&quot;Ramps&quot;] = 2,
&#9;[&quot;Rebridge&quot;] = 1,
&#9;[&quot;Swing&quot;] = 4,
&#9;[&quot;Tram&quot;] = 5,
&#9;[&quot;Button1&quot;] = 9,
&#9;[&quot;Shift1&quot;] = 7,
&#9;[&quot;Shuffle1&quot;] = 8,
&#9;[&quot;Crevice3&quot;] = 3,
&#9;[&quot;NoDrag1&quot;] = 10
}

local GUI_COMPARE_FUNC = function(a, b)
&#9;local aName = a:GetName()
&#9;local bName = b:GetName()
&#9;if GUI_ORDER[aName] and GUI_ORDER[bName] then
&#9;&#9;return GUI_ORDER[aName] &lt; GUI_ORDER[bName]
&#9;elseif GUI_ORDER[aName] then
&#9;&#9;return true
&#9;elseif GUI_ORDER[bName] then
&#9;&#9;return false
&#9;else return aName &lt; bName end -- fallback on string comparison
end

local useAssetVersionId = false
local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl

LevelManager = {}
LevelManger_mt = { __index = LevelManager}

LevelManager = setmetatable({indexTable = {}, nameTable = {}, pointerTable = {}}, LevelManager_mt)

function LevelManager:ChangeLevel(nextLevel)
&#9;if not nextLevel then DebugPrint(&quot;Requested Level is nil&quot;) return end
&#9;if type(nextLevel) == &apos;userdata&apos; then
&#9;&#9;if nextLevel:IsA(&apos;ObjectValue&apos;) then DebugPrint(&quot;ChangeLevel: Got level pointer, need lua-side level object&quot;) return end
&#9;&#9;if nextLevel:IsA(&apos;Model&apos;) then DebugPrint(&quot;ChangeLevel: Got level model, need lua-side level object&quot;) return end
&#9;end
&#9;if RequestedLevel then
&#9;&#9;RequestedLevel.Value = nextLevel:GetPointer()
&#9;end
end

function LevelManager:AddLevel(newLevel)
&#9;if newLevel and newLevel:GetName() and newLevel:GetPointer() and newLevel:GetNumber() then
&#9;&#9;if #self.indexTable &lt; newLevel:GetNumber() and not self.nameTable[newLevel:GetName()] and not self.pointerTable[newLevel:GetPointer()] then
&#9;&#9;&#9;self.indexTable[newLevel:GetNumber()] = newLevel
&#9;&#9;&#9;self.nameTable[newLevel:GetName()] = newLevel
&#9;&#9;&#9;self.pointerTable[newLevel:GetPointer()] = newLevel
&#9;&#9;else
&#9;&#9;&#9;DebugPrint(&quot;LevelManager:AddLevel: Tried to add&quot; , newLevel:GetName() , &quot;but another level with that number, or name, or pointer already exists.&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;DebugPrint(&quot;LevelManager:AddLevel: The new level either didn&apos;t exist or doesn&apos;t have a pointer, number, and name&quot;)
&#9;end
end

function LevelManager:GetNumberOfLevels()
&#9;return #self.indexTable
end

--[[ Right now I am going to let you index by either strings, numbers or objectvalues.
&#9;In the future I might make each index type be a separate function.
]]
function LevelManager:GetLevel(index)
&#9;if type(index) == &apos;string&apos; then
&#9;&#9;return self.nameTable[index]
&#9;elseif type(index) == &apos;number&apos; then
&#9;&#9;return self.indexTable[index]
&#9;elseif type(index) == &apos;userdata&apos; and index:IsA(&apos;ObjectValue&apos;) then
&#9;&#9;return self.pointerTable[index]
&#9;else
&#9;&#9;DebugPrint(&quot;LevelManager:GetLevel: Unrecognized indexing type :&quot; , type(index))
&#9;end
end

function LevelManager:GetCurrentLevel()
&#9;if CurrentLevel and CurrentLevel.Value then
&#9;&#9;return self.nameTable[CurrentLevel.Value.Name]
&#9;end
end

function LevelManager:GetNextLevel(level)
&#9;level = level or self:GetCurrentLevel()
&#9;if level then
&#9;&#9;local levelIndex = level:GetNumber()
&#9;&#9;local nextLevel = self.indexTable[levelIndex + 1]
&#9;&#9;return nextLevel
&#9;end
end

function LevelManager:SortLevels(sortingFunc)
&#9;table.sort(self.indexTable, sortingFunc)
&#9;--this is kinda of ugly but we need to update the numbers that are within the level objects after re-arranging their order
&#9;for number, level in pairs(self.indexTable) do
&#9;&#9;--print(&quot;Level:&quot; , level:GetName() , &quot;New num:&quot; , number , &quot;Old Num:&quot; , level:GetNumber())
&#9;&#9;level:SetNumber(number)
&#9;end
end

Level = {}
Level_mt = { __index = Level}

function Level:new(name, number, pointer)
&#9;return setmetatable({name = name, number = number, pointer = pointer, active = true}, Level_mt)
end

function Level:GetThumbnail()
&#9;-- not sure if I want it to be waiting or return nil
&#9;if self.pointer.Value then
&#9;&#9;local assetId = WaitForChild(self.pointer.Value, &apos;AssetId&apos;)
&#9;&#9;local assetVersionId = WaitForChild(self.pointer.Value, &apos;AssetVersionId&apos;)
&#9;&#9;local thumbnailUrl, largeThumbnailUrl
&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;thumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=110&amp;ht=110&amp;assetversionid=&quot; .. assetVersionId.Value
&#9;&#9;&#9; largeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot; .. assetVersionId.Value
&#9;&#9;else
&#9;&#9;&#9;thumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=110&amp;ht=110&amp;aid=&quot; .. assetId.Value
&#9;&#9;&#9; largeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=3200&amp;ht=320&amp;aid=&quot; .. assetId.Value
&#9;&#9;end
&#9;&#9;return thumbnailUrl, largeThumbnailUrl
&#9;end
end

function Level:SetNumber(num)
&#9;self.number = num
end

function Level:GetNumber()
&#9;return self.number
end

function Level:GetPointer()
&#9;return self.pointer
end

function Level:SetActive(value)
&#9;self.active = value
end

function Level:IsActive()
&#9;if DEBUG_MODE then return true end
&#9;if self.number == 1 then return true end
&#9;local previousLevel = LevelManager:GetLevel(math.max(0, self.number - 1))
&#9;if previousLevel then
&#9;&#9;return previousLevel:IsBeaten() or self:IsBeaten()
&#9;end
&#9;return true
end

function Level:IsBeaten()
&#9;if self.pointer and self.pointer.Value then
&#9;&#9;return self.pointer:FindFirstChild(&apos;Completed&apos;)
&#9;else
&#9;&#9;DebugPrint(&quot;Level:&quot; , self.name , &quot;has no pointer value associated with it.&quot;)
&#9;&#9;return nil
&#9;end
end

function Level:GetName()
&#9;return self.name
end

function DebugPrint(...)
&#9;if DEBUG_PRINT then
&#9;&#9;print(...)
&#9;end
end

function GetLevelThumbnail(theLevel)
&#9;local aid = WaitForChild(theLevel, &apos;AssetId&apos;)
&#9;local avid = WaitForChild(theLevel, &apos;AssetVersionId&apos;)
&#9;local ThumbnailUrl, LargeThumbnailUrl
&#9;if useAssetVersionId then
&#9;&#9;ThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=110&amp;ht=110&amp;assetversionid=&quot; .. avid.Value
&#9;&#9; LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot; .. avid.Value
&#9;else
&#9;&#9;ThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=110&amp;ht=110&amp;aid=&quot; .. aid.Value
&#9;&#9; LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=3200&amp;ht=320&amp;aid=&quot; .. aid.Value
&#9;end
&#9;return ThumbnailUrl, LargeThumbnailUrl
end

function BuildLevelImage(levelName)
&#9;local level = LevelManager:GetLevel(levelName)
&#9;if level then
&#9;&#9;local smallThumbUrl, largeThumbUrl = level:GetThumbnail()
&#9;&#9;if smallThumbUrl ~= nil then
&#9;&#9;&#9;local levelImage = Instance.new(&apos;ImageButton&apos;)
&#9;&#9;&#9;if level:IsActive() then
&#9;&#9;&#9;&#9;levelImage.Image = smallThumbUrl
&#9;&#9;&#9;&#9;levelImage.Size = UDim2.new(0, 64, 0, 64)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;levelImage.Image = QUESTION_MARK_URL
&#9;&#9;&#9;&#9;levelImage.Size = UDim2.new(0, 42, 0, 42)
&#9;&#9;&#9;&#9;levelImage.Position = UDim2.new(0, 0, 0, 22)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;levelImage.BackgroundTransparency = 1
&#9;&#9;&#9;levelImage.BorderSizePixel = 0
&#9;&#9;&#9;return levelImage
&#9;&#9;else
&#9;&#9;&#9;--Give question mark here
&#9;&#9;&#9;DebugPrint(&quot;Can&apos;t get image for:&quot; , levelName, theLevel)
&#9;&#9;end
&#9;else
&#9;&#9;DebugPrint(&quot;Cannot find the levels model in lighting.&quot;)
&#9;end
end

function GetButtonCount()
&#9;return #ScreenFrame:GetChildren() - NonButtonCount
end

function SortGuis()
&#9;for i = 1, LevelManager:GetNumberOfLevels() do
&#9;&#9;local level = LevelManager:GetLevel(i)
&#9;&#9;if ScreenFrame:FindFirstChild(level:GetName()) then
&#9;&#9;&#9;local levelName = level:GetName()
&#9;&#9;&#9;ScreenFrame[levelName].Position = UDim2.new(0, (BUTTON_WIDTH + MARGIN_SIZE) * (i - 1), 0, -15)

&#9;&#9;&#9;if level:IsActive() and not ScreenFrame[levelName].Active then
&#9;&#9;&#9;&#9;ScreenFrame[levelName].TextColor3 = Color3.new(1, 1, 1)
&#9;&#9;&#9;&#9;if level:IsBeaten() then
&#9;&#9;&#9;&#9;&#9;CompleteButton(ScreenFrame[levelName])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ScreenFrame[levelName].Active = true
&#9;&#9;&#9;&#9;local button = ScreenFrame[levelName]
&#9;&#9;&#9;&#9;while button:FindFirstChild(button.Name) do
&#9;&#9;&#9;&#9;&#9;button:FindFirstChild(button.Name):Destroy() --.Parent = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local img = BuildLevelImage(button.Name)
&#9;&#9;&#9;&#9;if img then
&#9;&#9;&#9;&#9;&#9;img.Name = button.Name
&#9;&#9;&#9;&#9;&#9;img.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;if img.Parent and img.Parent.Active then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;LevelManager:ChangeLevel(level)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;DebugPrint(img.Name , &quot;img not active&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;img.Parent = button
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif not level:IsActive() and ScreenFrame[levelName].Active then
&#9;&#9;&#9;&#9;ScreenFrame[levelName].TextColor3 = Color3.new(.4, .4, .4)
&#9;&#9;&#9;&#9;if level:IsBeaten() then
&#9;&#9;&#9;&#9;&#9;CompleteButton(ScreenFrame[levelName])
&#9;&#9;&#9;&#9;&#9;DebugPrint(&quot;Something went wrong, a non-active level was beaten&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ScreenFrame[levelName].Active = false
&#9;&#9;&#9;&#9;local button = ScreenFrame[levelName]
&#9;&#9;&#9;&#9;while button:FindFirstChild(button.Name) do
&#9;&#9;&#9;&#9;&#9;button:FindFirstChild(button.Name):Destroy()--Parent = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local img = BuildLevelImage(button.Name)
&#9;&#9;&#9;&#9;if img then
&#9;&#9;&#9;&#9;&#9;img.Name = button.Name
&#9;&#9;&#9;&#9;&#9;img.Parent = button
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;DebugPrint(&quot;Button:&quot;, levelName, &quot;not found!&quot;)
&#9;&#9;end
&#9;end
&#9;if NextLevelButton then
&#9;&#9;if not LevelManager:GetNextLevel() then
&#9;&#9;&#9;NextLevelButton.Visible = false
&#9;&#9;else
&#9;&#9;&#9;NextLevelButton.Visible = true
&#9;&#9;end
&#9;end
end

function SelectButton(button)
&#9;button.Font = &apos;ArialBold&apos;
&#9;--button.TextColor3 = Color3.new(0.1, 0.9, 0.1)
&#9;button.Style = &apos;RobloxButtonDefault&apos;
end

function DeselectButton(button)
&#9;button.Font = &apos;Arial&apos;
&#9;--button.TextColor3 = Color3.new(1, 1, 1)
&#9;button.Style = &apos;Custom&apos;
end

function CompleteButton(button)
&#9;button.Active = true
&#9;if button:FindFirstChild(button.Name) then
&#9;&#9;--button:FindFirstChild(button.Name).Active = button.Active
&#9;end
&#9;button.TextColor3 = Color3.new(1, 215/255, 83/255)
end

function CompletedLevel(levelPointer)
&#9;if levelPointer and levelPointer.Value then
&#9;&#9;if ScreenFrame:FindFirstChild(levelPointer.Value.Name) then
&#9;&#9;&#9;CompleteButton(ScreenFrame:FindFirstChild(levelPointer.Value.Name))
&#9;&#9;end
&#9;end
end

function CompletedCurrentLevel()
&#9;CompletedLevel(CurrentLevel)
end

function AddLevelButton(name, text, level)
&#9;local levelButton = Instance.new(&apos;TextButton&apos;)
&#9;levelButton.Name = name
&#9;levelButton.Text = text
&#9;levelButton.TextColor3 = Color3.new(1,1,1)
&#9;levelButton.TextStrokeTransparency = 0
&#9;levelButton.TextStrokeColor3 = Color3.new(0,0,0)
&#9;levelButton.Size = UDim2.new(0, BUTTON_WIDTH, 0, 30)
&#9;levelButton.Style = &apos;Custom&apos; --Enum.ButtonStyle.RobloxButton
&#9;levelButton.Position = UDim2.new(0, (BUTTON_WIDTH + MARGIN_SIZE) * GetButtonCount(), 0, -15)
&#9;levelButton.FontSize = &apos;Size18&apos;
&#9;levelButton.Font = &apos;Arial&apos;
&#9;levelButton.ZIndex = 3
&#9;levelButton.TextXAlignment = &apos;Left&apos;
&#9;levelButton.Active = false
&#9;levelButton.TextColor3 = Color3.new(.4, .4, .4)

&#9;levelButton.BackgroundTransparency = 1
&#9;levelButton.TextWrapped = true
&#9;--levelButton.ClipDescendants = true
&#9;levelButton.MouseButton1Click:connect(function()
&#9;&#9;if levelButton.Active then
&#9;&#9;&#9;LevelManager:ChangeLevel(level)
&#9;&#9;end
&#9;end)
&#9;levelButton.Parent = ScreenFrame
&#9;SortGuis()
&#9;-- Select the button if it is the currentLevel
&#9;if CurrentLevel and CurrentLevel.Value and name == CurrentLevel.Value.Name then
&#9;&#9;SelectButton(levelButton)
&#9;end
&#9;if level:IsBeaten() then
&#9;&#9;CompleteButton(levelButton)
&#9;else
&#9;&#9;-- If it isn&apos;t beaten yet then listen for if it does get beaten.
&#9;&#9;-- Got to do this or else when we finished the current level it won&apos;t show until we recreate the gui
&#9;&#9;level:GetPointer().ChildAdded:connect(function(child) if child.Name == &apos;Completed&apos; then CompleteButton(levelButton) end end)
&#9;end
&#9;local img = BuildLevelImage(name)
&#9;if img then
&#9;&#9;img.Name = levelButton.Name
&#9;&#9;img.MouseButton1Click:connect(function()
&#9;&#9;&#9;if level:IsActive() then
&#9;&#9;&#9;&#9;LevelManager:ChangeLevel(level)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;DebugPrint(img.Name , &quot;img not active&quot;)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;img.Parent = levelButton
&#9;end
&#9;DebugPrint(&quot;Added a button:&quot; , name)
&#9;return levelButton
end


for _, child in pairs(LevelPointers:GetChildren()) do
&#9;local newLevel = Level:new(child.Name, LevelManager:GetNumberOfLevels() + 1, child)
&#9;LevelManager:AddLevel(newLevel)
&#9;-- In the future: should probably only add level buttons after adding and sorting all the levels
&#9;AddLevelButton(newLevel:GetName(), newLevel:GetName(), newLevel)
end
LevelPointers.ChildAdded:connect(function(child)
&#9;local newLevel = Level:new(child.Name, LevelManager:GetNumberOfLevels() + 1, child)
&#9;LevelManager:AddLevel(newLevel)
&#9;AddLevelButton(newLevel:GetName(), newLevel:GetName(), newLevel)
&#9;LevelManager:SortLevels(GUI_COMPARE_FUNC)
&#9;SortGuis()
end)
LevelManager:SortLevels(GUI_COMPARE_FUNC)
SortGuis()

CurrentLevel.Changed:connect(function()
&#9;for _, child in pairs(ScreenFrame:GetChildren()) do
&#9;&#9;if child:IsA(&apos;TextButton&apos;) then
&#9;&#9;&#9;if CurrentLevel and CurrentLevel.Value and child.Text == CurrentLevel.Value.Name then
&#9;&#9;&#9;&#9;SelectButton(child)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;DeselectButton(child)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)

NextLevelButton.MouseButton1Click:connect(function()
&#9;local nextLevel = LevelManager:GetNextLevel()
&#9;if nextLevel then
&#9;&#9;LevelManager:ChangeLevel(nextLevel)
&#9;end
end)

ReplayButton.MouseButton1Click:connect(function()
&#9;local currLevel = LevelManager:GetCurrentLevel()
&#9;if currLevel then
&#9;&#9;LevelManager:ChangeLevel(currLevel)
&#9;end
end)

DebugPrint(&quot;Level Selection script done.&quot;)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX80">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">LevelSelectFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-500</XO>
						<YS>0</YS>
						<YO>44</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>1000</XO>
						<YS>0</YS>
						<YO>38</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX81">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX82">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">BottomBorder</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-10</XO>
								<YS>1</YS>
								<YO>8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>23</XO>
								<YS>0</YS>
								<YO>3</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX83">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4286479998</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">LeftBorder</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-8</XO>
								<YS>0</YS>
								<YO>-7</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>3</XO>
								<YS>1</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX84">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4286479998</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">RightBorder</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>8</XO>
								<YS>0</YS>
								<YO>-7</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>3</XO>
								<YS>1</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX85">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">TopBorder</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-10</XO>
								<YS>0</YS>
								<YO>-10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>23</XO>
								<YS>0</YS>
								<YO>3</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX86">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">1</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">TextButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>170</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>80</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Truck level</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="Frame" referent="RBX87">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.5</float>
								<Color3 name="BorderColor3">4294967295</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>1</YS>
									<YO>2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX88">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.5</float>
								<Color3 name="BorderColor3">4294967295</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX89">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>10</XO>
									<YS>1</YS>
									<YO>-2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX90">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=69969602</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>-8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX91">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">1</token>
							<token name="FontSize">6</token>
							<bool name="Modal">false</bool>
							<string name="Name">TextButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>-5</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>120</XO>
								<YS>1</YS>
								<YO>7</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Truck level</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">0</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="Frame" referent="RBX92">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.5</float>
								<Color3 name="BorderColor3">4294967295</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX93">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>10</XO>
									<YS>1</YS>
									<YO>-2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">3</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX94">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>10</XO>
									<YS>1</YS>
									<YO>-2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX95">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">1</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">TextButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>10</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>80</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Truck level</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="Frame" referent="RBX96">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.5</float>
								<Color3 name="BorderColor3">4294967295</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX97">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.5</float>
								<Color3 name="BorderColor3">4294967295</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX98">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Frame</string>
								<UDim2 name="Position">
									<XS>0.150000006</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0.699999988</XS>
									<XO>10</XO>
									<YS>1</YS>
									<YO>-2</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX99">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4280624421</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">TopHalf</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>0</YS>
								<YO>-10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>13</XO>
								<YS>0.5</YS>
								<YO>10</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX100">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">BottomHalf</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>13</XO>
								<YS>0.5</YS>
								<YO>10</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX101">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SuperBottomHalf</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>1</YS>
								<YO>11</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>13</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX102">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4280624421</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SuperBottomTopHalf</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>1</YS>
								<YO>10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>13</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX103">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SuperTopHalf</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>0</YS>
								<YO>-10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>13</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX104">
			<Properties>
				<string name="Name">WinGui</string>
			</Properties>
			<Item class="Frame" referent="RBX105">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">WinFrame</string>
					<UDim2 name="Position">
						<XS>0.25</XS>
						<XO>0</XO>
						<YS>-0.5</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.400000006</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX106">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">9</token>
						<string name="Name">YouWin</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.400000006</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">You Win</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX107">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">1</token>
						<token name="FontSize">7</token>
						<string name="Name">Instructions</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.400000006</YS>
							<YO>20</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">You Win</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX108">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">Replay</string>
						<UDim2 name="Position">
							<XS>0.330000013</XS>
							<XO>-63</XO>
							<YS>0.800000012</YS>
							<YO>-25</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>115</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">Replay</string>
						<Color3 name="TextColor3">4294901756</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">6</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX109">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">NextLevel</string>
						<UDim2 name="Position">
							<XS>0.670000017</XS>
							<XO>-83</XO>
							<YS>0.800000012</YS>
							<YO>-25</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>165</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">Next Level</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">6</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX110">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WinGuiScript</string>
					<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local WinGui = script.Parent
local WinFrame = WaitForChild(WinGui, &apos;WinFrame&apos;)

local LevelChangeScript = WaitForChild(Workspace, &apos;LevelChangeScript&apos;)
local CurrentLevelPointer = WaitForChild(LevelChangeScript, &apos;CurrentLevel&apos;)
local GameClock = WaitForChild(Workspace, &apos;GameClock&apos;)
local ClockTime = WaitForChild(GameClock, &apos;Time&apos;)

local LevelCompletionCallback = nil

function ListenToLevelComplete(event)
&#9;if not event then print(&quot;No level completion event to listen to!&quot;) return end
&#9;WaitForChild(event, &apos;Completion&apos;)
&#9;levelName = levelName or &quot;the level&quot;
&#9;WinFrame:TweenPosition(UDim2.new(0.25, 0, 0.3, 0))
&#9;WinFrame.Instructions.Text = &quot;You completed &quot; .. levelName .. &quot; in &quot; .. math.floor(ClockTime.Value) .. &quot; seconds! Pick another level to keep playing.&quot;
&#9;CurrentLevelPointer.Changed:wait()
&#9;WinFrame:TweenPosition(UDim2.new(0.25, 0, -0.5, 0))
end

function AcquireLevelEvent()
&#9;if CurrentLevelPointer then
&#9;&#9;if LevelCompletionCallback then
&#9;&#9;&#9;LevelCompletionCallback:disconnect()
&#9;&#9;&#9;LevelCompletionCallback = nil
&#9;&#9;end
&#9;&#9;if CurrentLevelPointer.Value then
&#9;&#9;&#9;ListenToLevelComplete(WaitForChild(CurrentLevelPointer.Value, &apos;LevelCompleted&apos;))
&#9;&#9;end
&#9;end
end

AcquireLevelEvent()
CurrentLevelPointer.Changed:connect(AcquireLevelEvent)

print(&apos;WinGui Script Loaded&apos;)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX111">
			<Properties>
				<string name="Name">GameClockGui</string>
			</Properties>
			<Item class="Frame" referent="RBX112">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">TimeFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-105</XO>
						<YS>0</YS>
						<YO>2</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>200</XO>
						<YS>0</YS>
						<YO>22</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX113">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">Time Remaining</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>-0.400000006</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX114">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">Time</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">1</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX115">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameClockGuiScript</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Gui = script.Parent
local Frame = WaitForChild(Gui, &apos;TimeFrame&apos;)
local Time = WaitForChild(Frame, &apos;Time&apos;)

local MainScript = Workspace:FindFirstChild(&apos;GameClock&apos;)
local TimeObject = WaitForChild(MainScript, &apos;Time&apos;)

--------------------
--| Script Logic |--
--------------------
local startPos = UDim2.new(0.5, -17, 0.8, -25)
local startSize = UDim2.new(0, 34, 0, 34)
local endPos = UDim2.new(0.5, -26, 0.8, -34)
local endSize = UDim2.new(0, 52, 0, 52)

local minutesPos = UDim2.new(0.5, 0, 0.8, -25)
local minutesSize = UDim2.new(0, 0, 1, 0)
local lastTime = -1

-- Whenever TimeObject changes, update the Time displayed
TimeObject.Changed:connect(function(newValue)
&#9;local currentTime = math.max(0, newValue)
&#9;if lastTime == math.floor(currentTime) then return end
&#9;lastTime = math.floor(currentTime)
&#9;--print(&quot;Time Changed, time is&quot; , newValue)
&#9;local hours = math.floor(currentTime / 3600)
&#9;local minutes = math.floor(currentTime / 60) % 60
&#9;local seconds = math.floor(currentTime) % 60
&#9;if minutes &gt; 0 then
&#9;&#9;Time.TextWrapped = false
&#9;&#9;Time.TextScaled = false
&#9;&#9;--Time.Position = minutesPos
&#9;&#9;--Time.Size = minutesSize
&#9;&#9;Time.Text = string.format(&quot;%d:%02d&quot;, minutes, seconds) -- (Looks like 00:00:00)
&#9;else
&#9;&#9;Time.TextWrapped = true
&#9;&#9;Time.TextScaled = true
&#9;&#9;-- One argument of tween is a callback, I use it to untween the text
&#9;&#9;--Time:TweenSizeAndPosition(endSize,endPos, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.2, false,
&#9;&#9;--&#9;function() Time:TweenSizeAndPosition(startSize,startPos, Enum.EasingDirection.In, Enum.EasingStyle.Linear, 0.3) end)
&#9;&#9;if seconds ~= 59 then
&#9;&#9;&#9;wait(0.1)
&#9;&#9;end
&#9;&#9;Time.Text = string.format(&quot;%d&quot;, seconds)
&#9;end
end)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX116">
			<Properties>
				<string name="Name">TutorialGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX117">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TutorialScript</string>
					<ProtectedString name="Source">function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local MOVEMENT_HINT_TIMEOUT = 15.5
local DRAG_HINT_TIMEOUT = 22.5
local TESTING = true
local ZOOM_OUT_DISTANCE = 60

local TutorialGui = script.Parent

local MovementHint = WaitForChild(TutorialGui, &apos;MovementHint&apos;)
local PushingHint = WaitForChild(TutorialGui, &apos;PushingHint&apos;)
local DraggingHint = WaitForChild(TutorialGui, &apos;DraggingHint&apos;)
local ButtonHint = WaitForChild(TutorialGui, &apos;ButtonHint&apos;)

local LevelChangeScript = WaitForChild(Workspace, &apos;LevelChangeScript&apos;)
local LevelsPointersModel = WaitForChild(LevelChangeScript, &apos;LevelPointers&apos;)

local PlayersService = Game:GetService(&apos;Players&apos;)
local MyPlayer = script.Parent.Parent.Parent --PlayersService.localPlayer
local MyCharacter
repeat
&#9;MyCharacter = MyPlayer.Character
&#9;wait()
until MyCharacter and MyCharacter.Parent == Game.Workspace
MyPlayer.CharacterAdded:connect(function(char) MyCharacter = char print(&quot;New char&quot;) end)
local MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
local MyHead = WaitForChild(MyCharacter, &apos;Head&apos;)

local MyCamera = Workspace.CurrentCamera
local CameraSubject = MyCamera.CameraSubject

local LevelChangeScript = WaitForChild(Workspace, &apos;LevelChangeScript&apos;)
local CurrentLevelPointer = WaitForChild(LevelChangeScript, &apos;CurrentLevel&apos;)
-- These values can be nil
local CurrentLevel = CurrentLevelPointer.Value
local CurrentStar
if CurrentLevel then
&#9;WaitForChild(CurrentLevel, &apos;Star&apos;)
end

local DEBUG_PRINT = true
function DebugPrint(...)
&#9;if DEBUG_PRINT then
&#9;&#9;print(...)
&#9;end
end

local LastMovedTime = tick()
local LastMoveSpeed = 0

local LastDragTime = tick()
local LastDragLocation

function IsTouchEnabled()
&#9;local success, touchEnabled = pcall(function() return Game:GetService(&apos;UserInputService&apos;).TouchEnabled end)
&#9;return success and touchEnabled
end

MyPlayer.CharacterAdded:connect(function(char)
&#9;MyCharacter = char
&#9;MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
end)

MyHumanoid.Running:connect(function(speed)
&#9;LastMovedTime = tick()
&#9;LastMoveSpeed = speed
end)

CurrentLevelPointer.Changed:connect(function()
&#9;CurrentLevel = CurrentLevelPointer.Value
&#9;if CurrentLevel then
&#9;&#9;CurrentStar = WaitForChild(CurrentLevel, &apos;Star&apos;)
&#9;end
end)


function RayIgnoreCheck(hit, pos)
&#9;if hit then
&#9;&#9;return (hit.Transparency &gt;= 0.96 or hit.CanCollide == false)
&#9;end
&#9;return false
end

-- @preconditions: vec should be a unit vector
function RayCast(startPos, vec, rayLength)
&#9;local hitObject, hitPos = game.Workspace:FindPartOnRay(Ray.new(startPos + (vec * .01), vec * rayLength), Handle)
&#9;if hitObject and hitPos then
&#9;&#9;local distance = rayLength - (hitPos - startPos).magnitude
&#9;&#9;if RayIgnoreCheck(hitObject, hitPos) and distance &gt; 0 then
&#9;&#9;&#9;return RayCast(hitPos, vec, distance)
&#9;&#9;end
&#9;end
&#9;return hitObject, hitPos
end

local function PointOnCircle(originX, originZ, radius, theta)
&#9;local x = originX + radius * math.cos(theta)
&#9;local z = originZ + radius * math.sin(theta)
&#9;return Vector3.new(0, z, x)
end

function NLerp(start, final, ratio)
&#9;return start:Lerp(final, ratio).unit
end

function CreateGoalGui(parentAdornee)
&#9;local gui = Instance.new(&apos;BillboardGui&apos;)
&#9;gui.Adornee = parentAdornee
&#9;gui.Size = UDim2.new(6, 0, 3, 0)
&#9;gui.StudsOffset = Vector3.new(0, 4, 0)
&#9;local frame = Instance.new(&apos;Frame&apos;)
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;frame.BackgroundTransparency = 1
&#9;frame.Parent = gui
&#9;local imgLabel = Instance.new(&apos;ImageLabel&apos;)
&#9;imgLabel.Image = &apos;http://www.roblox.com/asset/?id=99877955&apos;
&#9;imgLabel.Size = UDim2.new(1,0,1,0)
&#9;imgLabel.BackgroundTransparency = 1
&#9;imgLabel.Parent = frame
&#9;gui.Parent = parentAdornee
&#9;return gui
end


function ShowGoalTip()
&#9;wait(1)
&#9;if CurrentLevel and not CurrentStar then
&#9;&#9;CurrentStar = CurrentLevel:FindFirstChild(&apos;Star&apos;)
&#9;end
&#9;if CurrentLevel and CurrentStar then
&#9;&#9;while MyCamera.CameraType ~= Enum.CameraType.Scriptable do
&#9;&#9;&#9;MyCamera.CameraType = &apos;Scriptable&apos;
&#9;&#9;&#9;wait()
&#9;&#9;&#9;DebugPrint(&quot;Camera Type:&quot; , tostring(MyCamera.CameraType))
&#9;&#9;end
&#9;&#9;DebugPrint(&quot;Camera is now Scriptable&quot;)

&#9;&#9;local billboardGui = CreateGoalGui(CurrentStar)

&#9;&#9;local originalSubject = MyCamera.CameraSubject&#9;&#9;
&#9;&#9;local MyHead = MyPlayer.Character.Head
&#9;&#9;local shiftAmount = (MyCamera.CoordinateFrame.p - MyHead.CFrame.p).magnitude

&#9;&#9;local startPoint = MyHead.CFrame.p --+ Vector3.new(0, 10, 0)
&#9;&#9;local endPoint = WaitForChild(CurrentStar, &apos;Spike&apos;).CFrame.p
&#9;&#9;--[[ Let&apos;s shift over the points away from the star
&#9;&#9; so that the camera ends up looking at the star rather than being inside of it.]]
&#9;&#9;local shiftVector = (startPoint - endPoint).unit * shiftAmount
&#9;&#9;startPoint = startPoint + shiftVector
&#9;&#9;endPoint = endPoint + (shiftVector + Vector3.new(0, 15, 0)).unit * shiftAmount
&#9;&#9;local circleCenter = (endPoint - startPoint) / 2
&#9;&#9;local distance = (startPoint - endPoint).magnitude

&#9;&#9;local cameraStart = MyCamera.CoordinateFrame.p
&#9;&#9;-- Move camera slowly to the startPoint
&#9;&#9;for i = 0, 1, 0.05 do
&#9;&#9;&#9;MyCamera.CoordinateFrame = CFrame.new(cameraStart:Lerp(startPoint, i), MyHead.CFrame.p)
&#9;&#9;&#9;wait(0.03)
&#9;&#9;end
&#9;&#9;--MyCamera.CameraSubject = CurrentStar.Spike
&#9;&#9;for i = 0, 1, 0.015 do
&#9;&#9;&#9;local newPoint = startPoint:Lerp(endPoint, i) + Vector3.new(0, math.sin(math.pi * i) * (distance * 0.5), 0)
&#9;&#9;&#9;MyCamera.CoordinateFrame = CFrame.new(newPoint, CurrentStar.Spike.CFrame.p)
&#9;&#9;&#9;wait(0.03)
&#9;&#9;end
&#9;&#9;-- Give the player 1 second of time to look at the star
&#9;&#9;wait(1)
&#9;&#9;-- Move the camera back to the player time
&#9;&#9;local cameraSpeed = 3
&#9;&#9;local seconds = distance / cameraSpeed
&#9;&#9;local stepSize = 1 / seconds
&#9;&#9;for i = 0, 1, stepSize do
&#9;&#9;&#9;local nextPoint = endPoint:Lerp(startPoint, i)
&#9;&#9;&#9;MyCamera.CoordinateFrame = CFrame.new(nextPoint, CurrentStar.Spike.CFrame.p)
&#9;&#9;&#9;wait(0.03)
&#9;&#9;end

&#9;&#9;billboardGui:Destroy()
&#9;&#9;while MyCamera.CameraType ~= Enum.CameraType.Custom do
&#9;&#9;&#9;MyCamera.CameraType = &apos;Custom&apos;
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;&#9;MyCamera.CameraSubject = originalSubject

&#9;&#9;DebugPrint(&quot;Done&quot;)
&#9;else
&#9;&#9;DebugPrint(&quot;ShowGoalTip Error: Current Level:&quot; , CurrentLevel , &quot;Current Star is:&quot; , CurrentStar)
&#9;end
end

-- Easy tree traversal, infinite loops on cycles
local function BFS(model, functor, ...)
&#9;local queue = {}
&#9;table.insert(queue, model)
&#9;while #queue &gt; 0 do
&#9;&#9;local currNode = table.remove(queue, 1)
&#9;&#9;-- replace currNode with prefab
&#9;&#9;local result = functor(currNode, ...)
&#9;&#9;if result then
&#9;&#9;&#9;return result
&#9;&#9;end
&#9;&#9;for _, child in pairs(currNode:GetChildren()) do
&#9;&#9;&#9;table.insert(queue, child)&#9;&#9;&#9;&#9;
&#9;&#9;end
&#9;end
end

local MovementHintOn = false
function DisplayMovementHint()
&#9;if MovementHintOn then return end
&#9;MovementHintOn = true
&#9;if not MyCharacter.Parent then return end
&#9;MovementHint:TweenPosition(UDim2.new(0, 0, 1, -200))
&#9;DebugPrint(&quot;WAITING&quot;)
&#9;DebugPrint(MyHumanoid)
&#9;DebugPrint(MyHumanoid.Parent)
&#9;--MyHumanoid.Running:wait()
&#9;local MyTorso = WaitForChild(MyCharacter, &quot;Torso&quot;)
&#9;while (MyTorso.Velocity * Vector3.new(1, 0, 1)).magnitude &lt; 8 do wait(.25) end
&#9;DebugPrint(&quot;RUNNING&quot;)
&#9;MovementHint:TweenPosition(UDim2.new(0, 0, 1, 50))
&#9;MovementHintOn = false
end

function DisplayDraggingHint()
&#9;DebugPrint(&quot;DRAGGING HINT HERE&quot;)
&#9;DraggingHint.Visible = true
end
function RemoveDraggingHint()
&#9;DraggingHint.Visible = false
end

function BestowKnowsDragging()
&#9;local knowsDragging = Instance.new(&apos;BoolValue&apos;)
&#9;knowsDragging.Value = true
&#9;knowsDragging.Name = &apos;knowsDragging&apos;
&#9;knowsDragging.Parent = MyPlayer
end

local DragHintOn = false
function ListenForDragging()
&#9;local moveGui
&#9;local dragToLocation
&#9;for i = 0, DRAG_HINT_TIMEOUT, 1 do
&#9;&#9;wait(1)
&#9;&#9;moveGui = MyPlayer.PlayerGui:FindFirstChild(&apos;MoveGui&apos;)
&#9;&#9;if moveGui then
&#9;&#9;&#9;dragToLocation = moveGui:FindFirstChild(&apos;DragToLocation&apos;)&#9;&#9;
&#9;&#9;&#9;LastDragLocation = dragToLocation.Value
&#9;&#9;&#9;wait(DRAG_HINT_TIMEOUT - i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
&#9;if LastDragLocation and dragToLocation and dragToLocation.Value and (LastDragLocation - dragToLocation.Value).magnitude &gt; 3 then
&#9;&#9;-- They successfully dragged
&#9;&#9;BestowKnowsDragging()
&#9;else
&#9;&#9;DisplayDraggingHint()
&#9;end
&#9;moveGui = WaitForChild(MyPlayer.PlayerGui, &apos;MoveGui&apos;)
&#9;dragToLocation = WaitForChild(moveGui, &apos;DragToLocation&apos;)
&#9;dragToLocation.Changed:wait()
&#9;RemoveDraggingHint()
&#9;BestowKnowsDragging()
end


function DisplayPushingHint()
&#9;PushingHint.Visible = true
&#9;DebugPrint(&quot;PUSHING HINT HERE&quot;)
end
function RemovePushingHint()
&#9;PushingHint.Visible = false
&#9;BestowKnowsPushing()
end

function BestowKnowsPushing()
&#9;local knowsPushing = Instance.new(&apos;BoolValue&apos;)
&#9;knowsPushing.Value = true
&#9;knowsPushing.Name = &apos;knowsPushing&apos;
&#9;knowsPushing.Parent = MyPlayer
end

local PushingHintOn = false
function ListenForPushingOnABlock(block)
&#9;if PushingHintOn then return end
&#9;PushingHintOn = true
&#9;local MyTorso = MyCharacter:FindFirstChild(&apos;Torso&apos;)
&#9;while ((MyTorso.CFrame.p - block.CFrame.p) * Vector3.new(1, 5, 1)).magnitude &gt; 25 do
&#9;&#9;wait(1)
&#9;end
&#9;DisplayPushingHint()
&#9;local blockPos = block.CFrame.p
&#9;while blockPos == block.CFrame.p do
&#9;&#9;wait(0.5)
&#9;end
&#9;RemovePushingHint()
&#9;PushingHintOn = false
end

function DisplayButtonHint()
&#9;ButtonHint.Visible = true
&#9;DebugPrint(&quot;PUSHING HINT HERE&quot;)
end
function RemoveButtonHint()
&#9;ButtonHint.Visible = false
&#9;BestowKnowsButtons()
end

function BestowKnowsButtons()
&#9;local knowsButtons = Instance.new(&apos;BoolValue&apos;)
&#9;knowsButtons.Value = true
&#9;knowsButtons.Name = &apos;knowsButtons&apos;
&#9;knowsButtons.Parent = MyPlayer
end

local ButtonsHintOn = false
function ListenForButtons()
&#9;if ButtonsHintOn then return end
&#9;ButtonsHintOn = true
&#9;wait(1)
&#9;DisplayButtonHint()
&#9;wait(7)
&#9;RemoveButtonHint()
&#9;ButtonsHintOn = false
end

if CurrentLevel and LevelsPointersModel and
&#9;&#9;LevelsPointersModel:FindFirstChild(CurrentLevel.Name) and 
&#9;&#9;not LevelsPointersModel:FindFirstChild(CurrentLevel.Name):FindFirstChild(&apos;Completed&apos;) then
&#9;ShowGoalTip()
end
wait(1)
if not MyPlayer:FindFirstChild(&apos;knowsDragging&apos;) and CurrentLevel then
&#9;Spawn(ListenForDragging)
end

if CurrentLevel and not MyPlayer:FindFirstChild(&apos;knowsPushing&apos;) and CurrentLevel.Name == &quot;Tram&quot; then
&#9;--BFS(CurrentLevel, function(currNode) if currNode:IsA(&apos;BasePart&apos;) and currNode.BrickColor == BrickColor.new(&apos;Bright red&apos;) then return true end end) then
&#9;local pushingBlock = WaitForChild(WaitForChild(CurrentLevel, &apos;Pushable&apos;), &apos;Pushable&apos;)
&#9;coroutine.wrap(ListenForPushingOnABlock)(pushingBlock)
end

if not MyPlayer:FindFirstChild(&apos;knowsButtons&apos;) and CurrentLevel and CurrentLevel.Name == &quot;Button1&quot; then
&#9;Spawn(ListenForButtons)
end

while true do
&#9;if IsTouchEnabled() or TESTING then
&#9;&#9;if (tick() - LastMovedTime) &gt; MOVEMENT_HINT_TIMEOUT and LastMoveSpeed == 0 and MyHumanoid and MyHumanoid.Health &gt; 0 then
&#9;&#9;&#9;--Spawn(DisplayMovementHint)
&#9;&#9;end
&#9;end
&#9;wait(1)
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX118">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MovementHint</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>50</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>200</XO>
						<YS>0</YS>
						<YO>200</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextBox" referent="RBX119">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">5</token>
						<bool name="MultiLine">false</bool>
						<string name="Name">Hint</string>
						<UDim2 name="Position">
							<XS>0.25</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Touch here to move.</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX120">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">DraggingHint</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-256</XO>
						<YS>0.5</YS>
						<YO>-256</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>512</XO>
						<YS>0</YS>
						<YO>384</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextBox" referent="RBX121">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">1</token>
						<token name="FontSize">8</token>
						<bool name="MultiLine">false</bool>
						<string name="Name">Hint</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Drag on yellow blocks to move them.</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX122">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=99876310</url></Content>
						<string name="Name">ImageLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>512</XO>
							<YS>0</YS>
							<YO>256</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX123">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">PushingHint</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-256</XO>
						<YS>0.5</YS>
						<YO>-256</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>512</XO>
						<YS>0</YS>
						<YO>384</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextBox" referent="RBX124">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">1</token>
						<token name="FontSize">8</token>
						<bool name="MultiLine">false</bool>
						<string name="Name">Hint</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Push red blocks to move them.</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX125">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=99875990</url></Content>
						<string name="Name">ImageLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>512</XO>
							<YS>0</YS>
							<YO>256</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX126">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ButtonHint</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-256</XO>
						<YS>0.5</YS>
						<YO>-256</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>512</XO>
						<YS>0</YS>
						<YO>384</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextBox" referent="RBX127">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">1</token>
						<token name="FontSize">8</token>
						<bool name="MultiLine">false</bool>
						<string name="Name">Hint</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Tap the green buttons to move the pillars.</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX128">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=99876452</url></Content>
						<string name="Name">ImageLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>512</XO>
							<YS>0</YS>
							<YO>256</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX129">
			<Properties>
				<string name="Name">DiedGui</string>
			</Properties>
			<Item class="Frame" referent="RBX130">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">DiedFrame</string>
					<UDim2 name="Position">
						<XS>0.25</XS>
						<XO>0</XO>
						<YS>-0.5</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.400000006</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX131">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">1</token>
						<token name="FontSize">7</token>
						<string name="Name">Instructions</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.400000006</YS>
							<YO>20</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">You Win</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX132">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">Respawn</string>
						<UDim2 name="Position">
							<XS>0.330000013</XS>
							<XO>-63</XO>
							<YS>0.800000012</YS>
							<YO>-25</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>115</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">Replay</string>
						<Color3 name="TextColor3">4294901756</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">6</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX133">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DiedGuiScript</string>
					<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DiedGui = script.Parent
local DiedFrame = WaitForChild(DiedGui, &apos;DiedFrame&apos;)

local LevelChangeScript = WaitForChild(Workspace, &apos;LevelChangeScript&apos;)
local CurrentLevelPointer = WaitForChild(LevelChangeScript, &apos;CurrentLevel&apos;)
local RequestedLevel = WaitForChild(LevelChangeScript, &apos;RequestedLevel&apos;)

local LightingService = Game:GetService(&apos;Lighting&apos;)
local LevelsPointersModel = WaitForChild(LevelChangeScript, &apos;LevelPointers&apos;)



local MyPlayer = script.Parent.Parent.Parent
local MyCharacter
repeat
&#9;MyCharacter = MyPlayer.Character
&#9;wait()
until MyCharacter and MyCharacter.Parent == Game.Workspace
local MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)


function ChangeLevel(level)
&#9;if not level then DebugPrint(&quot;Requested Level is nil&quot;) return end
&#9;if RequestedLevel then
&#9;&#9;RequestedLevel.Value = level
&#9;end
end


MyHumanoid.Died:connect(function()
&#9;if CurrentLevelPointer and CurrentLevelPointer.Value then
&#9;&#9;-- Maybe we can show a gui here &quot;You Died&quot;
&#9;&#9;local thisLevel = LevelsPointersModel:FindFirstChild(CurrentLevelPointer.Value.Name)
&#9;&#9;ChangeLevel(thisLevel)
&#9;else
&#9;&#9;print(&quot;Current level pointer issue.&quot;)
&#9;end
end)

print(&apos;DiedGui Script Loaded&apos;)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX134">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">10</float>
			<float name="DopplerScale">1</float>
			<string name="Name">Soundscape</string>
			<float name="RolloffScale">1</float>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX135">
		<Properties>
			<string name="Name">CollectionService</string>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX136">
		<Properties>
			<string name="Name">PhysicsService</string>
		</Properties>
	</Item>
	<Item class="BadgeService" referent="RBX137">
		<Properties>
			<string name="Name">BadgeService</string>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX138">
		<Properties>
			<string name="Name">Geometry</string>
		</Properties>
	</Item>
	<Item class="RenderHooksService" referent="RBX139">
		<Properties>
			<string name="Name">RenderHooksService</string>
		</Properties>
	</Item>
	<Item class="SocialService" referent="RBX140">
		<Properties>
			<string name="Name">SocialService</string>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX141">
		<Properties>
			<string name="Name">GamePassService</string>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX142">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX143">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ScriptInformationProvider" referent="RBX144">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX145">
		<Properties>
			<string name="Name">CookiesService</string>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX146">
		<Properties>
			<string name="Name">Teleport Service</string>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX147">
		<Properties>
			<bool name="CharacterAutoLoads">false</bool>
			<string name="Name">Players</string>
		</Properties>
	</Item>
	<Item class="FWService" referent="RBX148">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="UserInputService" referent="RBX149">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX150">
		<Properties>
			<string name="Name">Selection</string>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX151">
		<Properties>
			<Color3 name="Ambient">4286611584</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">4278190080</Color3>
			<Color3 name="ColorShift_Top">4278190080</Color3>
			<Color3 name="FogColor">4290822336</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<string name="Name">Lighting</string>
			<Color3 name="ShadowColor">4289967032</Color3>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
		<Item class="Part" referent="RBX152">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">1002</int>
				<CoordinateFrame name="CFrame">
					<X>-3</X>
					<Y>49.7999992</Y>
					<Z>73</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">LevelStartPad</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>0.400000006</Y>
					<Z>4</Z>
				</Vector3>
			</Properties>
			<Item class="Decal" referent="RBX153">
				<Properties>
					<token name="Face">1</token>
					<string name="Name">Decal</string>
					<float name="Shiny">20</float>
					<float name="Specular">0</float>
					<Content name="Texture"><url>rbxasset://Textures/SpawnLocation.png</url></Content>
					<float name="Transparency">0</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX154">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">1004</int>
				<CoordinateFrame name="CFrame">
					<X>-16.0940285</X>
					<Y>2.73790979</Y>
					<Z>15</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Laser</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.300000012</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
			<Item class="CylinderMesh" referent="RBX155">
				<Properties>
					<float name="Bevel">0</float>
					<float name="Bevel Roundness">0</float>
					<float name="Bulge">0</float>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>4</Y>
						<Z>1</Z>
					</Vector3>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Sky" referent="RBX156">
			<Properties>
				<bool name="CelestialBodiesShown">true</bool>
				<string name="Name">{ Nauralus Vega_ }</string>
				<Content name="SkyboxBk"><url>http://www.roblox.com/asset/?id=47974894</url></Content>
				<Content name="SkyboxDn"><url>http://www.roblox.com/asset/?id=47974690</url></Content>
				<Content name="SkyboxFt"><url>http://www.roblox.com/asset/?id=47974821</url></Content>
				<Content name="SkyboxLf"><url>http://www.roblox.com/asset/?id=47974776</url></Content>
				<Content name="SkyboxRt"><url>http://www.roblox.com/asset/?id=47974859</url></Content>
				<Content name="SkyboxUp"><url>http://www.roblox.com/asset/?id=47974909</url></Content>
				<int name="StarCount">3000</int>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX157">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">StarterLevel</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX158">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">BigPlate</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Part" referent="RBX159">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1002</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.30000007</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">BasePlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>100</X>
							<Y>1.20000005</Y>
							<Z>100</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX160">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1002</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.20000005</Y>
							<Z>0</Z>
							<R00>0.707106709</R00>
							<R01>0</R01>
							<R02>0.707106829</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.707106829</R20>
							<R21>0</R21>
							<R22>0.707106709</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">ExtraPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>100</X>
							<Y>1.20000005</Y>
							<Z>100</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX161">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1002</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.10000002</Y>
							<Z>0</Z>
							<R00>0.382683307</R00>
							<R01>0</R01>
							<R02>0.923879564</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.923879564</R20>
							<R21>0</R21>
							<R22>0.382683307</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">ExtraPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>100</X>
							<Y>1.20000005</Y>
							<Z>100</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX162">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1002</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>0.923879504</R00>
							<R01>0</R01>
							<R02>0.382683456</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.382683456</R20>
							<R21>0</R21>
							<R22>0.923879504</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">ExtraPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>100</X>
							<Y>1.20000005</Y>
							<Z>100</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX163">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">GoldPlate</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Part" referent="RBX164">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">151</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.56250072</Y>
							<Z>0</Z>
							<R00>0.382683307</R00>
							<R01>0</R01>
							<R02>0.923879564</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.923879564</R20>
							<R21>0</R21>
							<R22>0.382683307</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>75</X>
							<Y>0.900000036</Y>
							<Z>75</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX165">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">151</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.63750052</Y>
							<Z>0</Z>
							<R00>0.707106709</R00>
							<R01>0</R01>
							<R02>0.707106829</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.707106829</R20>
							<R21>0</R21>
							<R22>0.707106709</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>75</X>
							<Y>0.900000036</Y>
							<Z>75</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX166">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">151</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.48750043</Y>
							<Z>0</Z>
							<R00>0.923879504</R00>
							<R01>0</R01>
							<R02>0.382683456</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.382683456</R20>
							<R21>0</R21>
							<R22>0.923879504</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>75</X>
							<Y>0.900000036</Y>
							<Z>75</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX167">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">151</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.71249986</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>75</X>
							<Y>0.900000036</Y>
							<Z>75</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX168">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">GoldPlate</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Part" referent="RBX169">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">102</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.97187543</Y>
							<Z>0</Z>
							<R00>0.382683307</R00>
							<R01>0</R01>
							<R02>0.923879564</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.923879564</R20>
							<R21>0</R21>
							<R22>0.382683307</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>56.25</X>
							<Y>0.675000012</Y>
							<Z>56.25</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX170">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">102</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.02812529</Y>
							<Z>0</Z>
							<R00>0.707106709</R00>
							<R01>0</R01>
							<R02>0.707106829</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.707106829</R20>
							<R21>0</R21>
							<R22>0.707106709</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>56.25</X>
							<Y>0.675000012</Y>
							<Z>56.25</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX171">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">102</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1.91562533</Y>
							<Z>0</Z>
							<R00>0.923879504</R00>
							<R01>0</R01>
							<R02>0.382683456</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.382683456</R20>
							<R21>0</R21>
							<R22>0.923879504</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>56.25</X>
							<Y>0.675000012</Y>
							<Z>56.25</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX172">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">102</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.0843749</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>56.25</X>
							<Y>0.675000012</Y>
							<Z>56.25</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX173">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">GoldPlate</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Part" referent="RBX174">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1026</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.27890635</Y>
							<Z>0</Z>
							<R00>0.382683307</R00>
							<R01>0</R01>
							<R02>0.923879564</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.923879564</R20>
							<R21>0</R21>
							<R22>0.382683307</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>42.1875</X>
							<Y>0.506250024</Y>
							<Z>42.1875</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX175">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1026</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.3210938</Y>
							<Z>0</Z>
							<R00>0.707106709</R00>
							<R01>0</R01>
							<R02>0.707106829</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.707106829</R20>
							<R21>0</R21>
							<R22>0.707106709</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>42.1875</X>
							<Y>0.506250024</Y>
							<Z>42.1875</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX176">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1026</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.23671889</Y>
							<Z>0</Z>
							<R00>0.923879504</R00>
							<R01>0</R01>
							<R02>0.382683456</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.382683456</R20>
							<R21>0</R21>
							<R22>0.923879504</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>42.1875</X>
							<Y>0.506250024</Y>
							<Z>42.1875</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX177">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<int name="BrickColor">1026</int>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>2.36328101</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<float name="Elasticity">0.5</float>
						<float name="Friction">0.300000012</float>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<token name="Material">1056</token>
						<string name="Name">GoldPlate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>42.1875</X>
							<Y>0.506250024</Y>
							<Z>42.1875</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="SpawnLocation" referent="RBX178">
				<Properties>
					<bool name="AllowTeamChangeOnTouch">false</bool>
					<bool name="Anchored">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">2</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">2</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">1002</int>
					<CoordinateFrame name="CFrame">
						<X>1.5978775</X>
						<Y>9.72869015</Y>
						<Z>5.588974</Z>
						<R00>-1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>-1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<int name="Duration">10</int>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">2</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">2</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">StarterLevelSpawnLocation</string>
					<bool name="Neutral">true</bool>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">2</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int name="TeamColor">194</int>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>6</X>
						<Y>1.20000005</Y>
						<Z>6</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX179">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>83</X>
					<Y>29</Y>
					<Z>46</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="Decal" referent="RBX180">
				<Properties>
					<token name="Face">2</token>
					<string name="Name">Decal</string>
					<float name="Shiny">20</float>
					<float name="Specular">0</float>
					<Content name="Texture"><url>http://www.roblox.com/asset/?id=69969602</url></Content>
					<float name="Transparency">0</float>
				</Properties>
			</Item>
			<Item class="Decal" referent="RBX181">
				<Properties>
					<token name="Face">1</token>
					<string name="Name">Decal</string>
					<float name="Shiny">20</float>
					<float name="Specular">0</float>
					<Content name="Texture"><url>http://www.roblox.com/asset/?id=69969584</url></Content>
					<float name="Transparency">0</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX182">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>62</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="BillboardGui" referent="RBX183">
				<Properties>
					<bool name="Active">false</bool>
					<Ref name="Adornee">RBX182</Ref>
					<bool name="AlwaysOnTop">false</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">BillboardGui</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>8</XS>
						<XO>0</XO>
						<YS>4</YS>
						<YO>0</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>4</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="Frame" referent="RBX184">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294963456</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4294935552</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX185">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=62493773</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Decal" referent="RBX186">
				<Properties>
					<token name="Face">5</token>
					<string name="Name">Decal</string>
					<float name="Shiny">20</float>
					<float name="Specular">0</float>
					<Content name="Texture"><url>http://www.roblox.com/asset/?id=62493773</url></Content>
					<float name="Transparency">0</float>
				</Properties>
			</Item>
		</Item>
		<Item class="TextButton" referent="RBX187">
			<Properties>
				<bool name="Active">true</bool>
				<bool name="AutoButtonColor">true</bool>
				<Color3 name="BackgroundColor3">4288914085</Color3>
				<float name="BackgroundTransparency">0</float>
				<Color3 name="BorderColor3">4279970357</Color3>
				<int name="BorderSizePixel">1</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<token name="Font">0</token>
				<token name="FontSize">6</token>
				<bool name="Modal">false</bool>
				<string name="Name">Rotate</string>
				<UDim2 name="Position">
					<XS>0.449999988</XS>
					<XO>0</XO>
					<YS>0.824999988</YS>
					<YO>0</YO>
				</UDim2>
				<bool name="Selected">false</bool>
				<UDim2 name="Size">
					<XS>0.0700000003</XS>
					<XO>0</XO>
					<YS>0.0700000003</YS>
					<YO>0</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<token name="Style">2</token>
				<string name="Text">Rotate</string>
				<Color3 name="TextColor3">4292269782</Color3>
				<bool name="TextScaled">false</bool>
				<Color3 name="TextStrokeColor3">4278190080</Color3>
				<float name="TextStrokeTransparency">1</float>
				<float name="TextTransparency">0</float>
				<bool name="TextWrapped">false</bool>
				<token name="TextXAlignment">2</token>
				<token name="TextYAlignment">1</token>
				<bool name="Visible">true</bool>
				<int name="ZIndex">1</int>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX188">
			<Properties>
				<string name="Name">MoveGui</string>
			</Properties>
			<Item class="Frame" referent="RBX189">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Frame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>-20</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBX190">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">8</token>
						<bool name="Modal">false</bool>
						<string name="Name">Up</string>
						<UDim2 name="Position">
							<XS>0.449999988</XS>
							<XO>0</XO>
							<YS>0.75</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.0700000003</XS>
							<XO>0</XO>
							<YS>0.0700000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">^</string>
						<Color3 name="TextColor3">4292269782</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX191">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">8</token>
						<bool name="Modal">false</bool>
						<string name="Name">Right</string>
						<UDim2 name="Position">
							<XS>0.524999976</XS>
							<XO>0</XO>
							<YS>0.824999988</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.0700000003</XS>
							<XO>0</XO>
							<YS>0.0700000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">&gt;</string>
						<Color3 name="TextColor3">4292269782</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX192">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">8</token>
						<bool name="Modal">false</bool>
						<string name="Name">Left</string>
						<UDim2 name="Position">
							<XS>0.375</XS>
							<XO>0</XO>
							<YS>0.824999988</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.0700000003</XS>
							<XO>0</XO>
							<YS>0.0700000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">&lt;</string>
						<Color3 name="TextColor3">4292269782</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX193">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">8</token>
						<bool name="Modal">false</bool>
						<string name="Name">Down</string>
						<UDim2 name="Position">
							<XS>0.449999988</XS>
							<XO>0</XO>
							<YS>0.899999976</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.0700000003</XS>
							<XO>0</XO>
							<YS>0.0700000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">v</string>
						<Color3 name="TextColor3">4292269782</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX194">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4278190080</Color3>
						<float name="BackgroundTransparency">0.300000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=59103214</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">Rotate</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-32</XO>
							<YS>0.824999988</YS>
							<YO>-32</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="CFrameValue" referent="RBX195">
				<Properties>
					<string name="Name">CurrentCameraCFrame</string>
					<CoordinateFrame name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
				</Properties>
			</Item>
			<Item class="Vector3Value" referent="RBX196">
				<Properties>
					<string name="Name">DragToLocation</string>
					<Vector3 name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX197">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerDragScript</string>
					<ProtectedString name="Source">local DRAG_SPEED = 4
local DRAG_PRECISION = .125
local STEP_PRECISION = .25

function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
&#9;return parent[child]
end

local DRAG_ERROR_COLOR = BrickColor.new(&apos;Really black&apos;)
local DRAG_ERROR_TIME = 0.4
local LastDragErrorTime = tick()
local PreviousSelectionBoxColor = BrickColor.new(&apos;Hot pink&apos;)

local LastSuccessfulDragTime = tick()
local SUCCESSFUL_DRAG_TIMEOUT = 0.15
local SUCCESSFUL_DRAG_THRESHOLD = 0.15

local moveGui = script.Parent
local moveGuiFrame = WaitForChild(moveGui, &quot;Frame&quot;)
local DragToLocation = WaitForChild(moveGui, &quot;DragToLocation&quot;)
local DragSelectionBox = WaitForChild(moveGui, &quot;DragSelectionBox&quot;)

local draggingModel = WaitForChild(workspace, &quot;DraggingModel&quot;)
local CurrentCameraCFrame = WaitForChild(moveGui, &quot;CurrentCameraCFrame&quot;)


local CantDragSound = WaitForChild(script, &apos;CantDrag&apos;)
local LastCantDragTime = tick()
local SoundDuration = 0.6

function vectorMin(vecA, vecB)
&#9;return Vector3.new(math.min(vecA.X, vecB.X), math.min(vecA.Y, vecB.Y), math.min(vecA.Z, vecB.Z))
end

function vectorMax(vecA, vecB)
&#9;return Vector3.new(math.max(vecA.X, vecB.X), math.max(vecA.Y, vecB.Y), math.max(vecA.Z, vecB.Z))
end

function calculateExtents(partCFrame, partSize)
&#9;local boundingVectorA = partCFrame:pointToWorldSpace(partSize/2)
&#9;local boundingVectorB = partCFrame:pointToWorldSpace(-partSize/2)
&#9;return vectorMin(boundingVectorA, boundingVectorB), vectorMax(boundingVectorA, boundingVectorB)
end

function recursiveCentroidHelper(model, centroidSoFar, numPartsSoFar)
&#9;local modelChildren = model:GetChildren()
&#9;for i = 1, #modelChildren do
&#9;&#9;if modelChildren[i]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;centroidSoFar = centroidSoFar + modelChildren[i].CFrame.p
&#9;&#9;&#9;numPartsSoFar = numPartsSoFar + 1
&#9;&#9;end
&#9;&#9;centroidSoFar, numPartsSoFar = recursiveCentroidHelper(modelChildren[i], centroidSoFar, numPartsSoFar)
&#9;end
&#9;return centroidSoFar, numPartsSoFar
end

function calculateCentroid(model)
&#9;-- below line should work, but doesn&apos;t because we don&apos;t always invalidate the model CFrame when we should
&#9;-- model:GetModelCFrame().p

&#9;-- so instead, just step thru
&#9;local centroid = Vector3.new(0, 0, 0)
&#9;local numParts = 0

&#9;centroid, numParts = recursiveCentroidHelper(model, centroid, numParts)

&#9;if numParts &gt; 0 then centroid = centroid / numParts end
&#9;return centroid
end

function playCantDragSound()
&#9;if tick() - LastSuccessfulDragTime &gt; SUCCESSFUL_DRAG_TIMEOUT then
&#9;&#9;local posixTime = tick()
&#9;&#9;if CantDragSound and (posixTime - LastCantDragTime) &gt; SoundDuration then
&#9;&#9;&#9;CantDragSound:Play()
&#9;&#9;&#9;LastCantDragTime = posixTime
&#9;&#9;end
&#9;end
end

function playRotateErrorSound()
&#9;playCantDragSound()
end

function DisplayDragError()
&#9;if tick() - LastSuccessfulDragTime &gt; SUCCESSFUL_DRAG_TIMEOUT then
&#9;&#9;local currTime = tick()
&#9;&#9;DragSelectionBox.Color = DRAG_ERROR_COLOR
&#9;&#9;LastDragErrorTime = currTime
&#9;&#9;wait(DRAG_ERROR_TIME)
&#9;&#9;if currTime == LastDragErrorTime then
&#9;&#9;&#9;DragSelectionBox.Color = PreviousSelectionBoxColor
&#9;&#9;end
&#9;end
end

local DRAG_DIRECTIONS = {UP = Vector3.new(0, 0, -1), DOWN = Vector3.new(0, 0, 1), LEFT = Vector3.new(-1, 0, 0), RIGHT = Vector3.new(1, 0, 0)}
local FUDGE_VECTOR = Vector3.new(.2, .2, .2)

function tryAbsoluteDrag(absoluteDir, dragDistance)
&#9;local objectsToMove = draggingModel:GetChildren()  -- effectively &quot;lock&quot; the objects we want to drag&#9;
&#9;local movementVector = absoluteDir * dragDistance

&#9;-- check here to see if dragging is ok&#9;
&#9;for i = 1, #objectsToMove do
&#9;&#9;local minExtents, maxExtents = calculateExtents(objectsToMove[i].CFrame + movementVector, objectsToMove[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then playCantDragSound() Spawn(DisplayDragError) return false end -- don&apos;t continue with drag if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end

&#9;-- if ok, then just translate the CFrames
&#9;for i = 1, #objectsToMove do
&#9;&#9;objectsToMove[i].CFrame = objectsToMove[i].CFrame + movementVector
&#9;end
&#9;if movementVector.magnitude &gt; SUCCESSFUL_DRAG_THRESHOLD then
&#9;&#9;LastSuccessfulDragTime = tick()
&#9;&#9;if (tick() - LastDragErrorTime) &gt; 0.15 then
&#9;&#9;&#9;DragSelectionBox.Color = PreviousSelectionBoxColor
&#9;&#9;end
&#9;&#9;--Delay(math.max(0, 0.15 - (tick() - LastDragErrorTime)), function() DragSelectionBox.Color = PreviousSelectionBoxColor end)
&#9;end
&#9;return true
end

function iterativeAbsoluteDrag(absoluteDir, stepSize)
&#9;local dragDistance = stepSize
&#9;while dragDistance &gt;= DRAG_PRECISION and not tryAbsoluteDrag(absoluteDir, dragDistance) do dragDistance = dragDistance / 2 end
end

function tryRelativeDrag(relativeDir)
&#9;local camFrame = CurrentCameraCFrame.Value

&#9;local indicatedDir = camFrame:vectorToWorldSpace(relativeDir)

&#9;-- match this with closest direction in absolute xz-plane
&#9;local bestMatchAmount = -10  -- less than -1,1 range of dot-products
&#9;local bestAbsoluteDir = nil
&#9;for _, absoluteDir in pairs(DRAG_DIRECTIONS) do
&#9;&#9;local matchAmount = absoluteDir:Dot(indicatedDir)
&#9;&#9;if matchAmount &gt; bestMatchAmount then
&#9;&#9;&#9;bestMatchAmount = matchAmount
&#9;&#9;&#9;bestAbsoluteDir = absoluteDir
&#9;&#9;end
&#9;end

&#9;iterativeAbsoluteDrag(bestAbsoluteDir, DRAG_SPEED)
end

-- returns cframe rotated 90-degrees about absolute y-axis at point
function rotateY(cframe, point)
&#9;return (CFrame.Angles(0, -math.pi/2, 0) * (cframe - point)) + point
end


function tryRotate()
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local objectsToRotate = draggingModel:GetChildren() -- effectively &quot;lock&quot; the objects we want to rotate

&#9;-- check here to see if the rotation is ok
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local newCFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;&#9;local minExtents, maxExtents = calculateExtents(newCFrame, objectsToRotate[i].Size)
&#9;&#9;local collidingParts = workspace:FindPartsInRegion3(Region3.new(minExtents + FUDGE_VECTOR, maxExtents - FUDGE_VECTOR), draggingModel, 5)
&#9;&#9;if #collidingParts &gt; 0 then return false end -- don&apos;t continue with rotation if we have ANY collisions of larger bounding box (very conservative for now)
&#9;end
&#9;
&#9;-- temporarily remove stabilizers and then re-add them with updated CFrames as well
&#9;local stabilizerParents = {}
&#9;for i = 1, #objectsToRotate do
&#9;&#9;local stabilizer = objectsToRotate[i]:FindFirstChild(&quot;TorqueStabilizer&quot;)
&#9;&#9;if stabilizer then
&#9;&#9;&#9;stabilizerParents[stabilizer] = stabilizer.Parent
&#9;&#9;&#9;stabilizer.Parent = nil
&#9;&#9;end
&#9;end

&#9;-- if ok, then just transform the CFrames
&#9;for i = 1, #objectsToRotate do
&#9;&#9;objectsToRotate[i].CFrame = rotateY(objectsToRotate[i].CFrame, centroid)
&#9;end

&#9;-- and re-add the stabilizers with updated CFrames
&#9;for stabilizer, stabilizerParent in pairs(stabilizerParents) do
&#9;&#9;stabilizer.cframe = rotateY(stabilizer.cframe, centroid)
&#9;&#9;stabilizer.Parent = stabilizerParent
&#9;end

&#9;return true
end

function onRotate()
&#9;if not tryRotate() then playRotateErrorSound() DisplayDragError() end
end

function onDown()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;DOWN&quot;])
end

function onUp()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;UP&quot;])
end

function onLeft()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;LEFT&quot;])
end

function onRight()
&#9;tryRelativeDrag(DRAG_DIRECTIONS[&quot;RIGHT&quot;])
end

function stepTowardsPoint(targetPoint)
&#9;local centroid = calculateCentroid(draggingModel)
&#9;local dragStepSize = DRAG_SPEED
&#9;if centroid.Z &gt; targetPoint.Z - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, -1), dragStepSize)
&#9;elseif centroid.Z &lt; targetPoint.Z + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.Z - centroid.Z))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(0, 0, 1), dragStepSize)
&#9;end
&#9;dragStepSize = DRAG_SPEED
&#9;if centroid.X &gt; targetPoint.X - STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(-1, 0, 0), dragStepSize)
&#9;elseif centroid.X &lt; targetPoint.X + STEP_PRECISION then
&#9;&#9;dragStepSize = math.min(dragStepSize, math.abs(targetPoint.X - centroid.X))
&#9;&#9;iterativeAbsoluteDrag(Vector3.new(1, 0, 0), dragStepSize)
&#9;end
end

function onDrag(targetPoint)
&#9;if targetPoint.Y ~= 0 then return end
&#9;local moveTries = (targetPoint - draggingModel:GetModelCFrame().p).magnitude / DRAG_SPEED
&#9;for i = 1, moveTries do
&#9;&#9;stepTowardsPoint(targetPoint)
&#9;end
end

WaitForChild(moveGuiFrame, &quot;Rotate&quot;).MouseButton1Click:connect(onRotate)
WaitForChild(moveGuiFrame, &quot;Left&quot;).MouseButton1Click:connect(onLeft)
WaitForChild(moveGuiFrame, &quot;Right&quot;).MouseButton1Click:connect(onRight)
WaitForChild(moveGuiFrame, &quot;Up&quot;).MouseButton1Click:connect(onUp)
WaitForChild(moveGuiFrame, &quot;Down&quot;).MouseButton1Click:connect(onDown)

DragToLocation.Changed:connect(onDrag)
</ProtectedString>
				</Properties>
				<Item class="Sound" referent="RBX198">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">CantDrag</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=99666774</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
			</Item>
			<Item class="SelectionBox" referent="RBX199">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">1032</int>
					<string name="Name">DragSelectionBox</string>
					<float name="Transparency">0.5</float>
					<bool name="Visible">true</bool>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ChangeHistoryService" referent="RBX200">
		<Properties>
			<string name="Name">ChangeHistoryService</string>
		</Properties>
	</Item>
</roblox>