<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0">
		<Properties>
			<Ref name="CurrentCamera">RBX1</Ref>
			<double name="DistributedGameTime">0</double>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Script" referent="RBX2">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DataPersistence</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
-- Constants
-----------------
--[[
&#9;Look up table of classNames coresponding to their correct persistent storeing function
--]]
local SAVE_FUNCTIONS = 
{
&#9;NumberValue = function(player, name, val) return player:SaveNumber(name, val.Value) end,
&#9;IntValue    = function(player, name, val) return player:SaveNumber(name, val.Value) end,
&#9;StringValue = function(player, name ,val) return player:SaveString(name, val.Value) end,
&#9;BoolValue   = function(player, name, val) return player:SaveBool(name, val.Value) end,
&#9;ObjectValue = function(player, name, val) return player:SaveInstance(name, val.Value) end,
}

--[[
&#9;Look up table of classNames coresponding to their correct persistent retreaving function
--]]
local FETCH_FUNCTIONS = 
{
&#9;NumberValue = function(player, name) return player:LoadNumber(name) end,
&#9;IntValue &#9;&#9;= function(player, name) return player:LoadNumber(name) end,
&#9;StringValue = function(player, name) return player:LoadString(name) end,
&#9;BoolValue   = function(player, name) return player:LoadBool(name) end,
&#9;ObjectValue = function(player, name) return player:LoadInstance(name) end,
}

----------------------
-- Workspace Variables
----------------------

local PlayersService = Game:GetService(&apos;Players&apos;)

--Wait for bindables
local RegisterNumber = WaitForChild(script, &apos;RegisterNumber&apos;)
local RegisterInt = WaitForChild(script, &apos;RegisterInt&apos;)
local RegisterString = WaitForChild(script, &apos;RegisterString&apos;)
local RegisterBool = WaitForChild(script, &apos;RegisterBool&apos;)
local RegisterInstance = WaitForChild(script, &apos;RegisterInstance&apos;)


----------------------
--Script Variables
----------------------
-- Locking table used to prevent race conditions, consists of keys of variables, and 
-- bool values for if the variable is locked
local LockTable = {}

-----------------------
--Global Functions
-----------------------

-- Variable lock system for preventing race conditions
local function Lock(var)
&#9;while LockTable[var] do
&#9;&#9;&#9;wait()
&#9;end
&#9;LockTable[var] = true
end

local function Unlock(var)
&#9;LockTable[var] = false
end


--[[
&#9;Fetches initial value for player&apos;s persistentKey, puts it in value
&#9;@Args
&#9;&#9;player &#9;&#9;player to fetch value from
&#9;&#9;value&#9;&#9;a ___value to store the fetched data in
&#9;&#9;persistentKey&#9;&#9;key to access stored persistent data
--]]
local function FetchValue(player, value, persistentKey)
&#9;player:WaitForDataReady()
&#9;Lock(value)
&#9;local success, _ = pcall(function() value.Value = FETCH_FUNCTIONS[value.ClassName](player, persistentKey) end)
&#9;Unlock(value)
end

--[[
&#9;Saves value.Value to player&apos;s persistentKey
&#9;@Args
&#9;&#9;player &#9;&#9;player to save value to
&#9;&#9;value&#9;&#9;a ___value to save to persistence
&#9;&#9;persistentKey&#9;&#9;key to overwrite in persistent data
--]]
local function SaveValue(player, value, persistentKey)
&#9;player:WaitForDataReady()
&#9;Lock(value) 
&#9;local success, _ = pcall(function() SAVE_FUNCTIONS[value.ClassName](player, persistentKey, value) end)
&#9;Unlock(value)
end

--[[
&#9;Shared initialization for setting up persistant values
&#9;@Args
&#9;&#9;player &#9;&#9;player to use
&#9;&#9;persistValue&#9;&#9;a ___value to use
&#9;&#9;persistentKey&#9;&#9;key to use for this value in persistent data
&#9;&#9;callback&#9;&#9;if exists, will be called when registering persistent data is complete
&#9;@Return&#9;&#9;new ____value that will auto save to persistence on changed
--]]
local function RegisterInit(player, persistValue, dataName, callback)
&#9;persistValue.Name = dataName
&#9;Spawn(function()
&#9;&#9;FetchValue(player, persistValue, dataName)
&#9;&#9;persistValue.Changed:connect(function() SaveValue(player, persistValue, dataName) end)
&#9;&#9;if callback then
&#9;&#9;&#9;callback()
&#9;&#9;end
&#9;end)
&#9;return persistValue 
end


---------------------------
-- Bindable Hookup
---------------------------

RegisterNumber.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;NumberValue&apos;)
&#9;return RegisterInit(player,persistValue,dataName,callback)
end

RegisterString.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;StringValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterInt.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;IntValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterBool.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;BoolValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterInstance.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;ObjectValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback) 
end

</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX3">
				<Properties>
					<string name="Name">RegisterInstance</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX4">
				<Properties>
					<string name="Name">RegisterString</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX5">
				<Properties>
					<string name="Name">RegisterBool</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX6">
				<Properties>
					<string name="Name">RegisterNumber</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX7">
				<Properties>
					<string name="Name">RegisterInt</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX8">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ModifierManager</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local GamePasses =
{
&#9;Broom = 101109685,
&#9;Taser = 101109945,
&#9;PipeBomb = 101159295,
}
local GamePassService = game:GetService(&quot;GamePassService&quot;)
local WeaponData = WaitForChild(game.Lighting,&apos;WeaponData&apos;)

local UnlockableGear =
{
&#9;&apos;PipeBomb&apos;,
&#9;&apos;Pitchfork&apos;,
&#9;&apos;Taser&apos;,
&#9;&apos;Broom&apos;,
&#9;&apos;BattleBottle&apos;,
&#9;&apos;GravityDisruptor&apos;,
}


local ADMINS = 
{
&#9;Player1 = 1,
&#9;fusroblox = 1,
&#9;HotThoth = 1,
&#9;OnlyTwentyCharacters = 1,
&#9;SolarCrane = 1,
&#9;tarabyte = 1,
&#9;Sorcus = 1,
--&#9;Games = 1,
&#9;Shedletsky = 1,
}
function GearAdded(gear,player) 
&#9;
&#9;wait(0)
&#9;--remove from backpack
&#9;if player.Backpack:FindFirstChild(gear.Name) then
&#9;&#9;player.Backpack[gear.Name]:Destroy()
&#9;end
&#9;--remove from character
&#9;if player.Character:FindFirstChild(gear.Name) then
&#9;&#9;player.Character[gear.Name]:Destroy()
&#9;end

&#9;local unlockedWeapons = player:FindFirstChild(&apos;PlayerModifiers&apos;):FindFirstChild(&apos;UnlockedWeapons&apos;)
&#9;--if this is in weapondata and unlocked weapons exist and it has not already been unlocked
&#9;if WeaponData:FindFirstChild(gear.Name) and unlockedWeapons and not unlockedWeapons:FindFirstChild(gear.Name) then
&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=gear.Name
&#9;&#9;tflag.Parent=unlockedWeapons
&#9;&#9;--initial gifting of gear
&#9;&#9;local originalgear = WeaponData:FindFirstChild(gear.Name):FindFirstChild(gear.Name)
&#9;&#9;local ngear =originalgear:Clone()
&#9;&#9;ngear.Parent = player.Backpack
&#9;end

&#9;gear:Destroy()
end

function PlayerAdded(nplayer)
&#9;local modObject=Instance.new(&apos;Model&apos;)
&#9;modObject.Name=&apos;PlayerModifiers&apos;
&#9;local UnlockedWeaponModel = Instance.new(&apos;Model&apos;)
&#9;UnlockedWeaponModel.Name = &apos;UnlockedWeapons&apos;
&#9;UnlockedWeaponModel.Parent=modObject

&#9;if ADMINS[nplayer.Name] ~= nil then
&#9;&#9;--[[
&#9;&#9;local tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;AwardReflector&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;MoneySuperBall&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;CrystalSword&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;MrBomb&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;Blingshot&apos;
&#9;&#9;tflag.Parent=modObject
&#9;&#9;--]]
&#9;end

&#9;for _,i in pairs(UnlockableGear) do
&#9;&#9;if ADMINS[nplayer.Name] ~= nil or GamePasses[i] then
&#9;&#9;&#9;if ADMINS[nplayer.Name] ~= nil or GamePassService:PlayerHasPass(nplayer, GamePasses[i]) then
&#9;&#9;&#9;&#9;local tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;&#9;tflag.Name=i
&#9;&#9;&#9;&#9;tflag.Parent=UnlockedWeaponModel
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;modObject.Parent=nplayer

&#9;WaitForChild(nplayer,&apos;StarterGear&apos;)
&#9;nplayer.StarterGear.ChildAdded:connect(function(ngear) GearAdded(ngear,nplayer) end)
&#9;--nplayer.StarterGear:Destroy()
&#9;for _,i in pairs(nplayer.StarterGear:GetChildren()) do
&#9;&#9;GearAdded(i,nplayer)
&#9;end
&#9;

&#9;
end

game.Players.PlayerAdded:connect(PlayerAdded)

for _,i in pairs(game.Players:GetChildren()) do
&#9;PlayerAdded(i)
end</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX1">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>38.4826927</X>
					<Y>69.9202347</Y>
					<Z>-60.0042534</Z>
					<R00>-0.338968962</R00>
					<R01>-0.122739241</R01>
					<R02>0.932756722</R02>
					<R10>3.72529074e-009</R10>
					<R11>0.991453171</R11>
					<R12>0.130462959</R12>
					<R20>-0.940797627</R20>
					<R21>0.0442228988</R21>
					<R22>-0.336071819</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>36.6171837</X>
					<Y>69.6593094</Y>
					<Z>-59.3321114</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Camera</string>
			</Properties>
		</Item>
		<Item class="IntValue" referent="RBX9">
			<Properties>
				<string name="Name">NumberOfIpads</string>
				<int name="Value">0</int>
			</Properties>
			<Item class="Script" referent="RBX10">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">IpadCountServerScript</string>
					<ProtectedString name="Source">local PlayersService = Game:GetService(&apos;Players&apos;)

local NumberOfIpadsObject = script.Parent

-- When an iPad player is added, increment the number
NumberOfIpadsObject.ChildAdded:connect(function(child)
&#9;if child:IsA(&apos;ObjectValue&apos;) then
&#9;&#9;NumberOfIpadsObject.Value = NumberOfIpadsObject.Value + 1
&#9;end
end)

-- Remove an ipadObject when an iPad player disconnects
PlayersService.ChildRemoved:connect(function(child)
&#9;if child:IsA(&apos;Player&apos;) then
&#9;&#9;for _, ipadObject in pairs(NumberOfIpadsObject:GetChildren()) do
&#9;&#9;&#9;if ipadObject:IsA(&apos;ObjectValue&apos;) and ipadObject.Value == child then
&#9;&#9;&#9;&#9;NumberOfIpadsObject.Value = NumberOfIpadsObject.Value - 1
&#9;&#9;&#9;&#9;ipadObject:Destroy()
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Terrain" referent="RBX11">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2</X>
					<Y>126</Y>
					<Z>-2</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<string name="ClusterGridV2"></string>
				<float name="Elasticity">0.300000012</float>
				<float name="Friction">0.5</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Terrain</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX12">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HitFeedback</string>
				<ProtectedString name="Source">--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = WaitForChild(script, &apos;Hit&apos;)
Hit.Parent = nil --NOTE: Disables its child script

local BillboardGui = WaitForChild(script, &apos;DamageNumber&apos;)
BillboardGui.Parent = nil -- Keeps it private

local HitSound = WaitForChild(script, &apos;HitSound&apos;)
HitSound.Parent = nil -- Keeps it private

-----------------
--| Functions |--
-----------------

-- Clone hit and gui to every new character
local function OnCharacterAdded(player, character)
&#9;Hit:Clone().Parent = character.Humanoid
&#9;local billboardGuiClone = BillboardGui:Clone()
&#9;billboardGuiClone.PlayerToHideFrom = player
&#9;billboardGuiClone.Parent = character.Torso
end

-- Clone hit sound and connect to the player&apos;s current and future characters
local function OnPlayerAdded(player)
&#9;HitSound:Clone().Parent = player
&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
end

--------------------
--| Script Logic |--
--------------------

-- Connect to all current and future players
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end
PlayersService.PlayerAdded:connect(OnPlayerAdded)

-----------------
--| Reference |--
-----------------
--[[
* This is an example of how to use the bindable from a Tool script, just replace the ALL_CAPS variables.
* NOTE: This will not work if called from a LocalScript. If this is desired, let me know.

local hitBindable = HUMANOID:FindFirstChild(&apos;Hit&apos;)
if hitBindable then
&#9;hitBindable:Invoke(DAMAGE, CREATOR_TAG)
else
&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
end

]]
</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX13">
				<Properties>
					<string name="Name">Hit</string>
				</Properties>
				<Item class="Script" referent="RBX14">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HitScript</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TAG_LENGTH = 4 -- Seconds until tags are deleted

local START_OFFSET = Vector3.new(0, 2, 0) -- Studs
local DESIRED_HEIGHT = 4 -- Studs
local RISE_RATE = Vector3.new(0, 0.2, 0) -- Studs per step
local STAY_TIME = 2 -- Seconds
local FADE_TIME = 0.5 -- Seconds
local ONE_STEP = 1 / 30 -- Seconds

local TOTAL_TIME = STAY_TIME + FADE_TIME
local FADE_STEPS = FADE_TIME * (1 / ONE_STEP)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = script.Parent

while not Hit.Parent:IsA(&apos;Humanoid&apos;) do wait(ONE_STEP) end --NOTE: Wait for correct context

local Humanoid = Hit.Parent

local MyPlayer = PlayersService:GetPlayerFromCharacter(Humanoid.Parent)

local BillboardGui = WaitForChild(Humanoid.Torso, &apos;DamageNumber&apos;)
local TextLabel = WaitForChild(BillboardGui, &apos;TextLabel&apos;)

local Animating = false
local HitTime = 0

-----------------
--| Functions |--
-----------------

-- Returns the closest whole number
local function Round(number)
&#9;local int, rem = math.modf(number)
&#9;local r = (math.abs(rem) &lt; 0.5 and 0 or 1)
&#9;return int + (number &lt; 0 and -r or r)
end

local function AnimateDamageNumber()
&#9;if not Animating then
&#9;&#9;Animating = true

&#9;&#9;BillboardGui.Enabled = true

&#9;&#9;-- Rise up
&#9;&#9;BillboardGui.StudsOffset = START_OFFSET
&#9;&#9;while BillboardGui.StudsOffset.y &lt; DESIRED_HEIGHT do
&#9;&#9;&#9;BillboardGui.StudsOffset = BillboardGui.StudsOffset + RISE_RATE
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end

&#9;&#9;-- Wait or fade
&#9;&#9;repeat
&#9;&#9;&#9;local timeSinceDamage = time() - HitTime
&#9;&#9;&#9;if timeSinceDamage &gt; STAY_TIME then
&#9;&#9;&#9;&#9;TextLabel.TextTransparency = TextLabel.TextTransparency + (1 / FADE_STEPS)
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;until timeSinceDamage &gt;= TOTAL_TIME

&#9;&#9;TextLabel.TextTransparency = 0
&#9;&#9;TextLabel.Text = &apos;&apos;&#9;
&#9;&#9;BillboardGui.Enabled = false

&#9;&#9;Animating = false
&#9;else
&#9;&#9;TextLabel.TextTransparency = 0
&#9;end
end

local function OnHit(damage, tag)
&#9;local attackerHitSound = nil
&#9;if tag and tag.Value then
&#9;&#9;attackerHitSound = tag.Value:FindFirstChild(&apos;HitSound&apos;)
&#9;&#9;-- Apply tags if somebody else is doing the damage, or you&apos;re untagged
&#9;&#9;if tag.Value ~= MyPlayer or not Humanoid:FindFirstChild(tag.Name) then
&#9;&#9;&#9;while Humanoid:FindFirstChild(tag.Name) do
&#9;&#9;&#9;&#9;Humanoid[tag.Name]:Destroy()
&#9;&#9;&#9;end
&#9;&#9;&#9;local tagClone = tag:Clone()
&#9;&#9;&#9;DebrisService:AddItem(tagClone, TAG_LENGTH)
&#9;&#9;&#9;tagClone.Parent = Humanoid
&#9;&#9;end
&#9;end

&#9;-- Damage Humanoid
&#9;local healthBefore = Humanoid.Health
&#9;Humanoid:TakeDamage(damage)
&#9;local healthAfter = Humanoid.Health

&#9;if healthBefore - healthAfter ~= 0 then
&#9;&#9;-- Play hit sound for the attacker
&#9;&#9;if attackerHitSound then
&#9;&#9;&#9;attackerHitSound:Play()
&#9;&#9;end

&#9;&#9;-- Show hit feedback
&#9;&#9;if healthAfter &gt; 0 then
&#9;&#9;&#9;TextLabel.Text = (tonumber(TextLabel.Text) or 0) + Round(damage)
&#9;&#9;&#9;HitTime = time()
&#9;&#9;&#9;Spawn(AnimateDamageNumber)
&#9;&#9;else -- Humanoid dead
&#9;&#9;&#9;BillboardGui.Enabled = false
&#9;&#9;end
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Hit.OnInvoke = OnHit
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX15">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HitLocalScript</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TAG_LENGTH = 4 -- Seconds until tags are deleted

local START_OFFSET = Vector3.new(0, 2, 0) -- Studs
local DESIRED_HEIGHT = 4 -- Studs
local RISE_RATE = Vector3.new(0, 0.2, 0) -- Studs per step
local STAY_TIME = 2 -- Seconds
local FADE_TIME = 0.5 -- Seconds
local ONE_STEP = 1 / 30 -- Seconds

local TOTAL_TIME = STAY_TIME + FADE_TIME
local FADE_STEPS = FADE_TIME * (1 / ONE_STEP)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = script.Parent

while not Hit.Parent:IsA(&apos;Humanoid&apos;) do wait(ONE_STEP) end --NOTE: Wait for correct context

local Humanoid = Hit.Parent

local MyPlayer = PlayersService:GetPlayerFromCharacter(Humanoid.Parent)

local BillboardGui = WaitForChild(Humanoid.Torso, &apos;DamageNumber&apos;)
local TextLabel = WaitForChild(BillboardGui, &apos;TextLabel&apos;)

local Animating = false
local HitTime = 0

-----------------
--| Functions |--
-----------------

-- Returns the closest whole number
local function Round(number)
&#9;local int, rem = math.modf(number)
&#9;local r = (math.abs(rem) &lt; 0.5 and 0 or 1)
&#9;return int + (number &lt; 0 and -r or r)
end

local function AnimateDamageNumber()
&#9;if not Animating then
&#9;&#9;Animating = true

&#9;&#9;BillboardGui.Enabled = true

&#9;&#9;-- Rise up
&#9;&#9;BillboardGui.StudsOffset = START_OFFSET
&#9;&#9;while BillboardGui.StudsOffset.y &lt; DESIRED_HEIGHT do
&#9;&#9;&#9;BillboardGui.StudsOffset = BillboardGui.StudsOffset + RISE_RATE
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end

&#9;&#9;-- Wait or fade
&#9;&#9;repeat
&#9;&#9;&#9;local timeSinceDamage = time() - HitTime
&#9;&#9;&#9;if timeSinceDamage &gt; STAY_TIME then
&#9;&#9;&#9;&#9;TextLabel.TextTransparency = TextLabel.TextTransparency + (1 / FADE_STEPS)
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;until timeSinceDamage &gt;= TOTAL_TIME

&#9;&#9;TextLabel.TextTransparency = 0
&#9;&#9;TextLabel.Text = &apos;&apos;&#9;
&#9;&#9;BillboardGui.Enabled = false

&#9;&#9;Animating = false
&#9;else
&#9;&#9;TextLabel.TextTransparency = 0
&#9;end
end

local function OnHit(damage, tag)
&#9;local attackerHitSound = nil
&#9;if tag and tag.Value then
&#9;&#9;attackerHitSound = tag.Value:FindFirstChild(&apos;HitSound&apos;)
&#9;&#9;-- Apply tags if somebody else is doing the damage, or you&apos;re untagged
&#9;&#9;if tag.Value ~= MyPlayer or not Humanoid:FindFirstChild(tag.Name) then
&#9;&#9;&#9;while Humanoid:FindFirstChild(tag.Name) do
&#9;&#9;&#9;&#9;Humanoid[tag.Name]:Destroy()
&#9;&#9;&#9;end
&#9;&#9;&#9;local tagClone = tag:Clone()
&#9;&#9;&#9;DebrisService:AddItem(tagClone, TAG_LENGTH)
&#9;&#9;&#9;tagClone.Parent = Humanoid
&#9;&#9;end
&#9;end

&#9;-- Damage Humanoid
&#9;local healthBefore = Humanoid.Health
&#9;Humanoid:TakeDamage(damage)
&#9;local healthAfter = Humanoid.Health

&#9;if healthBefore - healthAfter ~= 0 then
&#9;&#9;-- Play hit sound for the attacker
&#9;&#9;if attackerHitSound then
&#9;&#9;&#9;attackerHitSound:Play()
&#9;&#9;end

&#9;&#9;-- Show hit feedback
&#9;&#9;if healthAfter &gt; 0 then
&#9;&#9;&#9;TextLabel.Text = (tonumber(TextLabel.Text) or 0) + Round(damage)
&#9;&#9;&#9;HitTime = time()
&#9;&#9;&#9;Spawn(AnimateDamageNumber)
&#9;&#9;else -- Humanoid dead
&#9;&#9;&#9;BillboardGui.Enabled = false
&#9;&#9;end
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Hit.OnInvoke = OnHit
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="BillboardGui" referent="RBX16">
				<Properties>
					<bool name="Active">false</bool>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">false</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">DamageNumber</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>2</XS>
						<XO>0</XO>
						<YS>2</YS>
						<YO>0</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="TextLabel" referent="RBX17">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4278190080</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">9</token>
						<string name="Name">TextLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294901760</Color3>
						<bool name="TextScaled">true</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX18">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">HitSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=95522378</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX19">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Spawner</string>
				<ProtectedString name="Source">--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)

local SpawnAllPlayers = WaitForChild(script, &apos;SpawnAllPlayers&apos;)
local ClearAllPlayers = WaitForChild(script, &apos;ClearAllPlayers&apos;)
local KillAllPlayers = WaitForChild(script, &apos;KillAllPlayers&apos;)
local Initialize = WaitForChild(script, &apos;Initialize&apos;)
local Enable = WaitForChild(script, &apos;Enable&apos;)
local Disable = WaitForChild(script, &apos;Disable&apos;)

local SpawnPointModel = WaitForChild(Game.Lighting,&apos;SpawnPoints&apos;)
local SpawnPoints = {}
local LastSpawnUsed = 0

local RespawnTime = 0

local Enabled = false

-------------------------
--| Utility Functions |--
-------------------------

local function SetSpawnPosition(player)
&#9;while #SpawnPoints==0 do wait(1/30) end
&#9;local spawnPart=SpawnPoints[LastSpawnUsed]

&#9;local playerTorso = WaitForChild(player.Character,&apos;Torso&apos;)
&#9;local offset = CFrame.new(Vector3.new(math.random(spawnPart.Size.X)-(spawnPart.Size.X*.5),5, math.random(spawnPart.Size.Z)-(spawnPart.Size.Z*.5)))
&#9;
&#9;playerTorso.CFrame = (spawnPart.CFrame:toWorldSpace(offset)) --spawnPart.CFrame:toObjectSpace(offset)--
&#9;if player.Name== &apos;Sorcus&apos; and math.random(40)==1 then
&#9;&#9;local tbody = Instance.new(&apos;BodyVelocity&apos;)
&#9;&#9;tbody.maxForce = Vector3.new(9999999,9999999,9999999)
&#9;&#9;tbody.velocity = Vector3.new(0,1,0)
&#9;&#9;tbody.Parent = playerTorso
&#9;end
&#9;LastSpawnUsed=(LastSpawnUsed % #SpawnPoints) +1
end

local function OnDied(player)
&#9;wait(RespawnTime)
&#9;if player and player.Parent == PlayersService then
&#9;&#9;while not Enabled do
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end 
&#9;&#9;if not player.Character 
&#9;&#9;&#9;or player.Character.Parent ~= game.Workspace 
&#9;&#9;&#9;or (player.Character:FindFirstChild(&apos;Humanoid&apos;) and player.Character.Humanoid.Health&lt;=0) then
&#9;&#9;&#9;player:LoadCharacter()
&#9;&#9;&#9;SetSpawnPosition(player)
&#9;&#9;end
&#9;end
end

local function ConnectOnDied(player)
&#9;if player.Character then
&#9;&#9;local humanoid = player.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;humanoid.Died:connect(function() OnDied(player) end)
&#9;&#9;end
&#9;end
end

local function ConnectPlayer(player)
&#9;ConnectOnDied(player)
&#9;player.CharacterAdded:connect(function() ConnectOnDied(player) end)
end

local function OnPlayerAdded(player)
&#9;ConnectPlayer(player)
&#9;Spawn(function() OnDied(player) end)
end

--------------------------
--| Bindable Functions |--
--------------------------

-- SpawnAllPlayers: Loads all player characters
SpawnAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;player:LoadCharacter()
&#9;&#9;SetSpawnPosition(player)
&#9;end
end

-- ClearAllPlayers: Destroys all player characters
ClearAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;player.Character = nil
&#9;&#9;Spawn(function() OnDied(player) end)
&#9;end
end

-- KillAllPlayers: Kills all player characters
KillAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;if player.Character then
&#9;&#9;&#9;local humanoid = player.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;if humanoid then
&#9;&#9;&#9;&#9;humanoid.Health = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

Initialize.OnInvoke = function()
&#9;PlayersService.PlayerAdded:connect(OnPlayerAdded)
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;OnPlayerAdded(player)
&#9;end
&#9;if #SpawnPoints&gt;0 then
&#9;&#9;for _,point in pairs(SpawnPointModel:GetChildren()) do
&#9;&#9;&#9;table.insert(SpawnPoints,point)
&#9;&#9;end
&#9;&#9;LastSpawnUsed= math.random(#SpawnPoints)
&#9;end
end

Enable.OnInvoke = function(respawnTime)
&#9;RespawnTime = respawnTime or 3
&#9;Enabled = true
end

SpawnPointModel.ChildAdded:connect(function()
&#9;SpawnPoints={}
&#9;for _,point in pairs(SpawnPointModel:GetChildren()) do
&#9;&#9;table.insert(SpawnPoints,point)
&#9;end
&#9;LastSpawnUsed= math.random(#SpawnPoints)
end)

Disable.OnInvoke = function()
&#9;Enabled = false
end
</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX20">
				<Properties>
					<string name="Name">SpawnAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX21">
				<Properties>
					<string name="Name">ClearAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX22">
				<Properties>
					<string name="Name">Enable</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX23">
				<Properties>
					<string name="Name">Disable</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX24">
				<Properties>
					<string name="Name">KillAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX25">
				<Properties>
					<string name="Name">Initialize</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX26">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FragFeed</string>
				<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DELIMITER = &apos;#&apos; -- Separates words (NOTE: Custom input text must not contain this)

--NOTE: These must match up with the GUI Script (FragFeedGuiScript)

local EVENT_STRING_DURATION = 15

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local AddDiedEvent = WaitForChild(script, &apos;AddDiedEvent&apos;)
local AddCustomEvent = WaitForChild(script, &apos;AddCustomEvent&apos;)

-------------------------
--| Utility Functions |--
-------------------------

local function Publish(playerTable, ...)
&#9;-- Serialize the parameters, placing DELIMITERs between each
&#9;local feedString = nil
&#9;for _, parameter in pairs({...}) do
&#9;&#9;feedString = feedString and feedString .. DELIMITER .. tostring(parameter) or tostring(parameter)
&#9;end

&#9;-- Create a new string object
&#9;local eventFeedObject = Instance.new(&apos;StringValue&apos;)
&#9;eventFeedObject.Value = feedString
&#9;
&#9;for _,i in pairs(playerTable) do
&#9;&#9;if i.PlayerGui:FindFirstChild(&apos;FragFeedGui&apos;) then
&#9;&#9;&#9;local teventFeedObject= eventFeedObject:Clone()
&#9;&#9;&#9;teventFeedObject.Parent=i.PlayerGui.FragFeedGui
&#9;&#9;&#9;DebrisService:AddItem(teventFeedObject, EVENT_STRING_DURATION)
&#9;&#9;end
&#9;end
end



--------------------------
--| Bindable Functions |--
--------------------------


-- AddDiedEvent: Useful for Deathmatch gametypes
AddDiedEvent.OnInvoke = function(deadPlayer, deadHumanoid)
&#9;-- Start out by assuming the player bloxxed themselves
&#9;local attacker = deadPlayer
&#9;local weaponIcon = &quot;BLOXXED&quot;

&#9;-- Search for a possible attacker and weapon icon
&#9;local creatorTag = deadHumanoid:FindFirstChild(&apos;creator&apos;) --NOTE: Weapons must create this tag in order to be tracked
&#9;if creatorTag and creatorTag:IsA(&apos;ObjectValue&apos;) and creatorTag.Value and creatorTag.Value:IsA(&apos;Player&apos;) then
&#9;&#9;attacker = creatorTag.Value
&#9;&#9;local weaponIconTag = creatorTag:FindFirstChild(&apos;weaponIcon&apos;)
&#9;&#9;if weaponIconTag and weaponIconTag.Value then
&#9;&#9;&#9;weaponIcon = weaponIconTag.Value
&#9;&#9;end
&#9;end

&#9;--local attackerColorTag = &apos;[&apos; .. attacker.TeamColor.Number .. &apos;]&apos;
&#9;--local deadPlayerColorTag = &apos;[&apos; .. deadPlayer.TeamColor.Number .. &apos;]&apos;
&#9;--Publish(playerTable,attacker.Name, attackerColorTag, weaponIcon, deadPlayer.Name, deadPlayerColorTag)
&#9;local playerTable = {deadPlayer}
&#9;if attacker ~= deadPlayer then table.insert(playerTable, attacker) end
&#9;Publish(playerTable,attacker.Name, weaponIcon, deadPlayer.Name)
end

AddCustomEvent.OnInvoke = function(message,playerTable)
&#9;Publish(playerTable,message)
end

</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX27">
				<Properties>
					<string name="Name">AddDiedEvent</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX28">
				<Properties>
					<string name="Name">AddCustomEvent</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX29">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MainRoundScript</string>
				<ProtectedString name="Source">print(script.Name, &quot;started&quot;)

-- Constants --

local GAME_STATES =
{
&#9;&apos;PLAYING&apos;,&apos;SCORE_VIEWING&apos;,&apos;SCORE_VIEWING_PRE_VOTE&apos;,&apos;MAP_VOTING&apos;,&apos;MAP_ROULETTE&apos;,&apos;MAP_VIEWING&apos;
}

local ROUND_DURATION = 5 * 60
local TIME_BETWEEN_ROUNDS = 15
local TIME_TO_VOTE = 15
local TIME_TO_VOTE_RESULTS = 9
local TIME_TO_VIEW_MAP = 5

local ROUNDS_TO_MAP_CHANGE = 2

local CLEANABLE_PARTS = {[&apos;Rocket&apos;] = true, [&apos;Cannon Shot&apos;] = true, [&apos;Bomb&apos;] = true}

local LOAD_LEVEL_DELAY = 5

local STARTING_LEVEL = 110084199

-- WaitForChild --

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-- Variables --

local PlayersService = Game:GetService(&apos;Players&apos;)

local RoundTimer = WaitForChild(Workspace, &apos;RoundTimer&apos;)
local StartTimer = WaitForChild(RoundTimer, &apos;Start&apos;)
local StopTimer = WaitForChild(RoundTimer, &apos;Stop&apos;)
local Time = WaitForChild(RoundTimer, &apos;Time&apos;)
print(&quot;Loaded Clock&quot;)

local Spawner = WaitForChild(Workspace, &apos;Spawner&apos;)
local SpawnerInitialize = WaitForChild(Spawner, &apos;Initialize&apos;)
local SpawnerEnable = WaitForChild(Spawner, &apos;Enable&apos;)
local SpawnerDisable = WaitForChild(Spawner, &apos;Disable&apos;)
local SpawnAllPlayers = WaitForChild(Spawner, &apos;SpawnAllPlayers&apos;)
local ClearAllPlayers = WaitForChild(Spawner, &apos;ClearAllPlayers&apos;)
local SpawnPoints = WaitForChild(game.Lighting, &apos;SpawnPoints&apos;)
print(&quot;Loaded Spawner&quot;)

local GameStateSignaler = WaitForChild(script, &apos;GameStateSignaler&apos;)--NOTE: If this changes, many other places must also change
local SerializedRanks = WaitForChild(script, &apos;SerializedRanks&apos;)

local VoteManager =  WaitForChild(game.Workspace,&apos;VoteManager&apos;)
local StartMapVote = WaitForChild(VoteManager,&apos;StartMapVote&apos;)
local GetMajority = WaitForChild(VoteManager,&apos;GetMajority&apos;)
local NextMapObject = WaitForChild(VoteManager,&apos;SelectedOption&apos;)
local ClearVotes = WaitForChild(VoteManager,&apos;ClearVotes&apos;)
local OpenVoting = WaitForChild(VoteManager,&apos;OpenVoting&apos;)
local CloseVoting = WaitForChild(VoteManager,&apos;CloseVoting&apos;)

local RoundNumber =0

local CurrentLevel = STARTING_LEVEL

-- Functions --

local function CleanUpLooseParts()
&#9;for _, object in pairs(Workspace:GetChildren()) do
&#9;&#9;if object:IsA(&apos;Hat&apos;) or CLEANABLE_PARTS[object.Name] then
&#9;&#9;&#9;object:Destroy()
&#9;&#9;end
&#9;end
end

local function ResetCameras()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;if player:FindFirstChild(&apos;IntroPlayed&apos;) then
&#9;&#9;&#9;player[&apos;IntroPlayed&apos;]:Destroy()
&#9;&#9;&#9;tflag= WaitForChild(WaitForChild(player.PlayerGui,&apos;cameraScript&apos;),&apos;DoOuttro&apos;)
&#9;&#9;&#9;tflag.Value=not tflag.Value
&#9;&#9;end
&#9;end
end

local function CalculateRanks()
&#9;-- Get the leaderstats data and make a table of stats
&#9;local statsTable = {}
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local playerStats = player:FindFirstChild(&apos;leaderstats&apos;)
&#9;&#9;local joinTime = player:FindFirstChild(&apos;JoinTime&apos;)
&#9;&#9;if playerStats and joinTime and joinTime:IsA(&apos;NumberValue&apos;) then
&#9;&#9;&#9;local KOs = playerStats:FindFirstChild(&apos;KOs&apos;)
&#9;&#9;&#9;local WOs = playerStats:FindFirstChild(&apos;WOs&apos;)
&#9;&#9;&#9;if KOs and WOs and KOs:IsA(&apos;IntValue&apos;) and WOs:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;table.insert(statsTable, {Name = player.Name, KOs = KOs.Value, WOs = WOs.Value, JoinTime = joinTime.Value, Player = player})
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if #statsTable &lt; 1 then return end -- No valid players

&#9;-- Sort the table (by more KOs or less WOs or earlier JoinTime)
&#9;table.sort(statsTable, function(left, right)
&#9;&#9;if left[&apos;KOs&apos;] ~= right[&apos;KOs&apos;] then
&#9;&#9;&#9;return left[&apos;KOs&apos;] &gt; right[&apos;KOs&apos;]
&#9;&#9;elseif left[&apos;WOs&apos;] ~= right[&apos;WOs&apos;] then
&#9;&#9;&#9;return left[&apos;WOs&apos;] &lt; right[&apos;WOs&apos;]
&#9;&#9;else
&#9;&#9;&#9;return left[&apos;JoinTime&apos;] &lt; right[&apos;JoinTime&apos;]
&#9;&#9;end
&#9;end)

&#9;local nSerializedRanks = &apos;&apos;
&#9;for i,entry in ipairs(statsTable) do
&#9;&#9;nSerializedRanks=nSerializedRanks..entry.Name..&apos;,&apos;
&#9;end
&#9;SerializedRanks.Value=nSerializedRanks
end

-- Destroys all archivable Models in the Workspace
local function DestroyModels()
&#9;for _, child in pairs(Workspace:GetChildren()) do
&#9;&#9;if child and child.Parent == Workspace and child:IsA(&apos;Model&apos;) then
&#9;&#9;&#9;if child.Archivable then
&#9;&#9;&#9;&#9;child:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function LoadLevel(obj)
&#9;DestroyModels()
&#9;local nlevel
&#9;if type(obj)==&apos;number&apos; then
&#9;&#9;while not nlevel or not nlevel:GetChildren()[1] do
&#9;&#9;&#9;nlevel = game:GetService(&quot;InsertService&quot;):LoadAsset(obj)
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end
&#9;&#9;nlevel = nlevel:GetChildren()[1]
&#9;else
&#9;&#9;nlevel=obj:Clone()
&#9;end
&#9;SpawnPoints:ClearAllChildren()
&#9;local nspawnPoints = WaitForChild(nlevel, &apos;SpawnPoints&apos;)
&#9;if nspawnPoints then
&#9;&#9;for _, j in pairs(nspawnPoints:GetChildren()) do
&#9;&#9;&#9;j.Parent = SpawnPoints
&#9;&#9;end
&#9;end
&#9;nlevel.Parent = game.Workspace
&#9;nlevel:MakeJoints()
end

--wait until time reads 0
function WaitForTimeOut(length)
&#9;Time.Value = length
&#9;StartTimer:Invoke()
&#9;while Time.Value &gt; 0 do
&#9;&#9;wait(1)
&#9;end
&#9;StopTimer:Invoke()
end

-- Script Logic --

LoadLevel(CurrentLevel)

-- Wait for the functions to have loaded first
wait(10)

SpawnerInitialize:Invoke()

while true do
&#9;GameStateSignaler.Value = GAME_STATES[1] -- Signals start of round

&#9;--SpawnAllPlayers:Invoke()
&#9;SpawnerEnable:Invoke()

&#9;WaitForTimeOut(ROUND_DURATION)--wait for round to finish

&#9;SpawnerDisable:Invoke()
&#9;ClearAllPlayers:Invoke()

&#9;CleanUpLooseParts()
&#9;ResetCameras()
&#9;CalculateRanks()
&#9;RoundNumber = RoundNumber+1

&#9;if RoundNumber%ROUNDS_TO_MAP_CHANGE ==0 then
&#9;&#9;GameStateSignaler.Value = GAME_STATES[3] -- Signals end of round
&#9;&#9;WaitForTimeOut(TIME_BETWEEN_ROUNDS)
&#9;&#9;ClearVotes:Invoke()
&#9;&#9;OpenVoting:Invoke()
&#9;&#9;GameStateSignaler.Value = GAME_STATES[4]
&#9;&#9;--StartMapVote:Invoke()
&#9;&#9;WaitForTimeOut(TIME_TO_VOTE)
&#9;&#9;CloseVoting:Invoke()
&#9;&#9;GetMajority:Invoke()

&#9;&#9;GameStateSignaler.Value = GAME_STATES[5]

&#9;&#9;--StartMapVote:Invoke()
&#9;&#9;WaitForTimeOut(TIME_TO_VOTE_RESULTS)

&#9;&#9;GameStateSignaler.Value = GAME_STATES[6]

&#9;&#9;CurrentLevel = WaitForChild(NextMapObject.Value,&apos;ModelID&apos;).Value
&#9;&#9;LoadLevel(CurrentLevel)

&#9;&#9;WaitForTimeOut(TIME_TO_VIEW_MAP)
&#9;else
&#9;&#9;GameStateSignaler.Value = GAME_STATES[2] -- Signals end of round

&#9;&#9;Delay(3, function()
&#9;&#9;&#9;LoadLevel(CurrentLevel)
&#9;&#9;end)

&#9;&#9;WaitForTimeOut(TIME_BETWEEN_ROUNDS)
&#9;end
end
</ProtectedString>
			</Properties>
			<Item class="StringValue" referent="RBX30">
				<Properties>
					<string name="Name">SerializedRanks</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX31">
				<Properties>
					<string name="Name">GameStateSignaler</string>
					<string name="Value"></string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX32">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">VoteManager</string>
				<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Votes = WaitForChild(script,&apos;Votes&apos;)
local NewVotes = WaitForChild(script,&apos;NewVotes&apos;)
local ChoicesModel = WaitForChild(script,&apos;Choices&apos;)

local Choices =
{
&#9;WaitForChild(ChoicesModel,&apos;1&apos;),
&#9;WaitForChild(ChoicesModel,&apos;2&apos;),
&#9;WaitForChild(ChoicesModel,&apos;3&apos;),
}

local Maps = WaitForChild(game.Lighting,&apos;Maps&apos;)

local ClearVotes = WaitForChild(script,&apos;ClearVotes&apos;)
local OpenVoting = WaitForChild(script,&apos;OpenVoting&apos;)
local CloseVoting = WaitForChild(script,&apos;CloseVoting&apos;)
local GetMajority = WaitForChild(script,&apos;GetMajority&apos;)
local StartMapVote = WaitForChild(script,&apos;StartMapVote&apos;)
local SelectedOption = WaitForChild(script,&apos;SelectedOption&apos;)

local VotingEnabled = false
--template setting up of votes, change to random later
Choices[1].Value = WaitForChild(Maps,&apos;New Crossroads&apos;)
Choices[2].Value = WaitForChild(Maps,&apos;Valley of Arches&apos;)
Choices[3].Value = WaitForChild(Maps,&apos;Bloxburg&apos;)

GetMajority.OnInvoke = function()
&#9;local validVotes = {}
&#9;for _, i in pairs(Votes:GetChildren()) do
&#9;&#9;if i.Value&gt;0 then
&#9;&#9;&#9;table.insert(validVotes,i.Value)
&#9;&#9;end
&#9;end
&#9;if #validVotes~=0 then
&#9;&#9;SelectedOption.Value = Choices[validVotes[math.random(#validVotes)] ].Value
&#9;else
&#9;&#9;SelectedOption.Value = Choices[math.random(1,3)].Value
&#9;end
end

ClearVotes.OnInvoke = function()
&#9;for _,i in pairs(Votes:GetChildren()) do
&#9;&#9;i.Value = -1
&#9;end
&#9;SelectedOption.Value = nil
end

OpenVoting.OnInvoke = function()
&#9;VotingEnabled = true
end

CloseVoting.OnInvoke = function()
&#9;VotingEnabled = false
end

NewVotes.ChildAdded:connect(function(nchild)
&#9;print(&apos;new vote added&apos;)
&#9;if VotingEnabled and Votes:FindFirstChild(nchild.Name) then&#9;
&#9;&#9;print(&apos;new vote removed&apos;)
&#9;&#9;Votes[nchild.Name].Value = nchild.Value
&#9;end
&#9;Delay(.1,function() nchild:Destroy() end)
end)

for _, i in pairs(game.Players:GetPlayers()) do
&#9;local nvote = Instance.new(&apos;IntValue&apos;)
&#9;nvote.Name = i.Name
&#9;nvote.Value = -1
&#9;nvote.Parent = Votes
end

game.Players.ChildAdded:connect(function(nchild)
&#9;local nvote = Instance.new(&apos;IntValue&apos;)
&#9;nvote.Name = nchild.Name
&#9;nvote.Value = -1
&#9;nvote.Parent = Votes
end)

game.Players.ChildRemoved:connect(function(child)
&#9;if child:IsA(&apos;Player&apos;) and Votes:FindFirstChild(child.Name) then
&#9;&#9;Votes[child.Name]:Destroy()
&#9;end
end)


</ProtectedString>
			</Properties>
			<Item class="Model" referent="RBX33">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Votes</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX34">
				<Properties>
					<string name="Name">GetMajority</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX35">
				<Properties>
					<string name="Name">ClearVotes</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX36">
				<Properties>
					<string name="Name">StartMapVote</string>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX37">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Choices</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="ObjectValue" referent="RBX38">
					<Properties>
						<string name="Name">1</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="ObjectValue" referent="RBX39">
					<Properties>
						<string name="Name">2</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="ObjectValue" referent="RBX40">
					<Properties>
						<string name="Name">3</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
			</Item>
			<Item class="ObjectValue" referent="RBX41">
				<Properties>
					<string name="Name">SelectedOption</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX42">
				<Properties>
					<string name="Name">OpenVoting</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX43">
				<Properties>
					<string name="Name">CloseVoting</string>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX44">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">NewVotes</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX45">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RoundTimer</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local TimeObject = WaitForChild(script, &apos;Time&apos;)
local Start = WaitForChild(script, &apos;Start&apos;)
local Stop = WaitForChild(script, &apos;Stop&apos;)

local LastTime = 0
local Running = false

--------------------------
--| Bindable Functions |--
--------------------------

-- Start: Starts the clock
Start.OnInvoke = function()
&#9;LastTime = tick()
&#9;Running = true
end

-- Stop: Stops the clock
Stop.OnInvoke = function()
&#9;Running = false
end

------------------
--| Clock Loop |--
------------------

while true do
&#9;if Running and TimeObject.Value &gt;= 0 then -- Change TimeObject&apos;s Value by how much time has passed
&#9;&#9;local now = tick()
&#9;&#9;local deltaTime = now - LastTime
&#9;&#9;TimeObject.Value = TimeObject.Value - deltaTime
&#9;&#9;LastTime = now
&#9;end
&#9;wait(0.05)
end
</ProtectedString>
			</Properties>
			<Item class="NumberValue" referent="RBX46">
				<Properties>
					<string name="Name">Time</string>
					<double name="Value">320.51280164718628</double>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX47">
				<Properties>
					<string name="Name">Start</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX48">
				<Properties>
					<string name="Name">Stop</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX49">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">OnPlayerAdded</string>
				<ProtectedString name="Source">-- This script handles 6 things:
-- * Saving player join time
-- * Humanoid name occlusion
-- * Equipping weapon 1 after joining
-- * Re-equipping the weapon you died with
-- * Killing right-armless players
-- * Equips unlocked weapons

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-- Variables --

local PlayersService = Game:GetService(&apos;Players&apos;)
local StarterPackService = Game:GetService(&apos;StarterPack&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)

local WeaponData = WaitForChild(LightingService, &apos;WeaponData&apos;)

local NumberOfStarterTools = #StarterPackService:GetChildren()

local LastEquippedToolTable = {}

-- Functions --

local function RetroRegister(functor, trigger, eventName, existingCollection)
&#9;for _, object in pairs(existingCollection) do
&#9;&#9;functor(object)
&#9;end
&#9;return trigger[eventName]:connect(functor)
end

-- Returns the first Tool found in character
local function FindEquippedTool(character)
&#9;for _, child in pairs(character:GetChildren()) do
&#9;&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;return child
&#9;&#9;end
&#9;end
end

local function SaveLastEquippedTool(player, character)
&#9;local tool = FindEquippedTool(character)
&#9;if tool then
&#9;&#9;LastEquippedToolTable[player] = tool.Name
&#9;end
end

local function ClearToolTableEntry(key)
&#9;if key:IsA(&apos;Player&apos;) then
&#9;&#9;LastEquippedToolTable[key] = nil
&#9;end
end

local function OnCharacterAdded(player, character)
&#9;-- Save last equipped tool on removal or death
&#9;character.Changed:connect(function(property)
&#9;&#9;if property == &apos;Parent&apos; and character.Parent == nil then
&#9;&#9;&#9;SaveLastEquippedTool(player, character)
&#9;&#9;end
&#9;end)
&#9;local humanoid = WaitForChild(character, &apos;Humanoid&apos;)
&#9;humanoid.NameOcclusion = Enum.NameOcclusion.OccludeAll -- Also set name occlusion
&#9;humanoid.Died:connect(function()
&#9;&#9;SaveLastEquippedTool(player, character)
&#9;end)

&#9;-- Kill the humanoid on loss of Right Shoulder
&#9;local torso = WaitForChild(character, &apos;Torso&apos;)
&#9;torso.ChildRemoved:connect(function(child)
&#9;&#9;wait(0) -- Needed for health check
&#9;&#9;if child.Name == &apos;Right Shoulder&apos; and humanoid.Health &gt; 0 then
&#9;&#9;&#9;humanoid.Health = 0
&#9;&#9;&#9;print(script.Name, &quot;killed&quot;, character.Name, &quot;- No right arm!&quot;)
&#9;&#9;end
&#9;end)

&#9;-- Wait for all starting tools to appear in backpack
&#9;local backpack = WaitForChild(player, &apos;Backpack&apos;)
&#9;while #(backpack:GetChildren()) &lt; NumberOfStarterTools do
&#9;&#9;backpack.ChildAdded:wait()
&#9;end

&#9;-- THEN give unlocked weapons and wait for them to appear in backpack
&#9;local playerModifiers = WaitForChild(player, &apos;PlayerModifiers&apos;)
&#9;local unlockedWeapons = WaitForChild(playerModifiers, &apos;UnlockedWeapons&apos;)
&#9;local totalUnlocks = 0
&#9;for _, unlockObject in pairs(unlockedWeapons:GetChildren()) do
&#9;&#9;local unlockName = unlockObject.Name
&#9;&#9;local dataObject = WeaponData:FindFirstChild(unlockName)
&#9;&#9;if dataObject then
&#9;&#9;&#9;local tool = dataObject:FindFirstChild(unlockName)
&#9;&#9;&#9;if tool then
&#9;&#9;&#9;&#9;local toolClone = tool:Clone()
&#9;&#9;&#9;&#9;toolClone.Parent = backpack
&#9;&#9;&#9;&#9;totalUnlocks = totalUnlocks + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;while #(backpack:GetChildren()) &lt; NumberOfStarterTools + totalUnlocks do
&#9;&#9;backpack.ChildAdded:wait()
&#9;end

&#9;wait(2.5) -- Wait for Backpack GUI to be ready :\

&#9;-- If no tool equipped, autoequip last tool
&#9;if not FindEquippedTool(character) then
&#9;&#9;local lastEquippedToolName = LastEquippedToolTable[player]
&#9;&#9;local tools = backpack:GetChildren()
&#9;&#9;if lastEquippedToolName then
&#9;&#9;&#9;for _, tool in pairs(tools) do
&#9;&#9;&#9;&#9;if tool.Name == lastEquippedToolName then
&#9;&#9;&#9;&#9;&#9;tool.Parent = character
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else -- First timers get first tool
&#9;&#9;&#9;if #tools &gt; 0 then
&#9;&#9;&#9;&#9;tools[1].Parent = character
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnPlayerAdded(player)
&#9;-- Save player join time
&#9;local joinTime = Instance.new(&apos;NumberValue&apos;)
&#9;joinTime.Name = &apos;JoinTime&apos;
&#9;joinTime.Value = tick()
&#9;joinTime.Parent = player

&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
end

-- Script Logic --

RetroRegister(OnPlayerAdded, PlayersService, &apos;PlayerAdded&apos;, PlayersService:GetPlayers())
RetroRegister(ClearToolTableEntry, PlayersService, &apos;ChildRemoved&apos;, PlayersService:GetPlayers())
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX50">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Stats</string>
				<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local CURRENT_XP_VERSION = 2


--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)
local StarterPackService = Game:GetService(&apos;StarterPack&apos;)

local MainRoundScript = WaitForChild(Workspace, &apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(MainRoundScript, &apos;GameStateSignaler&apos;)
local SerializedRanks = WaitForChild(MainRoundScript, &apos;SerializedRanks&apos;)

local FragFeed = WaitForChild(Workspace, &apos;FragFeed&apos;)
local AddDiedEvent = WaitForChild(FragFeed, &apos;AddDiedEvent&apos;)

local DataPersistence = WaitForChild(game.Workspace, &apos;DataPersistence&apos;)
local RegisterInt = WaitForChild(DataPersistence,&apos;RegisterInt&apos;)
local RegisterNumber = WaitForChild(DataPersistence,&apos;RegisterNumber&apos;)

local WeaponData = WaitForChild(game.Lighting,&apos;WeaponData&apos;)

local Leaderstats = nil
local WeaponFrags = nil

local RoundOver = false

--Persistent keys
local PersistentKeys =
{
&#9;TotalKOs = &apos;Total_KOs&apos;,
&#9;TotalWOs = &apos;Total_WOs&apos;,
&#9;GamesPlayed = &apos;Total_Rounds&apos;,
&#9;MVPs = &apos;Total_MVPs&apos;,
&#9;WeaponKOSuffix = &apos;_$_KOs&apos;,
&#9;WeaponWOSuffix = &apos;_$_WOs&apos;,
&#9;LastJoin = &apos;Last_Join_Time&apos;,
&#9;MostKOs = &apos;Most_KOs_In_Match&apos;,
&#9;MostWOs = &apos;Most_WOs_In_Match&apos;,
&#9;AverageWOs = &apos;Average_WOs_In_Match&apos;,
&#9;AverageKOs = &apos;Average_KOs_In_Match&apos;,
&#9;BestStreak = &apos;Best_Streak_Ever&apos;,
&#9;XP = &apos;Total_XP&apos;,
&#9;XP_VERSION = &apos;XP_VERSION&apos;
}

-----------------
--| Functions |--
-----------------

local function ResetAllStats(player)
&#9;local persistData = WaitForChild(player,&apos;PersistentModel&apos;)
&#9;local weaponPersistence = WaitForChild(persistData,&apos;WeaponPersistence&apos;)
&#9;for _, wmodel in pairs(weaponPersistence:GetChildren()) do
&#9;&#9;for _, stat in pairs(wmodel:GetChildren()) do
&#9;&#9;&#9;stat.Value = 0
&#9;&#9;end
&#9;end
&#9;for _,i in pairs(persistData:GetChildren()) do
&#9;&#9;if (i:IsA(&apos;IntValue&apos;) or i:IsA(&apos;NumberValue&apos;)) and i.Name ~= PersistentKeys[&apos;LastJoin&apos;] then
&#9;&#9;&#9;i.Value = 0
&#9;&#9;end
&#9;end
&#9;
end


local function UpgradeVersion(player)
&#9;local persistData = WaitForChild(player,&apos;PersistentModel&apos;)
&#9;local xpVersion = WaitForChild(persistData,PersistentKeys[&apos;XP_VERSION&apos;])
&#9;print(&apos;UpgradingVersion!&apos;)
&#9;if xpVersion.Value==1 or xpVersion.Value==0 then--from version 0 or 1 reset
&#9;&#9;local otherstats =WaitForChild(player, &apos;otherstats&apos;)
&#9;&#9;local tflag = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name = &apos;DisplayStatsHighlight&apos;
&#9;&#9;tflag.Parent = otherstats
&#9;&#9;ResetAllStats(player)
&#9;&#9;
&#9;end
&#9;
&#9;xpVersion.Value=CURRENT_XP_VERSION
end

local function MakeLeaderstats()
&#9;local leaderstats = Instance.new(&apos;Model&apos;)
&#9;leaderstats.Name = &apos;leaderstats&apos;

&#9;local kos = Instance.new(&apos;IntValue&apos;, leaderstats)
&#9;kos.Name = &apos;KOs&apos;

&#9;local wos = Instance.new(&apos;IntValue&apos;, leaderstats)
&#9;wos.Name = &apos;WOs&apos;

&#9;return leaderstats
end

local function MakeOtherstats()
&#9;local otherstats = Instance.new(&apos;Model&apos;)
&#9;otherstats.Name = &apos;otherstats&apos;

&#9;local streakLength = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;streakLength.Name = &apos;StreakLength&apos;
&#9;
&#9;local MatchXp = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;MatchXp.Name = &apos;MatchXP&apos;
&#9;
&#9;local MatchXp = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;MatchXp.Name = &apos;Level&apos;

&#9;return otherstats
end



local function MakeWeaponFrags()
&#9;local weaponFrags = Instance.new(&apos;Model&apos;)
&#9;weaponFrags.Name = &apos;WeaponFrags&apos;

&#9;for _, weapon in pairs(WeaponData:GetChildren()) do
&#9;&#9;local frags = Instance.new(&apos;IntValue&apos;, weaponFrags)
&#9;&#9;frags.Name = weapon.Name
&#9;end

&#9;return weaponFrags
end

local function MakePersistentData(player)
&#9;local PersistentModel = Instance.new(&apos;Model&apos;)
&#9;PersistentModel.Name = &apos;PersistentModel&apos;
&#9;local WeaponPersistence = Instance.new(&apos;Model&apos;)
&#9;WeaponPersistence.Name = &apos;WeaponPersistence&apos;
&#9;WeaponPersistence.Parent = PersistentModel
&#9;for _, weapon in pairs(WeaponData:GetChildren()) do
&#9;&#9;local wmodel = Instance.new(&apos;Model&apos;)
&#9;&#9;wmodel.Name=weapon.Name

&#9;&#9;local frags = RegisterInt:Invoke(player,weapon.Name..PersistentKeys[&apos;WeaponKOSuffix&apos;])
&#9;&#9;frags.Name = &apos;KOs&apos;
&#9;&#9;frags.Parent = wmodel
&#9;&#9;frags = RegisterInt:Invoke(player,weapon.Name..PersistentKeys[&apos;WeaponWOSuffix&apos;])
&#9;&#9;frags.Name = &apos;WOs&apos;
&#9;&#9;frags.Parent = wmodel

&#9;&#9;wmodel.Parent=WeaponPersistence
&#9;end
&#9;
&#9;local KOs = RegisterInt:Invoke(player,PersistentKeys[&apos;TotalKOs&apos;])
&#9;KOs.Parent = PersistentModel
&#9;local WOs = RegisterInt:Invoke(player,PersistentKeys[&apos;TotalWOs&apos;])
&#9;WOs.Parent = PersistentModel

&#9;local MVPs = RegisterInt:Invoke(player,PersistentKeys[&apos;MVPs&apos;])
&#9;MVPs.Parent = PersistentModel

&#9;local GamesPlayed = RegisterInt:Invoke(player,PersistentKeys[&apos;GamesPlayed&apos;])
&#9;GamesPlayed.Parent = PersistentModel

&#9;local LastJoin = RegisterInt:Invoke(player,PersistentKeys[&apos;LastJoin&apos;])
&#9;LastJoin.Parent = PersistentModel
&#9;LastJoin.Value= tick()

&#9;local MostKills = RegisterInt:Invoke(player,PersistentKeys[&apos;MostKOs&apos;])
&#9;MostKills.Parent = PersistentModel
&#9;
&#9;local MostDeaths = RegisterInt:Invoke(player,PersistentKeys[&apos;MostWOs&apos;])
&#9;MostDeaths.Parent = PersistentModel

&#9;local AverageWOs = RegisterNumber:Invoke(player,PersistentKeys[&apos;AverageWOs&apos;])
&#9;AverageWOs.Parent = PersistentModel
&#9;
&#9;local AverageKOs = RegisterNumber:Invoke(player,PersistentKeys[&apos;AverageKOs&apos;])
&#9;AverageKOs.Parent = PersistentModel
&#9;
&#9;local BestStreak = RegisterInt:Invoke(player,PersistentKeys[&apos;BestStreak&apos;])
&#9;BestStreak.Parent = PersistentModel
&#9;
&#9;local TotalXp = RegisterInt:Invoke(player,PersistentKeys[&apos;XP&apos;])
&#9;TotalXp.Parent = PersistentModel

&#9;local XPVersion = RegisterInt:Invoke(player,PersistentKeys[&apos;XP_VERSION&apos;],function() UpgradeVersion(player) end )
&#9;XPVersion.Parent = PersistentModel
&#9;return PersistentModel
end

local function IncrementStat(player, statModelName, statName)
&#9;local statModel = player:FindFirstChild(statModelName)
&#9;if statModel then
&#9;&#9;local stat = statModel:FindFirstChild(statName)
&#9;&#9;if stat then
&#9;&#9;&#9;stat.Value = stat.Value + 1
&#9;&#9;&#9;return stat.Value
&#9;&#9;end
&#9;end
end

--I give up.
local function IncrementValue(initialObject, namesToValue)
&#9;local tobj = initialObject
&#9;for _,i in ipairs(namesToValue) do
&#9;&#9;if not tobj:FindFirstChild(i) then return end
&#9;&#9;tobj = tobj[i]
&#9;end
&#9;if tobj then
&#9;&#9;&#9;tobj.Value = tobj.Value + 1
&#9;&#9;&#9;return tobj.Value
&#9;end
end

local function SetStat(player, statModelName, statName, newValue)
&#9;local statModel = player:FindFirstChild(statModelName)
&#9;if statModel then
&#9;&#9;local stat = statModel:FindFirstChild(statName)
&#9;&#9;if stat then
&#9;&#9;&#9;stat.Value = newValue
&#9;&#9;end
&#9;end
end


-- When a player dies, publish the death and attribute points
local function OnDied(deadPlayer, deadHumanoid)
&#9;if RoundOver then return end -- Don&apos;t publish or update scores after round end

&#9;AddDiedEvent:Invoke(deadPlayer, deadHumanoid) -- Publish the death

&#9;-- Check for possible attacking player and attribute points accordingly
&#9;local creatorTag = deadHumanoid:FindFirstChild(&apos;creator&apos;)
&#9;if creatorTag and creatorTag:IsA(&apos;ObjectValue&apos;) and creatorTag.Value and creatorTag.Value:IsA(&apos;Player&apos;) and creatorTag.Value ~= deadPlayer then
&#9;&#9;IncrementStat(creatorTag.Value, Leaderstats.Name, &apos;KOs&apos;) -- Give attacker a Knockout point
&#9;&#9;IncrementStat(creatorTag.Value, &apos;PersistentModel&apos;, PersistentKeys[&apos;TotalKOs&apos;]) -- Give attacker a total ko point
&#9;&#9;
&#9;&#9;local weaponTag = creatorTag:FindFirstChild(&apos;weaponName&apos;)
&#9;&#9;if weaponTag and weaponTag.Value then
&#9;&#9;&#9;IncrementStat(creatorTag.Value, WeaponFrags.Name, weaponTag.Value)
&#9;&#9;&#9;-- Give attacker&apos;s weapon a point
&#9;&#9;&#9;IncrementValue(creatorTag.Value, {&apos;PersistentModel&apos;,&apos;WeaponPersistence&apos;,weaponTag.Value,&apos;KOs&apos;})
&#9;&#9;&#9;IncrementValue(deadPlayer, {&apos;PersistentModel&apos;,&apos;WeaponPersistence&apos;,weaponTag.Value,&apos;WOs&apos;})
&#9;&#9;end
&#9;end

&#9;IncrementStat(deadPlayer, Leaderstats.Name, &apos;WOs&apos;) -- Give deadPlayer a Wipeout point
&#9;IncrementStat(deadPlayer, &apos;PersistentModel&apos;, PersistentKeys[&apos;TotalWOs&apos;])
end

-- When player spawns, reconnect OnDied
local function OnCharacterAdded(player, character)
&#9;local humanoid = WaitForChild(character, &apos;Humanoid&apos;)
&#9;humanoid.Died:connect(function()
&#9;&#9;OnDied(player, humanoid)
&#9;end)
end

-- When a new player joins, give them stats and connect OnCharacterAdded
local function OnPlayerAdded(player)
&#9;Leaderstats:Clone().Parent = player
&#9;WeaponFrags:Clone().Parent = player
&#9;Otherstats:Clone().Parent = player
&#9;
&#9;local persistentModel = MakePersistentData(player)
&#9;persistentModel.Parent = player
&#9;-- Connect to current and future characters
&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
end



local function OnSignalerChanged(newValue)
&#9;if newValue == &apos;SCORE_VIEWING&apos; or newValue == &apos;SCORE_VIEWING_PRE_VOTE&apos; then -- End of round
&#9;&#9;RoundOver = true

&#9;&#9;local ranks = {}
&#9;&#9;for i in string.gmatch(SerializedRanks.Value,&apos;([^,]*),&apos;) do
&#9;&#9;&#9;table.insert(ranks,i)
&#9;&#9;&#9;print(i) 
&#9;&#9;end
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;local myGamesPlayed = IncrementStat(player, &apos;PersistentModel&apos;, PersistentKeys[&apos;GamesPlayed&apos;])
&#9;&#9;&#9;--award mvp
&#9;&#9;&#9;if player.Name == ranks[1] then
&#9;&#9;&#9;&#9;local myGamesPlayed = IncrementStat(player, &apos;PersistentModel&apos;, PersistentKeys[&apos;MVPs&apos;])
&#9;&#9;&#9;end

&#9;&#9;&#9;if player:FindFirstChild(&apos;leaderstats&apos;) and player:FindFirstChild(&apos;PersistentModel&apos;) then
&#9;&#9;&#9;&#9;local tpersist = player.PersistentModel
&#9;&#9;&#9;&#9;if player.leaderstats:FindFirstChild(&apos;KOs&apos;) then
&#9;&#9;&#9;&#9;&#9;--this match&apos;s kos
&#9;&#9;&#9;&#9;&#9;local newKos = player.leaderstats.KOs.Value
&#9;&#9;&#9;&#9;&#9;--set max kos
&#9;&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;MostKOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;&#9;local oldKos = tpersist[PersistentKeys[&apos;MostKOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;&#9;oldKos.Value = math.max(oldKos.Value, newKos)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;--set average kos
&#9;&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;AverageKOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;&#9;local oldAverage = tpersist[PersistentKeys[&apos;AverageKOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;&#9;oldAverage.Value = (((myGamesPlayed-1)*oldAverage.Value)+newKos)/myGamesPlayed
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if player.leaderstats:FindFirstChild(&apos;WOs&apos;) then
&#9;&#9;&#9;&#9;&#9;--this match&apos;s wos
&#9;&#9;&#9;&#9;&#9;local newWos = player.leaderstats.WOs.Value
&#9;&#9;&#9;&#9;&#9;--set max wos
&#9;&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;MostWOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;&#9;local oldWos = tpersist[PersistentKeys[&apos;MostWOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;&#9;oldWos.Value = math.max(oldWos.Value, newWos)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;--set average wos
&#9;&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;AverageWOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;&#9;local oldAverage = tpersist[PersistentKeys[&apos;AverageWOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;&#9;oldAverage.Value = (((myGamesPlayed-1)*oldAverage.Value)+newWos)/myGamesPlayed
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;end
&#9;&#9; 

&#9;elseif newValue == &apos;PLAYING&apos; then -- End of end of round
&#9;&#9;RoundOver = false

&#9;&#9;-- Reset all stats
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;while player:FindFirstChild(Leaderstats.Name) do
&#9;&#9;&#9;&#9;player[Leaderstats.Name]:Destroy()
&#9;&#9;&#9;end
&#9;&#9;&#9;Leaderstats:Clone().Parent = player

&#9;&#9;&#9;while player:FindFirstChild(WeaponFrags.Name) do
&#9;&#9;&#9;&#9;player[WeaponFrags.Name]:Destroy()
&#9;&#9;&#9;end
&#9;&#9;&#9;WeaponFrags:Clone().Parent = player
&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;end
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Otherstats = MakeOtherstats()
Leaderstats = MakeLeaderstats()
WeaponFrags = MakeWeaponFrags()

-- Connect to all players, current and future
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end
PlayersService.PlayerAdded:connect(OnPlayerAdded)

GameStateSignaler.Changed:connect(OnSignalerChanged)
</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX51">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StreakTracker</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local RoundScript = WaitForChild(game.Workspace, &apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(RoundScript,&apos;GameStateSignaler&apos;)
local FragFeed = WaitForChild(game.Workspace,&apos;FragFeed&apos;)
local AddCustomEvent = WaitForChild(FragFeed,&apos;AddCustomEvent&apos;)

local Sounds = 
{
&#9;StreakNotification = 104480252
}

local StreakLevels =
{
&#9;[3] = {Sound = 104480252, Title = &quot;&apos;s on a streak!&quot;, Global = true},
&#9;[5] = {Sound = 104480252, Title = &quot; is on fire!&quot;, Global = true},
&#9;[8] = {Sound = 104480252, Title = &quot; is UNSTOPPABLE!&quot;, Global = true},
}

--key = player
--value = 
--&#9;&#9;currentStreak
local PlayerEntries ={}

function PublishStreak(player,streak)
&#9;local streakLevel = StreakLevels[streak]
&#9;if streakLevel then
&#9;&#9;Delay(.5,function()
&#9;&#9;&#9;local nsound = Instance.new(&apos;Sound&apos;)
&#9;&#9;&#9;nsound.SoundId = &apos;http://www.roblox.com/asset/?id=&apos;.. streakLevel[&apos;Sound&apos;]
&#9;&#9;&#9;nsound.Volume = .6
&#9;&#9;&#9;nsound.Parent = player
&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;nsound:Play()
&#9;&#9;end)
&#9;&#9;game.Debris:AddItem(nsound,3)
&#9;&#9;--[[
&#9;&#9;if player.PlayerGui and player.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;) then
&#9;&#9;&#9;local strval = Instance.new(&apos;StringValue&apos;)
&#9;&#9;&#9;strval.Value = &apos;Streak#&apos;..&apos;1&apos;
&#9;&#9;&#9;strval.Parent = player.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;)
&#9;&#9;end
&#9;&#9;--]]
&#9;&#9;if streakLevel.Global then
&#9;&#9;&#9;AddCustomEvent:Invoke(player.Name..streakLevel[&apos;Title&apos;],
&#9;&#9;&#9;&#9;game.Players:GetChildren())
&#9;&#9;else
&#9;&#9;&#9;AddCustomEvent:Invoke(player.Name..streakLevel[&apos;Title&apos;],{player})
&#9;&#9;end
&#9;end
end

function OnLeaderstatsAdded(nplayer,leaderstats)
&#9;local kos = WaitForChild(leaderstats,&apos;KOs&apos;) &#9;
&#9;local wos = WaitForChild(leaderstats,&apos;WOs&apos;) &#9;
&#9;local persistStats = WaitForChild(nplayer,&apos;PersistentModel&apos;) 
&#9;local bestStreak = WaitForChild(persistStats,&apos;Best_Streak_Ever&apos;)
&#9;local otherstats = WaitForChild(nplayer,&apos;otherstats&apos;) 
&#9;local currentStreak = WaitForChild(otherstats,&apos;StreakLength&apos;) 
&#9;local oldKos=kos.Value
&#9;local oldWos = wos.Value
&#9;kos.Changed:connect(function() 
&#9;&#9;if kos.Value&gt;oldKos then
&#9;&#9;&#9;currentStreak.Value=currentStreak.Value+1
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;oldKos= kos.Value
&#9;&#9;&#9;PublishStreak(nplayer,currentStreak.Value)
&#9;&#9;&#9;
&#9;&#9;end
&#9;end)
&#9;wos.Changed:connect(function()
&#9;&#9;if wos.Value&gt;oldWos then
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;currentStreak.Value=0
&#9;&#9;end
&#9;&#9;
&#9;  end)
&#9;GameStateSignaler.Changed:connect(function()
&#9;&#9;if GameStateSignaler.Value == &apos;SCORE_VIEWING&apos; or
&#9;&#9;&#9; GameStateSignaler.Value == &apos;SCORE_VIEWING_PRE_VOTE&apos; then
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;currentStreak.Value=0
&#9;&#9;end
&#9;end)
end


function OnPlayerAdded(nplayer)
&#9;if nplayer:FindFirstChild(&apos;leaderstats&apos;) then
&#9;&#9;OnLeaderstatsAdded(nplayer,nplayer.leaderstats)
&#9;end &#9;
&#9;
&#9;nplayer.ChildAdded:connect(function(nchild)
&#9;&#9;if nchild.Name ==&apos;leaderstats&apos; then 
&#9;&#9;&#9;OnLeaderstatsAdded(nplayer,nchild) 
&#9;end end)&#9;
&#9;
end

for _, i in pairs(game.Players:GetChildren()) do
&#9;OnPlayerAdded(i)
end

game.Players.PlayerAdded:connect(OnPlayerAdded)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX52">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">XPTracker</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local XP_CONSTS =
{
&#9;KO = 10,
&#9;BaseMatch = 20,
&#9;DailyMatchMulti = 2,
&#9;LevelMatchMulti = .5,
&#9;PlaceMatchMulti =
&#9;{
&#9;&#9;1,
&#9;&#9;1.1,
&#9;&#9;1.15,
&#9;&#9;1.25,
&#9;&#9;1.5,
&#9;&#9;2,
&#9;&#9;3,
&#9;&#9;4,
&#9;},
&#9;StreakMultiplier = 
&#9;{
&#9;&#9;1,
&#9;&#9;1,
&#9;&#9;1.5,
&#9;&#9;1.5,
&#9;&#9;2,
&#9;&#9;2,
&#9;&#9;2.5,
&#9;&#9;2.5,
&#9;&#9;3,
&#9;}
}

local MainRoundScript = WaitForChild(game.Workspace,&apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(MainRoundScript,&apos;GameStateSignaler&apos;)
local SerializedRanks = WaitForChild(MainRoundScript,&apos;SerializedRanks&apos;)

GameStateSignaler.Changed:connect(function()
&#9;if GameStateSignaler.Value==&quot;SCORE_VIEWING&quot; then
&#9;&#9;
&#9;&#9;local ranks = {}
&#9;&#9;for i in string.gmatch(SerializedRanks.Value,&apos;([^,]*),&apos;) do
&#9;&#9;&#9;table.insert(ranks,i)
&#9;&#9;&#9;print(i) 
&#9;&#9;end
&#9;end
end)


function CalculateKOXP(StreakVal)
&#9;local streakLevel = math.min(StreakVal,#XP_CONSTS[&apos;StreakMultiplier&apos;])
&#9;local multiplier = XP_CONSTS[&apos;StreakMultiplier&apos;][streakLevel]
&#9;return (XP_CONSTS[&apos;KO&apos;]*multiplier)
end

function CalculateMatchBonus(level,place,numPlayers,getDailyBonus)
&#9;&#9;local dailyMult = 0
&#9;&#9;if getDailyBonus then
&#9;&#9;&#9;dailyMult = XP_CONSTS[&apos;DailyMatchMulti&apos;]
&#9;&#9;end
&#9;&#9;local adjustedPlace = math.min(math.max(1,numPlayers-(place-1)),#XP_CONSTS[&apos;PlaceMatchMulti&apos;])
&#9;&#9;print(&apos;adjusted place =&apos;..adjustedPlace)
&#9;&#9;local multiplier = (XP_CONSTS[&apos;LevelMatchMulti&apos;]*level)+dailyMult+XP_CONSTS[&apos;PlaceMatchMulti&apos;][adjustedPlace]
&#9;&#9;multiplier = math.max(1,multiplier)
&#9;&#9;return XP_CONSTS[&apos;BaseMatch&apos;]*multiplier
end

function CalculateXpForLevel(level)
&#9;return (level - 1)*(50+(50*math.floor((level-2)/2)))
end


function CalculateLevelAtXp(xp)
&#9;local level = ((math.sqrt((4*xp)+25)+5)/10)
&#9;if level==math.floor(level) then
&#9;&#9;return level
&#9;end
&#9;level = math.floor(level)
&#9;while CalculateXpForLevel(level)&lt;xp do
&#9;&#9;level= level+1
&#9;end
&#9;&#9;return level-1 
end

function OnPlayerAdded(nplayer)
&#9;local leaderstats = WaitForChild(nplayer,&apos;leaderstats&apos;) &#9;
&#9; &#9;
&#9;local persistStats = WaitForChild(nplayer,&apos;PersistentModel&apos;) 
&#9;local totalXP = WaitForChild(persistStats,&apos;Total_XP&apos;) 
&#9;
&#9;local otherStats = WaitForChild(nplayer,&apos;otherstats&apos;) 
&#9;local currentStreak = WaitForChild(otherStats,&apos;StreakLength&apos;) 
&#9;local matchXP = WaitForChild(otherStats,&apos;MatchXP&apos;) 
&#9;local savedLevel = WaitForChild(otherStats,&apos;Level&apos;) 
&#9;
&#9;savedLevel.Value = CalculateLevelAtXp(totalXP.Value)
&#9;local oldStreak=currentStreak.Value
&#9;
&#9;currentStreak.Changed:connect(function() 
&#9;&#9;if currentStreak.Value&gt;0 then
&#9;&#9;&#9;local kxp =CalculateKOXP(currentStreak.Value)
&#9;&#9;&#9;matchXP.Value = matchXP.Value + kxp
&#9;&#9;&#9;oldStreak= currentStreak.Value&#9;
&#9;&#9;&#9;--[[
&#9;&#9;&#9;if nplayer.PlayerGui and nplayer.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;) then
&#9;&#9;&#9;&#9;local strval = Instance.new(&apos;StringValue&apos;)
&#9;&#9;&#9;&#9;strval.Value = &apos;Kill#&apos;..kxp
&#9;&#9;&#9;&#9;strval.Parent = nplayer.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;--]]
&#9;&#9;end
&#9;end)
&#9;GameStateSignaler.Changed:connect(function()
&#9;&#9;if GameStateSignaler.Value==&apos;SCORE_VIEWING&apos; then
&#9;&#9;&#9;
&#9;&#9;&#9;local ranks = {}
&#9;&#9;&#9;local place = 0
&#9;&#9;&#9;for i in string.gmatch(SerializedRanks.Value,&apos;([^,]*),&apos;) do
&#9;&#9;&#9;&#9;table.insert(ranks,i)
&#9;&#9;&#9;&#9;print(i) 
&#9;&#9;&#9;&#9;if i == nplayer.Name then
&#9;&#9;&#9;&#9;&#9;place=#ranks+1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local matchBonus = CalculateMatchBonus(CalculateLevelAtXp(totalXP.Value),place,game.Players.NumPlayers,false)
&#9;&#9;&#9;totalXP.Value = totalXP.Value + matchXP.Value + matchBonus
&#9;&#9;&#9;savedLevel.Value = CalculateLevelAtXp(totalXP.Value)
&#9;&#9;end&#9;&#9;
&#9;end)
end

for _, i in pairs(game.Players:GetChildren()) do
&#9;OnPlayerAdded(i)
end

game.Players.PlayerAdded:connect(OnPlayerAdded)</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX53">
		<Properties>
			<string name="Name">StarterPack</string>
		</Properties>
		<Item class="Tool" referent="RBX54">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>-1.25</Y>
					<Z>0</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>-1</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>-0</R12>
					<R20>1</R20>
					<R21>0</R21>
					<R22>-0</R22>
				</CoordinateFrame>
				<string name="Name">Sword</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746192</url></Content>
				<string name="ToolTip">Sword</string>
			</Properties>
			<Item class="SpecialMesh" referent="RBX55">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94746028</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746105</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX56">
				<Properties>
					<string name="Name">PlayOverhead</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX57">
				<Properties>
					<string name="Name">PlaySlash</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX58">
				<Properties>
					<string name="Name">PlayThrust</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX59">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SwordScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end


local DebrisService = Game:GetService(&quot;Debris&quot;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local damage = 10


local SLASH_DAMAGE = 45
local LUNGE_DAMAGE = 60
local OVERHEAD_SLASH_DAMAGE = 100
local CAN_CUT_TREES = true

local Tool = script.Parent
local Handle = Tool.Handle

local KILL_FEED_ICON_URL = &apos;http://www.roblox.com/asset/?id=94746323&apos;

local MyCharacter
local MyHumanoid

local PlaySlash
local PlayThrust
local PlayOverhead

local AttackSequence = {}
local SlashSound = WaitForChild(Handle,&apos;SlashSound&apos;)

local OverheadSound = WaitForChild(Handle,&apos;OverheadSound&apos;)

local LungeSound = WaitForChild(Handle,&apos;LungeSound&apos;)

local UnsheathSound = WaitForChild(Handle,&apos;UnsheathSound&apos;)

local HitSound = WaitForChild(Handle,&apos;HitSound&apos;)

local IsCrystal = WaitForChild(Tool,&apos;IsCrystal&apos;)

local HitCharacters

local CreatorTag = nil

local function CheckInTreesModel(object)
&#9;if object == nil or not Workspace:FindFirstChild(&apos;Trees&apos;) or not object.Parent or object.Parent.Name == &apos;Billboard&apos; then return false end
&#9;return object:IsDescendantOf(Workspace.Trees)
end

function Blow(hit)
&#9;if (hit.Parent == nil) then return end -- happens when bullet hits sword
&#9;local humanoid = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;local vCharacter = Tool.Parent
&#9;--local vPlayer = game.Players:playerFromCharacter(vCharacter)
&#9;local hum = vCharacter:findFirstChild(&quot;Humanoid&quot;) -- non-nil if tool held by a character
&#9;if humanoid~=nil and humanoid ~= hum and hum ~= nil and HitCharacters and not HitCharacters[humanoid.Parent] then
&#9;&#9;-- final check, make sure sword is in-hand
&#9;&#9;local right_arm = vCharacter:FindFirstChild(&quot;Right Arm&quot;)
&#9;&#9;if (right_arm ~= nil) then
&#9;&#9;&#9;local joint = right_arm:FindFirstChild(&quot;RightGrip&quot;)
&#9;&#9;&#9;if (joint ~= nil and (joint.Part0 == Handle or joint.Part1 == Handle)) then
&#9;&#9;&#9;&#9;HitCharacters[humanoid.Parent] = true
&#9;&#9;&#9;&#9;--TagHumanoid(humanoid, vPlayer)
&#9;&#9;&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;&#9;if IsCrystal.Value then
&#9;&#9;&#9;&#9;&#9;&#9;HitSound:Play()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;hitBindable:Invoke(damage, CreatorTag)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif CheckInTreesModel(hit) and Tool.Enabled == false and CAN_CUT_TREES then
&#9;&#9;hit:BreakJoints()
&#9;&#9;if hit and not hit.Parent:FindFirstChild(&apos;Cut&apos;) then
&#9;&#9;&#9;if hit.Parent and hit.Parent:FindFirstChild(&apos;Ball&apos;) then
&#9;&#9;&#9;&#9;hit.Parent.Ball.Velocity =
&#9;&#9;&#9;&#9;&#9;hit.Parent.Ball.Velocity +
&#9;&#9;&#9;&#9;&#9; CFrame.Angles(0, -math.rad(math.random(0, 180)), 0) * ((hit.CFrame.p - MyCharacter.Torso.CFrame.p).unit:Cross(Vector3.new(0,1,0)) * 15)
&#9;&#9;&#9;&#9;local cut = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;&#9;cut.Value = true
&#9;&#9;&#9;&#9;cut.Name = &apos;Cut&apos;
&#9;&#9;&#9;&#9;cut.Parent = hit.Parent
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&apos;No Ball&apos;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end
--[[
function TagHumanoid(humanoid, player)
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end 
&#9;local creatorTag = Instance.new(&quot;ObjectValue&quot;)
&#9;creatorTag.Value = player
&#9;creatorTag.Name = &quot;creator&quot;
&#9;DebrisService:AddItem(creatorTag, 1.5)
&#9;creatorTag.Parent = humanoid

&#9;local weaponIconTag = Instance.new(&quot;StringValue&quot;)
&#9;weaponIconTag.Value = KILL_FEED_ICON_URL
&#9;weaponIconTag.Name = &quot;icon&quot;
&#9;weaponIconTag.Parent = creatorTag
end
--]]
function Attack()
&#9;damage = SLASH_DAMAGE
&#9;SlashSound:play()

&#9;if PlaySlash then
&#9;&#9;PlaySlash.Value = not PlaySlash.Value
&#9;end
&#9;wait(0.6)
end

function OverheadSlash()
&#9;damage = OVERHEAD_SLASH_DAMAGE
&#9;if PlayOverhead then
&#9;&#9;PlayOverhead.Value = not PlayOverhead.Value
&#9;end
&#9;--OverheadSound:Play()
LungeSound:play()
&#9;local force = Instance.new(&quot;BodyVelocity&quot;)
&#9;force.velocity = Vector3.new(0,10,0)
&#9;DebrisService:AddItem(force, 0.5)
&#9;force.Parent = Tool.Parent.Torso
&#9;wait(0.6)
end

function Lunge()
&#9;damage = LUNGE_DAMAGE
&#9;--LungeSound:play()
&#9;OverheadSound:Play()
&#9;if PlayThrust then
&#9;&#9;PlayThrust.Value = not PlayThrust.Value
&#9;end
&#9;wait(.45)
&#9;swordOut()
&#9;wait(.05)
&#9;if force then
&#9;&#9;force.Parent = nil
&#9;end
&#9;wait(.15)
&#9;swordUp()

&#9;damage = SLASH_DAMAGE
end

function swordUp()
&#9;Tool.GripForward = Vector3.new(1,0,0)
&#9;Tool.GripRight = Vector3.new(0,0,1)
&#9;Tool.GripUp = Vector3.new(0,1,0)
end

function swordOut()
&#9;Tool.GripForward = Vector3.new(0,-1,0)
&#9;Tool.GripRight = Vector3.new(0,0,1)
&#9;Tool.GripUp = Vector3.new(-1,0,0)
end

table.insert(AttackSequence, Attack)
table.insert(AttackSequence, Lunge)
table.insert(AttackSequence, OverheadSlash)

local CurrentIndex = 1

local LastAttackTime = tick()

Tool.Enabled = true
function OnActivated()
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;Tool.Enabled = false
&#9;HitCharacters = {[MyCharacter] = true}
&#9;----------- ATTACK SEQUENCE CODE --------------
&#9;local now = tick()
&#9;if now - LastAttackTime &gt; 1.5 then
&#9;&#9;CurrentIndex = 1
&#9;else
&#9;&#9;CurrentIndex = CurrentIndex + 1
&#9;end
&#9;LastAttackTime = now
&#9;if CurrentIndex &gt; #AttackSequence then
&#9;&#9;CurrentIndex = 1
&#9;end

  -----------------------------------------------
&#9;AttackSequence[CurrentIndex]()
&#9;if MyHumanoid == nil then
&#9;&#9;print(&quot;Humanoid not found&quot;)
&#9;&#9;return 
&#9;end
&#9;HitCharacters = nil
&#9;Tool.Enabled = true
end


function OnEquipped()
&#9;Delay(0.55, function() UnsheathSound:play() end)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = MyCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;MyHumanoid.WalkSpeed = 20
&#9;PlaySlash = WaitForChild(Tool, &apos;PlaySlash&apos;)
&#9;PlayOverhead = WaitForChild(Tool, &apos;PlayOverhead&apos;)
&#9;PlayThrust = WaitForChild(Tool, &apos;PlayThrust&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyCharacter)
end

function OnUnequipped()
&#9;MyHumanoid.WalkSpeed = 16
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

-- Create the CreatorTag once at the start
CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos;
local weaponNameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = KILL_FEED_ICON_URL

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

connection = Handle.Touched:connect(Blow)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX60">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AnimationScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local Animations = {}
local MyHumanoid
local MyCharacter


local function PlayAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Play()
&#9;end
end

local function StopAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Stop()
&#9;end
end


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;Animations[&apos;EquipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim5&apos;))
&#9;&#9;Animations[&apos;IdleAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleAnim3&apos;))
&#9;&#9;Animations[&apos;OverheadAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;OverheadAnim2&apos;))
&#9;&#9;Animations[&apos;SlashAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;SlashAnim2&apos;))
&#9;&#9;Animations[&apos;ThrustAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;ThrustAnim2&apos;))
&#9;&#9;Animations[&apos;UnequipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;UnequipAnim2&apos;))
&#9;end
&#9;PlayAnimation(&apos;EquipAnim&apos;)
&#9;PlayAnimation(&apos;IdleAnim&apos;)
end

function OnUnequipped()
&#9;for animName, _ in pairs(Animations) do
&#9;&#9;StopAnimation(animName)
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

WaitForChild(Tool, &apos;PlaySlash&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;SlashAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;SlashAnim&apos;)
&#9;&#9;--end
&#9;end)

WaitForChild(Tool, &apos;PlayThrust&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;ThrustAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;ThrustAnim&apos;)
&#9;&#9;--end
&#9;end)

WaitForChild(Tool, &apos;PlayOverhead&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;OverheadAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;OverheadAnim&apos;)
&#9;&#9;--end
&#9;end)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX61">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Local Gui</string>
					<ProtectedString name="Source">local Tool = script.Parent;

enabled = true
function onButton1Down(mouse)
&#9;if not enabled then
&#9;&#9;return
&#9;end

&#9;enabled = false
&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;
&#9;while not Tool.Enabled do
&#9;&#9;wait(0.05)
&#9;end
&#9;
&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;enabled = true

end

function onEquippedLocal(mouse)

&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;mouse.Button1Down:connect(function() onButton1Down(mouse) end)
end


Tool.Equipped:connect(onEquippedLocal)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX62">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>0.299747467</X>
						<Y>2.99999928</Y>
						<Z>-0.199989319</Z>
						<R00>-3.42285489e-008</R00>
						<R01>0</R01>
						<R02>-1</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>1</R20>
						<R21>0</R21>
						<R22>-3.42285489e-008</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">1</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.600000024</X>
						<Y>3.60000038</Y>
						<Z>0.400000036</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX63">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94746028</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746105</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX64">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">SlashSound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds//swordslash.wav</url></Content>
						<float name="Volume">0.349999994</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX65">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">OverheadSound</string>
						<float name="Pitch">1.16999996</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds//swordslash.wav</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX66">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">LungeSound</string>
						<float name="Pitch">0.800000012</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds//swordlunge.wav</url></Content>
						<float name="Volume">0.25</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX67">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">UnsheathSound</string>
						<float name="Pitch">1.29999995</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds//unsheath.wav</url></Content>
						<float name="Volume">0.280000001</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX68">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">HitSound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=98220998</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
			</Item>
			<Item class="Animation" referent="RBX69">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94160581</url></Content>
					<string name="Name">EquipAnim5</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX70">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94108418</url></Content>
					<string name="Name">IdleAnim3</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX71">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94160738</url></Content>
					<string name="Name">OverheadAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX72">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94161088</url></Content>
					<string name="Name">SlashAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX73">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94161333</url></Content>
					<string name="Name">ThrustAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX74">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94095929</url></Content>
					<string name="Name">UnequipAnim2</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX75">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifierScript</string>
					<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do print(&apos;waiting for&apos; .. childName) wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
--local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local CrystalSwordModifierName = &apos;CrystalSword&apos;

local IsCrystal=WaitForChild(Tool,&apos;IsCrystal&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94746105&apos;
local CrystalSwordTexture = &apos;http://www.roblox.com/asset/?id=97912267&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=94746192&apos;
local CrystalIcon = &apos;http://www.roblox.com/asset/?id=97913524&apos;


function OnModifierAdded(nmodifier)
&#9;if nmodifier.Name == CrystalSwordModifierName then
&#9;&#9;IsCrystal.Value=true
&#9;&#9;Mesh.TextureId=CrystalSwordTexture
&#9;&#9;Tool.TextureId= CrystalIcon
&#9;&#9;Tool.ToolTip= &apos;Emerald Edge&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == CrystalSwordModifierName then
&#9;&#9;IsCrystal.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= CrystalIcon
&#9;&#9;Tool.ToolTip= &apos;Sword&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX76">
				<Properties>
					<string name="Name">IsCrystal</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX77">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Superball</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=96508620</url></Content>
				<string name="ToolTip">Superball</string>
			</Properties>
			<Item class="LocalScript" referent="RBX78">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Local Gui</string>
					<ProtectedString name="Source">local Tool = script.Parent;

enabled = true
function onButton1Down(mouse)
&#9;if not enabled then
&#9;&#9;return
&#9;end

&#9;enabled = false
&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;

&#9;wait(2)
&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;enabled = true

end

function onEquippedLocal(mouse)


&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;mouse.Button1Down:connect(function() onButton1Down(mouse) end)
end



Tool.Equipped:connect(onEquippedLocal)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX79">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">208</int>
					<CoordinateFrame name="CFrame">
						<X>874</X>
						<Y>69.5</Y>
						<Z>-122</Z>
						<R00>0</R00>
						<R01>1</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1</R12>
						<R20>1</R20>
						<R21>0</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">1</float>
					<float name="Friction">0</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0.200000003</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">0</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Sound" referent="RBX80">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Boing</string>
						<float name="Pitch">1.10000002</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=96543718</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
				<Item class="SpecialMesh" referent="RBX81">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=96501868</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>2</X>
							<Y>2</Y>
							<Z>2</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=96502130</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX82">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Equip</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97095034</url></Content>
						<float name="Volume">0.800000012</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX83">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Throw</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97095069</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX84">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AnimationScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local MyHumanoid
local MyCharacter

local EquipAnim
local IdleEquipAnim
local ThrowAnim
local UnEquipAnim


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = MyCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;EquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim2&apos;))
&#9;&#9;IdleEquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleEquipAnim2&apos;))
&#9;&#9;ThrowAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;ThrowAnim2&apos;))
&#9;&#9;UnEquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;UnEquipAnim2&apos;))
&#9;end
&#9;if EquipAnim then
&#9;&#9;EquipAnim:Play()
&#9;end
&#9;if IdleEquipAnim then
&#9;&#9;IdleEquipAnim:Play()
&#9;end
end

function OnUnequipped()
&#9;if EquipAnim then
&#9;&#9;EquipAnim:Stop()
&#9;end
&#9;if ThrowAnim then
&#9;&#9;ThrowAnim:Stop()
&#9;end
&#9;if IdleEquipAnim then
&#9;&#9;IdleEquipAnim:Stop()
&#9;end
&#9;if UnEquipAnim then
&#9;&#9;--UnEquipAnim:Play()
&#9;end

end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

WaitForChild(Tool, &apos;PlayThrow&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;if ThrowAnim then
&#9;&#9;&#9;ThrowAnim:Play()
&#9;&#9;end
&#9;end)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX85">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156486</url></Content>
					<string name="Name">IdleEquipAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX86">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156535</url></Content>
					<string name="Name">EquipAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX87">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156580</url></Content>
					<string name="Name">UnEquipAnim2</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX88">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94157627</url></Content>
					<string name="Name">ThrowAnim2</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX89">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifierScript</string>
					<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local MoneyBallModifierName = &apos;MoneySuperBall&apos;

local IsMoneyBall=WaitForChild(WaitForChild(Tool,&apos;CannonBall&apos;),&apos;IsMoneyBall&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=96502130&apos;
local MoneyBallTexture = &apos;http://www.roblox.com/asset/?id=97907437&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=96508620&apos;
local MoneyBallIcon = &apos;http://www.roblox.com/asset/?id=97817523&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MoneyBallModifierName then
&#9;&#9;IsMoneyBall.Value=true
&#9;&#9;Mesh.TextureId=MoneyBallTexture
&#9;&#9;Tool.TextureId= MoneyBallIcon
&#9;&#9;Tool.ToolTip= &apos;Moneyball&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MoneyBallModifierName then
&#9;&#9;IsMoneyBall.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;Tool.ToolTip= &apos;SuperBall&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX90">
				<Properties>
					<string name="Name">PlayThrow</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX91">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CannonScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local LAUNCH_VELOCITY = 170

local MissileMesh = Instance.new(&apos;SpecialMesh&apos;)
MissileMesh.Name = &quot;MissileMesh&quot;
MissileMesh.MeshType = Enum.MeshType.Sphere
MissileMesh.Parent = DecalHolder

local Tool = script.Parent
local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local HandleMesh = WaitForChild(Handle, &apos;Mesh&apos;)


local FloatForce = Instance.new(&apos;BodyForce&apos;)
FloatForce.force = Vector3.new(0, Handle:GetMass() * 192.6 * 0.5, 0)
FloatForce.Name = &quot;FloatingForce&quot;

local PlayersService = Game:GetService(&apos;Players&apos;)

local PlayThrow
local EquipSound
local ThrowSound

local MoneyBallColors = 
{
&#9;Vector3.new(.9,.8,0),
&#9;Vector3.new(1,1,1), 
&#9;--Vector3.new(159/255,101/255,1/255),
}

local CannonBallScript = WaitForChild(Tool,&apos;CannonBall&apos;)
local IsMoneyBall= WaitForChild(CannonBallScript,&apos;IsMoneyBall&apos;)


function RayCast(startPos, vec, rayLength, ignoreModel)
&#9;vec = vec.unit
&#9;local hitObject, hitPos = game.Workspace:FindPartOnRay(Ray.new(startPos + (vec * .01), vec * rayLength), Handle)
&#9;if hitObject and hitPos then
&#9;&#9;local distance = rayLength - (hitPos - startPos).magnitude
&#9;&#9;if (not hitObject:IsDescendantOf(ignoreModel)) and distance &gt; 0 then
&#9;&#9;&#9;return RayCast(hitPos, vec, distance)
&#9;&#9;end
&#9;end
&#9;return hitObject, hitPos
end

-- This will return nil if there is nothing in the way, otherwise it will return the closest position it can start the ball at.
function FindClosestOpenPosition(cframe, radius, direction, character)
&#9;if not (cframe and radius and direction and character) then
&#9;&#9;print(&quot;FindClosestOpenPosition: Bad Args&quot;);
&#9;&#9;return
&#9;end
&#9;
&#9;local rightArm = character:FindFirstChild(&apos;Right Arm&apos;)
&#9;--print(&quot;Right Arm:&quot; , rightArm)
&#9;local maxHitPos = nil
&#9;do
&#9;&#9;local hitObj, hitPos = RayCast(cframe.p + direction.unit * 3, -direction, 3, character)
&#9;&#9;if hitObj and hitPos and hitObj ~= rightArm then
&#9;&#9;&#9;--print(hitObj.Name, (hitObj == rightArm))
&#9;&#9;&#9;maxHitPos = hitPos + direction.unit * (radius + 0.05)
&#9;&#9;end
&#9;end
&#9;
&#9;for r = 0, 2 do
&#9;&#9;local objectYOffset =  CFrame.Angles(0, 0, r * math.pi/4) * cframe:vectorToWorldSpace(Vector3.new(0, radius + 0.1, 0))
&#9;&#9;local objectXOffset = CFrame.Angles(0, 0, r * math.pi/4) * cframe:vectorToWorldSpace(Vector3.new(radius + 0.1, 0, 0))
&#9;&#9;for x = -1, 1, 2 do
&#9;&#9;&#9;for y = -1, 1, 2 do
&#9;&#9;&#9;&#9;local hitObj, hitPos = RayCast(cframe.p + objectYOffset + objectXOffset + direction.unit * 3, -direction, 3, character)
&#9;&#9;&#9;&#9;if hitObj ~= rightArm and hitObj and hitPos and
&#9;&#9;&#9;&#9;&#9;&#9;(not maxHitPos or (cframe.p - hitPos).magnitude &gt; (cframe.p - maxHitPos).magnitude) then
&#9;&#9;&#9;&#9;&#9;--print(hitObj.Name, (hitObj == rightArm))
&#9;&#9;&#9;&#9;&#9;--print(&quot;Side vectors hit&quot;)
&#9;&#9;&#9;&#9;&#9;maxHitPos = hitPos
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local openPos
&#9;if maxHitPos then
 &#9;&#9;openPos = maxHitPos + direction.unit * (radius + 0.05)
&#9;else
&#9;&#9;--openPos = cframe + direction.unit * (radius + 0.05) 
&#9;end
&#9;--print(&quot;Missile pos&quot; , cframe.p , &quot;  new pos:&quot; , openPos)
&#9;return openPos
end


function Fire(v)
&#9;if ThrowSound then
&#9;&#9;ThrowSound:Play()
&#9;end

&#9;local vCharacter = Tool.Parent
&#9;local vPlayer = PlayersService:GetPlayerFromCharacter(vCharacter)

&#9;local missile = Instance.new(&quot;Part&quot;)
&#9;local spawnPos = Handle.Position --vCharacter.PrimaryPart.Position
&#9;missile.Size = Handle.Size
&#9;missile.Velocity = v * LAUNCH_VELOCITY
&#9;spawnPos = FindClosestOpenPosition(CFrame.new(Handle.CFrame.p, Handle.CFrame.p + v), missile.Size.Z / 2, v, vCharacter)
&#9;--spawnPos + Handle.CFrame:vectorToWorldSpace(Vector3.new(0, 0, -(missile.Size.Z))) -- + (v * 5)
&#9;if spawnPos then
&#9;&#9;missile.CFrame = CFrame.new(spawnPos, spawnPos + v)
&#9;else
&#9;&#9;--print(&quot;No Spawn Pos&quot;);
&#9;&#9;missile.CFrame = Handle.CFrame + Handle.CFrame:vectorToWorldSpace(Vector3.new(0, 0, -2.1))
&#9;end
&#9;missile.BrickColor = BrickColor.new(HandleMesh.VertexColor.X, HandleMesh.VertexColor.Y, HandleMesh.VertexColor.Z)
&#9;missile.FormFactor = Enum.FormFactor.Custom
&#9;missile.Shape = Enum.PartType.Ball
&#9;missile.BottomSurface = 0
&#9;missile.TopSurface = 0
&#9;missile.Name = &quot;Cannon Shot&quot;
&#9;missile.Elasticity = 1
&#9;missile.Reflectance = .2
&#9;missile.Friction = 0.1
&#9;FloatForce:Clone().Parent = missile&#9;
&#9;if Handle:FindFirstChild(&apos;Mesh&apos;) then
&#9;&#9;local missileMesh = Handle.Mesh:Clone()
&#9;&#9;missileMesh.Name =&apos;MissileMesh&apos;
&#9;&#9;missileMesh.Parent = missile
&#9;end
&#9;Tool.Handle.Boing:clone().Parent = missile

&#9;local new_script = script.Parent.CannonBall:clone()
&#9;new_script.Disabled = false
&#9;new_script.Parent = missile

&#9;local creator_tag = Instance.new(&quot;ObjectValue&quot;)
&#9;creator_tag.Value = vPlayer
&#9;creator_tag.Name = &quot;creator&quot;
&#9;local weaponName_tag = Instance.new(&apos;StringValue&apos;, creator_tag)
&#9;weaponName_tag.Name = &apos;weaponName&apos;
&#9;weaponName_tag.Value = Tool.Name
&#9;local weaponIcon_tag = Instance.new(&apos;StringValue&apos;, creator_tag)
&#9;weaponIcon_tag.Name = &apos;weaponIcon&apos;
&#9;weaponIcon_tag.Value = Tool.TextureId
&#9;creator_tag.Parent = missile

&#9;missile.Parent = game.Workspace
end

Tool.Enabled = true
function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;if PlayThrow then
&#9;&#9;PlayThrow.Value = not PlayThrow.Value
&#9;end
&#9;wait(0.03)
&#9;Tool.Enabled = false
&#9;wait(0.1)
&#9;local character = Tool.Parent
&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then
&#9;&#9;
&#9;&#9;if character:FindFirstChild(&apos;Right Arm&apos;) then
&#9;&#9;&#9;local targetPos = targetOverride or humanoid.TargetPoint
&#9;&#9;&#9;local lookAt = (targetPos - Handle.Position).unit
&#9;&#9;&#9;Handle.Transparency = 1
&#9;&#9;&#9;Fire(lookAt)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Can&apos;t find right arm&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;print(&quot;Humanoid not found&quot;)
&#9;end

&#9;if IsMoneyBall.Value then
&#9;&#9;nextColor=MoneyBallColors[math.random(#MoneyBallColors)]
&#9;&#9;HandleMesh.VertexColor=Vector3.new((math.random()*.1)-.05,(math.random()*.1)-.05,(math.random()*.1)-.05)+ nextColor
&#9;end

&#9;wait(1.5)
&#9;Handle.Transparency = 0
&#9;Tool.Enabled = true
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

local function OnEquipped()
&#9;EquipSound = WaitForChild(Handle, &apos;Equip&apos;)
&#9;ThrowSound = WaitForChild(Handle, &apos;Throw&apos;)
&#9;PlayThrow = WaitForChild(Tool, &apos;PlayThrow&apos;)
&#9;wait(0.2)
&#9;EquipSound:Play()
end

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)

local MAX_STEPS = 20

function LerpColor(startColor, endColor, duration)
&#9;local startTime = time()
&#9;while time() - startTime &lt; duration do
&#9;&#9;wait(1 / MAX_STEPS)
&#9;&#9;local lerpedVec = startColor:Lerp(endColor, (time() - startTime) / duration)
&#9;&#9;HandleMesh.VertexColor = lerpedVec
&#9;end
end

-- For luminance calculation formula look at: http://en.wikipedia.org/wiki/Grayscale
local function IsDark(color)
&#9;local cieLuminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b
&#9;return cieLuminance &lt; 0.4
end

while true do
&#9;local nextColor
&#9;if not IsMoneyBall.Value then
&#9;&#9;repeat
&#9;&#9;&#9;&#9;nextColor = BrickColor.random()
&#9;&#9;until not IsDark(nextColor.Color)
&#9;&#9;LerpColor(HandleMesh.VertexColor, Vector3.new(nextColor.r, nextColor.g, nextColor.b), 2)
&#9;&#9;Handle.BrickColor = nextColor
&#9;end
&#9;
&#9;
&#9;wait(0.1)
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX92">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CannonBall</string>
					<ProtectedString name="Source">print(&quot;Running cannon ball script&quot;)
local ball = script.Parent

local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

--local KILL_FEED_ICON_URL = &apos;rbxasset://Textures/Superball.png&apos;
local START_DAMAGE = 42
local MIN_DAMAGE = 10
local DECAY_RATIO = 1 / 1.65
local VELOCITY_DAMPING = 0.9
local BOING_VOLUME = 0.666
local damage = START_DAMAGE

local DebrisService = Game:GetService(&apos;Debris&apos;)

local BounceScript = WaitForChild(script, &apos;BounceEffect&apos;)

local IsMoneyBall= WaitForChild(script,&apos;IsMoneyBall&apos;)

local MyHumanoid

local r = game:service(&quot;RunService&quot;)

local last_sound_time = r.Stepped:wait() - 0.2

local LastHitCharacter

local DecalHolder = Instance.new(&quot;Part&quot;)
DecalHolder.Size = Vector3.new(2, 2, 2)
DecalHolder.Anchored = true
DecalHolder.CanCollide = false
DecalHolder.Transparency = 0.5
DecalHolder.Reflectance = 0
DecalHolder.FormFactor = Enum.FormFactor.Custom
DecalHolder.Shape = Enum.PartType.Block
DecalHolder.Size = Vector3.new(0.1, 0.1, 0.1)
DecalHolder.BottomSurface = 0
DecalHolder.TopSurface = 0
DecalHolder.Name = &quot;Bounce Spot&quot;
local DecalMesh = Instance.new(&apos;SpecialMesh&apos;)
DecalMesh.Name = &quot;BounceMesh&quot;
DecalMesh.MeshType = Enum.MeshType.Sphere
DecalMesh.Scale = Vector3.new(1,1,1)
DecalMesh.Parent = DecalHolder
local MoneySound = Instance.new(&apos;Sound&apos;)
MoneySound.Name = &apos;MoneySound&apos;
MoneySound.SoundId = &apos;http://www.roblox.com/Asset?ID=97688233&apos;
MoneySound.Volume = 1
MoneySound.Parent=DecalHolder

function FindHumanoidRecursive(p)
&#9;if (p.className == Workspace) then return nil end
&#9;local h = p:FindFirstChild(&quot;Humanoid&quot;)
&#9;if (h ~= nil) then return h end
&#9;if (p.Parent ~= nil) then return FindHumanoidRecursive(p.Parent) end
&#9;return nil
end

function CreateBounceEffect(position)
&#9;local DecalCopy = DecalHolder:Clone()
&#9;DecalCopy.Size = ball.Size
&#9;DecalCopy.BrickColor = ball.BrickColor
&#9;DecalCopy.CFrame = CFrame.new(position)
&#9;DebrisService:AddItem(DecalCopy, 2)
&#9;DecalCopy.Parent = Workspace
&#9;local bounceCopy = BounceScript:Clone()
&#9;bounceCopy.Parent = DecalCopy
&#9;bounceCopy.Disabled = false
&#9;Spawn(function()
&#9;&#9;wait(0)
&#9;&#9;if IsMoneyBall.Value and DecalCopy then
&#9;&#9;&#9;DecalCopy.MoneySound:Play()
&#9;&#9;end
&#9;end)
end

function onTouched(hit)
&#9;local myHumanoid
&#9;local creatorTag = ball:FindFirstChild(&apos;creator&apos;) 
&#9;if creatorTag and creatorTag.Value and creatorTag.Value.Character then
&#9;&#9;myHumanoid = creatorTag.Value.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;end
&#9;local humanoid = FindHumanoidRecursive(hit)
&#9;if humanoid~=nil then -- make sure not to damage yourself unless it has bounced already
&#9;&#9;if myHumanoid and (humanoid ~= myHumanoid or damage &lt; START_DAMAGE) and
&#9;&#9;&#9;&#9;&#9;&#9;&#9;(not LastHitCharacter or humanoid.Parent ~= LastHitCharacter) then
&#9;&#9;&#9;LastHitCharacter = humanoid.Parent
&#9;&#9;&#9;--TagHumanoid(humanoid, ball.creator.Value)
&#9;&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(damage, ball:FindFirstChild(&apos;creator&apos;))
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;local now = r.Stepped:wait()
&#9;&#9;if (now - last_sound_time &gt; 0.32) then
&#9;&#9;&#9;ball.Boing.Volume = math.max(0.17, math.min(BOING_VOLUME, BOING_VOLUME * ball.Velocity.magnitude / 130))
&#9;&#9;&#9;--print(ball.Boing.Volume)
&#9;&#9;&#9;ball.Boing:play()
&#9;&#9;&#9;last_sound_time = now
&#9;&#9;&#9;damage = math.max(MIN_DAMAGE, damage * DECAY_RATIO)
&#9;&#9;&#9;--ball.Velocity = ball.Velocity * VELOCITY_DAMPING
&#9;&#9;&#9;CreateBounceEffect(ball.Position)
&#9;&#9;end
&#9;&#9;if now - last_sound_time &gt; 0.3 then
&#9;&#9;&#9;print(&quot;Resetting last hit character&quot;)
&#9;&#9;&#9;LastHitCharacter = nil
&#9;&#9;end
&#9;end
end
--[[
function TagHumanoid(humanoid, player)
&#9;print(&quot;Tagging player as creator:&quot; , player.Name , &quot;as damaging&quot; , humanoid.Name , tick())
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end 
&#9;local creatorTag = Instance.new(&quot;ObjectValue&quot;)
&#9;creatorTag.Value = player
&#9;creatorTag.Name = &quot;creator&quot;
&#9;creatorTag.Parent = humanoid
&#9;DebrisService:AddItem(creatorTag, 2)

&#9;local weaponIconTag = Instance.new(&quot;StringValue&quot;)
&#9;weaponIconTag.Value = KILL_FEED_ICON_URL
&#9;weaponIconTag.Name = &quot;icon&quot;
&#9;weaponIconTag.Parent = creatorTag
end
--]]
connection = ball.Touched:connect(onTouched)

DebrisService:AddItem(ball, 5)
</ProtectedString>
				</Properties>
				<Item class="Script" referent="RBX93">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BounceEffect</string>
						<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DecalCopy = script.Parent
local BallSize = Vector3.new(2,2,2)
local BallScale = BallSize * 0.6
local BounceMesh = WaitForChild(DecalCopy, &apos;BounceMesh&apos;)


BounceMesh.Scale = Vector3.new()
for i = 1, 7 do
&#9;if DecalCopy then
&#9;&#9;BounceMesh.Scale = BallSize * BallScale * i * 0.07
&#9;&#9;DecalCopy.Transparency = DecalCopy.Transparency + 1 / 28
&#9;&#9;wait(0.03)
&#9;end
end
for i = 7, 1, -1 do
&#9;if DecalCopy then
&#9;&#9;BounceMesh.Scale = BallSize * BallScale * i * 0.07
&#9;&#9;DecalCopy.Transparency = DecalCopy.Transparency + 1 / 28
&#9;&#9;wait(0.03)
&#9;end
end
DecalCopy:Destroy()
</ProtectedString>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX94">
					<Properties>
						<string name="Name">IsMoneyBall</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX95">
					<Properties>
						<string name="Name">PlayThrow</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX96">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>-0.699999988</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Slingshot</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689365</url></Content>
				<string name="ToolTip">Slingshot</string>
			</Properties>
			<Item class="Part" referent="RBX97">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>-53.5561562</X>
						<Y>5.09753084</Y>
						<Z>-27.7533607</Z>
						<R00>0.946185231</R00>
						<R01>0.0517470278</R01>
						<R02>-0.319461197</R02>
						<R10>0.00558891892</R10>
						<R11>0.98437345</R11>
						<R12>0.17600435</R12>
						<R20>0.323576748</R20>
						<R21>-0.168318182</R21>
						<R22>0.931110501</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>-7.89214315e-025</X>
						<Y>1.44442375e-022</Y>
						<Z>-2.56070561e-025</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>3.63574669e-020</X>
						<Y>-0.00053787831</Y>
						<Z>3.62891825e-020</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2.4000001</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX98">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94689497</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.5</X>
							<Y>0.5</Y>
							<Z>0.5</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689543</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX99">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">SlingshotSound1</string>
						<float name="Pitch">1.20000005</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795238</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX100">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">SlingshotSound2</string>
						<float name="Pitch">0.699999988</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795288</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX101">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">SlingshotSound3</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795305</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX102">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Equip</string>
						<float name="Pitch">1.29999995</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97105188</url></Content>
						<float name="Volume">0.349999994</float>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX103">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalGuiAndAnimations</string>
					<ProtectedString name="Source">local Tool = script.Parent;

local EquipAnim
local ShootAnim 

function OnChanged(property, mouse)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;if EquipAnim then EquipAnim:Stop() end
&#9;&#9;if Tool.Enabled == false then
&#9;&#9;&#9;ShootAnim:Play()
&#9;&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;
&#9;&#9;else
&#9;&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;&#9;end
&#9;end
end



function onEquippedLocal(mouse)
&#9;local humanoid = Tool.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;EquipAnim = humanoid:LoadAnimation(Tool.Equip)
&#9;ShootAnim = humanoid:LoadAnimation(Tool.Shoot)

&#9;-- Make sure that the tool is still equiped when we play equip anim
&#9;Spawn(function() wait() if Tool:IsDescendantOf(Workspace) then&#9;EquipAnim:Play() end end)
&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;Tool.Changed:connect(function(property) OnChanged(property, mouse) end)
end

function onUnequippedLocal()
&#9;if EquipAnim then EquipAnim:Stop() end
&#9;if ShootAnim then ShootAnim:Stop() end
end

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX104">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PelletScript</string>
					<ProtectedString name="Source">local debris = game:service(&quot;Debris&quot;)
local pellet = script.Parent
local startingDamage = 14
local damage = startingDamage
local LastHitCharacter


function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(child)
end

local CreatorTag = WaitForChild(pellet, &apos;creator&apos;)

local GemHitSound = Instance.new(&apos;Sound&apos;)
GemHitSound.SoundId = &apos;http://www.roblox.com/asset/?id=98265750&apos;
GemHitSound.Pitch=1.5
GemHitSound.Parent=pellet


--[[
function tagHumanoid(humanoid)
&#9;-- todo: make tag expire
&#9;local tag = pellet:findFirstChild(&quot;creator&quot;)
&#9;if tag ~= nil then
&#9;&#9;-- kill all other tags
&#9;&#9;while(humanoid:findFirstChild(&quot;creator&quot;) ~= nil) do
&#9;&#9;&#9;humanoid:findFirstChild(&quot;creator&quot;).Parent = nil
&#9;&#9;end

&#9;&#9;local new_tag = tag:clone()
&#9;&#9;new_tag.Parent = humanoid
&#9;&#9;debris:AddItem(new_tag, 1)
&#9;end
end
--]]
function onTouched(hit)
&#9;--local creator = WaitForChild(pellet,&apos;creator&apos;)
&#9;--if (not hit) or (hit.Name == &apos;Handle&apos;) or (not hit.Parent) then return end&#9;
&#9;if not (hit and hit.Name ~= &apos;Handle&apos; and hit.Parent) then return end
&#9;if pellet:FindFirstChild(&apos;IsBlingshot&apos;) then
&#9;&#9;GemHitSound:Play()
&#9;end
&#9;humanoid = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;if humanoid~=nil and humanoid.Parent ~= LastHitCharacter then
&#9;&#9;if startingDamage == damage and game.Players:playerFromCharacter(hit.Parent) == CreatorTag.Value then 
&#9;&#9;&#9;return 
&#9;&#9;end
&#9;&#9;--tagHumanoid(humanoid)
&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;LastHitCharacter = humanoid.Parent
&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;if hitBindable then
&#9;&#9;&#9;hitBindable:Invoke(damage, CreatorTag)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;if hit.CanCollide == false then return end
&#9;&#9;damage = damage / 1.42
&#9;&#9;if damage &lt; 1 then
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;pellet.Parent = nil
&#9;&#9;end
&#9;end
end

connection = pellet.Touched:connect(onTouched)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX105">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94123357</url></Content>
					<string name="Name">Equip</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX106">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94126022</url></Content>
					<string name="Name">Shoot</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX107">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Slingshot</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local VELOCITY = 110 -- constant
local VELOCITY_SQAURED = VELOCITY * VELOCITY
local VELOCITY_TO_FOURTH = VELOCITY_SQAURED * VELOCITY_SQAURED
local ASSET_PREFIX = &quot;http://www.roblox.com/asset/?id=&quot;

local MyMouse

local SlingShotMeshIds = {Ammo = 94689434, AttachMe = 94689472, Full = 94689497, Handle = 94689515}

local DebrisService = game:GetService(&apos;Debris&apos;)
local ContentProvider = Game:GetService(&quot;ContentProvider&quot;)
local Pellet = Instance.new(&quot;Part&quot;)
Pellet.Locked = true
Pellet.BackSurface = 0
Pellet.BottomSurface = 0
Pellet.FrontSurface = 0
Pellet.LeftSurface = 0
Pellet.RightSurface = 0
Pellet.TopSurface = 0
Pellet.Shape = 0
Pellet.Size = Vector3.new(1,1,1)
--Pellet.BrickColor = BrickColor.new(&apos;Bright red&apos;) --BrickColor.new(2)
local PelletMesh = Instance.new(&apos;SpecialMesh&apos;)
PelletMesh.MeshId = ASSET_PREFIX .. SlingShotMeshIds[&apos;Ammo&apos;]
PelletMesh.TextureId = ASSET_PREFIX .. 94689543
PelletMesh.Scale = Vector3.new(1.5, 1.5, 1.5)
PelletMesh.Name = &apos;PelletMesh&apos;
PelletMesh.Parent = Pellet

local SlingShotMesh

local EquipSound
local SlingshotSounds

local PelletCopy

local IsBlingshot= WaitForChild(Tool,&apos;IsBlingshot&apos;)

WaitForChild(Tool, &apos;PelletScript&apos;):clone().Parent = Pellet

function Fire(mouse_pos)

&#9;if SlingshotSounds then
&#9;&#9;local soundNum = math.random(1, #SlingshotSounds)
&#9;&#9;SlingshotSounds[soundNum]:Play()
&#9;end

-- find player&apos;s head pos

&#9;local vCharacter = Tool.Parent
&#9;local vPlayer = game.Players:GetPlayerFromCharacter(vCharacter)

&#9;local head = vCharacter:findFirstChild(&quot;Head&quot;)
&#9;if head == nil then return end

&#9;local startPosition = Tool.Handle.Position + Vector3.new(0,1,0)

&#9;local dir = mouse_pos - startPosition
&#9;dir = dir.unit

&#9;local launch = startPosition + 3 * dir

&#9;local delta = mouse_pos - launch
&#9;
&#9;local dy = delta.y
&#9;
&#9;local new_delta = Vector3.new(delta.x, 0, delta.z)
&#9;delta = new_delta

&#9;local dx = delta.magnitude
&#9;local unit_delta = delta.unit
&#9;
&#9;-- acceleration due to gravity in RBX units
&#9;local g = (-9.81 * 20)

&#9;local theta = computeLaunchAngle( dx, dy, g)

&#9;local vy = math.sin(theta)
&#9;local xz = math.cos(theta)
&#9;local vx = unit_delta.x * xz
&#9;local vz = unit_delta.z * xz
&#9;

&#9;local missile = Pellet:clone()

&#9;missile.CFrame = CFrame.new(launch, launch+Vector3.new(vx,vy,vz))
        
&#9;--missile.Position = launch
&#9;missile.Velocity = Vector3.new(vx,vy,vz) * VELOCITY

&#9;missile.PelletScript.Disabled = false
&#9;

&#9;if IsBlingshot.Value then
&#9;&#9;missile.PelletMesh.MeshId=&apos;http://www.roblox.com/asset/?id=98262500&apos;
&#9;&#9;missile.PelletMesh.TextureId=&apos;http://www.roblox.com/asset/?id=98259807&apos;
&#9;&#9;missile.PelletMesh.Scale = Vector3.new(3,3,3)
&#9;&#9;local tbling= IsBlingshot:Clone()
&#9;&#9;tbling.Parent=missile
&#9;else
&#9;&#9;missile.PelletMesh.Scale = Vector3.new(2,2,2)
&#9;end

&#9;local creator_tag = Instance.new(&quot;ObjectValue&quot;)
&#9;creator_tag.Value = vPlayer
&#9;creator_tag.Name = &quot;creator&quot;
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;weaponNameTag.Parent = creator_tag
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId
&#9;weaponIconTag.Parent = creator_tag
&#9;creator_tag.Parent = missile
&#9;
&#9;DebrisService:AddItem(missile,2.0)
&#9;missile.Parent = game.Workspace

end


function computeLaunchAngle(dx,dy,grav)
&#9;-- arcane
&#9;-- http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
&#9;
&#9;local g = math.abs(grav)
&#9;local inRoot = (VELOCITY_TO_FOURTH) - (g * ((g*dx*dx) + (2*dy*VELOCITY_SQAURED)))
&#9;if inRoot &lt;= 0 then
&#9;&#9;return .25 * math.pi
&#9;end
&#9;local root = math.sqrt(inRoot)
&#9;local inATan1 = ((VELOCITY_SQAURED) + root) / (g*dx)

&#9;local inATan2 = ((VELOCITY_SQAURED) - root) / (g*dx)
&#9;local answer1 = math.atan(inATan1)
&#9;local answer2 = math.atan(inATan2)
&#9;return math.min(answer1,answer2)
end


Tool.Enabled = true
function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;local character = Tool.Parent;
&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid == nil or humanoid.Health &lt;= 0 then
&#9;&#9;print(&quot;Humanoid not found, or not alive&quot;)
&#9;&#9;return
&#9;end

&#9;Tool.Enabled = false
&#9;local targetPos = targetOverride or MyMouse.Hit.p

&#9;Fire(targetPos)
&#9;if PelletCopy then PelletCopy.Transparency = 1 end
&#9;-- swap meshes here
&#9;--[[
&#9;for i = 0, 0.2, 0.05 do
&#9;&#9;SlingShotMesh.Scale = Vector3.new(0.5, 0.5, 0.5 + i * 8)
&#9;&#9;wait(0.05)
&#9;end
&#9;SlingShotMesh.Scale = Vector3.new(0.5, 0.5, 0.5)
&#9;--]]
&#9;wait(0.2)
&#9;if PelletCopy then PelletCopy.Transparency = 0 end

&#9;Tool.Enabled = true
end

function OnEquipped(mouse)
&#9;--print(&apos;equipped&apos;)
&#9;MyMouse = mouse
&#9;Spawn(function()
&#9;&#9;wait()
&#9;&#9;if Tool:IsDescendantOf(Workspace) then
&#9;&#9;&#9;local leftArm = Tool.Parent:FindFirstChild(&quot;Left Arm&quot;)
&#9;&#9;&#9;if leftArm and not PelletCopy then
&#9;&#9;&#9;&#9;PelletCopy = Pellet:Clone()
&#9;&#9;&#9;&#9;PelletCopy.CanCollide = false
&#9;&#9;&#9;&#9;local pelletWeld = Instance.new(&quot;Weld&quot;)
&#9;&#9;&#9;&#9;pelletWeld.Part0 = leftArm
&#9;&#9;&#9;&#9;pelletWeld.Part1 = PelletCopy
&#9;&#9;&#9;&#9;pelletWeld.C1 = CFrame.new(-.3,1.3,0)
&#9;&#9;&#9;&#9;PelletCopy.Parent = Tool
&#9;&#9;&#9;&#9;pelletWeld.Parent = PelletCopy
&#9;&#9;&#9;&#9;if IsBlingshot.Value then
&#9;&#9;&#9;&#9;&#9;PelletCopy.PelletMesh.MeshId=&apos;http://www.roblox.com/asset/?id=98262500&apos;
&#9;&#9;&#9;&#9;&#9;PelletCopy.PelletMesh.TextureId=&apos;http://www.roblox.com/asset/?id=98259807&apos;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--MyMouse.TargetFilter = PelletCopy
&#9;SlingShotMesh = WaitForChild(Handle, &apos;Mesh&apos;)
&#9;SlingshotSounds = {WaitForChild(Handle, &apos;SlingshotSound1&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WaitForChild(Handle, &apos;SlingshotSound2&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  WaitForChild(Handle, &apos;SlingshotSound3&apos;)}
&#9;wait(0.3)
&#9;EquipSound = WaitForChild(Handle, &apos;Equip&apos;)
&#9;EquipSound:Play()
--[[
&#9;for _, id in pairs(SlingShotMeshIds) do
&#9;&#9;ContentProvider:Preload(ASSET_PREFIX .. id)
&#9;end
--]]
end

function OnUnequipped()
&#9;if PelletCopy then 
&#9;&#9;PelletCopy:Destroy()
&#9;&#9;PelletCopy = nil
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX108">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifierScript</string>
					<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
--local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local BlingshotModifierName = &apos;Blingshot&apos;

local IsBlingshot=WaitForChild(Tool,&apos;IsBlingshot&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94689543&apos;
local BlingshotTexture = &apos;http://www.roblox.com/asset/?id=98259807&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94689365&apos;
local BlingshotIcon = &apos;http://www.roblox.com/asset/?id=98259146&apos;


function OnModifierAdded(nmodifier)
&#9;if nmodifier.Name == BlingshotModifierName then
&#9;&#9;IsBlingshot.Value=true
&#9;&#9;Mesh.TextureId=BlingshotTexture
&#9;&#9;Tool.TextureId= BlingshotIcon
&#9;&#9;Tool.ToolTip= &apos;Blingshot&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == BlingshotModifierName then
&#9;&#9;IsBlingshot.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;Tool.ToolTip= &apos;Slingshot&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX109">
				<Properties>
					<string name="Name">IsBlingshot</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX110">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0.0614605024</X>
					<Y>5.28547162e-009</Y>
					<Z>0.920917511</Z>
					<R00>0.974370062</R00>
					<R01>-9.83292381e-009</R01>
					<R02>-0.224951088</R02>
					<R10>9.8329247e-009</R10>
					<R11>1</R11>
					<R12>-1.12031984e-009</R12>
					<R20>0.224951088</R20>
					<R21>-1.12032339e-009</R21>
					<R22>0.974370062</R22>
				</CoordinateFrame>
				<string name="Name">Bomb</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94690231</url></Content>
				<string name="ToolTip">Bomb</string>
			</Properties>
			<Item class="Part" referent="RBX111">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">0</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX112">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94691640</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>2</X>
							<Y>2</Y>
							<Z>2</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94691681</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX113">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Boom</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX114">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Beep</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94137771</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX115">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Explode</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 12
local BLAST_PRESSURE = 1000000



--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local RedTextureId = WaitForChild(script.Parent,&apos;RedTextureId&apos;)

local DebrisService = Game:GetService(&apos;Debris&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local TimeBomb = script.Parent

local BombMesh = WaitForChild(TimeBomb, &apos;Mesh&apos;)

local BoomSound = WaitForChild(TimeBomb, &apos;Boom&apos;)
local BeepSound = WaitForChild(TimeBomb, &apos;Beep&apos;)

local CreatorTag = WaitForChild(TimeBomb, &apos;creator&apos;)

local OriginalTextureId = BombMesh.TextureId

local Connection = nil

local ParentTorso = WaitForChild(TimeBomb, &apos;ParentTorso&apos;)
local XGraceDistance=2.5
local YGraceDistance=2.5

local MrBombSoundLength = TimeBomb:FindFirstChild(&apos;MrBombLength&apos;)
local MrBombSound = TimeBomb:FindFirstChild(&apos;MrBombSound&apos;)

local IsMrBombPlaying=false
-----------------
--| Functions |--
-----------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- When a player is hit, if they are alive they will be tagged
local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- Needless to say, this should only be called once
local function Explode()
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.Position = TimeBomb.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace

&#9;BoomSound:Play()

&#9;-- NOTE:
&#9;-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

&#9;TimeBomb.Transparency = 1
&#9;TimeBomb.CanCollide = false
&#9;TimeBomb.Anchored = true
&#9;DebrisService:AddItem(TimeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------

--Distance check to see if can collide should be true
Spawn(function()
&#9;while not TimeBomb.CanCollide and ParentTorso.Value do
&#9;&#9;local TorsoPosition = ParentTorso.Value.CFrame.p
&#9;&#9;local XZOffset = TorsoPosition-Vector3.new(TimeBomb.CFrame.p.x,TorsoPosition.y,TimeBomb.CFrame.p.z)
&#9;&#9;if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-TimeBomb.CFrame.p.y)&gt;YGraceDistance then
&#9;&#9;&#9;TimeBomb.CanCollide=true
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
end)

if MrBombSoundLength and MrBombSound then
&#9;Delay(3-MrBombSoundLength.Value,function()
&#9;&#9;IsMrBombPlaying=true
&#9;&#9;MrBombSound:Play()
&#9;end)
end

-- Flash red and beep increasingly fast for about 3 seconds
local tickTime = 0.4
local red = true
repeat
&#9;BombMesh.TextureId = red and RedTextureId.Value or OriginalTextureId
&#9;if not IsMrBombPlaying then
&#9;&#9;BeepSound:Play()
&#9;end
&#9;wait(tickTime)
&#9;red = not red
&#9;tickTime = tickTime * 0.9
until tickTime &lt; 0.1

Explode()
</ProtectedString>
					</Properties>
				</Item>
				<Item class="ObjectValue" referent="RBX116">
					<Properties>
						<string name="Name">ParentTorso</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX117">
					<Properties>
						<string name="Name">RedTextureId</string>
						<string name="Value">http://www.roblox.com/asset/?id=94691735</string>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX118">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MouseIcon</string>
					<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX119">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ThrowBomb</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again
local THROW_SPEED = 80

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local JointsService = Game.JointsService -- Sketttttch

local Tool = script.Parent
local ToolHandle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

local IsGoldBomb = WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local MyModel = nil
local MyPlayer = nil

local BaseBomb = nil
local BombClone = nil
local BombCloneWeld = nil


local MrBombSounds = 
{
&#9;{SoundId=100204329,Length=1.6}
}

-----------------
--| Functions |--
-----------------

local function MakeBaseBomb()
&#9;local bomb = ToolHandle:Clone()
&#9;bomb.Name = &quot;Bomb&quot;

&#9;-- Attach creator tags to the bomb early on
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, bomb)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId

&#9;if IsGoldBomb.Value then
&#9;&#9;local randomEntry=MrBombSounds[math.random(#MrBombSounds)]
&#9;&#9;local soundlength=Instance.new(&apos;NumberValue&apos;)
&#9;&#9;soundlength.Name=&apos;MrBombLength&apos;
&#9;&#9;soundlength.Value=randomEntry.Length
&#9;&#9;soundlength.Parent=bomb
&#9;&#9;local sound=Instance.new(&apos;Sound&apos;)
&#9;&#9;sound.Name=&apos;MrBombSound&apos;
&#9;&#9;sound.SoundId=&apos;http://www.roblox.com/asset/?id=&apos;..randomEntry.SoundId
&#9;&#9;sound.Volume=1
&#9;&#9;sound.Parent=bomb
&#9;end
&#9;-- Arm the bomb
&#9;WaitForChild(bomb, &apos;Explode&apos;).Disabled = false

&#9;return bomb
end

local function OnMouseDownChanged(down, targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if down then -- Player just clicked
&#9;&#9;if Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 and not BombCloneWeld then
&#9;&#9;&#9;BombCloneWeld = Instance.new(&apos;Weld&apos;, JointsService)
&#9;&#9;&#9;BombCloneWeld.Part0 = ToolHandle
&#9;&#9;&#9;BombCloneWeld.Part1 = BombClone
&#9;&#9;&#9;DebrisService:AddItem(BombClone, 30)

&#9;&#9;&#9;
&#9;&#9;&#9;if MyModel:FindFirstChild(&apos;Head&apos;) then
&#9;&#9;&#9;&#9;print(&apos;setting position&apos;)
&#9;&#9;&#9;&#9;WaitForChild(BombClone, &apos;ParentTorso&apos;).Value = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;end

&#9;&#9;&#9;BombClone.Parent = Tool --Workspace -- NOTE: This starts the already-armed explosion script
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;end
&#9;else -- Player just released click
&#9;&#9;if BombCloneWeld then
&#9;&#9;&#9;Tool.Enabled = false
&#9;&#9;&#9;-- Throw the bomb
&#9;&#9;&#9;BombClone.Parent = Workspace
&#9;&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;&#9;BombCloneWeld = nil
&#9;&#9;&#9;if not DoDrop.Value then
&#9;&#9;&#9;&#9;--local direction = (MyModel.Humanoid.TargetPoint - ToolHandle.Position).unit
&#9;&#9;&#9;&#9;local direction = ((targetOverride or TargetPosition.Value) - ToolHandle.Position).unit
&#9;&#9;&#9;&#9;BombClone.Velocity = ToolHandle.Velocity + ((direction + Vector3.new(0, 1, 0)).unit * THROW_SPEED)
&#9;&#9;&#9;&#9;BombClone.CanCollide = true --false NOTE: Temporary
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;BombClone.CanCollide = true
&#9;&#9;&#9;end
&#9;&#9;&#9;--BombClone.CanCollide = true

&#9;&#9;&#9;-- Prepare the next bomb to be thrown
&#9;&#9;&#9;BombClone = BaseBomb:Clone()

&#9;&#9;&#9;wait(COOLDOWN)

&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;&#9;Tool.Enabled = true
&#9;&#9;end
&#9;end
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseBomb = MakeBaseBomb()
&#9;BombClone = BaseBomb:Clone()
end

local function OnUnequipped()
&#9;ToolHandle.Transparency = 0
&#9;OnMouseDownChanged(false)
&#9;BombClone:Destroy()
&#9;if BombCloneWeld then
&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;BombCloneWeld = nil
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true)
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel,BombClone})
&#9;&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(false, targetPosition)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX120">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClickTransmitter</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(script, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)
local HoldAniTrack
local ThrowAniTrack

local MouseHeld = false

local function OnMouseDown()
&#9;if Tool.Enabled and not MouseHeld then
&#9;&#9;MouseHeld= true
&#9;&#9;DoDrop.Value = false
&#9;&#9;HoldAniTrack:Play(0,1,2) 
&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;Tool.Grip=CFrame.new(0.623935461, -0.378438532, -3.49691121e-008, 0.848048091, 2.31635049e-008, 0.529919267, 0.529919267, -3.70693591e-008, -0.848048091, 0, 1, -4.37113883e-008)
&#9;end
end

local function OnMouseUp()
&#9;if MouseHeld then
&#9;&#9;MouseHeld=false
&#9;&#9;ThrowAniTrack:Play()
&#9;&#9;HoldAniTrack:Stop()
&#9;&#9;DoDrop.Value = false
&#9;&#9;wait(.1)
&#9;&#9;
&#9;&#9;Tool.Grip=CFrame.new(0.0614605024, 5.28547162e-009, 0.920917511, 0.974370062, -9.83292381e-009, -0.224951088, 9.8329247e-009, 1, -1.12031984e-009, 0.224951088, -1.12032339e-009, 0.974370062)
&#9;end
end

local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent
&#9;HoldAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;HoldAni&apos;))
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled and not MouseDownObject.Value then
&#9;&#9;&#9;
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;end
&#9;end)
&#9;mouse.Button1Up:connect(function()
&#9;&#9;if MouseDownObject.Value then
&#9;&#9;&#9;wait(0.01) --NOTE: Wait added to fix immediate down-up issue on iPad
&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;
&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;
&#9;&#9;end
&#9;end)
&#9;MouseDownObject.Value = false
&#9;MouseHeld=false
&#9;ThrowAniTrack:Stop()
&#9;HoldAniTrack:Stop()&#9;
&#9;Tool.Grip=CFrame.new(0.0614605024, 5.28547162e-009, 0.920917511, 0.974370062, -9.83292381e-009, -0.224951088, 9.8329247e-009, 1, -1.12031984e-009, 0.224951088, -1.12032339e-009, 0.974370062)
end

local function OnUnequipped()
&#9;HoldAniTrack:Stop()
&#9;DoDrop.Value = true
&#9;MouseDownObject.Value = false
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end


Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX121">
					<Properties>
						<string name="Name">MouseDown</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX122">
					<Properties>
						<string name="Name">DoDrop</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="Vector3Value" referent="RBX123">
					<Properties>
						<string name="Name">TargetPosition</string>
						<Vector3 name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Animation" referent="RBX124">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861246</url></Content>
					<string name="Name">HoldAni</string>
				</Properties>
			</Item>
			<Item class="Animation" referent="RBX125">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861252</url></Content>
					<string name="Name">ThrowAni</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX126">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifierScript</string>
					<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)

local RedTexture= WaitForChild(Handle,&apos;RedTextureId&apos;)

local MrBombModifierName = &apos;MrBomb&apos;

local IsGold=WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94691681&apos;
local MrBombTexture = &apos;http://www.roblox.com/asset/?id=98260356&apos;

local MrBombRedTexture = &apos;http://www.roblox.com/asset/?id=98261349&apos;
local NormalRedTexture = &apos;http://www.roblox.com/asset/?id=94691735&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94691640&apos;
local MrBombMesh = &apos;http://www.roblox.com/asset/?id=98260446&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94690231&apos;
local MrBombIcon = &apos;http://www.roblox.com/asset/?id=97923204&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=true
&#9;&#9;Mesh.TextureId=MrBombTexture
&#9;&#9;Mesh.MeshId=MrBombMesh
&#9;&#9;Tool.TextureId= MrBombIcon
&#9;&#9;RedTexture.Value=MrBombRedTexture
&#9;&#9;Tool.ToolTip= &apos;Professor Bomb&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;RedTexture.Value=NormalRedTexture
&#9;&#9;Tool.ToolTip= &apos;Bomb&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX127">
				<Properties>
					<string name="Name">IsGoldBomb</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX128">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0.0500000007</X>
					<Y>-0.600000024</Y>
					<Z>-1</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>-0</R12>
					<R20>-0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">RocketLauncher</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689922</url></Content>
				<string name="ToolTip">Rocket Launcher</string>
			</Properties>
			<Item class="Part" referent="RBX129">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1.00000024</R11>
						<R12>-6.30617142e-005</R12>
						<R20>0</R20>
						<R21>6.30617142e-005</R21>
						<R22>1.00000024</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.839999974</X>
						<Y>1.14999998</Y>
						<Z>3.55000019</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX130">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94690054</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689966</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX131">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">ReloadSound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=94132726</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX132">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Equip</string>
						<float name="Pitch">1.33000004</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97103817</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX133">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Launcher</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again

-- RocketPropulsion Fields
local TARGET_RADIUS = 5
local MAX_SPEED = 60
local MAX_TORQUE = Vector3.new(4e6, 4e6, 0)
local MAX_THRUST = 50000
local THRUST_P = 500
local THRUST_D = 50000

local TARGET_OVERSHOOT_DISTANCE = 10000000

local ROCKET_MESH_ID = &apos;http://www.roblox.com/asset/?id=94690081&apos;
local ROCKET_MESH_SCALE = Vector3.new(2.5, 2.5, 2)
local ROCKET_PART_SIZE = Vector3.new(1, 1, 4)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local RocketScript = WaitForChild(script, &apos;Rocket&apos;)

local SwooshSound = WaitForChild(script, &apos;Swoosh&apos;)
local BoomSound = WaitForChild(script, &apos;Boom&apos;)
local ReloadSound = WaitForChild(ToolHandle, &apos;ReloadSound&apos;)
local EquipSound = WaitForChild(ToolHandle, &apos;Equip&apos;)

local MyModel = nil
local MyPlayer = nil

local BaseRocket = nil
local RocketClone = nil

-----------------
--| Functions |--
-----------------

local function MakeBaseRocket()
&#9;-- Set up the rocket part
&#9;local rocket = Instance.new(&apos;Part&apos;)
&#9;rocket.Name = &apos;Rocket&apos;
&#9;rocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;rocket.Size = ROCKET_PART_SIZE
&#9;rocket.CanCollide = false
&#9;rocket.BottomSurface = Enum.SurfaceType.Smooth
&#9;rocket.TopSurface = Enum.SurfaceType.Smooth

&#9;-- Add the mesh
&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, rocket)
&#9;mesh.MeshId = ROCKET_MESH_ID
&#9;mesh.Scale = ROCKET_MESH_SCALE
&#9;mesh.TextureId = ToolHandle.Mesh.TextureId

&#9;-- Add fire
&#9;local fire = Instance.new(&apos;Fire&apos;, rocket)
&#9;fire.Heat = 5
&#9;fire.Size = 2

&#9;-- Add the propulsion
&#9;local rocketPropulsion = Instance.new(&apos;RocketPropulsion&apos;, rocket)
&#9;rocketPropulsion.CartoonFactor = 1
&#9;rocketPropulsion.TargetRadius = TARGET_RADIUS
&#9;rocketPropulsion.MaxSpeed = MAX_SPEED
&#9;rocketPropulsion.MaxTorque = MAX_TORQUE
&#9;rocketPropulsion.MaxThrust = MAX_THRUST
&#9;rocketPropulsion.ThrustP = THRUST_P
&#9;rocketPropulsion.ThrustD = THRUST_D

&#9;-- Clone the sounds
&#9;local swooshSoundClone = SwooshSound:Clone()
&#9;swooshSoundClone.Parent = rocket
&#9;local boomSoundClone = BoomSound:Clone()
&#9;boomSoundClone.PlayOnRemove = true
&#9;boomSoundClone.Parent = rocket

&#9;-- Attach creator tags
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, rocket)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local nameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;nameTag.Name = &apos;weaponName&apos;
&#9;nameTag.Value = Tool.Name
&#9;local iconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;iconTag.Name = &apos;weaponIcon&apos;
&#9;iconTag.Value = Tool.TextureId

&#9;-- Finally, clone the rocket script and enable it
&#9;local rocketScriptClone = RocketScript:Clone()
&#9;rocketScriptClone.Parent = rocket
&#9;rocketScriptClone.Disabled = false

&#9;return rocket
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseRocket = MakeBaseRocket()
&#9;RocketClone = BaseRocket:Clone()
&#9;EquipSound:Play()
end

local function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;-- Pick a target
&#9;&#9;local targetPosition = targetOverride or MyModel.Humanoid.TargetPoint

&#9;&#9;-- Position the rocket clone
&#9;&#9;local spawnPosition = ToolHandle.Position + (ToolHandle.CFrame.lookVector * (ToolHandle.Size.Z / 2))
&#9;&#9;RocketClone.CFrame = CFrame.new(spawnPosition, targetPosition) --NOTE: This must be done before assigning Parent
&#9;&#9;DebrisService:AddItem(RocketClone, 30)
&#9;&#9;RocketClone.Parent = Workspace

&#9;&#9;-- Assign target and launch!
&#9;&#9;local rocketPropulsion = RocketClone:FindFirstChild(&apos;RocketPropulsion&apos;)
&#9;&#9;if rocketPropulsion then
&#9;&#9;&#9;local direction = (targetPosition - RocketClone.Position).unit
&#9;&#9;&#9;rocketPropulsion.TargetOffset = RocketClone.Position + (direction * TARGET_OVERSHOOT_DISTANCE)
&#9;&#9;&#9;rocketPropulsion:Fire()
&#9;&#9;end

&#9;&#9;-- Prepare the next rocket to be fired
&#9;&#9;RocketClone = BaseRocket:Clone()

&#9;&#9;ReloadSound:Play()

&#9;&#9;wait(COOLDOWN)

&#9;&#9;-- Stop the reloading sound if it hasn&apos;t already finished
&#9;&#9;ReloadSound:Stop()

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;ReloadSound:Stop()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
				<Item class="Sound" referent="RBX134">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Boom</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/collide.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX135">
					<Properties>
						<bool name="Looped">true</bool>
						<string name="Name">Swoosh</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/Rocket whoosh 01.wav</url></Content>
						<float name="Volume">0.699999988</float>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX136">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Rocket</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 6
local BLAST_PRESSURE = 750000

local IGNORE_LIST = {rocket = 1, handle = 1, effect = 1, water = 1} -- Rocket will fly through things named these
--NOTE: Keys must be lowercase, values must evaluate to true

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Rocket = script.Parent

local CreatorTag = WaitForChild(Rocket, &apos;creator&apos;)

local SwooshSound = WaitForChild(Rocket, &apos;Swoosh&apos;)

-----------------
--| Functions |--
-----------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnTouched(otherPart)
&#9;if Rocket and otherPart then
&#9;&#9;-- Fly through anything in the ignore list
&#9;&#9;if IGNORE_LIST[string.lower(otherPart.Name)] then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- Fly through the creator
&#9;&#9;local myPlayer = CreatorTag.Value
&#9;&#9;if myPlayer and myPlayer.Character and myPlayer.Character:IsAncestorOf(otherPart) then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- Boom
&#9;&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;&#9;explosion.Position = Rocket.Position
&#9;&#9;explosion.Hit:connect(OnExplosionHit)
&#9;&#9;explosion.Parent = Workspace

&#9;&#9;-- Move this script and the creator tag (so our custom logic can execute), then destroy the rocket
&#9;&#9;script.Parent = explosion
&#9;&#9;CreatorTag.Parent = script
&#9;&#9;Rocket:Destroy()
&#9;end
end

--------------------
--| Script Logic |--
--------------------

SwooshSound:Play()

Rocket.Touched:connect(OnTouched)

-- Manually call OnTouched for parts the rocket might have spawned inside of
--TODO: Remove when Touched correctly fires for parts spawned within other parts
local partClone = Rocket:Clone()
partClone:ClearAllChildren()
partClone.Transparency = 1
--partClone.Anchored = true --NOTE: DOES NOT WORK if part is anchored!
DebrisService:AddItem(partClone, 0.1)
partClone.Parent = Workspace
partClone.Touched:connect(OnTouched)
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX137">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animation</string>
					<ProtectedString name="Source">--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent

local FireAndReloadAnimation = WaitForChild(script, &apos;FireAndReload&apos;)

local FireAndReloadTrack = nil

-----------------
--| Functions |--
-----------------

local function OnEquipped()
&#9;local myModel = Tool.Parent
&#9;local humanoid = myModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then -- Preload animations
&#9;&#9;FireAndReloadTrack = humanoid:LoadAnimation(FireAndReloadAnimation)
&#9;end
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;-- Play fire and reload animation
&#9;&#9;if FireAndReloadTrack then
&#9;&#9;&#9;FireAndReloadTrack:Play()
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;-- Stop animations
&#9;if FireAndReloadTrack then FireAndReloadTrack:Stop() end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
				</Properties>
				<Item class="Animation" referent="RBX138">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94771598</url></Content>
						<string name="Name">FireAndReload</string>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX139">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MouseIcon</string>
					<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX140">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">VisualizeReload</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local ROCKET_MESH_ID = &apos;http://www.roblox.com/asset/?id=94690081&apos;
local ROCKET_MESH_SCALE = Vector3.new(1, 1, 1)

local ROCKET_SHOW_TIME = 1.5 -- Seconds after animation begins to show the rocket
local ROCKET_HIDE_TIME = 2.2 -- Seconds after animation begins to hide the rocket

-----------------
--| Variables |--
-----------------

local Tool = script.Parent
local ToolHandle = Tool.Handle

local MyModel = nil
local ReloadRocket = nil

local StillEquipped = false

-----------------
--| Functions |--
-----------------

local function MakeReloadRocket()
&#9;local reloadRocket = Instance.new(&apos;Part&apos;)
&#9;reloadRocket.Name = &quot;Ammo&quot;
&#9;reloadRocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;reloadRocket.Size = Vector3.new() -- As small as possible

&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, reloadRocket)
&#9;mesh.MeshId = ROCKET_MESH_ID
&#9;mesh.Scale = ROCKET_MESH_SCALE
&#9;mesh.TextureId = ToolHandle.Mesh.TextureId

&#9;return reloadRocket
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;ReloadRocket = MakeReloadRocket()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;-- Show the next rocket going into the launcher
&#9;&#9;StillEquipped = true
&#9;&#9;wait(ROCKET_SHOW_TIME)
&#9;&#9;if StillEquipped then
&#9;&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;if torso and torso:FindFirstChild(&apos;Left Shoulder&apos;) then
&#9;&#9;&#9;&#9;local leftArm = MyModel:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;&#9;if leftArm then
&#9;&#9;&#9;&#9;&#9;local weld = ReloadRocket:FindFirstChild(&apos;Weld&apos;)
&#9;&#9;&#9;&#9;&#9;if not weld then
&#9;&#9;&#9;&#9;&#9;&#9;weld = Instance.new(&apos;Weld&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;weld.Part0 = leftArm
&#9;&#9;&#9;&#9;&#9;&#9;weld.Part1 = ReloadRocket
&#9;&#9;&#9;&#9;&#9;&#9;weld.C1 = CFrame.new(Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;&#9;&#9;weld.Parent = ReloadRocket
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;ReloadRocket.Parent = MyModel
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(ROCKET_HIDE_TIME - ROCKET_SHOW_TIME)
&#9;&#9;&#9;&#9;if StillEquipped and ReloadRocket.Parent == MyModel then
&#9;&#9;&#9;&#9;&#9;ReloadRocket.Parent = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;StillEquipped = false
&#9;ReloadRocket:Destroy()
&#9;ReloadRocket = nil
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX141">
			<Properties>
				<bool name="CanBeDropped">false</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>-0.100000083</X>
					<Y>-1.49011612e-008</Y>
					<Z>-2.86602809e-015</Z>
					<R00>4.37113883e-008</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1.91068547e-015</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>-1</R20>
					<R21>1.91068547e-015</R21>
					<R22>4.37113883e-008</R22>
				</CoordinateFrame>
				<string name="Name">Reflector</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94878549</url></Content>
				<string name="ToolTip">Reflector</string>
			</Properties>
			<Item class="Script" referent="RBX142">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BlockScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DebrisService = Game:GetService(&quot;Debris&quot;)

local CANNON_LAUNCH_VELOCITY = 170
local PELLET_VELOCITY = 85
local BOMB_VELOCITY = 90


local SphereMesh = WaitForChild(script.Parent,&apos;SphereMesh&apos;)

local Tool = script.Parent
local Handle = Tool.Handle

local BlockRadius=Vector3.new(20,20,20)

local BlockTime =  .7

local MyCharacter
local MyPlayer

local StartSphereScale=Vector3.new(.1,.1,.1)
local EndSphereScale=Vector3.new(10,10,10)
local EffectLength=.6

local ApplauseEnabled=WaitForChild(Tool,&apos;ApplauseEnabled&apos;)


local LastAttackTime = tick()

function CheckForProjectiles(character)
&#9;if not character:FindFirstChild(&apos;Torso&apos;) then return end
&#9;local center=character.Torso.CFrame.p
&#9;local parts = game.Workspace:FindPartsInRegion3(Region3.new(center-BlockRadius,center+BlockRadius),character,100)
&#9;local projectiles = {}
&#9;for _,i in pairs(parts) do
&#9;&#9;if i:FindFirstChild(&apos;creator&apos;) then
&#9;&#9;&#9;
&#9;&#9;&#9;table.insert(projectiles,i)
&#9;&#9;&#9;print(&apos;projectiles::::&apos;)
&#9;&#9;&#9;print (i)
&#9;&#9;end
&#9;end
&#9;
&#9;
&#9;return projectiles
end

function FireBeam(beamStart, beamEnd, color, part)
&#9;local distance = (beamStart - beamEnd).magnitude
&#9;if distance &gt; 1000 then distance = 1000 end
&#9;local laser = part or Instance.new(&apos;Part&apos;)
&#9;--Game.Debris:AddItem(laser, 0.05)
&#9;laser.Name = &apos;Effect&apos;
&#9;laser.Anchored = true
&#9;laser.CanCollide = false
&#9;laser.Shape = &apos;Block&apos;
&#9;laser.formFactor = &apos;Custom&apos;
&#9;laser.Size = Vector3.new(0.5, 0.5, distance + 0.2)
&#9;laser.Material = Enum.Material.Plastic
&#9;laser.Locked = true
&#9;laser.TopSurface = 0
&#9;laser.BottomSurface = 0
&#9;laser.BrickColor = color or BrickColor.new(&apos;Bright red&apos;)
&#9;laser.CFrame = CFrame.new(beamStart, beamEnd) * CFrame.new(0, 0, -distance/2)
&#9;laser.Parent = Workspace
end

function ReflectProjectiles(bullets)
&#9;local reflectedObject=false
&#9;for _,i in pairs(bullets) do
&#9;&#9;if i and i:FindFirstChild(&apos;creator&apos;) then
&#9;&#9;&#9;if i.creator.Value.Character and i.creator.Value ~= MyPlayer and i.creator.Value.Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;local source=i.creator.Value.Character.Torso.CFrame.p
&#9;&#9;&#9;&#9;if i.Name==&apos;Rocket&apos; and i:FindFirstChild(&apos;RocketPropulsion&apos;) then
&#9;&#9;&#9;&#9;&#9;i.CFrame= CFrame.new(i.CFrame.p,source)
&#9;&#9;&#9;&#9;&#9;i.RocketPropulsion.TargetOffset=((source-i.CFrame.p).unit*100000)+i.CFrame.p
&#9;&#9;&#9;&#9;&#9;i.RocketPropulsion:Fire()
&#9;&#9;&#9;&#9;&#9;--uncomment to show rocket propulsion is BORK&apos;d
&#9;&#9;&#9;&#9;&#9;--[[
&#9;&#9;&#9;&#9;&#9;Spawn( function()
&#9;&#9;&#9;&#9;&#9;&#9;local initPos= i.CFrame.p
&#9;&#9;&#9;&#9;&#9;&#9;local tpart = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;local tpart2 = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;local tpart3 = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;while i.Parent do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,((source-initPos).unit*100000)+initPos,BrickColor.new(&apos;Bright red&apos;),tpart)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,i.RocketPropulsion.TargetOffset,BrickColor.new(&apos;Magenta&apos;),tpart2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,i.CFrame.p+(i.Velocity.unit*10000),BrickColor.new(&apos;Camo&apos;),tpart3)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;--]]
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Cannon Shot&quot; then
&#9;&#9;&#9;&#9;&#9;i.Velocity=(source-i.CFrame.p).unit*CANNON_LAUNCH_VELOCITY
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Part&quot; then

&#9;&#9;&#9;&#9;&#9;i.Velocity=(source-i.CFrame.p).unit*PELLET_VELOCITY
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Bomb&quot; then
&#9;&#9;&#9;&#9;&#9;i.Velocity=(i.CFrame.p-MyCharacter.Torso.CFrame.p).unit*BOMB_VELOCITY
&#9;&#9;&#9;&#9;&#9;--WaitForChild(i,&apos;Explode&apos;).Disabled=true
&#9;&#9;&#9;&#9;&#9;--i.Explode.Disabled=false
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if i.creator:FindFirstChild(&apos;weaponName&apos;) then
&#9;&#9;&#9;&#9;&#9;i.creator.weaponName.Value=Tool.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if i.creator:FindFirstChild(&apos;weaponIcon&apos;) then
&#9;&#9;&#9;&#9;&#9;i.creator.weaponIcon.Value=Tool.TextureId
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if reflectedObject and ApplauseEnabled.Value then
&#9;&#9;WaitForChild(Handle,&apos;Applause&apos;):Play()
&#9;end
end



function VisualEffect(part)
&#9;local timeDelay = 0.2
&#9;local sphere = Instance.new(&apos;Part&apos;)
&#9;sphere.CanCollide = false
&#9;sphere.Anchored = true
&#9;sphere.Transparency = 0.5
&#9;sphere.FormFactor = Enum.FormFactor.Custom
&#9;sphere.Shape = Enum.PartType.Ball
&#9;sphere.Size = Vector3.new(0.2, 0.2, 0.2)
&#9;sphere.CFrame = CFrame.new(part.CFrame.p)
&#9;sphere.TopSurface = Enum.SurfaceType.Smooth
&#9;sphere.BottomSurface  = Enum.SurfaceType.Smooth
&#9;sphere.Name = &apos;water&apos; --LOL-CANO
&#9;sphere.BrickColor=BrickColor.new(&apos;Cyan&apos;)
&#9;sphere.Transparency = 1
&#9;-- Add 0.2 for the wait below
&#9;DebrisService:AddItem(sphere, EffectLength + timeDelay)
&#9;sphere.Parent = Workspace
&#9;
&#9;local sphereMesh = WaitForChild(Tool,&apos;SphereMesh&apos;):Clone()
&#9;sphereMesh.VertexColor=Vector3.new(1,1,1)
&#9;sphereMesh.Scale = Vector3.new(.1,.1,.1)
&#9;sphereMesh.Parent = sphere

&#9;Tool.Handle.Plant:Play()

&#9;wait(timeDelay)
&#9;sphere.Transparency = 0
&#9;local startTime=time()
&#9;while time()-startTime&lt;EffectLength do
&#9;&#9;sphere.CFrame = CFrame.new(part.CFrame.p)
&#9;&#9;sphereMesh.Scale=StartSphereScale:Lerp(EndSphereScale,(time()-startTime)/EffectLength)
&#9;&#9;sphere.Transparency=(time()-startTime)/EffectLength
&#9;&#9;wait()
&#9;end
end

Tool.Enabled = true
function OnActivated()
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;local now = tick()
&#9;if now - LastAttackTime &lt; 2 then
&#9;&#9;return
&#9;end
&#9;Tool.Enabled = false
&#9;LastAttackTime = now
&#9;local character = Tool.Parent;
&#9;local humanoid = character.Humanoid
&#9;if humanoid == nil then
&#9;&#9;print(&quot;Humanoid not found&quot;)
&#9;&#9;return 
&#9;end
&#9;Spawn(function() VisualEffect(Tool.Handle) end)

&#9;local startTime=time()
&#9;while time()-startTime&lt;BlockTime do 
&#9;&#9;ReflectProjectiles(CheckForProjectiles(character))
&#9;&#9;wait(1/30)
&#9;end
&#9;-- wait to set tool.Enabled so the icon isn&apos;t showing ready when it isn&apos;t ready
&#9;local waitTime = math.max(0, 2 - (tick() - now))
&#9;wait(waitTime)
&#9;Tool.Enabled = true
end


function OnEquipped()
&#9;MyCharacter = Tool.Parent
&#9;MyPlayer = game.Players:GetPlayerFromCharacter(MyCharacter)
&#9;OnActivated()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX143">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AnimationScript</string>
					<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local Animations = {}
local MyHumanoid
local MyCharacter


local function PlayAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Play()
&#9;end
end

local function StopAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Stop()
&#9;end
end


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;--Animations[&apos;EquipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim3&apos;))
&#9;&#9;--Animations[&apos;IdleAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleAnim3&apos;))
&#9;&#9;Animations[&apos;FireAni&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;FireAni&apos;))
&#9;end
&#9;--PlayAnimation(&apos;EquipAnim&apos;)
&#9;--PlayAnimation(&apos;IdleAnim&apos;)
end

function OnUnequipped()
&#9;--StopAnimation(&apos;IdleAnim&apos;)
&#9;--PlayAnimation(&apos;UnequipAnim&apos;)
end

local LastActivate=0

function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;if time()-LastActivate&gt;2 then
&#9;&#9;&#9;Animations[&apos;FireAni&apos;]:Play(.1,1,6)
&#9;&#9;&#9;LastActivate=time()
&#9;&#9;end
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

Tool.Changed:connect(OnChanged)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX144">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>29.5</X>
						<Y>9.98500061</Y>
						<Z>1.5</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">3</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>1.96999979</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX145">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94735473</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1.5</X>
							<Y>1.5</Y>
							<Z>1.5</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94735715</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX146">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Plant</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94215314</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX147">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Applause</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/asset/?id=97656068</url></Content>
						<float name="Volume">0.5</float>
					</Properties>
				</Item>
			</Item>
			<Item class="Animation" referent="RBX148">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94190213</url></Content>
					<string name="Name">FireAni</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX149">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifierScript</string>
					<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh=WaitForChild(Handle,&apos;Mesh&apos;)
local ApplauseEnabled=WaitForChild(Tool,&apos;ApplauseEnabled&apos;)
local SphereMesh=WaitForChild(Tool,&apos;SphereMesh&apos;)

local AwardModifierName = &apos;AwardReflector&apos;

local AwardMesh = &apos;http://www.roblox.com/asset/?id=97820425&apos;
local AwardTexture = &apos;http://www.roblox.com/asset/?id=97820380&apos;
local AwardIcon = &apos;http://www.roblox.com/asset/?id=97820334&apos;
local GoldShieldMesh = &apos;http://www.roblox.com/asset/?id=97908983&apos;
local GoldShieldTexture = &apos;http://www.roblox.com/asset/?id=97821269&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94735473&apos;
local NormalTexture = &apos;http://www.roblox.com/asset/?id=94735715&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=94878549&apos;
local NormalShieldMesh = &apos;http://www.roblox.com/asset/?id=94736101&apos;
local NormalShieldTexture = &apos;http://www.roblox.com/asset/?id=94735715&apos;

function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == AwardModifierName then
&#9;&#9;ApplauseEnabled.Value=true
&#9;&#9;Mesh.MeshId=AwardMesh
&#9;&#9;Mesh.TextureId=AwardTexture
&#9;&#9;Mesh.Scale=Vector3.new(.6,.6,.6)
&#9;&#9;Tool.Grip= CFrame.new(-0.400000006, -1.10000002, -0.499999881, -1, 1.91068547e-015, 0, 1.91068547e-015, 1, 0, 0, -8.35187172e-023, -1)
&#9;&#9;Tool.TextureId=AwardIcon
&#9;&#9;SphereMesh.MeshId=GoldShieldMesh
&#9;&#9;SphereMesh.TextureId=GoldShieldTexture
&#9;&#9;Tool.ToolTip= &apos;24-Carat Reflector&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == AwardModifierName then
&#9;&#9;ApplauseEnabled.Value=false
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Mesh.TextureId=NormalTexture
&#9;&#9;Mesh.Scale=Vector3.new(1.5, 1.5, 1.5)
&#9;&#9;Tool.Grip= CFrame.new(-0.100000083, -1.49011612e-008, -2.86602809e-015, 4.37113883e-008, 0, 1, 1.91068547e-015, 1, 0, -1, 1.91068547e-015, 4.37113883e-008)
&#9;&#9;Tool.TextureId=NormalIcon
&#9;&#9;SphereMesh.MeshId=NormalShieldMesh
&#9;&#9;SphereMesh.TextureId=NormalShieldTexture
&#9;&#9;Tool.ToolTip= &apos;Reflector&apos;
&#9;end
&#9;
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX150">
				<Properties>
					<string name="Name">ApplauseEnabled</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="SpecialMesh" referent="RBX151">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94736101</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">SphereMesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94735715</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX152">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MouseIcon</string>
					<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterGui" referent="RBX153">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ShowDevelopmentGui">true</bool>
		</Properties>
		<Item class="LocalScript" referent="RBX154">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Ragdoll</string>
				<ProtectedString name="Source">--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayerGui = script.Parent
local Player = PlayerGui.Parent

-----------------
--| Functions |--
-----------------

-- Creates a new version of oldJoint
local function ReWeld(oldJoint, weldType)
&#9;local newJoint = Instance.new(weldType or &apos;Weld&apos;)
&#9;newJoint.Part0 = oldJoint.Part0
&#9;newJoint.Part1 = oldJoint.Part1
&#9;newJoint.C0 = oldJoint.C0
&#9;newJoint.C1 = oldJoint.C1
&#9;newJoint.Parent = oldJoint.Part0
end

-- Welds a new 1x1x1 Part to mainPart
local function AddPart(mainPart)
&#9;local part = Instance.new(&apos;Part&apos;)
&#9;part.TopSurface = Enum.SurfaceType.Smooth
&#9;part.BottomSurface = Enum.SurfaceType.Smooth
&#9;part.FormFactor = Enum.FormFactor.Symmetric
&#9;part.Size = Vector3.new(1, 1, 1)
&#9;part.Transparency = 1
&#9;part.Parent = mainPart.Parent

&#9;local weld = Instance.new(&apos;Weld&apos;)
&#9;weld.Part0 = mainPart
&#9;weld.Part1 = part
&#9;weld.C0 = CFrame.new(0, -0.5, 0)
&#9;weld.Parent = mainPart
end

local function CalmDown(model)
&#9;for _, child in pairs(model:GetChildren()) do
&#9;&#9;if child:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;child.Velocity = Vector3.new()
&#9;&#9;&#9;child.RotVelocity = Vector3.new()
&#9;&#9;end
&#9;end
end

local function OnDied(deadHumanoid, jointTable)
&#9;local character = deadHumanoid.Parent
&#9;local torso = character:FindFirstChild(&apos;Torso&apos;)
&#9;if not torso then return end

&#9;-- Check if killed by explosion
&#9;for _, child in pairs(Workspace:GetChildren()) do
&#9;&#9;if child:IsA(&apos;Explosion&apos;) and (child.Position - torso.Position).magnitude &lt;= 13 then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;-- Destroy dropped tool(s)
&#9;for _, child in pairs(character:GetChildren()) do
&#9;&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;child:Destroy()
&#9;&#9;end
&#9;end

&#9;CalmDown(character)

&#9;wait(0) --NOTE: Without this, the player will not respawn
&#9;deadHumanoid:Destroy()

&#9;-- Make new joints
&#9;for _, joint in pairs(jointTable) do
&#9;&#9;if joint.Part0.Parent and joint.Part1.Parent then
&#9;&#9;&#9;if joint.Part1.Name == &apos;Head&apos; then
&#9;&#9;&#9;&#9;ReWeld(joint)
&#9;&#9;&#9;else -- Limb
&#9;&#9;&#9;&#9;ReWeld(joint, &apos;Rotate&apos;)
&#9;&#9;&#9;&#9;AddPart(joint.Part1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local uhOh = Instance.new(&apos;Humanoid&apos;)
&#9;uhOh.Health = 0
&#9;uhOh.Parent = character
end

-- Saves joints and connects to character&apos;s death
local function OnCharacterAdded(character)
&#9;local humanoid = WaitForChild(character, &apos;Humanoid&apos;)
&#9;local torso = WaitForChild(character, &apos;Torso&apos;)
&#9;local jointTable = {}
&#9;for _, child in pairs(torso:GetChildren()) do
&#9;&#9;if child:IsA(&apos;JointInstance&apos;) then
&#9;&#9;&#9;jointTable[child.Part1] = child
&#9;&#9;end
&#9;end
&#9;humanoid.Died:connect(function() OnDied(humanoid, jointTable) end)
end

--------------------
--| Script Logic |--
--------------------

-- Connect to Player&apos;s current and future characters
if Player.Character then
&#9;OnCharacterAdded(Player.Character)
end
Player.CharacterAdded:connect(OnCharacterAdded)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX155">
			<Properties>
				<string name="Name">IpadCountGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX156">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">IpadCountGuiScript</string>
					<ProtectedString name="Source">local Success, Ipad = pcall(function() return Game:GetService(&apos;UserInputService&apos;).TouchEnabled end)
--TODO: Use this instead when UserInputService is fully available on PC:
--local Ipad = Game:GetService(&apos;UserInputService&apos;).TouchEnabled

local SuperUsers = {OnlyTwentyCharacters = 1, Sorcus = 1, Games = 1, GongfuTiger = 1}

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local IpadCountGui = script.Parent
local PlayerGui = IpadCountGui.Parent
local Player = PlayerGui.Parent

local IpadCountText = WaitForChild(IpadCountGui, &apos;IpadCountText&apos;)

local NumberOfIpadsObject = WaitForChild(Workspace, &apos;NumberOfIpads&apos;)

local function UpdateText()
&#9;IpadCountText.Text = &quot;Number of iPads: &quot; .. NumberOfIpadsObject.Value
end

local function SendSignalIfNotAlreadySent()
&#9;for _, child in pairs(NumberOfIpadsObject:GetChildren()) do
&#9;&#9;if child:IsA(&apos;ObjectValue&apos;) and child.Value == Player then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;local objectValue = Instance.new(&apos;ObjectValue&apos;)
&#9;objectValue.Value = Player
&#9;objectValue.Parent = NumberOfIpadsObject
end

if Success and Ipad then
&#9;SendSignalIfNotAlreadySent()
end

if SuperUsers[Player.Name] then
&#9;NumberOfIpadsObject.Changed:connect(UpdateText)
&#9;UpdateText()
&#9;IpadCountText.Visible = true
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="TextLabel" referent="RBX157">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">0</token>
					<token name="FontSize">2</token>
					<string name="Name">IpadCountText</string>
					<UDim2 name="Position">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>0.0500000007</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>125</XO>
						<YS>0</YS>
						<YO>20</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">Initializing...</string>
					<Color3 name="TextColor3">4283760640</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX158">
			<Properties>
				<string name="Name">ScreenSizeGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX159">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScreenSizeGuiScript</string>
					<ProtectedString name="Source">local SuperUsers = {OnlyTwentyCharacters = 1, Sorcus = 1, Games = 1, Player1 = 1}

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local ScreenSizeGui = script.Parent
local PlayerGui = ScreenSizeGui.Parent
local Player = PlayerGui.Parent

local ScreenSizeText = WaitForChild(ScreenSizeGui, &apos;ScreenSizeText&apos;)

local function Update()
&#9;local size = ScreenSizeGui.AbsoluteSize
&#9;ScreenSizeText.Text = &quot;Size: &quot; .. size.X .. &quot;x&quot; .. size.Y
end

local function OnScreenGuiChanged(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;Update()
&#9;end
end

if SuperUsers[Player.Name] then
&#9;Update()
&#9;ScreenSizeGui.Changed:connect(OnScreenGuiChanged)
&#9;ScreenSizeText.Visible = true
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="TextLabel" referent="RBX160">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">0</token>
					<token name="FontSize">2</token>
					<string name="Name">ScreenSizeText</string>
					<UDim2 name="Position">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>0.100000001</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>125</XO>
						<YS>0</YS>
						<YO>20</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">Initializing...</string>
					<Color3 name="TextColor3">4278190080</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX161">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">cameraScript</string>
				<ProtectedString name="Source">function WaitForChild(parent,child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;wait() print(&quot; waitforchild: &quot;..parent.Name..&quot; waiting for &quot;..child)
&#9;end
&#9;return parent[child]
end

local KillingPlayer = WaitForChild(script,&apos;KillingPlayer&apos;)
local DoOuttro = WaitForChild(script,&apos;DoOuttro&apos;)
local MyPlayer=script.Parent.Parent
local initialPosition=MyPlayer:FindFirstChild(&apos;IntroInitialPosition&apos;)
if not initialPosition then
&#9;initialPosition = WaitForChild(script,&apos;IntroInitialPosition&apos;)
&#9;initialPosition.Parent=MyPlayer
end

local Camera= Workspace.CurrentCamera

local IntroTime=1.5
local KillCamTime=2
local PreIntroWaitTime=.5
local OuttroTime=6

local InIntro=false
local InOuttro=false
local InKillCam=false

local function Freeze(basePart)
&#9;local bodyPosition = Instance.new(&apos;BodyPosition&apos;)
&#9;bodyPosition.maxForce = Vector3.new(1e9, 0, 1e9)
&#9;bodyPosition.position = basePart.Position
&#9;bodyPosition.Parent = basePart
&#9;local bodyGyro = Instance.new(&apos;BodyGyro&apos;)
&#9;bodyGyro.maxTorque = Vector3.new(1e9, 1e9, 1e9)
&#9;bodyGyro.cframe = CFrame.new(Vector3.new(), basePart.CFrame.lookVector)
&#9;bodyGyro.Parent = basePart
&#9;return bodyPosition, bodyGyro
end

function DoIntroCam()
&#9;local MyCharacter=MyPlayer.Character
&#9;local Humanoid=WaitForChild(MyCharacter,&apos;Humanoid&apos;)
&#9;local torso=WaitForChild(MyCharacter,&apos;Torso&apos;)

&#9;InIntro=true
&#9;--you have to wait until player has properly spawned and been repositioned, a little ugly

&#9;local head = WaitForChild(MyCharacter,&apos;Head&apos;)
&#9;local torsoPosition, torsoGyro = Freeze(torso)

&#9;local startTime=tick()
&#9;while (tick()-startTime)&lt;PreIntroWaitTime and not InOuttro do
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=initialPosition.Value
&#9;&#9;wait()
&#9;end

&#9;startTime=tick()
&#9;local startTime=tick()
&#9;while (tick()-startTime)&lt;IntroTime and not InOuttro do
&#9;&#9;local myDir=head.CFrame.lookVector
&#9;&#9;local myPosition = head.CFrame.p
&#9;&#9;local finalPosition = CFrame.new(myPosition-(myDir*4),myPosition)
&#9;&#9;local initialLookVector = (initialPosition.Value.p+initialPosition.Value.lookVector)
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=CFrame.new(
&#9;&#9;&#9;initialPosition.Value.p:Lerp(finalPosition.p,(tick()-startTime)/IntroTime),
&#9;&#9;&#9;initialLookVector:Lerp(myPosition,(tick()-startTime)/IntroTime))
&#9;&#9;wait(1/30)
&#9;end
&#9;Camera.CameraSubject = Humanoid
&#9;Camera.CameraType=&apos;Custom&apos;

&#9;--add the tag that the intro has played
&#9;local playedTag = MyPlayer:FindFirstChild(&apos;IntroPlayed&apos;)
&#9;if not playedTag then
&#9;&#9;playedTag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;playedTag.Name=&apos;IntroPlayed&apos;
&#9;&#9;playedTag.Parent=MyPlayer
&#9;end
&#9;playedTag.Value=true

&#9;torsoPosition:Destroy()
&#9;torsoGyro:Destroy()
&#9;InIntro=false
end

function DoOuttroCam()
&#9;InOuttro=true
&#9;initialPosition.Value=WaitForChild(script,&apos;IntroInitialPosition&apos;).Value
&#9;local cameraStart=Camera.CoordinateFrame
&#9;local startTime=tick()
&#9;local initialLookVector = (cameraStart.p+cameraStart.lookVector)
&#9;local StartPosition=initialPosition.Value
&#9;while (tick()-startTime)&lt;OuttroTime do
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=CFrame.new(
&#9;&#9;&#9;cameraStart.p:Lerp(StartPosition.p,(tick()-startTime)/OuttroTime),
&#9;&#9;&#9;initialLookVector:Lerp(Vector3.new(0,0,0),(tick()-startTime)/OuttroTime))
&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;&#9;wait(1/30)
&#9;end

&#9;local focus = Vector3.new(0,0,0)
&#9;local radius = Vector3.new(Camera.CoordinateFrame.p.x,0,Camera.CoordinateFrame.p.z).magnitude
&#9;local angle = math.atan2(Camera.CoordinateFrame.p.x,Camera.CoordinateFrame.p.z)
&#9;local omega = .0025
&#9;local initialY=Camera.CoordinateFrame.y
&#9;while true do
&#9;&#9;Camera.CameraType = Enum.CameraType.Scriptable
&#9;&#9;Camera.CoordinateFrame = CFrame.new( Vector3.new(math.sin(angle) * radius, initialY, math.cos(angle) * radius), focus)
&#9;&#9;angle = angle + omega
&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
 &#9;&#9;wait(1/30)
&#9;end

&#9;InOuttro=false
end

function DoKillCam()
&#9;if InIntro or InOuttro then return end
&#9;InKillCam=true
&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;wait(1.5)
&#9;local killerHead= KillingPlayer.Value.Character:FindFirstChild(&apos;Head&apos;)
&#9;Camera= game.Workspace.CurrentCamera
&#9;
&#9;if KillingPlayer.Value ~= MyPlayer then
&#9;&#9;Camera.CameraType=&apos;Watch&apos;
&#9;&#9;Camera.CameraSubject=killerHead
&#9;&#9;while not InIntro and not InOuttro do
&#9;&#9;&#9;--have to do this in a loop in case player resets unexpectedly
&#9;&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end
&#9;end
&#9;--have to do this also after loop in case of suicide or round reset
&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;InKillCam=false
end

KillingPlayer.Changed:connect(DoKillCam)

DoOuttro.Changed:connect(DoOuttroCam)

MyPlayer.CharacterAdded:connect(function()
&#9;wait(0) -- Otherwise we get invalid characters
&#9;DoIntroCam()
end)
</ProtectedString>
			</Properties>
			<Item class="ObjectValue" referent="RBX162">
				<Properties>
					<string name="Name">KillingPlayer</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="CFrameValue" referent="RBX163">
				<Properties>
					<string name="Name">IntroInitialPosition</string>
					<CoordinateFrame name="Value">
						<X>-22.2998962</X>
						<Y>284.594025</Y>
						<Z>-287.420837</Z>
						<R00>-0.996024728</R00>
						<R01>0.0636545345</R01>
						<R02>-0.0623119995</R02>
						<R10>3.7252903e-009</R10>
						<R11>0.69953078</R11>
						<R12>0.71460247</R12>
						<R20>0.0890768468</R20>
						<R21>0.711761713</R21>
						<R22>-0.696749985</R22>
					</CoordinateFrame>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX164">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DeathListener</string>
					<ProtectedString name="Source">--
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end
local LocalPlayer=script.Parent.Parent.Parent
LocalPlayer.CharacterAdded:connect(function()
&#9;local Humanoid=WaitForChild(LocalPlayer.Character,&apos;Humanoid&apos;)
&#9;Humanoid.Died:connect(function()
&#9;&#9;print(&apos;humanoid.died fired&apos;)
&#9;&#9;local tag = WaitForChild(Humanoid,&quot;creator&quot;)
&#9;&#9;if tag and tag.Value then
&#9;&#9;&#9;WaitForChild(script.Parent,&apos;KillingPlayer&apos;).Value=tag.Value
&#9;&#9;end
&#9;end)
end)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX165">
				<Properties>
					<string name="Name">DoOuttro</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX166">
			<Properties>
				<string name="Name">FragFeedGui</string>
			</Properties>
			<Item class="Frame" referent="RBX167">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">FragFeedFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0.400000036</YS>
						<YO>-22</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>500</XO>
						<YS>0</YS>
						<YO>150</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX168">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FragFeedGuiScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DELIMITER = &apos;#&apos; -- Separates words (NOTE: Custom input text must not contain this)
local NOGAP_TAG = &apos;_&apos; -- Placed at the front of a custom word, this will remove the gap between this and the last word
--NOTE: These must match up with the MainScript (FragFeed)

local LABEL_GAP = 5
local DISPLAY_DURATION = 7
local VERTICAL_SCALE_AMOUNT = 0.55
local TWEEN_DURATION = 0.75
local NEW_ELEMENT_VERTICAL_SCALE = 0.90
local VERTICAL_GAP= .4

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local FragFeedGui = script.Parent
local FragFeedFrame = WaitForChild(FragFeedGui, &apos;FragFeedFrame&apos;)

local Events = {}

local Scrolling  = false
local Initalized = false

local TextLabelBase = Instance.new(&apos;TextLabel&apos;) do
&#9;TextLabelBase.BackgroundTransparency = 1.0
&#9;TextLabelBase.Font = Enum.Font.ArialBold
&#9;TextLabelBase.TextColor3=Color3.new(0,0,0)
&#9;TextLabelBase.FontSize = Enum.FontSize.Size24
&#9;TextLabelBase.TextStrokeColor3=Color3.new(1,1,1)
&#9;TextLabelBase.TextStrokeTransparency=0
end

local ImageLabelBase = Instance.new(&apos;ImageLabel&apos;) do
&#9;ImageLabelBase.BackgroundTransparency = 1.0
&#9;ImageLabelBase.Size = UDim2.new(0, 50, 0, 50)
end

-----------------
--| Functions |--
-----------------


function FadeOut(tframe,aliveTime)
&#9;--[[
&#9;local start=time()
&#9;while time()-start&lt;aliveTime do
&#9;&#9;local nalpha= (time()-start)/aliveTime
&#9;&#9;for _,i in pairs(tframe:GetChildren()) do
&#9;&#9;&#9;if i:IsA(&apos;TextLabel&apos;) then
&#9;&#9;&#9;&#9;i.TextTransparency=nalpha
&#9;&#9;&#9;&#9;i.TextStrokeTransparency=nalpha
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
&#9;--]]
&#9;tframe:TweenPosition(UDim2.new(-2, 0, tframe.Position.Y.Scale,tframe.Position.Y.Offset), &quot;Out&quot;, &quot;Quad&quot;, aliveTime, true)
end

function FragFeedChildAdded(child)
&#9;if not child:IsA(&apos;StringValue&apos;) then return end

&#9;-- Read in the input string and separate it into words
&#9;local inputWords = {}
&#9;for word in child.Value:gmatch(&apos;[^&apos; .. DELIMITER ..&apos;]+&apos;) do
&#9;&#9;table.insert(inputWords, word)
&#9;end

&#9;-- Wait for scrolling (within other calls) to finish
&#9;while Scrolling do
&#9;&#9;wait()
&#9;end

&#9;-- Scroll existing events up a level to make room for the new event
&#9;Scrolling  = true
&#9;local tweenTime = TWEEN_DURATION
&#9;if not Initalized then tweenTime = 0.10 end
&#9;for _, event in pairs(Events) do
&#9;&#9;if event then
&#9;&#9;&#9;for _, field in pairs(event) do
&#9;&#9;&#9;&#9;if field and field.Parent then
&#9;&#9;&#9;&#9;&#9;field:TweenPosition(field.Position + UDim2.new(0, 0, -(VERTICAL_SCALE_AMOUNT+VERTICAL_GAP), 0), 
&#9;&#9;&#9;&#9;&#9;&#9;&quot;Out&quot;, &quot;Quad&quot;, tweenTime, true)
&#9;&#9;&#9;&#9;&#9;if field.Position.Y.Scale &lt; -VERTICAL_SCALE_AMOUNT then
&#9;&#9;&#9;&#9;&#9;&#9;field:Destroy()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;wait(tweenTime)
&#9;Scrolling  = false


&#9;local tframe=Instance.new(&apos;Frame&apos;)
&#9;
&#9;tframe.Size=UDim2.new(0, 500, 0, 50)
&#9;tframe.BackgroundTransparency=1
&#9;tframe.Parent=FragFeedFrame
&#9;tframe.Position= UDim2.new(-1, 0, NEW_ELEMENT_VERTICAL_SCALE, 0 - (tframe.Size.Y.Offset / 2))

&#9;-- Create and place all the elements that make up the event line
&#9;local eventLine = {}
&#9;do
&#9;&#9;
&#9;&#9;local lastElement = nil
&#9;&#9;for _, word in pairs(inputWords) do
&#9;&#9;&#9;if word then
&#9;&#9;&#9;&#9;-- Try word as a color (formatted like this: [1032])
&#9;&#9;&#9;&#9;local match, n = word:gsub(&apos;%[(%d+)%]&apos;, &apos;%1&apos;, 1)
&#9;&#9;&#9;&#9;local colorCode = (n == 1) and tonumber(match) or nil
&#9;&#9;&#9;&#9;if colorCode and lastElement then
&#9;&#9;&#9;&#9;&#9;lastElement.TextColor3 = BrickColor.new(colorCode).Color
&#9;&#9;&#9;&#9;else -- Not a color, so must be image or string
&#9;&#9;&#9;&#9;&#9;local element = nil
&#9;&#9;&#9;&#9;&#9;local addGap = true
&#9;&#9;&#9;&#9;&#9;if word:find(&apos;://&apos;) then -- Word is content, use as image
&#9;&#9;&#9;&#9;&#9;&#9;element = ImageLabelBase:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;element.Image = word
&#9;&#9;&#9;&#9;&#9;&#9;element.Parent = tframe
&#9;&#9;&#9;&#9;&#9;else -- Word is just a string
&#9;&#9;&#9;&#9;&#9;&#9;element = TextLabelBase:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;local text, n = word:gsub(&apos;^&apos; .. NOGAP_TAG, &apos;&apos;, 1) -- Check for and remove the NOGAP_TAG
&#9;&#9;&#9;&#9;&#9;&#9;if n == 1 then addGap = false end -- If it was there, don&apos;t add a LABEL_GAP later
&#9;&#9;&#9;&#9;&#9;&#9;element.Text = text
&#9;&#9;&#9;&#9;&#9;&#9;element.Parent = tframe  --NOTE: This must be done before we can use TextBounds
&#9;&#9;&#9;&#9;&#9;&#9;element.Size = UDim2.new(0, math.ceil(element.TextBounds.x), 0, math.ceil(element.TextBounds.y))
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;DebrisService:AddItem(element, DISPLAY_DURATION)
&#9;&#9;&#9;&#9;&#9;local xOffset = lastElement and lastElement.Position.X.Offset + lastElement.Size.X.Offset + (addGap and LABEL_GAP or 0) or 0
&#9;&#9;&#9;&#9;&#9;element.Position = UDim2.new(0, xOffset, NEW_ELEMENT_VERTICAL_SCALE, 0 - (element.Size.Y.Offset / 2))
&#9;&#9;&#9;&#9;&#9;table.insert(eventLine, element)
&#9;&#9;&#9;&#9;&#9;lastElement = element
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end --end while loop
&#9;&#9;&#9;tframe:TweenPosition(UDim2.new(0, 20, NEW_ELEMENT_VERTICAL_SCALE, 0 - (tframe.Size.Y.Offset / 2)), &quot;Out&quot;, &quot;Quad&quot;, tweenTime, true)
&#9;&#9;&#9;DebrisService:AddItem(tframe, DISPLAY_DURATION)
&#9;&#9;&#9;Spawn(function() wait(3) FadeOut(tframe,2) end)
&#9;&#9;end
&#9;end
&#9;table.insert(Events, eventLine) -- Save the event so we can scroll it later
end

--------------------
--| Script Logic |--
--------------------

-- Connect to ChildAdded for all future events
script.Parent.ChildAdded:connect(FragFeedChildAdded)

Initalized = true
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX169">
			<Properties>
				<string name="Name">RoundTimerGui</string>
			</Properties>
			<Item class="Frame" referent="RBX170">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">TimeFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-100</XO>
						<YS>0.0500000007</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>200</XO>
						<YS>0</YS>
						<YO>30</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX171">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">Time Remaining</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>-0.400000006</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Time Remaining</string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX172">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">Time</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>-25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX173">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RoundTimerGuiScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local START_POSITION = UDim2.new(0.5, -17, 0.8, -25)
local END_POSITION = UDim2.new(0.5, -26, 0.8, -34)
local START_SIZE = UDim2.new(0, 34, 0, 34)
local END_SIZE = UDim2.new(0, 52, 0, 52)

local MINUTES_POSITION = UDim2.new(0.5, 0, 0.8, -25)
local MINUTES_SIZE = UDim2.new(0, 0, 1, 0)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Gui = script.Parent
local Frame = WaitForChild(Gui, &apos;TimeFrame&apos;)
local Time = WaitForChild(Frame, &apos;Time&apos;)
local TimeText = WaitForChild(Frame, &apos;Time Remaining&apos;)

local MainScript = WaitForChild(Workspace, &apos;RoundTimer&apos;)
local TimeObject = WaitForChild(MainScript, &apos;Time&apos;)

local MainRoundScript = WaitForChild(Workspace, &apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(MainRoundScript, &apos;GameStateSignaler&apos;)

local LastTime = -1
local OriginalText = TimeText.Text

-----------------
--| Functions |--
-----------------

-- Whenever TimeObject changes, update the Time displayed (now with exciting graphics!)
local function OnTimeChanged(newValue)
&#9;local currentTime = math.max(0, newValue)
&#9;if LastTime == math.floor(currentTime) then return end
&#9;LastTime = math.floor(currentTime)
&#9;--print(&quot;Time Changed, time is&quot; , newValue)
&#9;local hours = math.floor(currentTime / 3600)
&#9;local minutes = math.floor(currentTime / 60) % 60
&#9;local seconds = math.floor(currentTime) % 60
&#9;if minutes &gt; 0 then
&#9;&#9;Time.TextWrapped = false
&#9;&#9;Time.TextScaled = false
&#9;&#9;Time.Position = MINUTES_POSITION
&#9;&#9;Time.Size = MINUTES_SIZE
&#9;&#9;Time.Text = string.format(&quot;%d:%02d&quot;, minutes, seconds) -- (Looks like 00:00:00)
&#9;else
&#9;&#9;Time.TextWrapped = true
&#9;&#9;Time.TextScaled = true
&#9;&#9;-- One argument of tween is a callback, I use it to untween the text
&#9;&#9;Time:TweenSizeAndPosition(END_SIZE,END_POSITION, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.2, false,
&#9;&#9;&#9;function() Time:TweenSizeAndPosition(START_SIZE,START_POSITION, Enum.EasingDirection.In, Enum.EasingStyle.Linear, 0.3) end)
&#9;&#9;if seconds ~= 59 then
&#9;&#9;&#9;wait(0.1)
&#9;&#9;end
&#9;&#9;Time.Text = string.format(&quot;%d&quot;, seconds)
&#9;end
end

local function OnSignalerChanged(newValue)
&#9;if newValue == &apos;SCORE_VIEWING&apos; then -- End of round
&#9;&#9;TimeText.Text = &quot;Map Selection Next Round&quot;
&#9;elseif newValue == &apos;SCORE_VIEWING_PRE_VOTE&apos; then-- End of end of round
&#9;&#9;TimeText.Text = &apos;Voting Starts In&apos;
&#9;elseif newValue == &apos;PLAYING&apos; then-- End of end of round
&#9;&#9;TimeText.Text = OriginalText
&#9;elseif newValue == &apos;MAP_VOTING&apos; then-- End of end of round
&#9;&#9;TimeText.Text = &apos;Voting Ends In&apos;
&#9;elseif newValue == &apos;MAP_ROULETTE&apos; then-- End of end of round
&#9;&#9;TimeText.Text = &apos;Choosing Map&apos;
&#9;elseif newValue == &apos;MAP_VIEWING&apos; then-- End of end of round
&#9;&#9;TimeText.Text = &quot;Next Round Starts In&quot;
&#9;end
end

--------------------
--| Script Logic |--
--------------------

TimeObject.Changed:connect(OnTimeChanged)

GameStateSignaler.Changed:connect(OnSignalerChanged)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX174">
			<Properties>
				<string name="Name">MapSelector</string>
			</Properties>
			<Item class="Frame" referent="RBX175">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Frame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>-800</XO>
						<YS>0.150000021</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>586</XO>
						<YS>0</YS>
						<YO>424</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX176">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Choice1</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>15</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>174</XO>
							<YS>0</YS>
							<YO>315</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX177">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ChoiceArea</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>325</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>100</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX178">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105940341</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Button</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX179">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294965700</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105941422</url></Content>
							<string name="Name">Highlight</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-24</XO>
								<YS>0</YS>
								<YO>-9</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>219</XO>
								<YS>0</YS>
								<YO>372</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX180">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=105939270</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX181">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Choice2</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>205</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>174</XO>
							<YS>0</YS>
							<YO>315</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX182">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ChoiceArea</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>325</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>100</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX183">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105943792</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Button</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX184">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294965700</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105941422</url></Content>
							<string name="Name">Highlight</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-24</XO>
								<YS>0</YS>
								<YO>-9</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>219</XO>
								<YS>0</YS>
								<YO>372</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX185">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Choice3</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>395</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>174</XO>
							<YS>0</YS>
							<YO>315</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX186">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ChoiceArea</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>325</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>100</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX187">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105943792</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Button</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX188">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294965700</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105941422</url></Content>
							<string name="Name">Highlight</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-24</XO>
								<YS>0</YS>
								<YO>-9</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>219</XO>
								<YS>0</YS>
								<YO>372</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX189">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=105974796</url></Content>
						<string name="Name">Header</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-15</XO>
							<YS>0</YS>
							<YO>-10</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>620</XO>
							<YS>0</YS>
							<YO>66</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX190">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=106091217</url></Content>
						<string name="Name">BCTitleHeader</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>1</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>583</XO>
							<YS>0</YS>
							<YO>74</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX191">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=105974963</url></Content>
						<string name="Name">TitleHeader</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>1</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>583</XO>
							<YS>0</YS>
							<YO>74</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX192">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MapSelectGuiScript</string>
					<ProtectedString name="Source">--[[Super Util]]--
function WaitForChild(parent,child)
&#9;while not parent:FindFirstChild(child) do  print(child) wait(1/30) end
&#9;return parent[child]
end

function MakeValue(class,name,value,parent)
&#9;local temp = Instance.new(class)
&#9;temp.Name = name
&#9;temp.Value = value
&#9;temp.Parent = parent
&#9;return temp
end&#9;

function TweenProperty(obj, propName, inita, enda, length)
&#9;local startTime = tick()
&#9;while startTime - tick()&lt;length do
&#9;&#9;obj[propName] = (startTime - tick())/length
&#9;&#9;wait(1/30)
&#9;end
&#9;obj[propName] = enda&#9;
end

--DEBUG
--local DebrisService = Game:GetService(&apos;Debris&apos;)
--local DebugPrintOffset = 0
--local OldPrint = print
--local function print(...)
--&#9;local line = &apos;&apos;
--&#9;for _, segment in pairs({...}) do
--&#9;&#9;line = line .. (line and &apos; &apos; or &apos;&apos;) .. tostring(segment)
--&#9;end
--&#9;local gui = Instance.new(&apos;ScreenGui&apos;)
--&#9;local label = Instance.new(&apos;TextLabel&apos;)
--&#9;label.Text = line
--&#9;label.Size = UDim2.new(0.25, 0, 0.05, 0)
--&#9;label.BackgroundTransparency = 0.5
--&#9;label.Position = UDim2.new(0, 0, 0, DebugPrintOffset)
--&#9;label.TextWrapped = true
--&#9;label.Parent = gui
--&#9;DebrisService:AddItem(gui, 30)
--&#9;gui.Parent = script.Parent
--&#9;DebugPrintOffset = (DebugPrintOffset &lt;= 600) and DebugPrintOffset + 30 or 0
--&#9;OldPrint(&quot;DebugPrinted this:&quot;, line)
--end
--print(&quot;DEBUGTEST&quot;)

--[[Constants]]--

local ROULETTE_LENGTH = 5
local ASSET_URL = &apos;http://www.roblox.com/asset/?id=&apos;

local IMAGES = 
{
&#9;VoteImg = 105939602,
&#9;SelectedVoteImg = 106547573,
&#9;HighlightFrame = 105941422,
&#9;HighlightFrameLocked = 106477483,
&#9;105939270,
}
local SOUNDS =
{
&#9;click1 = 106522319,--106521661
&#9;spinClick = 106543491,
&#9;boomSelect = 106551577,
}
--[[Workspace Variables]]--

local ScreenGui=script.Parent
local MainFrame = WaitForChild(ScreenGui,&apos;Frame&apos;)
local VoteManager = WaitForChild(game.Workspace,&apos;VoteManager&apos;)
local Votes = WaitForChild(VoteManager,&apos;Votes&apos;)
local NewVotes = WaitForChild(VoteManager,&apos;NewVotes&apos;)
local MapChoiceModel = WaitForChild(VoteManager,&apos;Choices&apos;)
local SelectedOption = WaitForChild(VoteManager, &apos;SelectedOption&apos;)

local SmallFrame = WaitForChild(ScreenGui,&apos;SmallFrame&apos;)
local SmallCenterText = WaitForChild(SmallFrame,&apos;CenterText&apos;)
local SmallTopText = WaitForChild(SmallFrame,&apos;TopLine&apos;)
local SmallBottomText = WaitForChild(SmallFrame,&apos;BottomLine&apos;)
local MapChoices = 
{
&#9;WaitForChild(MapChoiceModel,&apos;1&apos;),
&#9;WaitForChild(MapChoiceModel,&apos;2&apos;),
&#9;WaitForChild(MapChoiceModel,&apos;3&apos;),
}
local MyVote = WaitForChild(Votes, game.Players.LocalPlayer.Name)
local TemplateVote = WaitForChild(script,&apos;TemplateVote&apos;)

local MainRoundScript = WaitForChild(game.Workspace,&apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(MainRoundScript, &apos;GameStateSignaler&apos;)

local BCHeader = WaitForChild(MainFrame,&apos;BCTitleHeader&apos;)
&#9;
--[[Script Variables]]--

local Choices = {}
local IsOpen = false
local StartRoulette = false
local CanVote = game.Players.LocalPlayer.MembershipType~=Enum.MembershipType.None

--[[Script Functions]]--
function PlaySound(id)
&#9;local nsound = Instance.new(&apos;Sound&apos;)
&#9;nsound.SoundId= ASSET_URL..id
&#9;nsound.Parent=script.Parent.Parent.Parent
&#9;nsound:Play()
&#9;game.Debris:AddItem(nsound,10)
end
function SetUpChoice(index,nchoice)
&#9;Choices[index].SelectedImage =  WaitForChild(nchoice,&apos;SelectedImage&apos;).Value
&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(ASSET_URL..Choices[index].SelectedImage)
&#9;Choices[index].UnselectedImage =  WaitForChild(nchoice,&apos;UnselectedImage&apos;).Value
&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(ASSET_URL..Choices[index].UnselectedImage)
&#9;if WaitForChild(Choices[index].Frame,&apos;Highlight&apos;).Visible then
&#9;&#9;WaitForChild(Choices[index].Frame,&apos;Button&apos;).Image = ASSET_URL
&#9;&#9;..Choices[index].SelectedImage
&#9;else
&#9;&#9;WaitForChild(Choices[index].Frame,&apos;Button&apos;).Image = ASSET_URL
&#9;&#9;&#9;..Choices[index].UnselectedImage
&#9;end
&#9;Choices[index].Frame.Highlight.Image = ASSET_URL..IMAGES[&apos;HighlightFrame&apos;]
end

function SendVote(index)
&#9;if CanVote then
&#9;&#9;nvote = MyVote:Clone()
&#9;&#9;nvote.Value = index
&#9;&#9;nvote.Parent = NewVotes
&#9;end
end

function ChoiceSelected(choice)
&#9;if IsOpen and not StartRoulette and CanVote then
&#9;&#9;for index,i in pairs(Choices) do
&#9;&#9;&#9;if i ==choice then
&#9;&#9;&#9;&#9;WaitForChild(i.Frame,&apos;Highlight&apos;).Visible = true
&#9;&#9;&#9;&#9;print(&apos;Selecting &apos; .. index)
&#9;&#9;&#9;&#9;WaitForChild(i.Frame,&apos;Button&apos;).Image = ASSET_URL .. i.SelectedImage
&#9;&#9;&#9;&#9;--MyVote.Value = index
&#9;&#9;&#9;&#9;PlaySound(SOUNDS.click1)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;WaitForChild(i.Frame,&apos;Highlight&apos;).Visible = false
&#9;&#9;&#9;&#9;WaitForChild(i.Frame,&apos;Button&apos;).Image = ASSET_URL .. i.UnselectedImage
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
end

function MakeVoteEntry(playerName,vote)
&#9;local nentry = 
&#9;{
&#9;&#9;Touched = true,--if this entry was &apos;seen&apos; in this poll, used for removing votes
&#9;&#9;Vote = vote,
&#9;&#9;Name = playerName,
&#9;&#9;Frame = TemplateVote:Clone(),
&#9;} &#9;
&#9;WaitForChild(nentry.Frame,&apos;TextLabel&apos;).Text = string.sub(playerName, 1, 2)
&#9;return nentry
end

function ReAdjustFrames(voteFrames)
&#9;
&#9;for choiceNum,i in ipairs(voteFrames) do
&#9;&#9;for index,j in pairs(i) do
&#9;&#9;&#9;j[&apos;Frame&apos;].Parent = WaitForChild(Choices[choiceNum][&apos;Frame&apos;],&apos;ChoiceArea&apos;)
&#9;&#9;&#9;--print (&apos;vote in &apos;..choiceNum)
&#9;&#9;&#9;j[&apos;Frame&apos;].Position = UDim2.new(0,(index-1)*j[&apos;Frame&apos;].Size.X.Offset,0,0)
&#9;&#9;end
&#9;end
&#9;
end

function BlinkElement(element,length,rate,endVisible)
&#9;local stime = tick()
&#9;while tick()-stime&lt;length do
&#9;&#9;element.Visible=not element.Visible
&#9;&#9;wait(rate)
&#9;end
&#9;element.Visible=endVisible
end

function UpdateGui(voteFrames,allVotes)
&#9;for index, i in pairs(allVotes) do
&#9;&#9;i.Touched=false
&#9;end&#9;&#9;
&#9;
&#9;for _,i in pairs(Votes:GetChildren()) do
&#9;&#9;if not allVotes[i.Name] then --create new frame
&#9;&#9;&#9;local nentry = MakeVoteEntry(i.Name,i.Value)
&#9;&#9;&#9;allVotes[i.Name]=nentry
&#9;&#9;&#9;if i.Value&gt;0 then
&#9;&#9;&#9;&#9;table.insert(voteFrames[i.Value],nentry)
&#9;&#9;&#9;end
&#9;&#9;elseif i.Value ~=allVotes[i.Name].Vote then -- move frame
&#9;&#9;&#9;if voteFrames[allVotes[i.Name].Vote] then
&#9;&#9;&#9;&#9;for index,j in pairs(voteFrames[allVotes[i.Name].Vote]) do
&#9;&#9;&#9;&#9;&#9;if j.Name==i.Name then
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(voteFrames[allVotes[i.Name].Vote],index)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;allVotes[i.Name].Vote=i.Value
&#9;&#9;&#9;if voteFrames[i.Value] then
&#9;&#9;&#9;&#9;table.insert(voteFrames[i.Value],allVotes[i.Name])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--custom icons down the line
&#9;&#9;--if i:FindFirstChild(&apos;Icon&apos;) and i.Icon.Value ~= allVotes[i.Name].Frame.Image then
&#9;&#9;--&#9;allVotes[i.Name].Frame.Image=i.Icon.Value
&#9;&#9;--end
&#9;&#9;allVotes[i.Name].Touched = true
&#9;end&#9;&#9;
&#9;
&#9;ReAdjustFrames(voteFrames)
&#9;
&#9;for index, i in pairs(allVotes) do
&#9;&#9;if not i.Touched then 
&#9;&#9;&#9;i.Frame:Destroy()
&#9;&#9;&#9;
&#9;&#9;&#9;if voteFrames[i.Vote] then
&#9;&#9;&#9;&#9;for index,j in pairs(voteFrames[i.Vote]) do
&#9;&#9;&#9;&#9;&#9;if j.Name==i.Name then
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(voteFrames[i.Vote],index)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;allVotes[index] = nil
&#9;&#9;end
&#9;end
end

function OpenNormalMenu()
&#9;MainFrame:TweenPosition(UDim2.new(.5,-268,.15,0),&apos;Out&apos;, &apos;Quad&apos;, .25, true)
&#9;local voteFrames = {[1]={},[2]={},[3]={}}
&#9;local allVotes = {}
&#9;ChoiceSelected(nil)
&#9;while IsOpen and not StartRoulette do
&#9;&#9;
&#9;&#9;UpdateGui(voteFrames,allVotes)

&#9;&#9;wait(1/30)
&#9;end&#9;
&#9;Spawn( function()
&#9;&#9;for i=1,55,1 do
&#9;&#9;&#9;UpdateGui(voteFrames,allVotes)
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end
&#9;end)
&#9;if MyVote.Value&gt;0 then
&#9;&#9;Choices[MyVote.Value].Frame.Highlight.Image=ASSET_URL..IMAGES.HighlightFrameLocked
&#9;end
&#9;
&#9;local selectedIndex = 1
&#9;local finalChoiceIndex = 1
&#9;local finalIndex = 1
&#9;local unrolledPlayers ={}
&#9;while not SelectedOption.Value do print(&apos;selected option DNE&apos;) wait() end
&#9;print(&apos;SELECTED PLACE:&apos;..SelectedOption.Value.Name)
&#9;
&#9;for index,i in ipairs(voteFrames) do
&#9;&#9;if MapChoices[index].Value==SelectedOption.Value then
&#9;&#9;&#9;print(&apos;Have choice Index: &apos;.. index)
&#9;&#9;&#9;if #i&gt;0 then
&#9;&#9;&#9;&#9;finalIndex =#unrolledPlayers+math.random(#i)
&#9;&#9;&#9;end
&#9;&#9;&#9;finalChoiceIndex = index
&#9;&#9;end
&#9;&#9;for _,j in ipairs(i) do
&#9;&#9;&#9;table.insert(unrolledPlayers,j)
&#9;&#9;end
&#9;end
&#9;print(&apos;num unrolled players : &apos;..#unrolledPlayers)&#9;&#9;
&#9;local startRoulette = tick()
&#9;if #unrolledPlayers&gt;1 then
&#9;&#9;local lastWait
&#9;&#9;while tick()-startRoulette&lt;ROULETTE_LENGTH-1 do
&#9;&#9;&#9;lastWait =math.pow((tick()-startRoulette)/5,1.5)+.05
&#9;&#9;&#9;wait(lastWait)
&#9;&#9;&#9;PlaySound(SOUNDS.spinClick)
&#9;&#9;&#9;unrolledPlayers[selectedIndex].Frame.Image = ASSET_URL..IMAGES.VoteImg
&#9;&#9;&#9;selectedIndex=selectedIndex+1
&#9;&#9;&#9;if selectedIndex&gt;#unrolledPlayers then selectedIndex = 1 end
&#9;&#9;&#9;unrolledPlayers[selectedIndex].Frame.Image = ASSET_URL..IMAGES.SelectedVoteImg
&#9;&#9;end
&#9;
&#9;&#9;local stepsToFinal = finalIndex-selectedIndex
&#9;&#9;if stepsToFinal&lt;0 then stepsToFinal = stepsToFinal+#unrolledPlayers end
&#9;&#9;for i=1,stepsToFinal,1 do
&#9;&#9;&#9;wait(lastWait)
&#9;&#9;&#9;PlaySound(SOUNDS.spinClick)
&#9;&#9;&#9;unrolledPlayers[selectedIndex].Frame.Image = ASSET_URL..IMAGES.VoteImg
&#9;&#9;&#9;selectedIndex=selectedIndex+1
&#9;&#9;&#9;if selectedIndex&gt;#unrolledPlayers then selectedIndex = 1 end
&#9;&#9;&#9;unrolledPlayers[selectedIndex].Frame.Image = ASSET_URL..IMAGES.SelectedVoteImg
&#9;&#9;end
&#9;end
&#9;Choices[finalChoiceIndex].Frame.Highlight.Image = ASSET_URL..IMAGES.HighlightFrame
&#9;for _,i in ipairs(Choices) do
&#9;&#9;i.Frame.Button.Image = ASSET_URL .. i.UnselectedImage
&#9;end
&#9;PlaySound(SOUNDS.boomSelect)
&#9;Choices[finalChoiceIndex].Frame.Button.Image = ASSET_URL .. Choices[finalChoiceIndex].SelectedImage
&#9;Spawn( function() BlinkElement(Choices[finalChoiceIndex].Frame.Highlight,1.5,.2,true) end)
end

function OpenSmallMenu()
&#9;SmallFrame:TweenPosition(UDim2.new(.25,0,.15,0),&apos;Out&apos;, &apos;Quad&apos;, .25, true)
&#9;SmallCenterText.Visible = true
&#9;SmallTopText.Visible = false
&#9;SmallBottomText.Visible = false
&#9;while not StartRoulette do wait() end
&#9;wait(6)--wait for roulette to fire for normal players
&#9;
&#9;while not SelectedOption.Value do print(&apos;selected option DNE&apos;) wait() end
&#9;SmallBottomText.Text = SelectedOption.Value.Name
&#9;SmallCenterText.Visible = false
&#9;SmallTopText.Visible = true
&#9;SmallBottomText.Visible = true
&#9;
end

function OpenMenu()
&#9;IsOpen=true
&#9;StartRoulette = false
&#9;-- Show full frame if enough room
&#9;local screenSize = script.Parent.AbsoluteSize
&#9;if screenSize.X &gt; MainFrame.Size.X.Offset and screenSize.Y &gt; MainFrame.Size.Y.Offset then
&#9;&#9;OpenNormalMenu()
&#9;else
&#9;&#9;OpenSmallMenu()
&#9;end
&#9;
end


function CloseMenu()
&#9;IsOpen=false
&#9;MainFrame:TweenPosition(UDim2.new(0,-800,.15,0),&apos;Out&apos;, &apos;Quad&apos;, .25, true)
&#9;SmallFrame:TweenPosition(UDim2.new(-1,0,.15,0),&apos;Out&apos;, &apos;Quad&apos;, .25, true)
end

function KeyDown(key)

&#9;if key:byte() == 20 then --left
&#9;&#9;local nvote = MyVote.Value-1
&#9;&#9;if nvote &lt;= 0 then nvote =3 end
&#9;&#9;SendVote(nvote)
&#9;elseif key:byte() == 19 then --right
&#9;&#9;local nvote = MyVote.Value+1
&#9;&#9;if nvote &gt;= 4 then nvote =1 end
&#9;&#9;SendVote(nvote)
&#9;end
end

--[[Running Logic]]--

do
&#9;local tchoice = {Votes={},Frame = WaitForChild(MainFrame,&apos;Choice1&apos;)}
&#9;table.insert(Choices,tchoice)
&#9;tchoice = {Votes={},Frame = WaitForChild(MainFrame,&apos;Choice2&apos;)}
&#9;table.insert(Choices,tchoice)
&#9;tchoice = {Votes={},Frame = WaitForChild(MainFrame,&apos;Choice3&apos;)}
&#9;table.insert(Choices,tchoice)
end

for index,i in ipairs(Choices) do
&#9;WaitForChild(i.Frame,&apos;Button&apos;).MouseButton1Click:connect(function()
&#9;&#9;SendVote(index) 
&#9;end)
&#9;
&#9;if index==MyVote.Value then
&#9;&#9;WaitForChild(i.Frame,&apos;Highlight&apos;).Visible = true
&#9;else
&#9;&#9;WaitForChild(i.Frame,&apos;Highlight&apos;).Visible = false
&#9;end
&#9;SetUpChoice(index,MapChoices[index].Value)
&#9;MapChoices[index].Changed:connect(function() 
&#9;&#9;SetUpChoice(index,MapChoices[index].Value) 
&#9;end)
end

if not MyVote:FindFirstChild(&apos;Icon&apos;) then
&#9;local icon = Instance.new(&apos;StringValue&apos;)
&#9;icon.Name = &apos;Icon&apos;
&#9;icon.Parent = MyVote
end
--MyVote[&apos;Icon&apos;].Value = &apos;http://www.roblox.com/asset/?id=94690231&apos;

GameStateSignaler.Changed:connect( function()
&#9;if GameStateSignaler.Value == &apos;MAP_VOTING&apos; then&#9;
&#9;&#9;OpenMenu()
&#9;elseif GameStateSignaler.Value == &apos;MAP_ROULETTE&apos; then
&#9;&#9;StartRoulette = true
&#9;elseif GameStateSignaler.Value == &apos;PLAYING&apos; then
&#9;&#9;CloseMenu()
&#9;end&#9;

end)
MyVote.Changed:connect(function()
&#9;print(&apos;got changed &apos;.. MyVote.Value)
&#9;if MyVote.Value&gt;0 and MyVote.Value&lt;4 then
&#9;&#9;ChoiceSelected(Choices[MyVote.Value])
&#9;end
end)
if not CanVote then
&#9;BCHeader.Visible = false
end
Game.Players.LocalPlayer:GetMouse().KeyDown:connect(KeyDown)
--preload Images
for _, i in pairs(IMAGES) do
&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(ASSET_URL..i)
end

for _, i in pairs(SOUNDS) do
&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(ASSET_URL..i)
end
</ProtectedString>
				</Properties>
				<Item class="ImageButton" referent="RBX193">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4294902535</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=105939602</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">TemplateVote</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>27</XO>
							<YS>0</YS>
							<YO>31</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">5</int>
					</Properties>
					<Item class="TextLabel" referent="RBX194">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">6</token>
							<string name="Name">TextLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Label</string>
							<Color3 name="TextColor3">4279970357</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX195">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">SmallFrame</string>
					<UDim2 name="Position">
						<XS>-1</XS>
						<XO>0</XO>
						<YS>0.150000006</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">10</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX196">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=94793101</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX197">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97839255</url></Content>
						<string name="Name">Logo</string>
						<UDim2 name="Position">
							<XS>-0.0729166642</XS>
							<XO>0</XO>
							<YS>-0.25</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.89084506</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX198">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">0</token>
						<string name="Name">TopLine</string>
						<UDim2 name="Position">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.600000024</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.899999976</XS>
							<XO>0</XO>
							<YS>0.200000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Loading Map:</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">true</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX199">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">0</token>
						<string name="Name">BottomLine</string>
						<UDim2 name="Position">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.790000021</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.899999976</XS>
							<XO>0</XO>
							<YS>0.200000003</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Valley of Arches</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">true</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX200">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">0</token>
						<string name="Name">CenterText</string>
						<UDim2 name="Position">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.649999976</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.910000026</XS>
							<XO>0</XO>
							<YS>0.300000012</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Deciding Next Map...</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">true</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX201">
			<Properties>
				<string name="Name">ActionButtonGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX202">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ActionButtonGuiScript</string>
					<ProtectedString name="Source">-------------------
--| Touch Check |--
-------------------

if not Game:GetService(&apos;UserInputService&apos;).TouchEnabled then return end

-----------------
--| Constants |--
-----------------

local DOWN_IMAGE = &apos;http://www.roblox.com/asset/?id=97166756&apos;

local ICON_SUBSTITUTION_TABLE = {Sword = &apos;http://www.roblox.com/asset/?id=96601703&apos;}

local CROSSHAIR_ENABLED_TOOLS = {Superball = 1, Slingshot = 1, Bomb = 1, RocketLauncher = 1, PipeBomb = 1, Taser = 1, BattleBottle = 1}
-- The above Tools will display the crosshair and receive data on its position when the Action Button is used

local DATA_OBJECT_NAME = &apos;ActionButtonData&apos;
local BINDABLE_NAME = &apos;GetTargetPosition&apos;
--NOTE: Changing the above names requires changing all Tools (See Reference, below)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local ActionButtonGui = script.Parent
local PlayerGui = ActionButtonGui.Parent
local Player = PlayerGui.Parent

local ActionButtonFrame = WaitForChild(ActionButtonGui, &apos;ActionButtonFrame&apos;)
local ActionButton = WaitForChild(ActionButtonFrame, &apos;ActionButton&apos;)
local ToolIcon = WaitForChild(ActionButtonFrame, &apos;ToolIcon&apos;)
local ReloadingIcon = WaitForChild(ActionButtonFrame, &apos;ReloadingIcon&apos;)

local CrosshairFrame = WaitForChild(ActionButtonGui, &apos;CrosshairFrame&apos;)

local BindableLocalScript = WaitForChild(script, &apos;BindableLocalScript&apos;)
local BindableScript = WaitForChild(script, &apos;BindableScript&apos;)

local Backpack = WaitForChild(Player, &apos;Backpack&apos;)

local PlayerMouse = Player:GetMouse()

local UpImage = ActionButton.Image

local OriginalSize = ActionButtonFrame.Size
local OriginalPosition = ActionButtonFrame.Position
local SmallScreenPosition = UDim2.new(1 - ActionButtonFrame.Size.X.Scale * 1.25 - 0.01, 0, 0.01, 0) -- Top right
local SmallScreenSize = UDim2.new(ActionButtonFrame.Size.X.Scale * 1.25, 0, ActionButtonFrame.Size.Y.Scale * 1.25, 0) -- 25% bigger

local ButtonDown = false

local DataObjectBase = nil

local ToolChangedConnection = nil
local BackpackChildAddedConnection = nil
local BackpackChildRemovedConnection = nil

-----------------
--| Functions |--
-----------------

local function MakeBaseObject()
&#9;local buttonDataObject = Instance.new(&apos;StringValue&apos;)
&#9;buttonDataObject.Name = DATA_OBJECT_NAME

&#9;local bindable = Instance.new(&apos;BindableFunction&apos;)
&#9;bindable.Name = BINDABLE_NAME
&#9;bindable.Parent = buttonDataObject

&#9;local bindableLocalScriptClone = BindableLocalScript:Clone()
&#9;bindableLocalScriptClone.Disabled = false
&#9;bindableLocalScriptClone.Parent = bindable

&#9;local bindableScriptClone = BindableScript:Clone()
&#9;bindableScriptClone.Disabled = false
&#9;bindableScriptClone.Parent = bindable

&#9;return buttonDataObject
end

local function ClearToolConnection()
&#9;if ToolChangedConnection then
&#9;&#9;ToolChangedConnection:disconnect()
&#9;&#9;ToolChangedConnection = nil
&#9;end
end

-- Returns the first Tool found in character
local function FindEquippedTool(character)
&#9;for _, child in pairs(character:GetChildren()) do
&#9;&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;return child
&#9;&#9;end
&#9;end
end

-- Waits for a new character to be added if the current one is invalid
-- (Ensures that you don&apos;t have the old dead character after a respawn)
local function WaitForValidCharacter(player)
&#9;local character = player.Character
&#9;if not character or not character.Parent or not character:FindFirstChild(&apos;Humanoid&apos;) or character.Humanoid.Health &lt;= 0 then
&#9;&#9;player.CharacterAdded:wait()
&#9;&#9;wait(0) --NOTE: Necessary for server scripts executing on the same event
&#9;&#9;character = player.Character
&#9;end
&#9;return character
end

-- When Action Button is pressed or depressed, update images and send button state information to the Player&apos;s equipped Tool
-- For crosshair-enabled Tools, screen information is also serialized and sent
local function OnButton1Changed(down)
&#9;ButtonDown = down
&#9;ActionButton.Image = down and DOWN_IMAGE or UpImage
&#9;if Player.Character then
&#9;&#9;local equippedTool = FindEquippedTool(Player.Character)
&#9;&#9;if equippedTool then
&#9;&#9;&#9;local dataObject = equippedTool:FindFirstChild(DATA_OBJECT_NAME)
&#9;&#9;&#9;if dataObject then
&#9;&#9;&#9;&#9;local dataString = down and &apos;v&apos; or &apos;^&apos;
&#9;&#9;&#9;&#9;if CROSSHAIR_ENABLED_TOOLS[equippedTool.Name] then
&#9;&#9;&#9;&#9;&#9;CrosshairFrame.Visible = true
&#9;&#9;&#9;&#9;&#9;local screenPosition = CrosshairFrame.AbsolutePosition + (CrosshairFrame.AbsoluteSize / 2)
&#9;&#9;&#9;&#9;&#9;local screenSize = ActionButtonGui.AbsoluteSize
&#9;&#9;&#9;&#9;&#9;dataString = dataString .. tostring(screenPosition) .. &apos;;&apos; .. tostring(screenSize)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;dataObject.Value = dataString
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnPlayerMouseChanged(down)
&#9;do -- Ignore click if over Action Button
&#9;&#9;local mouseX = PlayerMouse.X
&#9;&#9;local mouseY = PlayerMouse.Y
&#9;&#9;local topLeft = ActionButtonFrame.AbsolutePosition
&#9;&#9;local bottomRight = topLeft + ActionButtonFrame.AbsoluteSize
&#9;&#9;if (mouseX &gt; topLeft.X and mouseX &lt; bottomRight.X) and (mouseY &gt; topLeft.Y and mouseY &lt; bottomRight.Y) then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;if down then
&#9;&#9;CrosshairFrame.Visible = false
&#9;elseif ButtonDown then -- Letting go after dragging off button
&#9;&#9;OnButton1Changed(false)
&#9;end
end

-- Fires when a Tool is unequipped normally
local function OnBackpackChildAdded(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;local tool = child

&#9;&#9;ToolIcon.Image = &apos;&apos; -- Remove any icon
&#9;&#9;ReloadingIcon.Visible = false
&#9;&#9;CrosshairFrame.Visible = false

&#9;&#9;-- Remove data object(s) from Tool
&#9;&#9;while tool:FindFirstChild(DATA_OBJECT_NAME) do
&#9;&#9;&#9;tool[DATA_OBJECT_NAME]:Destroy()
&#9;&#9;end

&#9;&#9;-- Remove the saved connection
&#9;&#9;ClearToolConnection()
&#9;end
end

-- Fires when a Tool is equipped normally
local function OnBackpackChildRemoved(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;local tool = child

&#9;&#9;ToolIcon.Image = ICON_SUBSTITUTION_TABLE[tool.Name] or tool.TextureId
&#9;&#9;ReloadingIcon.Visible = not tool.Enabled
&#9;&#9;if CROSSHAIR_ENABLED_TOOLS[tool.Name] then
&#9;&#9;&#9;CrosshairFrame.Visible = true
&#9;&#9;end

&#9;&#9;-- Add data object to Tool (if necessary)
&#9;&#9;if not tool:FindFirstChild(DATA_OBJECT_NAME) then
&#9;&#9;&#9;DataObjectBase:Clone().Parent = tool
&#9;&#9;end

&#9;&#9;-- Connect to Changed and save the connection
&#9;&#9;ClearToolConnection() -- Do this first, just in case
&#9;&#9;ToolChangedConnection = tool.Changed:connect(function(property)
&#9;&#9;&#9;if property == &apos;Enabled&apos; then
&#9;&#9;&#9;&#9;ReloadingIcon.Visible = not tool.Enabled
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

local function CleanUp(character)
&#9;-- Clean up / reset images
&#9;local equippedTool = FindEquippedTool(character)
&#9;if equippedTool then
&#9;&#9;OnBackpackChildAdded(equippedTool)
&#9;else
&#9;&#9;ToolIcon.Image = &apos;&apos;
&#9;&#9;ReloadingIcon.Visible = false
&#9;&#9;CrosshairFrame.Visible = false
&#9;end

&#9;-- Disconnect Backpack events
&#9;BackpackChildAddedConnection:disconnect()
&#9;BackpackChildRemovedConnection:disconnect()
end

-- Updates button size and position based on screen size
local function AdjustForScreenSize()
&#9;if ActionButtonGui.AbsoluteSize.X &lt; 1024 then
&#9;&#9;ActionButtonFrame.Size = SmallScreenSize
&#9;&#9;ActionButtonFrame.Position = SmallScreenPosition
&#9;else
&#9;&#9;ActionButtonFrame.Size = OriginalSize
&#9;&#9;ActionButtonFrame.Position = OriginalPosition
&#9;end
end

--------------------
--| Script Logic |--
--------------------

DataObjectBase = MakeBaseObject()

ContentProviderService:Preload(DOWN_IMAGE)

ActionButton.MouseButton1Down:connect(function() OnButton1Changed(true) end)
ActionButton.MouseButton1Up:connect(function() OnButton1Changed(false) end)

PlayerMouse.Button1Down:connect(function() OnPlayerMouseChanged(true) end)
PlayerMouse.Button1Up:connect(function() OnPlayerMouseChanged(false) end)

BackpackChildAddedConnection = Backpack.ChildAdded:connect(OnBackpackChildAdded)
BackpackChildRemovedConnection = Backpack.ChildRemoved:connect(OnBackpackChildRemoved)

-- Automatically adjust when the screen changes
AdjustForScreenSize()
ActionButtonGui.Changed:connect(function(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;AdjustForScreenSize()
&#9;end
end)

ActionButtonFrame.Visible = true

-- Make sure we have the newly spawned character and not the old dead one
local character = WaitForValidCharacter(Player)

-- Check for tools that may already be equipped
local autoEquippedTool = FindEquippedTool(character)
if autoEquippedTool then
&#9;OnBackpackChildRemoved(autoEquippedTool)
end

-- Call CleanUp on character removal or death
character.Changed:connect(function(property)
&#9;if property == &apos;Parent&apos; and character.Parent == nil then
&#9;&#9;CleanUp(character)
&#9;end
end)
local humanoid = WaitForChild(character, &apos;Humanoid&apos;)
humanoid.Died:connect(function()
&#9;CleanUp(character)
end)

-----------------
--| Reference |--
-----------------

--[[
* One of the following code blocks must be adapted into a Tool for it to work with the Action Button.
* Both blocks expect a function OnActivated() which it will call when the button is down (or up, if you change &apos;v&apos; to &apos;^&apos;).

* This block is for Tools that don&apos;t need a target position:

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

* This block will pass a target position to OnActivated(), for Tools that throw or shoot:
* (Remember to add the Tool&apos;s name to the list of crosshair-enabled Tools at the top)

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

* Don&apos;t forget to connect the function:

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)

]]
</ProtectedString>
				</Properties>
				<Item class="Script" referent="RBX203">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BindableScript</string>
						<ProtectedString name="Source">--NOTE: This script and its children are only necessary because bindables cannot be called from server to client (and vice-versa)

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local GetTargetPosition = script.Parent

local CameraCFrameObject = WaitForChild(script, &apos;CameraCFrame&apos;)
local CameraFOVObject = WaitForChild(script, &apos;CameraFOV&apos;)

GetTargetPosition.OnInvoke = function(screenPosition, screenSize, ignoreList)
&#9;local cameraCFrame = CameraCFrameObject.Value
&#9;local cameraFOV = CameraFOVObject.Value
&#9;local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(cameraFOV) / 2))
&#9;local direction = Vector3.new(screenPosition.x - (screenSize.x / 2), (screenSize.y / 2) - screenPosition.y, -imagePlaneDepth)
&#9;local ray = Ray.new(cameraCFrame.p, (cameraCFrame:vectorToWorldSpace(direction)).unit * 999)
&#9;local _, targetPosition = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {})
&#9;return targetPosition
end
</ProtectedString>
					</Properties>
					<Item class="CFrameValue" referent="RBX204">
						<Properties>
							<string name="Name">CameraCFrame</string>
							<CoordinateFrame name="Value">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX205">
						<Properties>
							<string name="Name">CameraFOV</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX206">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ValueUpdater</string>
							<ProtectedString name="Source">local ONE_STEP = 1/30

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local ServerScript = script.Parent
local CameraCFrameObject = WaitForChild(ServerScript, &apos;CameraCFrame&apos;)
local CameraFOVObject = WaitForChild(ServerScript, &apos;CameraFOV&apos;)

local Camera = Workspace.CurrentCamera
CameraCFrameObject.Value = Camera.CoordinateFrame
CameraFOVObject.Value = Camera.FieldOfView

--[[ NOTE: Can&apos;t do event-based because Camera CFrame does not update when you zoom nor when you move the character
Camera.Changed:connect(function(property)
&#9;print(&apos;Camera Changed&apos;)
&#9;if property == &apos;CoordinateFrame&apos; then
&#9;&#9;CameraCFrameObject.Value = Camera.CoordinateFrame
&#9;elseif property == &apos;FieldOfView&apos; then
&#9;&#9;CameraFOVObject.Value = Camera.FieldOfView
&#9;end
end)
--]]

while true do
&#9;CameraCFrameObject.Value = Camera.CoordinateFrame
&#9;CameraFOVObject.Value = Camera.FieldOfView
&#9;wait(ONE_STEP)
end
</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX207">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BindableLocalScript</string>
						<ProtectedString name="Source">local GetTargetPosition = script.Parent

local Camera = Workspace.CurrentCamera

GetTargetPosition.OnInvoke = function(screenPosition, screenSize, ignoreList)
&#9;local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(Camera.FieldOfView) / 2))
&#9;local direction = Vector3.new(screenPosition.x - (screenSize.x / 2), (screenSize.y / 2) - screenPosition.y, -imagePlaneDepth)
&#9;local ray = Ray.new(Camera.CoordinateFrame.p, (Camera.CoordinateFrame:vectorToWorldSpace(direction)).unit * 999)
&#9;local _, targetPosition = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {})
&#9;return targetPosition
end
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX208">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ActionButtonFrame</string>
					<UDim2 name="Position">
						<XS>0.873046875</XS>
						<XO>0</XO>
						<YS>0.713541687</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.09765625</XS>
						<XO>0</XO>
						<YS>0.09765625</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">1</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">10</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX209">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><null></null></Content>
						<string name="Name">ToolIcon</string>
						<UDim2 name="Position">
							<XS>0.174999997</XS>
							<XO>0</XO>
							<YS>0.174999997</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.649999976</XS>
							<XO>0</XO>
							<YS>0.649999976</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX210">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97166793</url></Content>
						<string name="Name">ReloadingIcon</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX211">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97166444</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">ActionButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX212">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">CrosshairFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-16</XO>
						<YS>0.400000006</YS>
						<YO>-16</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>32</XO>
						<YS>0</YS>
						<YO>32</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">10</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX213">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97244912</url></Content>
						<string name="Name">Crosshair</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX214">
			<Properties>
				<string name="Name">RoundEndGui</string>
			</Properties>
			<Item class="Frame" referent="RBX215">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">RoundEndFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>-60</XO>
						<YS>0</YS>
						<YO>-60</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>821</XO>
						<YS>0</YS>
						<YO>555</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">7</int>
				</Properties>
				<Item class="Frame" referent="RBX216">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StaticElements</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX217">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97837313</url></Content>
							<string name="Name">Backdrop</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>58</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>827</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX218">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97859010</url></Content>
							<string name="Name">Castle</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>118</XO>
								<YS>0</YS>
								<YO>235</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>724</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">6</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX219">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839320</url></Content>
							<string name="Name">FavoriteWeapon</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>742</XO>
								<YS>0</YS>
								<YO>478</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX220">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839283</url></Content>
							<string name="Name">Knockouts</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>421</XO>
								<YS>0</YS>
								<YO>480</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX221">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97853709</url></Content>
							<string name="Name">Leaderboard</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>541</XO>
								<YS>0</YS>
								<YO>172</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>512</XO>
								<YS>0</YS>
								<YO>256</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX222">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839255</url></Content>
							<string name="Name">Logo</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>574</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX223">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839265</url></Content>
							<string name="Name">MVP</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>289</XO>
								<YS>0</YS>
								<YO>373</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX224">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839309</url></Content>
							<string name="Name">Wipeouts</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>593</XO>
								<YS>0</YS>
								<YO>477</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX225">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=OnlyTwentyCharacters</url></Content>
						<string name="Name">MvpImage</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>250</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>230</XO>
							<YS>0</YS>
							<YO>230</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">5</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX226">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Leaderboard</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>541</XO>
							<YS>0</YS>
							<YO>194</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>297</XO>
							<YS>0</YS>
							<YO>193</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX227">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97820612</url></Content>
							<string name="Name">Highlight</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>296</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX228">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">BaseRow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>297</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">7</int>
						</Properties>
						<Item class="TextLabel" referent="RBX229">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">Rank</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">1</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX230">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">PlayerName</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>20</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>192</XO>
									<YS>0</YS>
									<YO>24</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">OnlyTwentyCharacters</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX231">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">KOs</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>240</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">99</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX232">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">WOs</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>285</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">99</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX233">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpKnockouts</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>380</XO>
							<YS>0</YS>
							<YO>507</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX234">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">LeftImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX235">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">RightImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX236">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpWipeouts</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>550</XO>
							<YS>0</YS>
							<YO>507</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX237">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">LeftImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX238">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">RightImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX239">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=101199048</url></Content>
						<string name="Name">MvpWeapon</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>730</XO>
							<YS>0</YS>
							<YO>510</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX240">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpName</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>285</XO>
							<YS>0</YS>
							<YO>422</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX241">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">7</token>
							<string name="Name">MvpNameShadow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX242">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">7</token>
							<string name="Name">MvpName</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX243">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RoundEndGuiScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local REQUEST_URL = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;

local ASSET_URL = &apos;http://www.roblox.com/asset/?id=&apos;

local NUMBER_TABLE = {97830501, 97830521, 97830539, 97830556, 97830577, 97830598, 97830609, 97830634, 97830645, 97830658}

local TOOL_TABLE = {
&#9;Sword = 97830724,
&#9;Superball = 97830748,
&#9;Slingshot = 97830769,
&#9;Bomb = 97830794,
&#9;RocketLauncher = 97830812,
&#9;Reflector = 97830832,
&#9;Pitchfork = 101198127,
&#9;PipeBomb = 101199024
}

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local RoundEndGui = script.Parent
local PlayerGui = RoundEndGui.Parent
local Player = PlayerGui.Parent

-- Full Version --

local RoundEndFrame = WaitForChild(RoundEndGui, &apos;RoundEndFrame&apos;)

local LeaderboardFrame = WaitForChild(RoundEndFrame, &apos;Leaderboard&apos;)
local BaseLeaderboardRow = WaitForChild(LeaderboardFrame, &apos;BaseRow&apos;)
local BaseRowRank = WaitForChild(BaseLeaderboardRow, &apos;Rank&apos;)
local BaseRowName = WaitForChild(BaseLeaderboardRow, &apos;PlayerName&apos;)
local BaseRowKOs = WaitForChild(BaseLeaderboardRow, &apos;KOs&apos;)
local BaseRowWOs = WaitForChild(BaseLeaderboardRow, &apos;WOs&apos;)
local Highlight = WaitForChild(LeaderboardFrame, &apos;Highlight&apos;)

local MvpImage = WaitForChild(RoundEndFrame, &apos;MvpImage&apos;)
local MvpNameFrame = WaitForChild(RoundEndFrame, &apos;MvpName&apos;)
local MvpName = WaitForChild(MvpNameFrame, &apos;MvpName&apos;)
local MvpNameShadow = WaitForChild(MvpNameFrame, &apos;MvpNameShadow&apos;)

local MvpKnockoutsFrame = WaitForChild(RoundEndFrame, &apos;MvpKnockouts&apos;)
local KnockoutsLeftImage = WaitForChild(MvpKnockoutsFrame, &apos;LeftImage&apos;)
local KnockoutsRightImage = WaitForChild(MvpKnockoutsFrame, &apos;RightImage&apos;)

local MvpWipeoutsFrame = WaitForChild(RoundEndFrame, &apos;MvpWipeouts&apos;)
local WipeoutsLeftImage = WaitForChild(MvpWipeoutsFrame, &apos;LeftImage&apos;)
local WipeoutsRightImage = WaitForChild(MvpWipeoutsFrame, &apos;RightImage&apos;)

local MvpWeapon = WaitForChild(RoundEndFrame, &apos;MvpWeapon&apos;)

local MainRoundScript = WaitForChild(Workspace, &apos;MainRoundScript&apos;)
local GameStateSignaler = WaitForChild(MainRoundScript, &apos;GameStateSignaler&apos;)

local FrameSize = Vector2.new(RoundEndFrame.Size.X.Offset, RoundEndFrame.Size.Y.Offset)
local FrameOffset = Vector2.new(RoundEndFrame.Position.X.Offset, RoundEndFrame.Position.Y.Offset)
local ShadowTextOffset = Vector2.new(MvpNameShadow.Position.X.Offset, MvpNameShadow.Position.Y.Offset)

local ScreenChangeConnection = nil

-- Basic Version --

local BasicRoundEndFrame = WaitForChild(RoundEndGui, &apos;RoundEndFrame_Basic&apos;)

local BasicSideA = WaitForChild(BasicRoundEndFrame, &apos;SideA&apos;)
local BasicSideA_Text = WaitForChild(BasicSideA, &apos;Text&apos;)
local BasicSideA_KOs = WaitForChild(BasicSideA, &apos;KOs&apos;)
local BasicSideA_WOs = WaitForChild(BasicSideA, &apos;WOs&apos;)

local BasicSideB = WaitForChild(BasicRoundEndFrame, &apos;SideB&apos;)
local BasicSideB_Text = WaitForChild(BasicSideB, &apos;Text&apos;)
local BasicSideB_KOs = WaitForChild(BasicSideB, &apos;KOs&apos;)
local BasicSideB_WOs = WaitForChild(BasicSideB, &apos;WOs&apos;)

local BasicMvpSideA = WaitForChild(BasicRoundEndFrame, &apos;MVP_SideA&apos;)

local BasicMvpSideB = WaitForChild(BasicRoundEndFrame, &apos;MVP_SideB&apos;)
local BasicMvpSideB_KOs = WaitForChild(BasicMvpSideB, &apos;KOs&apos;)
local BasicMvpSideB_WOs = WaitForChild(BasicMvpSideB, &apos;WOs&apos;)

-----------------
--| Functions |--
-----------------

-- Centers the RoundEndFrame on the screen
local function PositionRoundEndFrame()
&#9;local newPosition = UDim2.new(0, FrameOffset.X, 0, FrameOffset.Y)
&#9;local screenSize = RoundEndGui.AbsoluteSize
&#9;local offset = (screenSize - FrameSize) / 2
&#9;RoundEndFrame.Position = newPosition + UDim2.new(0, offset.X, 0, offset.Y)
end

local function OnScreenChanged(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;PositionRoundEndFrame()
&#9;end
end

local function SuffixNumber(n)
&#9;return n .. (n == 1 and &apos;st&apos; or (n == 2 and &apos;nd&apos; or (n == 3 and &apos;rd&apos; or &apos;th&apos;)))
end

local function SwitchFrameVisibility(frames)
&#9;for _, frame in pairs(frames) do
&#9;&#9;frame.Visible = not frame.Visible
&#9;end
end

local function SetupBasicRoundEndFrame(playerRow, mvpEntry)
&#9;local playerRank = playerRow[1]
&#9;local playerEntry = playerRow[2]
&#9;local activeSubFrames = nil
&#9;if playerEntry ~= mvpEntry then
&#9;&#9;BasicSideA_Text.Text = &quot;You got &quot; .. SuffixNumber(playerRank) .. &quot; place!&quot;
&#9;&#9;BasicSideA_KOs.Text = &quot;KOs: &quot; .. playerEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicSideA_WOs.Text = &quot;WOs: &quot; .. playerEntry[&apos;WOs&apos;]
&#9;&#9;BasicSideB_Text.Text = &quot;MVP: &quot; .. mvpEntry[&apos;Name&apos;]
&#9;&#9;BasicSideB_KOs.Text = &quot;KOs: &quot; .. mvpEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicSideB_WOs.Text = &quot;WOs: &quot; .. mvpEntry[&apos;WOs&apos;]
&#9;&#9;activeSubFrames = {BasicSideA, BasicSideB}
&#9;else -- Player is MVP
&#9;&#9;BasicMvpSideB_KOs.Text = &quot;KOs: &quot; .. playerEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicMvpSideB_WOs.Text = &quot;WOs: &quot; .. playerEntry[&apos;WOs&apos;]
&#9;&#9;activeSubFrames = {BasicMvpSideA, BasicMvpSideB}
&#9;end
&#9;activeSubFrames[1].Visible = true
&#9;Spawn(function()
&#9;&#9;while BasicRoundEndFrame.Visible do
&#9;&#9;&#9;wait(3)
&#9;&#9;&#9;SwitchFrameVisibility(activeSubFrames)
&#9;&#9;end
&#9;end)
end



local function StatSort(left, right)
&#9;if left[&apos;KOs&apos;] ~= right[&apos;KOs&apos;] then
&#9;&#9;return left[&apos;KOs&apos;] &gt; right[&apos;KOs&apos;]
&#9;elseif left[&apos;WOs&apos;] ~= right[&apos;WOs&apos;] then
&#9;&#9;return left[&apos;WOs&apos;] &lt; right[&apos;WOs&apos;]
&#9;else
&#9;&#9;return left[&apos;JoinTime&apos;] &lt; right[&apos;JoinTime&apos;]
&#9;end
end

local function GetRoundResults()
&#9;local statsTable = {}
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local playerStats = player:FindFirstChild(&apos;leaderstats&apos;)
&#9;&#9;local joinTime = player:FindFirstChild(&apos;JoinTime&apos;)
&#9;&#9;if playerStats and joinTime and joinTime:IsA(&apos;NumberValue&apos;) then
&#9;&#9;&#9;local KOs = playerStats:FindFirstChild(&apos;KOs&apos;)
&#9;&#9;&#9;local WOs = playerStats:FindFirstChild(&apos;WOs&apos;)
&#9;&#9;&#9;if KOs and WOs and KOs:IsA(&apos;IntValue&apos;) and WOs:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;table.insert(statsTable, {Name = player.Name, KOs = KOs.Value, WOs = WOs.Value, JoinTime = joinTime.Value, Player = player})
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if #statsTable &lt; 1 then return {} end -- No valid players

&#9;-- Sort the table (by more KOs or less WOs or earlier JoinTime)
&#9;table.sort(statsTable, StatSort)
&#9;return statsTable
end

local function SetMVP(mvpEntry)
&#9;-- Show their name and image
&#9;local mvpName = mvpEntry[&apos;Name&apos;]
&#9;MvpImage.Image = REQUEST_URL .. mvpName
&#9;MvpName.Text = mvpName
&#9;MvpNameShadow.Text = mvpName

&#9;-- Show their KOs and WOs
&#9;local mvpKOs = mvpEntry[&apos;KOs&apos;]
&#9;local rightDigit = mvpKOs % 10
&#9;local leftDigit = ((mvpKOs % 100) - rightDigit) / 10
&#9;KnockoutsLeftImage.Image = ASSET_URL .. NUMBER_TABLE[leftDigit + 1]
&#9;KnockoutsRightImage.Image = ASSET_URL .. NUMBER_TABLE[rightDigit + 1]
&#9;local mvpWOs = mvpEntry[&apos;WOs&apos;]
&#9;rightDigit = mvpWOs % 10
&#9;leftDigit = ((mvpWOs % 100) - rightDigit) / 10
&#9;WipeoutsLeftImage.Image = ASSET_URL .. NUMBER_TABLE[leftDigit + 1]
&#9;WipeoutsRightImage.Image = ASSET_URL .. NUMBER_TABLE[rightDigit + 1]

&#9;-- Show their favorite weapon
&#9;local mvp = mvpEntry[&apos;Player&apos;]
&#9;if mvp then
&#9;&#9;local weaponStats = mvp:FindFirstChild(&apos;WeaponFrags&apos;)
&#9;&#9;if weaponStats then
&#9;&#9;&#9;-- Get the weapon frag data
&#9;&#9;&#9;local weaponStatsTable = {}
&#9;&#9;&#9;for _, weaponStat in pairs(weaponStats:GetChildren()) do
&#9;&#9;&#9;&#9;if weaponStat:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;&#9;weaponStatsTable[weaponStat.Name] = weaponStat.Value
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Find the weapon with the most frags
&#9;&#9;&#9;local mvpWeaponName = nil
&#9;&#9;&#9;for name, value in pairs(weaponStatsTable) do
&#9;&#9;&#9;&#9;if not mvpWeaponName or value &gt; weaponStatsTable[mvpWeaponName] then
&#9;&#9;&#9;&#9;&#9;mvpWeaponName = name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if weaponStatsTable[mvpWeaponName] &gt; 0 then -- Show it if we have an icon for it
&#9;&#9;&#9;&#9;local weaponIconId = TOOL_TABLE[mvpWeaponName]
&#9;&#9;&#9;&#9;if weaponIconId then
&#9;&#9;&#9;&#9;&#9;MvpWeapon.Image = ASSET_URL .. weaponIconId
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local playerRow = nil
end

local function SetUpRows(statsTable)
&#9;-- Make the leaderboard rows from statsTable
&#9;for i, entry in ipairs(statsTable) do
&#9;&#9;BaseRowRank.Text = i
&#9;&#9;BaseRowName.Text = entry[&apos;Name&apos;]
&#9;&#9;BaseRowKOs.Text = entry[&apos;KOs&apos;]
&#9;&#9;BaseRowWOs.Text = entry[&apos;WOs&apos;]

&#9;&#9;-- Highlight the current player, add shadow text, and save their rank and entry
&#9;&#9;if entry[&apos;Player&apos;] == Player then
&#9;&#9;&#9;Highlight.Position = UDim2.new(0, 1, 0, (i - 1) * Highlight.Size.Y.Offset)
&#9;&#9;&#9;Highlight.Visible = true

&#9;&#9;&#9;local originalColor = BaseRowName.TextColor3

&#9;&#9;&#9;local shadowColor = Color3.new(0, 0, 0)
&#9;&#9;&#9;BaseRowRank.TextColor3 = shadowColor
&#9;&#9;&#9;BaseRowName.TextColor3 = shadowColor
&#9;&#9;&#9;BaseRowKOs.TextColor3 = shadowColor
&#9;&#9;&#9;BaseRowWOs.TextColor3 = shadowColor

&#9;&#9;&#9;local shadowRow = BaseLeaderboardRow:Clone()
&#9;&#9;&#9;shadowRow.Position = UDim2.new(0, ShadowTextOffset.X, 0, (i - 1) * shadowRow.Size.Y.Offset + ShadowTextOffset.Y)
&#9;&#9;&#9;shadowRow.Name = &quot;ShadowRow&quot;
&#9;&#9;&#9;shadowRow.Parent = LeaderboardFrame
&#9;&#9;&#9;shadowRow.Visible = true

&#9;&#9;&#9;BaseRowRank.TextColor3 = originalColor
&#9;&#9;&#9;BaseRowName.TextColor3 = originalColor
&#9;&#9;&#9;BaseRowKOs.TextColor3 = originalColor
&#9;&#9;&#9;BaseRowWOs.TextColor3 = originalColor

&#9;&#9;&#9;playerRow = {i, entry}
&#9;&#9;end

&#9;&#9;local newRow = BaseLeaderboardRow:Clone()
&#9;&#9;newRow.Position = UDim2.new(0, 0, 0, (i - 1) * newRow.Size.Y.Offset)
&#9;&#9;newRow.Name = BaseRowName.Text
&#9;&#9;newRow.Parent = LeaderboardFrame
&#9;&#9;newRow.Visible = true
&#9;end
end

local function OnSignalerChanged(newValue)
&#9;if newValue == &apos;SCORE_VIEWING&apos; or newValue ==&apos;SCORE_VIEWING_PRE_VOTE&apos; then -- End of round
&#9;&#9;-- Get the leaderstats data and make a table of stats
&#9;&#9;statsTable = GetRoundResults()
&#9;&#9;if #statsTable&lt;1 then return end
&#9;&#9;-- Get the MVP
&#9;&#9;local mvpEntry = statsTable[1]
&#9;&#9;SetMVP(mvpEntry)
&#9;&#9;
&#9;&#9;SetUpRows(statsTable)
&#9;&#9;
&#9;&#9;-- Show full frame if enough room
&#9;&#9;local screenSize = RoundEndGui.AbsoluteSize
&#9;&#9;if screenSize.X &gt; FrameSize.X and screenSize.Y &gt; FrameSize.Y then
&#9;&#9;&#9;PositionRoundEndFrame()
&#9;&#9;&#9;ScreenChangeConnection = RoundEndGui.Changed:connect(OnScreenChanged)
&#9;&#9;&#9;RoundEndFrame.Visible = true
&#9;&#9;else -- Otherwise show basic frame
&#9;&#9;&#9;SetupBasicRoundEndFrame(playerRow, mvpEntry)
&#9;&#9;&#9;BasicRoundEndFrame.Visible = true
&#9;&#9;end
&#9;else -- End of end of round
&#9;&#9;if RoundEndFrame.Visible then
&#9;&#9;&#9;RoundEndFrame.Visible = false
&#9;&#9;&#9;ScreenChangeConnection:disconnect()
&#9;&#9;else
&#9;&#9;&#9;BasicRoundEndFrame.Visible = false
&#9;&#9;end

&#9;&#9;-- Clean up generated leaderboard rows
&#9;&#9;for _, child in pairs(LeaderboardFrame:GetChildren()) do
&#9;&#9;&#9;if child.Name ~= BaseLeaderboardRow.Name and child.Name ~= Highlight.Name then
&#9;&#9;&#9;&#9;child:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function PreloadThumbnail(player)
&#9;ContentProviderService:Preload(REQUEST_URL .. player.Name .. &quot;&amp;cb=&quot; .. tick())
end

--------------------
--| Script Logic |--
--------------------

-- Preload images for all players, current and future
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;PreloadThumbnail(player)
end
PlayersService.PlayerAdded:connect(PreloadThumbnail)

GameStateSignaler.Changed:connect(OnSignalerChanged)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX244">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">RoundEndFrame_Basic</string>
					<UDim2 name="Position">
						<XS>0.25</XS>
						<XO>0</XO>
						<YS>0.150000006</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">7</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX245">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=94793101</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">5</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX246">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97839255</url></Content>
						<string name="Name">Logo</string>
						<UDim2 name="Position">
							<XS>-0.0729166642</XS>
							<XO>0</XO>
							<YS>-0.25</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.89084506</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">6</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX247">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">SideA</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX248">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">Text</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.899999976</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">You got 8th place!</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX249">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX250">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX251">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">SideB</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX252">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">Text</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.899999976</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">MVP: OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX253">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX254">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX255">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MVP_SideA</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX256">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">YouGot</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">You got</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX257">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839265</url></Content>
							<string name="Name">MVP</string>
							<UDim2 name="Position">
								<XS>0.529999971</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.450704217</XS>
								<XO>0</XO>
								<YS>0.225352108</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX258">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MVP_SideB</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX259">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX260">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX261">
			<Properties>
				<string name="Name">VersionGui</string>
			</Properties>
			<Item class="TextLabel" referent="RBX262">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">2</token>
					<token name="FontSize">7</token>
					<string name="Name">VersionText</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.300000012</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">4/4/13</string>
					<Color3 name="TextColor3">4279970357</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4293984250</Color3>
					<float name="TextStrokeTransparency">0</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="LocalScript" referent="RBX263">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VersionGuiScript</string>
						<ProtectedString name="Source">local SuperUsers = {OnlyTwentyCharacters = 1, Sorcus = 1, Games = 1, Player1 = 1, fusroblox = 1}

local VersionText = script.Parent
local VersionGui = VersionText.Parent
local PlayerGui = VersionGui.Parent
local Player = PlayerGui.Parent

if SuperUsers[Player.Name] then
&#9;VersionText.Visible = true
&#9;wait(1)
&#9;while VersionText.TextTransparency &lt; 1 do
&#9;&#9;VersionText.TextTransparency = VersionText.TextTransparency + 0.05
&#9;&#9;VersionText.TextStrokeTransparency = VersionText.TextStrokeTransparency + 0.05
&#9;&#9;wait()
&#9;end
&#9;VersionText.Visible = false
end

wait(0)
VersionGui:Destroy()
</ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX264">
			<Properties>
				<string name="Name">StatsGui</string>
			</Properties>
			<Item class="Frame" referent="RBX265">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">buttonFrame</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>-3</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>73</XO>
						<YS>0</YS>
						<YO>37</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageButton" referent="RBX266">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107928300</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">ImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX267">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=108039909</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">HighlightImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-30</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>134</XO>
							<YS>0</YS>
							<YO>68</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX268">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StatGuiScript</string>
					<ProtectedString name="Source">function WaitForChild(parent,child)
&#9;while not parent:FindFirstChild(child)  do
&#9;&#9;wait()
&#9;end
&#9;return parent[child]
end

--Workspace Variables

local ScreenGui = script.Parent
local LocalPlayer = ScreenGui.Parent.Parent

local REQUEST_URL = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;

Game:GetService(&quot;ContentProvider&quot;):Preload(REQUEST_URL .. LocalPlayer.Name .. &quot;&amp;cb=&quot; .. tick())

local SelectedPlayer=LocalPlayer
local SelectedFrame = nil

local LocalOtherStats = WaitForChild(LocalPlayer,&apos;otherstats&apos;)
local MenuOpen = LocalOtherStats:FindFirstChild(&apos;StatsMenuOpen&apos;)
if not MenuOpen then
&#9;MenuOpen = Instance.new(&apos;IntValue&apos;)
&#9;MenuOpen.Value = 0
&#9;MenuOpen.Name = &apos;StatsMenuOpen&apos;
&#9;MenuOpen.Parent = LocalOtherStats
end

local PersistentData = WaitForChild(SelectedPlayer,&apos;PersistentModel&apos;)
local WeaponPersistence = WaitForChild(PersistentData,&apos;WeaponPersistence&apos;)


local ButtonFrame = WaitForChild(ScreenGui,&apos;buttonFrame&apos;)
local Button = WaitForChild(ButtonFrame,&apos;ImageButton&apos;)
local HighlightButton = WaitForChild(ButtonFrame,&apos;HighlightImageButton&apos;)

local MainFrame = WaitForChild(ScreenGui,&apos;MainFrame&apos;)
local ProfileImage = WaitForChild(MainFrame,&apos;ProfileImage&apos;)

local MainStats = WaitForChild(MainFrame,&apos;MainStats&apos;)
local OpenMainStats = WaitForChild(MainStats,&apos;OpenButton&apos;)

local WeaponData = WaitForChild(game.Lighting, &apos;WeaponData&apos;)

local WeaponStats = WaitForChild(MainFrame,&apos;WeaponStats&apos;)
local ClipFrame = WaitForChild(WeaponStats,&apos;ClipFrame&apos;)
local ScrollFrame = WaitForChild(ClipFrame,&apos;ScrollFrame&apos;)
local OpenWeaponStats = WaitForChild(WeaponStats,&apos;OpenButton&apos;)
local WeaponScrollUp = WaitForChild(WeaponStats,&apos;scrollUp&apos;)
local WeaponScrollDown = WaitForChild(WeaponStats,&apos;scrollDown&apos;)

local WeaponTemplate = WaitForChild(ScrollFrame,&apos;TemplateWeapon&apos;)

local PlayerListFrame = WaitForChild(MainFrame,&apos;playerList&apos;)
local TemplateFrame = WaitForChild(PlayerListFrame,&apos;TemplateFrame&apos;)

local NameText = WaitForChild(MainFrame,&apos;NameText&apos;)

local SlideSpeed = .26

local UpdatedStats = 
{
&#9;{Tag = &apos;Total_KOs&apos;,Obj = WaitForChild(MainStats, &apos;TotalKOs&apos;)},
&#9;{Tag = &apos;Total_WOs&apos;,Obj = WaitForChild(MainStats, &apos;TotalWOs&apos;)},
&#9;{Tag = &apos;Total_MVPs&apos;,Obj = WaitForChild(MainStats, &apos;TotalMVP&apos;)},
&#9;{Tag = &apos;Total_Rounds&apos;,Obj = WaitForChild(MainStats, &apos;TotalGames&apos;)},
&#9;{Tag = &apos;Best_Streak_Ever&apos;,Obj = WaitForChild(MainStats, &apos;BestStreak&apos;)},
&#9;{Tag = &apos;Most_KOs_In_Match&apos;,Obj = WaitForChild(MainStats, &apos;MostKos&apos;)},
&#9;{Tag = &apos;Most_WOs_In_Match&apos;,Obj = WaitForChild(MainStats, &apos;MostWos&apos;)},
}
local KDRText = WaitForChild(MainStats, &apos;KDR&apos;)

--Script Variables

--array of player entries, consisting of
--MyPlayer
--PersistentVars
--Frame (frame in playerlist)
local PlayerList = {}

local LocalPlayerEntry = nil

local TextUpdateConnections = {}

local WeaponRows = {}

local OpenPanel = MainStats

local ScrollIndex = 0
local WeaponPanelLength = 8

--Persistent keys
local PersistentKeys =
{
&#9;TotalKOs = &apos;Total_KOs&apos;,
&#9;TotalWOs = &apos;Total_WOs&apos;,
&#9;GamesPlayed = &apos;Total_Rounds&apos;,
&#9;MVPs = &apos;Total_MVPs&apos;,
&#9;WeaponKOSuffix = &apos;_$_KOs&apos;,
&#9;WeaponWOSuffix = &apos;_$_WOs&apos;,
&#9;LastJoin = &apos;Last_Join_Time&apos;,
&#9;MostKOs = &apos;Most_KOs_In_Match&apos;,
&#9;MostWOs = &apos;Most_WOs_In_Match&apos;,
&#9;AverageWOs = &apos;Average_WOs_In_Match&apos;,
&#9;AverageKOs = &apos;Average_KOs_In_Match&apos;,
&#9;BestStreak = &apos;Best_Streak_Ever&apos;,
&#9;XP = &apos;Total_XP&apos;,
&#9;XP_VERSION = &apos;XP_VERSION&apos;
}


local Admins=
{
&#9;&apos;fusroblox&apos;,
&#9;&apos;imtotallyadmin&apos;,
&#9;&apos;Sorcus&apos;,
&#9;&apos;OnlyTwentyCharacters&apos;,
&#9;&apos;Player1&apos;,
&#9;&apos;HotThoth&apos;,
&#9;&apos;Games&apos;,
&#9;&apos;Shedletsky&apos;,
&#9;&apos;SolarCrane&apos;,
}

--script functions

function SortFunction(a,b)
&#9;if b==LocalPlayer then return true end
&#9;--Add checking of rank here
&#9;return false
end

function MakeWeaponEntries()
&#9;
&#9;for _,i in pairs(WeaponData:GetChildren()) do
&#9;&#9;local WeaponEntry = {}
&#9;&#9;local nWeaponFrame=WeaponTemplate:Clone()
&#9;&#9;nWeaponFrame.Name= i.Name
&#9;&#9;WaitForChild(nWeaponFrame,&apos;WeaponName&apos;).Text = i.Name
&#9;&#9;WeaponEntry[&apos;KOs&apos;]=0
&#9;&#9;WeaponEntry[&apos;Frame&apos;]=nWeaponFrame
&#9;&#9;
&#9;&#9;if i:FindFirstChild(&apos;WhiteIcon&apos;) then
&#9;&#9;&#9;WaitForChild(nWeaponFrame,&apos;icon&apos;).Image = &apos;http://www.roblox.com/asset/?id=&apos;..i.WhiteIcon.Value
&#9;&#9;end
&#9;
&#9;&#9;table.insert(WeaponRows,WeaponEntry)
&#9;end
&#9;
end

function SortWeapons()
&#9;table.sort(WeaponRows,function(a,b)
&#9;&#9;return a[&apos;KOs&apos;]&gt;b[&apos;KOs&apos;] 
&#9;end)

&#9;local frameYSize =WeaponTemplate.Size.Y.Offset
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;entry[&apos;Frame&apos;].Position=WeaponTemplate.Position+UDim2.new(0,0,0,frameYSize*((i-1)+ScrollIndex))
&#9;&#9;entry[&apos;Frame&apos;].Parent=ScrollFrame
&#9;&#9;
&#9;&#9;if i%2==1 then
&#9;&#9;&#9;entry[&apos;Frame&apos;].BackgroundTransparency =.65
&#9;&#9;else
&#9;&#9;&#9;entry[&apos;Frame&apos;].BackgroundTransparency =1
&#9;&#9;end
&#9;&#9;if entry[&apos;KOs&apos;]==0 then entry[&apos;Frame&apos;].Visible = false 
&#9;&#9;else entry[&apos;Frame&apos;].Visible=true end
&#9;end
end

function ConnectWeaponEntries()
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;if entry[&apos;Connection&apos;] then entry[&apos;Connection&apos;]:disconnect() end
&#9;&#9;if WeaponPersistence:FindFirstChild(entry[&apos;Frame&apos;].Name) then
&#9;&#9;&#9;local wKos = WaitForChild(WeaponPersistence[entry[&apos;Frame&apos;].Name],&apos;KOs&apos;)
&#9;&#9;&#9;entry[&apos;Connection&apos;] = wKos.Changed:connect(function()
&#9;&#9;&#9;&#9;WaitForChild(entry[&apos;Frame&apos;],&apos;WeaponKOs&apos;).Text=tostring(wKos.Value)
&#9;&#9;&#9;&#9;entry[&apos;KOs&apos;]=wKos.Value
&#9;&#9;&#9;&#9;SortWeapons()
&#9;&#9;&#9;end)
&#9;&#9;&#9;WaitForChild(entry[&apos;Frame&apos;],&apos;WeaponKOs&apos;).Text = tostring(wKos.Value)
&#9;&#9;&#9;entry[&apos;KOs&apos;]=wKos.Value
&#9;&#9;end
&#9;end
&#9;SortWeapons()
end

function UpdateRatio(kos,wos)
&#9;if wos ==0 then 
&#9;&#9;KDRText.Text = &apos;N/A&apos;
&#9;&#9;if KDRText:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;&#9;KDRText.Background.Text = KDRText.Text
&#9;&#9;end
&#9;&#9;return
&#9;end
&#9;local ratio =kos/wos

&#9;KDRText.Text=string.format(&quot;%.2f&quot;,ratio)
&#9;if KDRText:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;KDRText.Background.Text = KDRText.Text
&#9;end
end

function OnPlayerClicked(entry)
&#9;for _,i in ipairs(TextUpdateConnections) do
&#9;&#9;i:disconnect()
&#9;end
&#9;TextUpdateConnections={}
&#9;SelectedPlayer = entry[&apos;MyPlayer&apos;]
&#9;NameText.Text= SelectedPlayer.Name
&#9;if SelectedFrame then
&#9;&#9;SelectedFrame.BackgroundTransparency=0
&#9;end
&#9;SelectedFrame=entry[&apos;Frame&apos;]
&#9;SelectedFrame.BackgroundTransparency=.4
&#9;PersistentData = WaitForChild(SelectedPlayer,&apos;PersistentModel&apos;)
&#9;WeaponPersistence = WaitForChild(PersistentData,&apos;WeaponPersistence&apos;)
&#9;local myKos = WaitForChild(PersistentData,&apos;Total_KOs&apos;)
&#9;local myWos = WaitForChild(PersistentData,&apos;Total_WOs&apos;)
&#9;table.insert(TextUpdateConnections,myKos.Changed:connect(function() UpdateRatio(myKos.Value,myWos.Value) end))
&#9;table.insert(TextUpdateConnections,myWos.Changed:connect(function() UpdateRatio(myKos.Value,myWos.Value) end))
&#9;UpdateRatio(myKos.Value,myWos.Value)
&#9;
&#9;ProfileImage.Image = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;..entry[&apos;MyPlayer&apos;].Name
&#9;for _, i in pairs(UpdatedStats) do
&#9;&#9;MakeUpdatedText(i.Obj,WaitForChild(PersistentData,i.Tag))
&#9;end
&#9;
&#9;ConnectWeaponEntries()
end

--makes a textlabel update when a given value changes
function MakeUpdatedText(textObj,value)
&#9;table.insert(TextUpdateConnections,value.Changed:connect(function()
&#9;&#9;textObj.Text=value.Value
&#9;&#9;if textObj:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;&#9;textObj.Background.Text = value.Value
&#9;&#9;end
&#9;end))
&#9;textObj.Text=value.Value
&#9;if textObj:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;textObj.Background.Text = value.Value
&#9;end
end

function MovePlayerEntries()
&#9;for i,entry in ipairs(PlayerList) do
&#9;&#9;entry[&apos;Frame&apos;].Position = UDim2.new(0,0,(1/8)*(i-1),0)
&#9;end
end

function MakePlayerFrame(player)
&#9;local nentry = {}
&#9;nentry[&apos;MyPlayer&apos;]=player
&#9;nentry[&apos;PersistentVars&apos;] = WaitForChild(player,&apos;PersistentModel&apos;)
&#9;local nframe = TemplateFrame:Clone()
&#9;WaitForChild(nframe,&apos;PlayerName&apos;).Text=player.Name
&#9;WaitForChild(nframe,&apos;button&apos;).MouseButton1Click:connect(function() OnPlayerClicked(nentry) end)
&#9;MakeUpdatedText(WaitForChild(nframe,&apos;Rank&apos;), WaitForChild(nentry[&apos;PersistentVars&apos;],PersistentKeys[&apos;TotalKOs&apos;]))
&#9;nentry[&apos;Frame&apos;]=nframe
&#9;nframe.Parent=PlayerListFrame
&#9;nframe.Visible=true
&#9;if player == game.Players.LocalPlayer then
&#9;&#9;LocalPlayerEntry = nentry
&#9;end
&#9;return nentry
end

function OnPlayerAdded(player) 
&#9;print(&apos;adding player:&apos; ..player.Name)
&#9;table.insert(PlayerList,MakePlayerFrame(player))
&#9;MovePlayerEntries()
end

function OnPlayerRemoved(player)
&#9;for i,entry in ipairs(PlayerList) do
&#9;&#9;if player ==entry[&apos;MyPlayer&apos;] then
&#9;&#9;&#9;table.remove(PlayerList,i)
&#9;&#9;&#9;entry[&apos;Frame&apos;]:Destroy()
&#9;&#9;&#9;MovePlayerEntries()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
end

function OffsetZIndex(obj,offset)
&#9;obj.ZIndex=obj.ZIndex+offset
&#9;for _,i in pairs(obj:GetChildren()) do
&#9;&#9;if i:IsA(&apos;GuiObject&apos;) then
&#9;&#9;&#9;OffsetZIndex(i,offset)
&#9;&#9;end
&#9;end
end

function OpenWeaponPanel()
&#9;if not OpenPanel or OpenPanel == WeaponStats then return end
&#9;MenuOpen.Value=2
&#9;OpenPanel = nil
&#9;WeaponStats:TweenPosition(UDim2.new(0, 260+WeaponStats.Size.X.Offset, 0, 70), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OffsetZIndex(MainStats,-1)
&#9;OffsetZIndex(WeaponStats,1)
&#9;WeaponStats:TweenPosition(UDim2.new(0, 260, 0, 70), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OpenPanel = WeaponStats
end

function OpenMainPanel()
&#9;if not OpenPanel or OpenPanel == MainStats then return end
&#9;MenuOpen.Value=1
&#9;OpenPanel = nil
&#9;MainStats:TweenPosition(UDim2.new(0, 250+MainStats.Size.X.Offset, 0, 60), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OffsetZIndex(MainStats,1)
&#9;OffsetZIndex(WeaponStats,-1)
&#9;MainStats:TweenPosition(UDim2.new(0, 250, 0, 60), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OpenPanel = MainStats
end

function ScrollWeapons(amount)
&#9;local nindex = ScrollIndex+amount
&#9;if nindex&gt;0 or -nindex&gt;(#WeaponRows-WeaponPanelLength) or not WeaponRows[(-nindex)+WeaponPanelLength][&apos;Frame&apos;].Visible then
&#9;&#9;return
&#9;end
&#9;ScrollIndex = nindex
&#9;local frameYSize =WeaponTemplate.Size.Y.Offset
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;entry[&apos;Frame&apos;].Position=WeaponTemplate.Position+UDim2.new(0,0,0,frameYSize*((i-1)+ScrollIndex))
&#9;end
end

function PreloadAll(obj)
&#9;for _, i in pairs(obj:GetChildren()) do
&#9;&#9;PreloadAll(i)
&#9;end
&#9;if obj:IsA(&apos;ImageButton&apos;) or obj:IsA(&apos;ImageLabel&apos;) then
&#9;&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(obj.Image)
&#9;&#9;--print(&apos;preloading &apos;.. obj.Name)
&#9;end
end

--setting up bindables

Button.MouseButton1Click:connect(function()
&#9;OnPlayerClicked(LocalPlayerEntry)
&#9;MainFrame.Visible= not MainFrame.Visible
&#9;if MainFrame.Visible then MenuOpen.Value=1
&#9;else MenuOpen.Value=0 end
&#9;if HighlightButton.Visible then
&#9;&#9;HighlightButton.Visible = false
&#9;&#9;WaitForChild(LocalOtherStats,&apos;DisplayStatsHighlight&apos;):Destroy()
&#9;end
end)

for _,player in pairs(game.Players:GetPlayers()) do
&#9;OnPlayerAdded(player)
end

game.Players.ChildAdded:connect(OnPlayerAdded)

game.Players.ChildRemoved:connect(OnPlayerRemoved)

OpenWeaponStats.MouseButton1Click:connect(OpenWeaponPanel)
OpenMainStats.MouseButton1Click:connect(OpenMainPanel)

WeaponScrollUp.MouseButton1Click:connect(function()ScrollWeapons(1)end)
WeaponScrollDown.MouseButton1Click:connect(function()ScrollWeapons(-1)end)

MakeWeaponEntries()

for _, i in ipairs(Admins) do
&#9;if LocalPlayer.Name == i then
&#9;&#9;PlayerListFrame.Visible=true
&#9;end
end

if MenuOpen.Value~=0 then
&#9;OnPlayerClicked(LocalPlayerEntry)
&#9;MainFrame.Visible= not MainFrame.Visible
&#9;if MenuOpen == 2 then
&#9;&#9;OffsetZIndex(MainStats,-1)
&#9;&#9;OffsetZIndex(WeaponStats,1)
&#9;end
end

local screenSize = script.Parent.AbsoluteSize
if screenSize.X &gt; MainFrame.Size.X.Offset and screenSize.Y &gt; MainFrame.Size.Y.Offset then
&#9;Button.Visible = true
&#9;if LocalOtherStats:FindFirstChild(&apos;DisplayStatsHighlight&apos;) then
&#9;&#9;HighlightButton.Visible = true
&#9;end
end

PreloadAll(script.Parent)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX269">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MainFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-320</XO>
						<YS>0.5</YS>
						<YO>-250</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>640</XO>
						<YS>0</YS>
						<YO>434</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX270">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294901764</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">playerList</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-200</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>400</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="Frame" referent="RBX271">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">TemplateFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.125</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
						<Item class="TextLabel" referent="RBX272">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">6</token>
								<string name="Name">PlayerName</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">OnlyTwentyCharacters</string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX273">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">Rank</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">12</string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX274">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><null></null></Content>
								<bool name="Modal">false</bool>
								<string name="Name">button</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX275">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107892608</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX276">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">XpBar</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>18</XO>
							<YS>0</YS>
							<YO>383</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>222</XO>
							<YS>0</YS>
							<YO>22</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
					<Item class="Frame" referent="RBX277">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ClipFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX278">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=107893470</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX279">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">5</token>
							<string name="Name">ToNextLevel</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-5</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">12345678 XP to Lv. 9</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX280">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=OnlyTwentyCharacters</url></Content>
						<string name="Name">ProfileImage</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>300</XO>
							<YS>0</YS>
							<YO>300</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX281">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107923922</url></Content>
						<string name="Name">Highlight</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>235</XO>
							<YS>0</YS>
							<YO>365</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>417</XO>
							<YS>0</YS>
							<YO>42</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX282">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">WeaponStats</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>260</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>423</XO>
							<YS>0</YS>
							<YO>308</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX283">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107926023 </url></Content>
							<string name="Name">background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX284">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<bool name="Modal">false</bool>
							<string name="Name">OpenButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-45</XO>
								<YS>0</YS>
								<YO>160</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0</YS>
								<YO>135</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX285">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">true</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ClipFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>25</XO>
								<YS>0</YS>
								<YO>50</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>341</XO>
								<YS>0</YS>
								<YO>205</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
						<Item class="Frame" referent="RBX286">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">ScrollFrame</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
							<Item class="Frame" referent="RBX287">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4294967295</Color3>
									<float name="BackgroundTransparency">0.699999988</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<string name="Name">TemplateWeapon</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>26</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">8</int>
								</Properties>
								<Item class="TextLabel" referent="RBX288">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">0</token>
										<token name="FontSize">5</token>
										<string name="Name">WeaponKOs</string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>-10</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">153</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX289">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">0</token>
										<token name="FontSize">5</token>
										<string name="Name">WeaponName</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>35</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Rocket Launcher</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX290">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><null></null></Content>
										<string name="Name">icon</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>25</XO>
											<YS>0</YS>
											<YO>25</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX291">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107895951</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">scrollDown</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>300</XO>
								<YS>0</YS>
								<YO>265</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>62</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX292">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107895765</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">scrollUp</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>220</XO>
								<YS>0</YS>
								<YO>265</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>62</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX293">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MainStats</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>250</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>423</XO>
							<YS>0</YS>
							<YO>308</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
					<Item class="TextLabel" referent="RBX294">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalGames</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>148</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">25</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX295">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX296">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalKOs</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">153</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX297">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX298">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalWOs</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>75</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">111</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX299">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX300">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107924595</url></Content>
							<string name="Name">Background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>9</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX301">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">KDR</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>112</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">2.10</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX302">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX303">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalMVP</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>183</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX304">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX305">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">BestStreak</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>220</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX306">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX307">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<bool name="Modal">false</bool>
							<string name="Name">OpenButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-35</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0</YS>
								<YO>115</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX308">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">MostKos</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>255</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX309">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX310">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">MostWos</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>290</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX311">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX312">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">NameText</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>135</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">OnlyTwentyCharacters</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">2</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX313">
			<Properties>
				<string name="Name">StoreGui</string>
			</Properties>
			<Item class="Frame" referent="RBX314">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4281479730</Color3>
					<float name="BackgroundTransparency">0.600000024</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MainFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX315">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4279505940</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StoreFrame</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-352</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>704</XO>
							<YS>0</YS>
							<YO>681</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX316">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105102078</url></Content>
							<string name="Name">Background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX317">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4281479730</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PageFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>125</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>525</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX318">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">CategoriesFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>122</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>35</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX319">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105102876</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">2</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX320">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PlayerCurrencyFrame</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-352</XO>
								<YS>0</YS>
								<YO>105</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>339</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX321">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105103085</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX322">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">StoreHeaderFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>12</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>114</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX323">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105102296</url></Content>
								<string name="Name">StoreHeader</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">2</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX324">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Title</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>75</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>100</XO>
									<YS>0</YS>
									<YO>30</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Store</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX325">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">FooterFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>5</XO>
								<YS>1</YS>
								<YO>-20</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-10</XO>
								<YS>0</YS>
								<YO>14</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="StringValue" referent="RBX326">
				<Properties>
					<string name="Name">AssetIds_CSV</string>
					<string name="Value">101110605, 101109685, 101159295</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX327">
				<Properties>
					<string name="Name">Categories_CSV</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX328">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreScript</string>
					<ProtectedString name="Source">--[[
&#9;// Filename: InGameStore.LUA
&#9;// Written by: Sorcus 
&#9;// Description: Creates all the GUI elements for the store 
&#9;// NOTE: If you find any bugs or other inconsistences PM Sorcus on ROBLOX 
&#9;&#9;&#9; or @Canavus on Twitter 
]]

-- NOTE: The below code only works in Lua 5.1 
-- As of Lua 5.2 they have removed global envs
-- It is still possible to do this but no non-nasty way 
if _VERSION ~= &apos;Lua 5.1&apos; then 
&#9;error(&apos;This code assumes that you are running Lua 5.1. Please read through the first 50 lines if you wonder why.&apos;)
end 
-- Get the current environment
local _ENV = getfenv() 

-- Create a metatable where new indices aren&apos;t allowed to make global variables 
local gMetatable = {&#9;__index = _ENV;
&#9;&#9;&#9;&#9;&#9;&#9;__newindex = function(t, k, v) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Global variable &apos;..  k ..  &apos; detected. Was this an accident?&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;&#9;end; 
&#9;&#9;&#9;&#9;&#9;}

-- Create a new table that is going to be the executing environment for the current script 
local _NewENV = setmetatable({ }, gMetatable)

-- Apply our table to be the environment 
-- NOTE: Indices are redirected to the default environment 
-- So stuff like print(&apos;blah&apos;) will still work 
-- NOTE #2: This is necessary because the default env is protected 
setfenv(1, _NewENV)

-- Now create a stricter environment for our table 
-- This will basically make it such that variables that are within the function are 
-- checked to make sure to be in the table first before checking global scope or erroring out 
local envMetatable = {
&#9;__newindex = function(t,k,v)
&#9;&#9;if type(v) == &apos;function&apos; then
&#9;&#9;&#9;setfenv(v,t)                            
&#9;&#9;end
&#9;&#9;rawset(t, k, v)
&#9;end;

&#9;__index = _NewENV;
}
------------------------------ GLOBALS -------------------------------

local ContentProvider = Game:GetService(&apos;ContentProvider&apos;)
local MarketplaceService = Game:GetService(&apos;MarketplaceService&apos;)
local Debris = Game:GetService(&apos;Debris&apos;)
local InsertService = Game:GetService(&apos;InsertService&apos;)
local UserInputService = Game:GetService(&apos;UserInputService&apos;)

local RBX_Utility = LoadLibrary(&apos;RbxUtility&apos;)
-- The utility library comes with Marks Create functionality 
local NewInstance = RBX_Utility -- typedef 
local RBX_Gui = LoadLibrary(&apos;RbxGui&apos;)

local BASE_URL = ContentProvider.BaseUrl:lower() 

local AssetsToPrefetch_List = {106467812, 106467831, 106467851, 106467877, 106467898, 106467911, 106467923, 106467948, 106469554}

--- PREFETCH ASSETS BEFORE EVERYTHING ELSE  -- 
for _, assetId in pairs(AssetsToPrefetch_List) do 
&#9;ContentProvider:Preload(&quot;http://www.roblox.com/asset/?id=&quot; .. assetId)
end
-- 
local Player = Game.Players.LocalPlayer 
local Character 
----------------------- STORE NAMESPACE --------------------------------
-- Set the metatable to be our special metatable 
-- This allows for removing the obnoxious self keyword whereever we need to access the variables in the Store table 
-- NOTE: Only functions within this table can access the vars directly, because it makes sense 
local Store = setmetatable({

&#9;&#9;&#9;&#9;Gui = nil,
&#9;&#9;&#9;&#9;MainIcon = nil, 
&#9;&#9;&#9;&#9;MainFrame = nil,&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;StoreFrame = nil,
&#9;&#9;&#9;&#9;CategoriesFrame = nil,
&#9;&#9;&#9;&#9;PlayerCurrencyFrame = nil,
&#9;&#9;&#9;&#9;PageFrame = nil, 

&#9;&#9;&#9;&#9;AssetIds_StringValue = nil,
&#9;&#9;&#9;&#9;Categories_StringValue = nil,

&#9;&#9;&#9;&#9;CurrentActiveTab = nil, 
&#9;&#9;&#9;&#9;CurrentActiveCategory = nil, 

&#9;&#9;&#9;&#9;Searchbar = nil, 

&#9;&#9;&#9;&#9;TabHighlight = nil, 

&#9;&#9;&#9;&#9;ItemType_WhiteList = {[&apos;Hat&apos;] = true, [&apos;Gear&apos;] = true, [&apos;Model&apos;] = true, [&apos;ShirtGraphic&apos;] = true, [&apos;Shirts&apos;] = true, [&apos;Pants&apos;] = true, [&apos;GamePass&apos;] = true, [&apos;Face&apos;]= true, [&apos;Packages&apos;] = true, [&apos;Passes&apos;] = true},

&#9;&#9;&#9;&#9;ItemTypeId_WhiteList = {[&apos;19&apos;] = &apos;Gear&apos;, [&apos;10&apos;] = &apos;Model&apos;, [&apos;11&apos;] = &apos;Shirts&apos;, [&apos;12&apos;] = &apos;Pants&apos;, [&apos;8&apos;] = &apos;Hat&apos;, [&apos;18&apos;] = &apos;Face&apos;, [&apos;2&apos;] = &apos;ShirtGraphic&apos;, [&apos;32&apos;] = &apos;Packages&apos;, [&apos;34&apos;] = &apos;Passes&apos;},

&#9;&#9;&#9;&#9;Categories_List = {},

&#9;&#9;&#9;&#9;Items_List = {},
&#9;&#9;&#9;&#9;PopupFrames_List = {},

&#9;&#9;&#9;&#9;ItemHashTable = {}, 

&#9;&#9;&#9;&#9;Layout = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;InitOffsetX = 10,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;InitOffsetY = 36,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;GridOffsetX = 21,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;GridOffsetY = 20,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NumCellsInRow = 5; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;NumRowsInPage = 3; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MaxItemsInPage = 5*3; 

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CurrencyIcon = 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;{&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Robux = 105177508;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Tickets = 105192824;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CurrencyTextColor = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Robux = Color3.new(27/255, 186/255 ,27/255),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Tickets = Color3.new(255/255, 203/255, 52/255)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CategoryTabOffsetX = 8,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;SearchbarX = 124,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;SearchbarY = 17,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;MembershipIcon = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- get these icons from tara 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[1] = {[&apos;Small&apos;] = 105264972},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[2] = {[&apos;Small&apos;] = 105265090},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[3] = {[&apos;Small&apos;] = 105265112}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;LimitedIcon = {[&apos;Small&apos;] = 105278471},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;LimitedUniqueIcon = {[&apos;Small&apos;] = 105278547}
&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;SearchCache_List = {},&#9;&#9;
&#9;&#9;&#9;Loading = true 
&#9;
}, envMetatable)

function Store:MakeItemPage(itemInfo_List)
&#9;local itemPageFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;}
end 

function Store:CreatePopupFrame(itemInfo_List) 

end 

function Store:HideAllPopups() 
end

function Store:ShowHoverFrame(item)
end

function Store:MakeItemCell(itemInfo_List)
&#9;-- Our store is partial, it always chooses to show price in ROBUX unless the item is tix only
&#9;local currencyIconId = Layout.CurrencyIcon.Robux
&#9;local currencyOfItem = &apos;PriceInRobux&apos;
&#9;local currencyTextColor = Layout.CurrencyTextColor.Robux
&#9;local membershipIcon = nil
&#9;local limitedItemIcon = nil
&#9;if itemInfo_List[&apos;PriceInRobux&apos;] == nil or itemInfo_List[&apos;PriceInRobux&apos;] == &apos;null&apos; then 
&#9;&#9;if itemInfo_List[&apos;PriceInTickets&apos;] and itemInfo_List[&apos;PriceInTickets&apos;] &gt; 0 then 
&#9;&#9;&#9;currencyIconId = Layout.CurrencyIcon.Tickets
&#9;&#9;&#9;currencyOfItem = &apos;PriceInTickets&apos;
&#9;&#9;&#9;currencyTextColor = Layout.CurrencyTextColor.Tickets
&#9;&#9;end 
&#9;end 

&#9;if itemInfo_List[&apos;MinimumMembershipLevel&apos;] &gt; 0 then 
&#9;&#9;membershipIcon = Layout.MembershipIcon[itemInfo_List[&apos;MinimumMembershipLevel&apos;]][&apos;Small&apos;]
&#9;end 

&#9;if itemInfo_List[&apos;IsLimitedUnique&apos;] then 
&#9;&#9;limitedItemIcon = Layout.LimitedUniqueIcon[&apos;Small&apos;]
&#9;elseif itemInfo_List[&apos;IsLimited&apos;] then 
&#9;&#9;limitedItemIcon = Layout.LimitedIcon[&apos;Small&apos;]
&#9;end 

&#9;local itemPage 
&#9;local itemFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 115, 0, 146);
&#9;&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;&#9;&#9;&#9;&#9;&#9;&#9;

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Background&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 115);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=105177613&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextButton&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;CLICK&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&apos;; 
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;ItemName&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 115);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10; &#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeColor3 = Color3.new(0, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 0.75;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextXAlignment = Enum.TextXAlignment.Left;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Currency&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 23, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 130);&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. currencyIconId;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;CurrencyAmount&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 26, 0, 130);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = itemInfo_List[currencyOfItem] or 0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = currencyTextColor;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size12;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextXAlignment = Enum.TextXAlignment.Left;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Thumbnail&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 0, 100);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 8, 0, 8);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = BASE_URL .. &apos;thumbs/asset.ashx?assetid=&apos; .. itemInfo_List[&apos;AssetId&apos;] .. &apos;&amp;x=100&amp;y=100&amp;format=png&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;&#9;}

&#9;&#9;if itemFrame.ItemName.TextBounds.X &gt; itemFrame.ItemName.Size.X.Offset then 
&#9;&#9;&#9;itemFrame.ItemName.TextWrapped = true 
&#9;&#9;end 

&#9;if membershipIcon then 
&#9;&#9;local mIcon = NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name =&apos;MembershipIcon&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. membershipIcon;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = itemFrame;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 32, 0, 32);
&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 87);
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;}
&#9;end 

&#9;if limitedItemIcon then 
&#9;&#9;local xPos = (membershipIcon and 32) or 0
&#9;&#9;local lIcon = NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;LimitedIcon&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. limitedItemIcon;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = itemFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 70, 0, 24);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, xPos, 0, 89);
&#9;&#9;&#9;&#9;&#9;&#9;}
&#9;end 

&#9;itemHoverFrame = Store:CreatePopupFrame(itemInfo_List)

&#9;itemPage = Store:MakeItemPage(itemInfo_List) 

&#9;itemFrame.CLICK.MouseButton1Down:connect(function()
&#9;&#9;print(itemInfo_List[&apos;AssetId&apos;])
&#9;&#9;MarketplaceService:PromptPurchase(Player, itemInfo_List[&apos;AssetId&apos;])
&#9;&#9;--itemPage.Visible = true 
&#9;&#9;--itemPage.Parent = StoreFrame 
&#9;end)&#9;

&#9;itemFrame.CLICK.MouseEnter:connect(function()
&#9;&#9;Store:HideAllPopups() 
&#9;&#9;Store:ShowHoverFrame(itemFrame)
&#9;end)

&#9;return itemFrame 
end

function Store:AdjustGrid(isCategorized, category, pageNum)
&#9;category = category or CurrentActiveCategory
&#9;pageNum = pageNum or 1
&#9;local row = 0 
&#9;local yOffset = 0 
&#9;local column = 1&#9;&#9;
&#9;local activeItems_List = Items_List[category]&#9;&#9;
&#9;--print(&apos;CATEGORY - &apos;, category, &apos;PAGE NUMBER - &apos;, pageNum, &apos;NUMBER OF ELEMENTS IN PAGE - &apos;, #activeItems_List[pageNum])
&#9;for i = 1, #activeItems_List[pageNum] do 
&#9;&#9;row = row + 1 
&#9;&#9;if row &gt; Layout.NumCellsInRow then 
&#9;&#9;&#9;row = row%Layout.NumCellsInRow 
&#9;&#9;&#9;yOffset = yOffset + activeItems_List[pageNum][i].Size.Y.Offset
&#9;&#9;&#9;column = column + 1
&#9;&#9;end 
&#9;&#9;activeItems_List[pageNum][i].Position = UDim2.new(0, Layout.InitOffsetX + (row - 1) * (activeItems_List[pageNum][i].Size.X.Offset + Layout.GridOffsetX), 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;0, Layout.InitOffsetY + yOffset + (column - 1) * Layout.GridOffsetY)
&#9;end &#9;
&#9;
&#9;---- FOOTER STUFF ----
&#9;FooterPageText.Text = &apos;Page &apos; .. pageNum .. &apos; of &apos; .. activeItems_List[&apos;NumberOfPages&apos;]
&#9;if pageNum &gt; 1 then 
&#9;&#9;FooterBackButton.Visible = true 
&#9;end 
&#9;if activeItems_List[&apos;NumberOfPages&apos;] &gt; 1 then 
&#9;&#9;FooterNextButton.Visible = true 
&#9;else 
&#9;&#9;FooterNextButton.Visible = false 
&#9;end 
&#9;----------------------
end

function Store:UpdateView(cName)
&#9;for i = 1, #Items_List do 
&#9;&#9;Items_List[i].Visible = false 
&#9;end 

&#9;if Items_List[cName] then 
&#9;&#9;-- do stuff here 
&#9;&#9;for pageNum, itemList in pairs(Items_List[cName]) do 
&#9;&#9;&#9;if type(itemList) == &apos;table&apos; then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local isCurrentPage = pageNum == Items_List[cName].CurrentActivePage
&#9;&#9;&#9;&#9;print(cName, isCurrentPage, pageNum, pageNum == Items_List[cName].CurrentActivePage, #itemList)
&#9;&#9;&#9;&#9;for i = 1, #itemList do 
&#9;&#9;&#9;&#9;&#9;if itemList[i] then 
&#9;&#9;&#9;&#9;&#9;&#9;itemList[i].Visible = isCurrentPage
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end 
&#9;&#9;end 

&#9;&#9;Store:AdjustGrid(true, cName, Items_List[cName].CurrentActivePage)
&#9;end 
end 

function Store:FindCategory(category) -- returns true or false 
&#9;for i = 1, #Categories_List do 
&#9;&#9;if Categories_List[i] == category then &#9;&#9;&#9;
&#9;&#9;&#9;return true 
&#9;&#9;end
&#9;end 
&#9;return false 
end 

function Store:ApplyBackgroundColor(category)
&#9;local cChildren = CategoriesFrame:GetChildren()
&#9;for i = 1, #cChildren do 
&#9;&#9;if cChildren[i].Name == category then 
&#9;&#9;&#9;TabHighlight.Parent = cChildren[i]&#9;&#9;&#9;
&#9;&#9;end 
&#9;end 
end

function Store:AddCategory(category, pos)
&#9;local cFrame = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = category;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 75, 0, 20);
&#9;&#9;&#9;&#9;&#9;&#9;Text = category;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 0.75;
&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 8 + (pos-1) * 75, 0, 7);
&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size18;
&#9;&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = CategoriesFrame;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundColor3 = Color3.new(200/255, 0, 0);
&#9;&#9;&#9;&#9;&#9;}

&#9;cFrame.MouseButton1Down:connect(function()
&#9;&#9;if Categories_List[&apos;Search&apos;] then 
&#9;&#9;&#9;Categories_List[&apos;Search&apos;] = {}
&#9;&#9;end 
&#9;&#9;Store.CurrentActiveCategory = cFrame.Name
&#9;&#9;Store:UpdateView(cFrame.Name)
&#9;&#9;Store:ApplyBackgroundColor(cFrame.Name)&#9;&#9;
&#9;end)

&#9;return cFrame &#9;
end 

function Store:CreateCategories()
&#9;--- HACK! Not sure where to put this -- 
&#9;TabHighlight = NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Highlight&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 75, 0, 20);
&#9;&#9;&#9;&#9;&#9;&#9;Image = &quot;http://www.roblox.com/asset/?id=106469554&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 3.0; &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;}
&#9;-- 
&#9;for i = 1, #Categories_List do 
&#9;&#9;local category = Categories_List[i]
&#9;&#9;Store:AddCategory(category, i)
&#9;end
&#9;Store:ApplyBackgroundColor(CurrentActiveCategory)
end

function Store:AddItemToGrid(itemGui, assetType, isCategorized)
&#9;local pageNum = 1
&#9;-- Used for swapping stuff out 
&#9;table.insert(Items_List, itemGui)
&#9;-- Used for searching 
&#9;ItemHashTable[itemGui.Name:lower()] = itemGui
&#9;if isCategorized then 
&#9;&#9;if not Items_List[assetType] then 
&#9;&#9;&#9;if not CurrentActiveCategory then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = assetType 
&#9;&#9;&#9;&#9;TabHighlight.Parent = Store:ApplyBackgroundColor(CurrentActiveCategory)
&#9;&#9;&#9;end 
&#9;&#9;&#9;Items_List[assetType] = {}
&#9;&#9;&#9;Items_List[assetType][pageNum] = {}
&#9;&#9;&#9;Items_List[assetType][&apos;NumElements&apos;] = 1
&#9;&#9;&#9;Items_List[assetType][&apos;CurrentActivePage&apos;] = 1
&#9;&#9;&#9;Items_List[assetType][&apos;NumberOfPages&apos;] = 1
&#9;&#9;end 
&#9;&#9;if Items_List[assetType].NumElements ~= 0 and Items_List[assetType].NumElements/Layout.MaxItemsInPage &gt; 1 then &#9;&#9;&#9;
&#9;&#9;&#9;pageNum = math.ceil(Items_List[assetType].NumElements/Layout.MaxItemsInPage)&#9;&#9;&#9;
&#9;&#9;&#9;Items_List[assetType][&apos;NumberOfPages&apos;] = pageNum
&#9;&#9;&#9;if not Items_List[assetType][pageNum] then  
&#9;&#9;&#9;&#9;Items_List[assetType][pageNum] = {}
&#9;&#9;&#9;end 
&#9;&#9;end 

&#9;&#9;table.insert(Items_List[assetType][pageNum], itemGui)&#9;&#9;&#9;&#9;
&#9;&#9;Items_List[assetType].NumElements = Items_List[assetType].NumElements + 1
&#9;end &#9;
&#9;Store:AdjustGrid(isCategorized, assetType)&#9;
end

 

function Store:CreateItemGrid(isCategorized)
&#9;for assetId in string.gmatch(AssetIds_StringValue.Value, &apos;[^,]+&apos;) do &#9;&#9;
&#9;&#9;local productInfo
&#9;&#9;local productInfo_List
&#9;&#9;local itemGui 
&#9;&#9;local assetType
&#9;&#9;local success, error = ypcall(function() productInfo = MarketplaceService:GetProductInfo(tonumber(assetId)) end)&#9;&#9;&#9;&#9;
&#9;&#9;
&#9;&#9;if productInfo then 
&#9;&#9;&#9;productInfo_List = RBX_Utility.DecodeJSON(productInfo)
&#9;&#9;&#9;assetType = ItemTypeId_WhiteList[tostring(productInfo_List[&apos;AssetTypeId&apos;])] 
&#9;&#9;&#9;if assetType then 
&#9;&#9;&#9;&#9;if not Store:FindCategory(assetType) then &#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;table.insert(Categories_List, assetType)
&#9;&#9;&#9;&#9;&#9;Store:AddCategory(assetType, #Categories_List)
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;itemGui = Store:MakeItemCell(productInfo_List)
&#9;&#9;&#9;&#9;Store:AddItemToGrid(itemGui, assetType, isCategorized)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end 
&#9;&#9;end &#9;
&#9;end 
end

function Store:CreateFooter()
&#9;FooterPageText = NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;PageInfo&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -50, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;Page 1 of 1&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterBackButton = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Back&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&lt;&lt;&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Visible = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 30, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -70, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterNextButton = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Next&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&gt;&gt;&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 30, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, 40, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Visible = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterNextButton.MouseButton1Down:connect(function()
&#9;&#9;if Items_List[CurrentActiveCategory] and Items_List[CurrentActiveCategory].CurrentActivePage then 
&#9;&#9;&#9;if Items_List[CurrentActiveCategory].CurrentActivePage + 1 &lt;= Items_List[CurrentActiveCategory].NumberOfPages then 
&#9;&#9;&#9;&#9;Items_List[CurrentActiveCategory].CurrentActivePage = Items_List[CurrentActiveCategory].CurrentActivePage  + 1
&#9;&#9;&#9;&#9;Store:UpdateView(CurrentActiveCategory)
&#9;&#9;&#9;&#9;Store:AdjustGrid(true, CurrentActiveCategory, Items_List[CurrentActiveCategory].CurrentActivePage)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;end)

&#9;FooterBackButton.MouseButton1Down:connect(function()
&#9;&#9;if Items_List[CurrentActiveCategory] and Items_List[CurrentActiveCategory].CurrentActivePage then 
&#9;&#9;&#9;if Items_List[CurrentActiveCategory].CurrentActivePage - 1 &gt; 0 then 
&#9;&#9;&#9;&#9;Items_List[CurrentActiveCategory].CurrentActivePage = Items_List[CurrentActiveCategory].CurrentActivePage - 1
&#9;&#9;&#9;&#9;Store:UpdateView(CurrentActiveCategory)
&#9;&#9;&#9;&#9;Store:AdjustGrid(true, CurrentActiveCategory, Items_List[CurrentActiveCategory].CurrentActivePage)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;end)
end

function Store:CreateSearchbar()
&#9;SearchbarFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;SearchBarFrame&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = CategoriesFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, Layout.SearchbarX, 0, Layout.SearchbarY);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(1, -(Layout.SearchbarX + 5), 0, 7);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Background&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=105218627&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextBox&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Search&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;Search&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size14;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;SearchbarFrame.Visible = false 

&#9;Searchbar = SearchbarFrame.Search

&#9;table.insert(Categories_List, &apos;Search&apos;) -- need to clean this up
&#9;local sTab = Store:AddCategory(&apos;Search&apos;, #Categories_List) -- Not sure if this is bad 
&#9;Items_List[&apos;Search&apos;] = {}
&#9;Items_List[&apos;Search&apos;][1] = {}
&#9;Items_List[&apos;Search&apos;].NumElements = 0
&#9;Items_List[&apos;Search&apos;].NumberOfPages = 1
&#9;sTab.Visible = false 

&#9;Searchbar.FocusLost:connect(function()
&#9;&#9;-- This is a direct string search 
&#9;&#9;-- If the item is 2 words and you type only one word it won&apos;t search it correctly.
&#9;&#9;-- For now this should be plenty for you. &#9;&#9;
&#9;&#9;local searchText = Searchbar.Text&#9;&#9;
&#9;&#9;if searchText then 
&#9;&#9;&#9;Items_List[&apos;Search&apos;][1] = {}
&#9;&#9;&#9;if ItemHashTable[searchText:lower()] then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = &apos;Search&apos;
&#9;&#9;&#9;&#9;table.insert(Items_List[&apos;Search&apos;][1], ItemHashTable[searchText])
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;-- Print info text that no such thing was found 
&#9;&#9;&#9;end 
&#9;&#9;&#9;Store:UpdateView(&apos;Search&apos;)
&#9;&#9;end 
&#9;end)
end

function Store:CreateIcon()

end

function Store:ShowLoading()&#9;
&#9;local loadingCircles = {106467812, 106467831, 106467851, 106467877, 106467898, 106467911, 106467923, 106467948} 

&#9;PageFrame.ZIndex = 7.0 
&#9;local lText = NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;Loading&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 200, 0, 40);
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -100, 0.5, -60);
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;Text = &apos;Loading&apos;;
&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size36;
&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(132/255, 112/255, 1);
&#9;&#9;&#9;&#9;&#9;ZIndex = 8.0;
&#9;&#9;&#9;&#9;}

&#9;local lCircle = NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;Circle&apos;;
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 64);
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -32, 0.5, -16);
&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;ZIndex = 8.0;
&#9;&#9;&#9;&#9;}

&#9;local count = 0
&#9;while Store.Loading do 
&#9;&#9;lCircle.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. loadingCircles[count%8 + 1]
&#9;&#9;count = count + 1
&#9;&#9;wait(0.1) 
&#9;end 

&#9;PageFrame.ZIndex = 1.0
&#9;FooterFrame.Visible = true 
&#9;lText.Visible = false 
&#9;lCircle.Visible = false 
end 

function Store:Initialize()&#9;
&#9;local isCategorized = true 
&#9;local count = 0
&#9;Gui = script.Parent 
&#9;MainFrame = Gui:WaitForChild(&apos;MainFrame&apos;)
&#9;StoreFrame = MainFrame:WaitForChild(&apos;StoreFrame&apos;)
&#9;CategoriesFrame = StoreFrame:WaitForChild(&apos;CategoriesFrame&apos;)
&#9;PlayerCurrencyFrame = StoreFrame:WaitForChild(&apos;PlayerCurrencyFrame&apos;)
&#9;FooterFrame = StoreFrame:WaitForChild(&apos;FooterFrame&apos;)

&#9;MainIcon = Gui:WaitForChild(&apos;Icon&apos;)

&#9;PageFrame = StoreFrame:WaitForChild(&apos;PageFrame&apos;)

&#9;AssetIds_StringValue = Gui:WaitForChild(&apos;AssetIds_CSV&apos;)
&#9;Categories_StringValue = Gui:WaitForChild(&apos;Categories_CSV&apos;)

&#9;for category in string.gmatch(Categories_StringValue.Value, &apos;[^,]+&apos;) do 
&#9;&#9;if category and category ~= &apos;&apos; and ItemType_WhiteList[category] then 
&#9;&#9;&#9;count = count + 1
&#9;&#9;&#9;isCategorized = true 
&#9;&#9;&#9;if count == 1 then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = category
&#9;&#9;&#9;end 
&#9;&#9;&#9;table.insert(Categories_List, category)
&#9;&#9;end 
&#9;end 

&#9;Spawn(function()
&#9;&#9;Store:ShowLoading() 
&#9;end)
&#9;
&#9;-- ########################################### -- 
&#9;-- Hack to remove the store from Phones 
&#9;-- Just makes the store hidden 
&#9;if not UserInputService.TouchEnabled or Gui.AbsoluteSize.Y &gt; 320 then 
&#9;&#9;MainIcon.Visible = true
&#9;end 
&#9;
&#9;Store:CreateFooter() 
&#9;Store:CreateCategories()
&#9;Store:CreateItemGrid(isCategorized)&#9;
&#9;Store:UpdateView(CurrentActiveCategory) &#9;
&#9;Store:CreateSearchbar()&#9;

&#9;Store.Loading = false 

&#9;MainIcon.MouseButton1Click:connect(function()
&#9;&#9;Store.MainFrame.Visible = not Store.MainFrame.Visible 
&#9;end)&#9;&#9;
end

Store:Initialize() 

</ProtectedString>
				</Properties>
			</Item>
			<Item class="ImageButton" referent="RBX329">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><url>http://www.roblox.com/asset/?id=109426216</url></Content>
					<bool name="Modal">false</bool>
					<string name="Name">Icon</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>77</XO>
						<YS>0</YS>
						<YO>-2</YO>
					</UDim2>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>80</XO>
						<YS>0</YS>
						<YO>36</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX330">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">10</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<float name="RolloffScale">1</float>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX331">
		<Properties>
			<string name="Name">CollectionService</string>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX332">
		<Properties>
			<string name="Name">PhysicsService</string>
		</Properties>
	</Item>
	<Item class="BadgeService" referent="RBX333">
		<Properties>
			<string name="Name">BadgeService</string>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX334">
		<Properties>
			<string name="Name">Geometry</string>
		</Properties>
	</Item>
	<Item class="RenderHooksService" referent="RBX335">
		<Properties>
			<string name="Name">RenderHooksService</string>
		</Properties>
	</Item>
	<Item class="SocialService" referent="RBX336">
		<Properties>
			<string name="Name">SocialService</string>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX337">
		<Properties>
			<string name="Name">GamePassService</string>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX338">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX339">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ScriptInformationProvider" referent="RBX340">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX341">
		<Properties>
			<string name="Name">CookiesService</string>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX342">
		<Properties>
			<string name="Name">Teleport Service</string>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX343">
		<Properties>
			<bool name="CharacterAutoLoads">false</bool>
			<string name="Name">Players</string>
		</Properties>
	</Item>
	<Item class="FWService" referent="RBX344">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="UserInputService" referent="RBX345">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX346">
		<Properties>
			<string name="Name">ContextActionService</string>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX347">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX348">
		<Properties>
			<string name="Name">Selection</string>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX349">
		<Properties>
			<Color3 name="Ambient">4286677377</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">4278190080</Color3>
			<Color3 name="ColorShift_Top">4278190080</Color3>
			<Color3 name="FogColor">4290822336</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<string name="Name">Lighting</string>
			<Color3 name="ShadowColor">4290032825</Color3>
			<string name="TimeOfDay">08:00:00</string>
		</Properties>
		<Item class="Model" referent="RBX350">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LoadingGui</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
		</Item>
		<Item class="Sky" referent="RBX351">
			<Properties>
				<bool name="CelestialBodiesShown">true</bool>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>http://www.roblox.com/asset?id=58372690</url></Content>
				<Content name="SkyboxDn"><url>http://www.roblox.com/asset?id=58372722</url></Content>
				<Content name="SkyboxFt"><url>http://www.roblox.com/asset?id=58372742</url></Content>
				<Content name="SkyboxLf"><url>http://www.roblox.com/asset?id=58372777</url></Content>
				<Content name="SkyboxRt"><url>http://www.roblox.com/asset?id=58372794</url></Content>
				<Content name="SkyboxUp"><url>http://www.roblox.com/asset?id=58372812</url></Content>
				<int name="StarCount">3000</int>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX352">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">SpawnPoints</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
		</Item>
		<Item class="SpawnLocation" referent="RBX353">
			<Properties>
				<bool name="AllowTeamChangeOnTouch">false</bool>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-4</X>
					<Y>47.7000008</Y>
					<Z>-8</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<int name="Duration">5</int>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">InitialSpawn</string>
				<bool name="Neutral">true</bool>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int name="TeamColor">194</int>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX354">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">WeaponData</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX355">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RocketLauncher</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX356">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Sword</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX357">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Superball</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX358">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Reflector</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX359">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Bomb</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX360">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Slingshot</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX361">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">PipeBomb</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX362">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0614605024</X>
							<Y>5.28547162e-009</Y>
							<Z>0.0209175348</Z>
							<R00>0.974370062</R00>
							<R01>-9.83292381e-009</R01>
							<R02>-0.224951088</R02>
							<R10>9.8329247e-009</R10>
							<R11>1</R11>
							<R12>-1.12031984e-009</R12>
							<R20>0.224951088</R20>
							<R21>-1.12032339e-009</R21>
							<R22>0.974370062</R22>
						</CoordinateFrame>
						<string name="Name">PipeBomb</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100206218</url></Content>
						<string name="ToolTip">Tubular Surprise</string>
					</Properties>
					<Item class="LocalScript" referent="RBX363">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX364">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ThrowBomb</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------
local GRAVITY = (-9.81 * 20)
local COOLDOWN = 5 -- Seconds until tool can be used again
local THROW_SPEED = 80
local MIN_THROW_DISTANCE = 5
--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait(1/30) end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local JointsService = Game.JointsService -- Sketttttch

local Tool = script.Parent
local ToolHandle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

--local ThrowAni = WaitForChild(Tool, &apos;ThrowAni&apos;)
--local ThrowAniTrack = nil

local MyModel = nil
local MyPlayer = nil

local BaseBomb = nil
local BombClone = nil
local BombCloneWeld = nil


local MrBombSounds = 
{
&#9;{SoundId=98299395,Length=.7}
}

-----------------
--| Functions |--
-----------------


function ComputeLaunchAngle(dx,dy,vel,grav)
&#9;-- arcane
&#9;-- http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
&#9;
&#9;local g = math.abs(grav)
&#9;local inRoot = (math.pow(vel,4)) - (g * ((g*dx*dx) + (2*dy*math.pow(vel,2))))
&#9;if inRoot &lt;= 0 then
&#9;&#9;return .25 * math.pi
&#9;end
&#9;local root = math.sqrt(inRoot)
&#9;local inATan1 = ((math.pow(vel,2)) + root) / (g*dx)

&#9;local inATan2 = ((math.pow(vel,2)) - root) / (g*dx)
&#9;local answer1 = math.atan(inATan1)
&#9;local answer2 = math.atan(inATan2)
&#9;return math.min(answer1,answer2)
end


local function MakeBaseBomb()
&#9;local bomb = ToolHandle:Clone()
&#9;bomb.Name = &quot;Bomb&quot;

&#9;-- Attach creator tags to the bomb early on
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, bomb)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId
&#9;-- Arm the bomb
&#9;WaitForChild(bomb, &apos;Explode&apos;).Disabled = false

&#9;return bomb
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseBomb = MakeBaseBomb()
&#9;BombClone = BaseBomb:Clone()
&#9;--ThrowAniTrack = MyModel:FindFirstChild(&apos;Humanoid&apos;):LoadAnimation(ThrowAni)
end

local function OnUnequipped()
&#9;ToolHandle.Transparency = 0
&#9;BombClone:Destroy()
&#9;if BombCloneWeld then
&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;BombCloneWeld = nil
&#9;end
end

local function ThrowPipeBomb(targetPos, projectile)

&#9;local delta = targetPos - projectile.CFrame.p
&#9;--if delta.magnitude&lt;MIN_THROW_DISTANCE then
&#9;--&#9;projectile.Velocity = delta.unit * THROW_SPEED
&#9;--&#9;return
&#9;--end
&#9;
&#9;local dy = delta.y
&#9;
&#9;local new_delta = Vector3.new(delta.x, 0, delta.z)
&#9;delta = new_delta

&#9;local dx = delta.magnitude
&#9;local unit_delta = delta.unit
&#9;
&#9;local theta = ComputeLaunchAngle( dx, dy, THROW_SPEED, GRAVITY)

&#9;local vy = math.sin(theta)
&#9;local xz = math.cos(theta)
&#9;local vx = unit_delta.x * xz
&#9;local vz = unit_delta.z * xz
&#9;projectile.Velocity = Vector3.new(vx,vy,vz) * THROW_SPEED

end
local InAttack =false
local function OnMouseDownChanged(down, targetOverride)
&#9;if down then -- Player just clicked
&#9;&#9;if Tool.Enabled and not InAttack and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 then
&#9;&#9;&#9;InAttack=true
&#9;&#9;&#9;wait(.1) --must do for click transmitter script :/
&#9;&#9;&#9;Tool.Enabled = false&#9;
&#9;&#9;&#9;BombCloneWeld = Instance.new(&apos;Weld&apos;, JointsService)
&#9;&#9;&#9;BombCloneWeld.Part0 = ToolHandle
&#9;&#9;&#9;BombCloneWeld.Part1 = BombClone
&#9;&#9;&#9;BombClone.CFrame=ToolHandle.CFrame
&#9;&#9;&#9;DebrisService:AddItem(BombClone, 30)
&#9;&#9;&#9;

&#9;&#9;&#9;if MyModel:FindFirstChild(&apos;Head&apos;) then
&#9;&#9;&#9;&#9;print(&apos;setting position&apos;)
&#9;&#9;&#9;&#9;WaitForChild(BombClone, &apos;ParentTorso&apos;).Value = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;BombClone.Parent = Workspace -- NOTE: This starts the already-armed explosion script
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;&#9;--ThrowAniTrack:Play()
&#9;&#9;&#9;wait(.3)
&#9;&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;&#9;BombCloneWeld = nil
&#9;&#9;&#9;local target = targetOverride or TargetPosition.Value
&#9;&#9;&#9;ThrowPipeBomb(target, BombClone)
&#9;&#9;&#9;BombClone.CanCollide = false --//NOTE: Temporary
&#9;
&#9;&#9;&#9;BombClone = BaseBomb:Clone()
&#9;&#9;&#9;wait(COOLDOWN)
&#9;&#9;&#9;-- Prepare the next bomb to be thrown
&#9;&#9;&#9;
&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;&#9;Tool.Enabled = true
&#9;&#9;&#9;InAttack=false
&#9;&#9;end
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true, targetPosition)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX365">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickTransmitter</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(script, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)
local ThrowAniTrack


local function OnMouseDown()
&#9;if Tool.Enabled then
&#9;&#9;ThrowAniTrack:Play(0,1,2)
&#9;end
end

local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled then
&#9;&#9;&#9;DoDrop.Value = false
&#9;&#9;&#9;MouseDownObject.Value = true

&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;wait(.1)
&#9;&#9;&#9;DoDrop.Value = false
&#9;&#9;&#9;MouseDownObject.Value = false 
&#9;&#9;end
&#9;end)
&#9;&#9;&#9;
end

local function OnUnequipped()
&#9;DoDrop.Value = true
&#9;MouseDownObject.Value = false
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end


Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="BoolValue" referent="RBX366">
							<Properties>
								<string name="Name">MouseDown</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX367">
							<Properties>
								<string name="Name">DoDrop</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX368">
							<Properties>
								<string name="Name">TargetPosition</string>
								<Vector3 name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX369">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100289053</url></Content>
							<string name="Name">ThrowAni</string>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX370">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.400000006</X>
								<Y>1.97000003</Y>
								<Z>0.439999998</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBX371">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Boom</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX372">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">fuseSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=100240645</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX373">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Explode</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 12
local BLAST_PRESSURE = 1000000



--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local RedTextureId = WaitForChild(script.Parent,&apos;RedTextureId&apos;)

local DebrisService = Game:GetService(&apos;Debris&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local PipeBomb = script.Parent

local BombMesh = WaitForChild(PipeBomb, &apos;Mesh&apos;)

local BoomSound = WaitForChild(PipeBomb, &apos;Boom&apos;)
local fuseSound = WaitForChild(PipeBomb, &apos;fuseSound&apos;)

local CreatorTag = WaitForChild(PipeBomb, &apos;creator&apos;)

local OriginalTextureId = BombMesh.TextureId

local Connection = nil

local ParentTorso = WaitForChild(PipeBomb, &apos;ParentTorso&apos;)
local XGraceDistance=2.5
local YGraceDistance=2.5


local MyWeld

-----------------
--| Functions |--
-----------------

local function TweenScale(element,starts,ends,length)
&#9;local startTime = time()
&#9;while time() - startTime &lt; length do
&#9;&#9;element.Scale = ((ends - starts) * ((time() - startTime)/length)) + starts
&#9;&#9;wait(.01)
&#9;end
&#9;element.Scale = ends
end

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- When a player is hit, if they are alive they will be tagged
local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnTouch(part)
&#9;local stuckCharacter = FindCharacterAncestor(part)
&#9;if stuckCharacter == CreatorTag.Value.Character 
&#9;&#9;or MyWeld ~= nil then
&#9;&#9;return
&#9;end
&#9;if stuckCharacter then
&#9;&#9;part= stuckCharacter:FindFirstChild(&apos;Torso&apos;)
&#9;end
&#9;local MyWeld = Instance.new(&quot;Weld&quot;)
&#9; MyWeld.Part0 = PipeBomb 
&#9; MyWeld.Part1 = part
&#9; MyWeld.C0 = CFrame.new()
&#9; MyWeld.C1 = part.CFrame:inverse() * PipeBomb.CFrame
&#9; MyWeld.Parent = PipeBomb
&#9; return weld
end

-- Needless to say, this should only be called once
local function Explode()
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.Position = PipeBomb.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace

&#9;BoomSound:Play()

&#9;-- NOTE:
&#9;-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

&#9;PipeBomb.Transparency = 1
&#9;PipeBomb.CanCollide = false
&#9;PipeBomb.Anchored = true
&#9;DebrisService:AddItem(PipeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------
PipeBomb.Touched:connect(OnTouch)

--Distance check to see if can collide should be true
Spawn(function()
&#9;while not PipeBomb.CanCollide and ParentTorso.Value do
&#9;&#9;local TorsoPosition = ParentTorso.Value.CFrame.p
&#9;&#9;local XZOffset = TorsoPosition-Vector3.new(PipeBomb.CFrame.p.x,TorsoPosition.y,PipeBomb.CFrame.p.z)
&#9;&#9;if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-PipeBomb.CFrame.p.y)&gt;YGraceDistance then
&#9;&#9;&#9;PipeBomb.CanCollide=true
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
end)


-- Flash red and beep increasingly fast for about 3 seconds
local startMeshScale =BombMesh.Scale
local largeMeshScale = startMeshScale*1.1
local tickTime = .5
local red = true
wait(0)
fuseSound:Play()
Delay(3.2,Explode)
while true do
&#9;--BombMesh.TextureId = red and RedTextureId.Value or OriginalTextureId
&#9;--[[if red then
&#9;&#9;Spawn(function()
&#9;&#9;&#9;TweenScale(BombMesh,startMeshScale,largeMeshScale,tickTime/2)
&#9;&#9;&#9;TweenScale(BombMesh,largeMeshScale,startMeshScale,tickTime/2)
&#9;&#9;&#9;--largeMeshScale= largeMeshScale*1.1
&#9;&#9;end)
&#9;else --]]
&#9;&#9;Spawn(function()
&#9;&#9;&#9;TweenScale(BombMesh,startMeshScale,largeMeshScale,tickTime/2)
&#9;&#9;&#9;TweenScale(BombMesh,largeMeshScale,startMeshScale,tickTime/2)
&#9;&#9;&#9;largeMeshScale= largeMeshScale*1.1
&#9;&#9;end)
&#9;--end
&#9;wait(tickTime)
&#9;red = not red
&#9;--tickTime = tickTime * 0.9
end


</ProtectedString>
							</Properties>
						</Item>
						<Item class="ObjectValue" referent="RBX374">
							<Properties>
								<string name="Name">ParentTorso</string>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
						<Item class="StringValue" referent="RBX375">
							<Properties>
								<string name="Name">RedTextureId</string>
								<string name="Value">http://www.roblox.com/asset/?id=94691735</string>
							</Properties>
						</Item>
						<Item class="SpecialMesh" referent="RBX376">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99862108</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99862640</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX377">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Pitchfork</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX378">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0614605024</X>
							<Y>1.80000019</Y>
							<Z>-0.079082571</Z>
							<R00>0.974370062</R00>
							<R01>2.94987714e-008</R01>
							<R02>0.224951088</R02>
							<R10>9.8329247e-009</R10>
							<R11>-1</R11>
							<R12>8.85430964e-008</R12>
							<R20>0.224951088</R20>
							<R21>-8.406181e-008</R21>
							<R22>-0.974370062</R22>
						</CoordinateFrame>
						<string name="Name">Pitchfork</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100253786</url></Content>
						<string name="ToolTip">Farmer&apos;s Revenge</string>
					</Properties>
					<Item class="Part" referent="RBX379">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>1.64999938</X>
								<Y>6.13000011</Y>
								<Z>1.76499975</Z>
								<R00>-0.707106709</R00>
								<R01>0.707106709</R01>
								<R02>6.67885161e-008</R02>
								<R10>-0.707106709</R10>
								<R11>-0.707106709</R11>
								<R12>-8.28150704e-008</R12>
								<R20>-1.13325012e-008</R20>
								<R21>-1.05785723e-007</R21>
								<R22>0.999999881</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.699999988</X>
								<Y>6.38000011</Y>
								<Z>0.370000005</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX380">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=100253437</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1.10000002</X>
									<Y>1.10000002</Y>
									<Z>1.10000002</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100253531</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX381">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">ChargeUp</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101090565</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX382">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SonicBoom</string>
								<float name="Pitch">0.800000012</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101084318</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX383">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX384">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickTransmitter</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)&#9;

local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)

local HoldAniTrack
local ThrowAniTrack
local ChargeAniTrack
local ChargeArmAniTrack

local ChargeUpSound = WaitForChild(WaitForChild(Tool,&apos;Handle&apos;),&apos;ChargeUp&apos;)
local SonicBoomSound = WaitForChild(WaitForChild(Tool,&apos;Handle&apos;),&apos;SonicBoom&apos;)


local ChargeAniBaseLength=4
local MaxChargeSpeed=15

local BaseFire = Instance.new(&apos;Fire&apos;)
BaseFire.Size = 4

local ChargingThrust = false

local function ChargeThrust()
&#9;ChargingThrust = true
&#9;local aniSpeed = 5
&#9;Spawn(function() while ChargingThrust and MouseDownObject.Value do wait(1/30) end SonicBoomSound:Play() end)
&#9;ChargeArmAniTrack:Play(0,1,.5)
&#9;while ChargingThrust and MouseDownObject.Value and aniSpeed&lt;MaxChargeSpeed do
&#9;&#9;ChargeAniTrack:Play(0,1,aniSpeed)
&#9;&#9;ChargeUpSound:Play()
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;if ChargingThrust then ChargeUpSound:Play() end
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;aniSpeed=aniSpeed*1.3
&#9;end
&#9;
&#9;local tfire1 = BaseFire:Clone()
&#9;local tfire2 = BaseFire:Clone()

&#9;if ChargingThrust and MouseDownObject.Value then 
&#9;&#9;tfire2.Parent = Tool.Parent:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;tfire1.Parent = Tool.Parent:FindFirstChild(&apos;Left Leg&apos;)
&#9;end

&#9;while ChargingThrust and MouseDownObject.Value do
&#9;&#9;ChargeAniTrack:Play(0,1,aniSpeed)
&#9;&#9;ChargeUpSound:Play()
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;if ChargingThrust then ChargeUpSound:Play() end
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;end
&#9;
&#9;game.Debris:AddItem(tfire1,1)
&#9;game.Debris:AddItem(tfire2,1)
end

local function OnMouseDown()
&#9;if Tool.Enabled then
&#9;&#9;HoldAniTrack:Play()
&#9;&#9;Spawn(ChargeThrust)
&#9;end
end

local function OnMouseUp()
&#9;if Tool.Enabled then
&#9;&#9;ChargingThrust = false
&#9;&#9;HoldAniTrack:Stop()
&#9;&#9;ChargeArmAniTrack:Stop()
&#9;&#9;ThrowAniTrack:Play()
&#9;end
end


local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent

&#9;HoldAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;HoldAni&apos;))
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;ChargeAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ChargeUpAni&apos;))
&#9;ChargeArmAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ChargeUpArm&apos;))
&#9;
&#9;

&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled and not MouseDownObject.Value then
&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;end
&#9;end)
&#9;mouse.Button1Up:connect(function()
&#9;&#9;if MouseDownObject.Value then
&#9;&#9;&#9;wait(0.01) --NOTE: Wait added to fix immediate down-up issue on iPad
&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;OnMouseUp()
&#9;&#9;end
&#9;end)
end

local function OnUnequipped()
&#9;MouseDownObject.Value = false
&#9;ChargingThrust = false
&#9;HoldAniTrack:Stop()
&#9;ChargeArmAniTrack:Stop()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="BoolValue" referent="RBX385">
							<Properties>
								<string name="Name">MouseDown</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX386">
							<Properties>
								<string name="Name">DoDrop</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX387">
							<Properties>
								<string name="Name">TargetPosition</string>
								<Vector3 name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX388">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100353779</url></Content>
							<string name="Name">HoldAni</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX389">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100356641</url></Content>
							<string name="Name">ThrowAni</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX390">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)

local RedTexture= WaitForChild(Handle,&apos;RedTextureId&apos;)

local MrBombModifierName = &apos;MrBomb&apos;

local IsGold=WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94691681&apos;
local MrBombTexture = &apos;http://www.roblox.com/asset/?id=98260356&apos;

local MrBombRedTexture = &apos;http://www.roblox.com/asset/?id=98261349&apos;
local NormalRedTexture = &apos;http://www.roblox.com/asset/?id=94691735&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94691640&apos;
local MrBombMesh = &apos;http://www.roblox.com/asset/?id=98260446&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94690231&apos;
local MrBombIcon = &apos;http://www.roblox.com/asset/?id=97923204&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=true
&#9;&#9;Mesh.TextureId=MrBombTexture
&#9;&#9;Mesh.MeshId=MrBombMesh
&#9;&#9;Tool.TextureId= MrBombIcon
&#9;&#9;RedTexture.Value=MrBombRedTexture
&#9;&#9;Tool.ToolTip= &apos;Professor Bomb&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;RedTexture.Value=NormalRedTexture
&#9;&#9;Tool.ToolTip= &apos;Bomb&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX391">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PitchScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BASE_COOLDOWN = 1 -- Seconds until tool can be used again
local THROW_FORCE = 75
local THROW_ANGLE =  1.30899694 --75 degrees...ish
local THRUST_SPEED = 100
local BASE_DAMAGE = 45
--------------------
--| WaitForChild |--
--------------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local Handle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

local MouseDownTime = 0
local MouseDownLength = 0

local MyModel = nil
local MyPlayer = nil

local ThrustVelocity= Instance.new(&apos;BodyVelocity&apos;)
ThrustVelocity.maxForce=Vector3.new(9999999,0,9999999)

local TouchEnabled = false

local ThrowVelocity= Instance.new(&apos;BodyVelocity&apos;)
ThrowVelocity.maxForce = Vector3.new(9999999,9999999,9999999)
ThrowVelocity.velocity = Vector3.new(0,THROW_FORCE,0)

local creatorTag = Instance.new(&apos;ObjectValue&apos;,Tool)
creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats

local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = Tool.TextureId

-----------------
--| Functions |--
-----------------

local function ThrowCharacter(hitCharacter)
&#9;print(&apos;throwing character&apos;)
&#9;local throwTorso = hitCharacter:FindFirstChild(&apos;Torso&apos;)
&#9;local myTorso = MyModel:FindFirstChild(&apos;Torso&apos;)

&#9;if not (throwTorso and myTorso) then return end

&#9;local dir = (throwTorso.CFrame.p - myTorso.CFrame.p)
&#9;dir = Vector3.new(dir.x,0,dir.z).unit
&#9;local holdMultiplier = math.min(2.5,math.max(MouseDownLength*.8,1))
&#9;ThrowVelocity.velocity = Vector3.new(math.cos(THROW_ANGLE)*THROW_FORCE*dir.x*holdMultiplier,math.sin(THROW_ANGLE)*THROW_FORCE*holdMultiplier,
&#9;&#9;math.cos(THROW_ANGLE)*THROW_FORCE*dir.z*holdMultiplier)
&#9;print(ThrowVelocity.velocity)
&#9;local hitHumanoid= hitCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;if hitHumanoid then
&#9;&#9;local throwFinished=false
&#9;&#9;ThrustVelocity.velocity=Vector3.new(0,0,0)
&#9;&#9;Spawn(function()
&#9;&#9;&#9;while not throwFinished do
&#9;&#9;&#9;&#9;hitHumanoid.PlatformStand =true
&#9;&#9;&#9;&#9;wait(1/30)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;ThrowVelocity.Parent=throwTorso

&#9;&#9;--Do damage
&#9;&#9;local hitBindable = hitHumanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;if hitBindable then
&#9;&#9;&#9;hitBindable:Invoke(BASE_DAMAGE*math.min(2,math.max(MouseDownLength*.8,1)), creatorTag)
&#9;&#9;else
&#9;&#9;&#9;local ntag = creatorTag:Clone()
&#9;&#9;&#9;ntag.Parent = hitHumanoid
&#9;&#9;&#9;game.Debris:AddItem(ntag,1)
&#9;&#9;&#9;hitHumanoid:TakeDamage(BASE_DAMAGE*math.min(2,math.max(MouseDownLength*.8,1)))
&#9;&#9;end

&#9;&#9;Delay(.1, function() ThrowVelocity.Parent=nil end)
&#9;&#9;Delay(.5,function()
&#9;&#9;&#9;throwFinished=true 
&#9;&#9;&#9;ThrustVelocity.Parent=nil 
&#9;&#9;&#9;wait(2/30)
&#9;&#9;&#9;hitHumanoid.PlatformStand = false 
&#9;&#9;end)
&#9;end
end

local function EndThrust()

end

local function OnTouch(part)
&#9;--print(&apos;got to touch&apos;)
&#9;if not TouchEnabled then return end
&#9;
&#9;local hitCharacter = FindCharacterAncestor(part)
&#9;if hitCharacter and hitCharacter ~= MyModel then
&#9;&#9;ThrowCharacter(hitCharacter)
&#9;&#9;EndThrust()
&#9;&#9;TouchEnabled = false
&#9;end
end

local function ThrustAttack(direction)
&#9;local torso=WaitForChild(MyModel,&apos;Torso&apos;)
&#9;local humanoid=MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if Tool.Parent == MyModel and humanoid and torso then
&#9;&#9;ThrustVelocity.velocity=Vector3.new(direction.x,0,direction.z).unit*THRUST_SPEED
&#9;&#9;ThrustVelocity.Parent=torso
&#9;&#9;Delay(.25*math.min(math.max(MouseDownLength,1),3),function() 
&#9;&#9;&#9;ThrustVelocity.Parent=nil 
&#9;&#9;&#9;TouchEnabled = false 
&#9;&#9;end)
&#9;end
end


local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;creatorTag.Value = MyPlayer
end

local function OnUnequipped()
&#9;MyModel.Humanoid.WalkSpeed = 16
&#9;ThrustVelocity.Parent=nil
end

local ThrustDirection
local cameraPos = WaitForChild(WaitForChild(script.Parent,&apos;CameraTransmitter&apos;),&apos;CameraCFrame&apos;)
local MouseDown =false
local function OnMouseDownChanged(down, targetOverride)
&#9;local myTorso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;local myHead = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;if not(Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and myTorso and myHead and MyModel.Humanoid.Health &gt; 0) then return end
&#9;if down then -- Player just clicked
&#9;&#9;MouseDownTime = tick()
&#9;&#9;MyModel.Humanoid.WalkSpeed = 0
&#9;&#9;wait(0)
&#9;&#9;MouseDown= true 
&#9;&#9;Spawn(function()
&#9;&#9;&#9;local bgyro = Instance.new(&apos;BodyGyro&apos;) 
&#9;&#9;&#9;bgyro.maxTorque= Vector3.new(9999999,9999999,9999999)
&#9;&#9;&#9;bgyro.Parent= myTorso
&#9;&#9;&#9;while MouseDown do
&#9;&#9;&#9;&#9;ThrustDirection =(myHead.CFrame.p-cameraPos.Value.p)
&#9;&#9;&#9;&#9;ThrustDirection = Vector3.new(ThrustDirection.X,0,ThrustDirection.Z).unit
&#9;&#9;&#9;&#9;--myTorso.CFrame = CFrame.new(myTorso.CFrame.p,myTorso.CFrame.p+ThrustDirection)
&#9;&#9;&#9;&#9;bgyro.cframe = CFrame.new(Vector3.new(0,0,0),ThrustDirection)
&#9;&#9;&#9;&#9;wait(1/30)
&#9;&#9;&#9;end
&#9;&#9;&#9;bgyro:Destroy()
&#9;&#9;end)
&#9;&#9;--ThrustDirection = ((targetOverride or TargetPosition.Value) - MyModel.Torso.CFrame.p).unit
&#9;else -- Player just released click
&#9;&#9;Tool.Enabled = false
&#9;&#9;MouseDownLength = tick() - MouseDownTime
&#9;&#9;MouseDown = false
&#9;&#9;TouchEnabled = true
&#9;&#9;ThrustAttack(ThrustDirection)
&#9;&#9;MyModel.Humanoid.WalkSpeed = 16
&#9;&#9;wait(BASE_COOLDOWN*math.min(math.max(MouseDownLength,1),3))

&#9;&#9;Tool.Enabled = true
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true)
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(false)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)
Handle.Touched:connect(OnTouch)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX392">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100348530</url></Content>
							<string name="Name">ChargeUpAni</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX393">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100356237</url></Content>
							<string name="Name">ChargeUpArm</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX394">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraTransmitter</string>
							<ProtectedString name="Source">local myCamera = game.Workspace.CurrentCamera

while not script:FindFirstChild(&apos;CameraCFrame&apos;) do wait() end

while true do
&#9;script.CameraCFrame.Value = myCamera.CoordinateFrame
&#9;wait()
end</ProtectedString>
						</Properties>
						<Item class="CFrameValue" referent="RBX395">
							<Properties>
								<string name="Name">CameraCFrame</string>
								<CoordinateFrame name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
							</Properties>
						</Item>
					</Item>
					<Item class="Camera" referent="RBX396">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>1.93089318</X>
								<Y>5.95214415</Y>
								<Z>-2.20321321</Z>
								<R00>-1</R00>
								<R01>-2.74756616e-007</R01>
								<R02>-6.55651183e-006</R02>
								<R10>-0</R10>
								<R11>0.999123156</R11>
								<R12>-0.0418691672</R12>
								<R20>6.56226575e-006</R20>
								<R21>-0.0418691672</R21>
								<R22>-0.999123156</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>1.9309063</X>
								<Y>6.03588247</Y>
								<Z>-0.204967141</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">Camera</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX397">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">BattleBottle</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX398">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.25</X>
							<Y>-0.300000012</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<string name="Name">BattleBottle</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856058</url></Content>
						<string name="ToolTip">Battle Bottle</string>
					</Properties>
					<Item class="Part" referent="RBX399">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>138.768265</X>
								<Y>4.49772549</Y>
								<Z>103.706985</Z>
								<R00>-0.747106791</R00>
								<R01>0.00059383281</R01>
								<R02>-0.664703667</R02>
								<R10>0.000781149545</R10>
								<R11>0.999999642</R11>
								<R12>1.53910478e-005</R12>
								<R20>0.664703488</R20>
								<R21>-0.000507734308</R21>
								<R22>-0.747106969</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.520000041</X>
								<Y>2.1299994</Y>
								<Z>0.590000629</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX400">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=100856357</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX401">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">equipSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064872</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX402">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">singleReload</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064901</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX403">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">explodeSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064920</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX404">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">launchSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064941</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Part" referent="RBX405">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>138.768784</X>
									<Y>5.36772537</Y>
									<Z>103.706543</Z>
									<R00>0.937424481</R00>
									<R01>-0.314661562</R01>
									<R02>-0.149074674</R02>
									<R10>-0.156833291</R10>
									<R11>0.000668821624</R11>
									<R12>-0.987624824</R12>
									<R20>0.310867161</R20>
									<R21>0.949203551</R21>
									<R22>-0.0487224311</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX406">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX407">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>-0.493844241</R00>
										<R01>0.866025329</R01>
										<R02>0.0782172456</R02>
										<R10>-0.156434432</R10>
										<R11>2.18556959e-008</R11>
										<R12>-0.987688363</R12>
										<R20>-0.855363131</R20>
										<R21>-0.50000006</R21>
										<R22>0.135476172</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX399</Ref>
									<Ref name="Part1">RBX405</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX408">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>138.768784</X>
									<Y>5.36772537</Y>
									<Z>103.706543</Z>
									<R00>-0.199701726</R00>
									<R01>0.97936523</R01>
									<R02>0.0310284384</R02>
									<R10>-0.156807065</R10>
									<R11>-0.000684169063</R11>
									<R12>-0.987628996</R12>
									<R20>-0.967228293</R20>
									<R21>-0.20209673</R21>
									<R22>0.153708011</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX409">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX410">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>-0.493844092</R00>
										<R01>-0.866025448</R01>
										<R02>0.0782172233</R02>
										<R10>-0.156434521</R10>
										<R11>2.18556906e-008</R11>
										<R12>-0.987688363</R12>
										<R20>0.85536325</R20>
										<R21>-0.499999911</R21>
										<R22>-0.135476276</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX399</Ref>
									<Ref name="Part1">RBX408</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX411">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>138.768784</X>
									<Y>5.36772537</Y>
									<Z>103.706543</Z>
									<R00>-0.738001466</R00>
									<R01>-0.664703786</R01>
									<R02>0.11628674</R02>
									<R10>-0.155662879</R10>
									<R11>1.53474739e-005</R11>
									<R12>-0.987810194</R12>
									<R20>0.656599462</R20>
									<R21>-0.74710685</R21>
									<R22>-0.103481047</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX412">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX413">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>0.987688363</R00>
										<R01>1.74845553e-007</R01>
										<R02>-0.156434476</R02>
										<R10>-0.156434476</R10>
										<R11>-4.37113883e-008</R11>
										<R12>-0.987688363</R12>
										<R20>-1.79530886e-007</R20>
										<R21>1</R21>
										<R22>-1.58213584e-008</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX399</Ref>
									<Ref name="Part1">RBX411</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX414">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BottleRocketScript</string>
							<ProtectedString name="Source">-- Made By SolarCrane


-- Not sure if we want to get content url from roblox function?
local ICON_URL = &apos;http://www.roblox.com/asset/?id=100856058&apos;
local BOTTLE_MESH_URL = &apos;http://www.roblox.com/asset/?id=100856357&apos;
--local ROCKET_MESH_URL = &apos;http://www.roblox.com/asset/?id=100856397&apos;
local ROCKET_MESH_URL = &apos;http://www.roblox.com/asset/?id=101005977&apos;
local TEXTURE_URL = &apos;http://www.roblox.com/asset/?id=100856280&apos;

local NUMBER_OF_ROCKETS = 3
local ROCKET_LAUNCH_SPEED = 53
local RELOAD_TIME_PER_ROCKET = 0.9
local ROCKET_DEBRIS_TIME = 4
local PROJECTILE_NAME = &apos;BR_Rocket&apos;


local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)



local BottleInstance
local Tool = script.Parent

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end


local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local Sounds = {equip = WaitForChild(Handle, &apos;equipSound&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;reload = WaitForChild(Handle, &apos;singleReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;explode = WaitForChild(Handle, &apos;explodeSound&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;launch = WaitForChild(Handle, &apos;launchSound&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;}


local Animations = {[&apos;EndReload&apos;] = WaitForChild(Tool, &apos;EndReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;FireAnim&apos;] = WaitForChild(Tool, &apos;FireAnim&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;ReloadLoop&apos;] = WaitForChild(Tool, &apos;ReloadLoop&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;StartReload&apos;] = WaitForChild(Tool, &apos;StartReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;StopFire&apos;] = WaitForChild(Tool, &apos;StopFire&apos;)
&#9;&#9; &#9;&#9;&#9;&#9;&#9;&#9;}

local AnimationTracks = {}

local RocketMineScript = WaitForChild(script, &apos;RocketMineScript&apos;)

-- TODO: keep a list of say object pointers of rockets fired in workspace


local DEBUG_PRINT = false
function dPrint(...)
&#9;if DEBUG_PRINT then
&#9;&#9;print(...)
&#9;end
end

Bottle = {}
Bottle_mt = { __index = Bottle}


function PointOnUnitCircle(angle)
&#9;return Vector3.new(math.cos(angle), 0, math.sin(angle))
end

function CanFire()
&#9;local character = Tool.Parent
&#9;if character then
&#9;&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;local rightArm = character:FindFirstChild(&apos;Right Arm&apos;)
&#9;&#9;if humanoid and rightArm then
&#9;&#9;&#9;local rightGrip = rightArm:FindFirstChild(&apos;RightGrip&apos;)
&#9;&#9;&#9;if humanoid.Health &gt; 0 and rightGrip then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function GetHumanoid()
&#9;local character = Tool.Parent
&#9;return character and character:FindFirstChild(&apos;Humanoid&apos;)
end

function GetTorso()
&#9;local character = Tool.Parent
&#9;if character then
&#9;&#9;return character:FindFirstChild(&apos;Torso&apos;)
&#9;end
end

function Bottle:Create()
&#9;return setmetatable({rockets = {}, lastRocketAddedTick = tick(), lastFiredTime = tick(), inReload = false}, Bottle_mt)
end

function Bottle:OnEquipped()
&#9;dPrint(self.rockets)
&#9;Handle.Transparency = 0.55
&#9;PlaySound(&apos;equip&apos;)
&#9;for _, child in pairs(self:GetPart():GetChildren()) do
&#9;&#9;if child.Name == PROJECTILE_NAME then
&#9;&#9;&#9;local nextIndex = self:FirstOpenRocketIndex()
&#9;&#9;&#9;if nextIndex then
&#9;&#9;&#9;&#9;self.rockets[nextIndex] = Rocket:Create(child)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;for i = 1, NUMBER_OF_ROCKETS do
&#9;&#9;if not self.rockets[i] then
&#9;&#9;&#9;local tempRocket = self:AddRocket(i)
&#9;&#9;&#9;self.rockets[i] = tempRocket
&#9;&#9;end
&#9;end
end

function Bottle:OnUnequipped()
&#9;local myTorso = GetTorso()
&#9;if myTorso then
&#9;&#9;if myTorso:FindFirstChild(&apos;spinVelocity&apos;) then
&#9;&#9;&#9;myTorso:FindFirstChild(&apos;spinVelocity&apos;).Parent = nil
&#9;&#9;end
&#9;end
end

function Bottle:FirstOpenRocketIndex()
&#9;local firstOpenIndex = nil
&#9;for i = 1, NUMBER_OF_ROCKETS do
&#9;&#9;if not self.rockets[i] then
&#9;&#9;&#9;firstOpenIndex = i
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
&#9;return firstOpenIndex
end

function Bottle:OnActivated(targetOverride)
&#9;if CanFire() then
&#9;&#9;print(&quot;Activated&quot;)
&#9;&#9;local numRocketsToFire = 0
&#9;&#9;for i, rocket in pairs(self.rockets) do
&#9;&#9;&#9;if rocket then
&#9;&#9;&#9;&#9;numRocketsToFire = 1 --numRocketsToFire + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if numRocketsToFire &gt; 0 then
&#9;&#9;&#9;print(&quot;Has rockets&quot;)
&#9;&#9;&#9;PlayAnimation(&apos;FireAnim&apos;)
&#9;&#9;&#9;local firedCount = 0
&#9;&#9;&#9;--[[
&#9;&#9;&#9;local spinVelocity = Instance.new(&apos;BodyAngularVelocity&apos;)
&#9;&#9;&#9;spinVelocity.angularvelocity = Vector3.new(0,11,0)
&#9;&#9;&#9;spinVelocity.maxTorque = Vector3.new(0, 400000000, 0)
&#9;&#9;&#9;spinVelocity.P = 9000
&#9;&#9;&#9;spinVelocity.Name = &apos;spinVelocity&apos;
&#9;&#9;&#9;local myTorso = GetTorso()
&#9;&#9;&#9;if myTorso then
&#9;&#9;&#9;&#9;--spinVelocity.Parent = myTorso
&#9;&#9;&#9;end
&#9;&#9;&#9;--]]
&#9;&#9;&#9;
&#9;&#9;&#9;--local waitTime = 1.3 --((math.pi*2) / spinVelocity.angularvelocity.Y) / numRocketsToFire
&#9;&#9;&#9;for i, rocket in pairs(self.rockets) do
&#9;&#9;&#9;&#9;if firedCount &gt;= numRocketsToFire then break end
&#9;&#9;&#9;&#9;--local angle = (2 * math.pi) * (firedCount / numRocketsToFire)
&#9;&#9;&#9;&#9;--dPrint(&quot;Angle:&quot; , angle)
&#9;&#9;&#9;&#9;--rocket:Launch(waitTime, PointOnUnitCircle(angle))
&#9;&#9;&#9;&#9;self.rockets[i] = nil
&#9;&#9;&#9;&#9;rocket:LaunchTargeted(targetOverride)
&#9;&#9;&#9;&#9;firedCount = firedCount + 1
&#9;&#9;&#9;&#9;self.lastFiredTime = tick()
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--spinVelocity.Parent = nil
&#9;&#9;&#9;StopAnimation(&apos;FireAnim&apos;)
&#9;&#9;end
&#9;&#9;Spawn(function() self:Reload() end)
&#9;end
end

function Bottle:GetPart()
&#9;return script.Parent:FindFirstChild(&apos;Handle&apos;)
end

function Bottle:WeldToBottle(otherRocket, firstOpenIndex)
&#9;local rocketPart = otherRocket:GetPart()
&#9;local bottlePart = self:GetPart()
&#9;if rocketPart and bottlePart then
&#9;&#9;if not firstOpenIndex then
&#9;&#9;&#9;firstOpenIndex = self:FirstOpenRocketIndex()
&#9;&#9;end
&#9;&#9;if not firstOpenIndex then
&#9;&#9;&#9;dPrint(&quot;Bottle:WeldToBottle: No More space for rockets.&quot;)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;local bottleWeld = Instance.new(&apos;ManualWeld&apos;)
&#9;&#9;bottleWeld.Part0 = bottlePart
&#9;&#9;bottleWeld.Part1 = rocketPart
&#9;&#9;--bottleWeld.C0 = CFrame.Angles(math.pi/2,0,0) * CFrame.Angles(0, 0, (2 * math.pi) * (firstOpenIndex / NUMBER_OF_ROCKETS)):inverse() * CFrame.Angles(0, math.pi / 18, 0) + Vector3.new(0,0.7,0)
bottleWeld.C0 = CFrame.Angles(math.pi/2, 0,0) * CFrame.Angles(0, math.pi / 20, (2 * math.pi) * (firstOpenIndex / NUMBER_OF_ROCKETS)):inverse() + Vector3.new(0,0.87,0)
&#9;&#9;bottleWeld.C1 = CFrame.new()
&#9;&#9;bottleWeld.Parent = rocketPart
&#9;&#9;otherRocket.weld = bottleWeld
&#9;else
&#9;&#9;dPrint(&quot;Bottle:WeldToBottle called but either the bottle or the rocket&apos;s parts have not been instantiated yet.&quot;)
&#9;end
end

function Bottle:Reload()
&#9;if self.inReload then return end
&#9;self.inReload = true
&#9;wait(3.2)
&#9;PlayAnimation(&apos;StartReload&apos;, 1)
&#9;PlayAnimation(&apos;ReloadLoop&apos;, 1/3)
&#9;while Tool and Tool:IsDescendantOf(Workspace) do
&#9;&#9;local firstOpenIndex = self:FirstOpenRocketIndex()
&#9;&#9;if not firstOpenIndex then break end
&#9;&#9;local now = tick()
&#9;&#9;local waitTime = math.max(0, math.max(2.3 - math.min(2.3, now - self.lastFiredTime),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  RELOAD_TIME_PER_ROCKET))  -- math.min(RELOAD_TIME_PER_ROCKET, now - self.lastRocketAddedTick)))
&#9;&#9;print(waitTime)
&#9;&#9;wait(waitTime)
&#9;&#9;PlaySound(&apos;reload&apos;)
&#9;&#9;local tempRocket = self:AddRocket(firstOpenIndex)
&#9;&#9;self.rockets[firstOpenIndex] = tempRocket
&#9;&#9;self.lastRocketAddedTick = now
&#9;&#9;StopAnimation(&apos;StartReload&apos;)
&#9;end
&#9;StopAnimation(&apos;StartReload&apos;)
&#9;StopAnimation(&apos;ReloadLoop&apos;)
&#9;PlayAnimation(&apos;EndReload&apos;)
&#9;self.inReload = false
end

function Bottle:AddRocket(index)
&#9;local newRocket = Rocket:Create()
&#9;newRocket:MakeRocket()
&#9;self:WeldToBottle(newRocket, index)
&#9;newRocket:GetPart().Parent = self:GetPart()
&#9;return newRocket
end

Rocket = {}
Rocket_mt = { __index = Rocket}

function Rocket:Create(rocketPart)
&#9;local newRocket = setmetatable({}, Rocket_mt)
&#9;if rocketPart then
&#9;&#9;newRocket.part = rocketPart
&#9;&#9;local weld = rocketPart:FindFirstChild(&apos;ManualWeld&apos;)
&#9;&#9;if weld then
&#9;&#9;&#9;newRocket.weld = weld
&#9;&#9;end
&#9;end
&#9;return newRocket
end

function Rocket:GetPart()
&#9;return self.part
end

function Rocket:MakeRocket()
&#9;local rocketPart = Instance.new(&apos;Part&apos;)
&#9;rocketPart.TopSurface = &apos;Smooth&apos;
&#9;rocketPart.BottomSurface = &apos;Smooth&apos;
&#9;rocketPart.FormFactor = &apos;Custom&apos;
&#9;rocketPart.Size = Vector3.new(0.2, 0.2, 3.4)
&#9;rocketPart.Locked = true
&#9;rocketPart.CanCollide = false
&#9;rocketPart.Name = PROJECTILE_NAME
&#9;local rocketMesh = Instance.new(&apos;SpecialMesh&apos;)
&#9;rocketMesh.MeshId = ROCKET_MESH_URL
&#9;rocketMesh.TextureId = TEXTURE_URL
&#9;rocketMesh.Parent = rocketPart
&#9;self.part = rocketPart
&#9;return rocketPart
end

function Rocket:CreateCreatorTag()
&#9;local myPlayer = PlayersService:GetPlayerFromCharacter(Tool.Parent)
&#9;if myPlayer then
&#9;&#9;-- Attach creator tags
&#9;&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, rocket)
&#9;&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;&#9;creatorTag.Value = myPlayer
&#9;&#9;local iconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;&#9;iconTag.Name = &apos;weaponIcon&apos;
&#9;&#9;iconTag.Value = Tool.TextureId
&#9;&#9;local nameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;&#9;nameTag.Name = &apos;weaponName&apos;
&#9;&#9;nameTag.Value = Tool.Name
&#9;&#9;return creatorTag
&#9;end
end

function Rocket:LaunchTargeted(targetPosition)
&#9;local rocketPart = self:GetPart()
&#9;local humanoid = GetHumanoid()
&#9;if rocketPart and humanoid then
&#9;&#9;PlaySound(&apos;launch&apos;)
&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Size = 3
&#9;&#9;fire.Heat = 5
&#9;&#9;fire.Name = &apos;RocketTrail&apos; 
&#9;&#9;fire.Parent = rocketPart

&#9;&#9;targetPosition = targetPosition or humanoid.TargetPoint
&#9;&#9;dPrint(&quot;TargetPos:&quot;, targetPosition)
&#9;&#9;--[[
&#9;&#9;local targetPart = Instance.new(&apos;Part&apos;)
&#9;&#9;targetPart.Transparency = 1
&#9;&#9;targetPart.CanCollide = false
&#9;&#9;targetPart.Anchored = true
&#9;&#9;targetPart.FormFactor = &apos;Custom&apos;
&#9;&#9;targetPart.Size = Vector3.new()
&#9;&#9;targetPart.CFrame = CFrame.new(targetPosition)
&#9;&#9;targetPart.Parent = Workspace
&#9;&#9;DebrisService:AddItem(targetPart, ROCKET_DEBRIS_TIME + 1)
&#9;&#9;--]]
&#9;&#9;rocketPart.Parent = Workspace
&#9;&#9;if self.weld then
&#9;&#9;&#9;self.weld:Destroy()
&#9;&#9;&#9;self.weld = nil
&#9;&#9;end

&#9;&#9;rocketPart.Velocity = Vector3.new(0,1,0) * ROCKET_LAUNCH_SPEED * 1.8

&#9;&#9;local rocketPropulsion = Instance.new(&apos;RocketPropulsion&apos;)
&#9;&#9;--rocketPropulsion.Target = targetPart
&#9;&#9;rocketPropulsion.TargetOffset = rocketPart.CFrame.p + (targetPosition - rocketPart.CFrame.p) -- .unit * 1000000000
&#9;&#9;rocketPropulsion.CartoonFactor = 0.1
&#9;&#9;rocketPropulsion.TurnP = 23000
&#9;&#9;rocketPropulsion.MaxTorque = Vector3.new(1000000000, 100000000, 100000000)
&#9;&#9;rocketPropulsion.MaxSpeed = ROCKET_LAUNCH_SPEED
&#9;&#9;rocketPropulsion.Parent = rocketPart

&#9;&#9;DebrisService:AddItem(rocketPart, ROCKET_DEBRIS_TIME)

&#9;&#9;local rocketScriptClone = RocketMineScript:Clone()
&#9;&#9;rocketScriptClone.Parent = rocketPart
&#9;&#9;rocketScriptClone.Disabled = false


&#9;&#9;local tag = self:CreateCreatorTag()
&#9;&#9;if tag then
&#9;&#9;&#9;tag.Parent = rocketPart
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Was unable to make creator tag in MakeRocket&quot;)
&#9;&#9;end
&#9;&#9;if Sounds[&apos;explode&apos;] then
&#9;&#9;&#9;Sounds[&apos;explode&apos;]:Clone().Parent = rocketPart
&#9;&#9;end

&#9;&#9;wait(0.3)
&#9;&#9;rocketPropulsion.TargetOffset = rocketPart.CFrame.p + (targetPosition - rocketPart.CFrame.p).unit * 1000000000
&#9;&#9;rocketPropulsion:Fire()
&#9;end
end

function Rocket:Launch(launchTime, direction)
&#9;local rocketPart = self:GetPart()
&#9;if rocketPart then
&#9;&#9;DebrisService:AddItem(rocketPart, ROCKET_DEBRIS_TIME)
&#9;&#9;rocketPart.Parent = Workspace
&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Size = 3
&#9;&#9;fire.Heat = 5
&#9;&#9;fire.Name = &apos;RocketTrail&apos; 
&#9;&#9;fire.Parent = rocketPart
&#9;&#9;--[[
&#9;&#9;local smoke = Instance.new(&apos;Smoke&apos;)
&#9;&#9;smoke.Size = 0.1
&#9;&#9;smoke.Opacity = 0.3
&#9;&#9;smoke.RiseVelocity = 0
&#9;&#9;smoke.Parent = rocketPart
&#9;&#9;local sparkles = Instance.new(&apos;Sparkles&apos;)
&#9;&#9;sparkles.SparkleColor = Color3.new(222,33,15)
&#9;&#9;]]
&#9;&#9;wait(launchTime)
&#9;&#9;if self.weld then
&#9;&#9;&#9;self.weld:Destroy()
&#9;&#9;&#9;self.weld = nil
&#9;&#9;end

&#9;&#9;--rocketPart.Velocity = rocketPart.CFrame:vectorToWorldSpace(Vector3.new(0, ROCKET_LAUNCH_SPEED, 0))
&#9;&#9;local originalCFrame = rocketPart.CFrame
&#9;&#9;rocketPart.Size = Vector3.new(5, rocketPart.Size.Y, rocketPart.Size.Z)
&#9;&#9;local floatForce = Instance.new(&apos;BodyForce&apos;)
&#9;&#9;floatForce.force = Vector3.new(0, rocketPart:GetMass() * 196.2 / 1.13, 0)
&#9;&#9;floatForce.Parent = rocketPart
&#9;&#9;rocketPart.Velocity = direction.unit * ROCKET_LAUNCH_SPEED
&#9;&#9;rocketPart.RotVelocity = Vector3.new()
&#9;&#9;rocketPart.CFrame = CFrame.new(originalCFrame.p, originalCFrame.p + direction.unit) * CFrame.Angles(-math.pi / 2 , 0, 0)
&#9;&#9;dPrint(&quot;Shooting at:&quot; , direction.unit)
&#9;&#9;--[[
&#9;&#9;local myTorso = GetTorso()
&#9;&#9;if myTorso then
&#9;&#9;&#9;rocketPart.Velocity = myTorso.CFrame.lookVector * ROCKET_LAUNCH_SPEED
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Rocket Launch, no torso found.&quot;)
&#9;&#9;&#9;rocketPart.Velocity = Vector3.new(0,0, ROCKET_LAUNCH_SPEED)
&#9;&#9;end
]]
&#9;&#9;
&#9;&#9;local tag = self:CreateCreatorTag()
&#9;&#9;if tag then
&#9;&#9;&#9;tag.Parent = rocketPart
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Was unable to make creator tag in MakeRocket&quot;)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local rocketScriptClone = RocketMineScript:Clone()
&#9;&#9;rocketScriptClone.Parent = rocketPart
&#9;&#9;rocketScriptClone.Disabled = false
&#9;end
end

function PlaySound(soundName, volume)
&#9;local sound = Sounds[soundName]
&#9;if sound then
&#9;&#9;if volume then
&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;end
&#9;&#9;sound:Play()
&#9;end
end


function PlayAnimation(animName, animSpeed)
&#9;local animTrack = AnimationTracks[animName]
&#9;if animTrack then
&#9;&#9;animTrack:Play()
&#9;end
&#9;if animSpeed then
&#9;&#9;animTrack:AdjustSpeed(animSpeed)
&#9;end
end

function StopAnimation(animName)
&#9;local animTrack = AnimationTracks[animName]
&#9;if animTrack then
&#9;&#9;animTrack:Stop()
&#9;end
end

function LoadAnimationTracks()
&#9;local myHumanoid = GetHumanoid()
&#9;if myHumanoid then
&#9;&#9;for animName, animObject in pairs(Animations) do
&#9;&#9;&#9;AnimationTracks[animName] = myHumanoid:LoadAnimation(animObject)
&#9;&#9;end
&#9;end
end

function StopAllAnimations()
&#9;for animName, animTrack in pairs(AnimationTracks) do
&#9;&#9;StopAnimation(animName)
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;BottleInstance:OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

BottleInstance = Bottle:Create()

dPrint(BottleInstance.rockets)

Tool.Equipped:connect(function() LoadAnimationTracks() BottleInstance:OnEquipped() end)
Tool.Unequipped:connect(function() BottleInstance:OnUnequipped() StopAllAnimations() end)
Tool.Activated:connect(
&#9;function()
&#9;&#9;wait() -- iPad derp, doesn&apos;t update targetpoint
&#9;&#9;BottleInstance:OnActivated()
&#9;end)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX415">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RocketMineScript</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 4.3
local BLAST_PRESSURE = 0
local MAX_DMG = 42

-- Rocket will fly through things named these
local ROCKET_IGNORE_LIST = {rocket = 1, handle = 1, effect = 1, water = 1} --NOTE: Keys must be lowercase, values must evaluate to true

ROCKET_IGNORE_LIST[string.lower(script.Parent.Name)] = 1


--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Rocket = script.Parent
local CreatorTag = WaitForChild(Rocket, &apos;creator&apos;)

local HitHumanoids = {}
local ExplosionOrigin
local Connection = nil


local CreatorPlayer = CreatorTag.Value
if CreatorPlayer.Character and CreatorPlayer.Character:FindFirstChild(&apos;Humanoid&apos;) then
&#9;HitHumanoids[CreatorPlayer.Character:FindFirstChild(&apos;Humanoid&apos;)] = true
end

-----------------
--| Functions |--
-----------------

--  Adjusted from overpressure formula
local function DamageFalloffEquation(distance, startDamage)
&#9;local distance = math.max(1, distance)
&#9;local explosionNetWeight = 1.1
&#9;local volumeOfHemisphere = math.max(1, math.log(distance))
&#9;return startDamage * (explosionNetWeight / volumeOfHemisphere)
end

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

function TagHumanoid(humanoid, creatorTag)
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end
&#9;creatorTag.Parent = humanoid 
end

local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;if not HitHumanoids[humanoid] and ExplosionOrigin then
&#9;&#9;&#9;&#9;local dmg = DamageFalloffEquation((hitPart.CFrame.p - ExplosionOrigin).magnitude , MAX_DMG)
&#9;&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;&#9;hitBindable:Invoke(dmg, CreatorTag)
&#9;&#9;&#9;&#9;else --Not in Roblox Battle
&#9;&#9;&#9;&#9;&#9;TagHumanoid(humanoid, CreatorTag:Clone())
&#9;&#9;&#9;&#9;&#9;humanoid:TakeDamage(dmg)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;HitHumanoids[humanoid] = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end


local Exploded = false

local function Explode()
&#9;if Exploded then return end
&#9;Exploded = true
&#9;-- Create the explosion
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.Position = Rocket.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace
&#9;ExplosionOrigin = Rocket.CFrame.p
&#9;-- Start playing the boom sound
&#9;local boomSound = Rocket:FindFirstChild(&apos;explodeSound&apos;)
&#9;if boomSound then
&#9;&#9;boomSound:Play()
&#9;end

&#9;-- NOTE:
&#9;-- If we just destroyed the rocket at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the rocket, keep it in the same spot, and schedule it for deletion

&#9;-- Stop playing the swoosh sound
&#9;local swooshSound = Rocket:FindFirstChild(&apos;Swoosh&apos;)
&#9;if swooshSound then
&#9;&#9;swooshSound:Stop()
&#9;end

&#9;-- Put out the fire
&#9;local fire = Rocket:FindFirstChild(&apos;RocketTrail&apos;)
&#9;if fire then
&#9;&#9;fire:Destroy()
&#9;end

&#9;local smoke = Rocket:FindFirstChild(&apos;Smoke&apos;)
&#9;if smoke then
&#9;&#9;smoke.Size = 5
&#9;&#9;smoke.RiseVelocity = 1.3
&#9;end


&#9;Rocket.Transparency = 1
&#9;Rocket.CanCollide = false
&#9;Rocket.Anchored = true
&#9;Rocket.CFrame = CFrame.new(Rocket.CFrame.p)
&#9;DebrisService:AddItem(Rocket, 3)

end

local function OnTouched(otherPart)
&#9;if Rocket and otherPart then
&#9;&#9;-- Fly through anything in the ignore list
&#9;&#9;if ROCKET_IGNORE_LIST[string.lower(otherPart.Name)] then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- Don&apos;t react to creator
&#9;&#9;local myPlayer = CreatorTag.Value
&#9;&#9;if myPlayer and myPlayer.Character and myPlayer.Character:IsAncestorOf(otherPart) then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local character = FindCharacterAncestor(otherPart)
&#9;&#9;Explode()
&#9;&#9;-- Destroy the connection so this method won&apos;t be called again
&#9;&#9;Connection:disconnect()
&#9;&#9;Rocket.Anchored = true
--[[
&#9;&#9;if character then
&#9;&#9;&#9;print(&quot;Triggering on &quot; , otherPart.Name)
&#9;&#9;&#9;Explode()
&#9;&#9;&#9;-- Destroy the connection so this method won&apos;t be called again
&#9;&#9;&#9;Connection:disconnect()
&#9;&#9;else
&#9;&#9;&#9;print(&quot;No Character, otherPart:&quot; , otherPart , &quot;character:&quot; , character)
&#9;&#9;&#9;Rocket.CFrame = CFrame.new(Rocket.CFrame.p)
&#9;&#9;&#9;Rocket.Anchored = true
&#9;&#9;end
&#9;&#9;]]
&#9;end
end

--------------------
--| Script Logic |--
--------------------

-- Arm the rocket and save the touch connection so we can disconnect it later
Connection = Rocket.Touched:connect(OnTouched)

wait(3)

Explode()

</ProtectedString>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX416">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX417">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100998342</url></Content>
							<string name="Name">FireAnim</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX418">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100998595</url></Content>
							<string name="Name">StopFire</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX419">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100999683</url></Content>
							<string name="Name">StartReload</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX420">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101004654</url></Content>
							<string name="Name">ReloadLoop</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX421">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101001475</url></Content>
							<string name="Name">EndReload</string>
						</Properties>
					</Item>
					<Item class="Camera" referent="RBX422">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>140.009918</X>
								<Y>5.44335079</Y>
								<Z>106.780846</Z>
								<R00>0.927172601</R00>
								<R01>-0.0274642911</R01>
								<R02>0.373626322</R02>
								<R10>1.86264515e-009</R10>
								<R11>0.997309208</R11>
								<R12>0.073309578</R12>
								<R20>-0.374634385</R20>
								<R21>-0.0679706335</R21>
								<R22>0.924677789</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>139.262665</X>
								<Y>5.29673147</Y>
								<Z>104.931488</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">ThumbnailCamera</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX423">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Taser</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX424">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0.400000006</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Taser</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99866630</url></Content>
						<string name="ToolTip">Shocker</string>
					</Properties>
					<Item class="Part" referent="RBX425">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-0.999999881</R02>
								<R10>-6.30617142e-005</R10>
								<R11>1.00000024</R11>
								<R12>0</R12>
								<R20>1.00000024</R20>
								<R21>6.30617142e-005</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.259999961</X>
								<Y>0.590000153</Y>
								<Z>1.40000045</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX426">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99866654</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99866675</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX427">
							<Properties>
								<bool name="Looped">true</bool>
								<string name="Name">StunGunLoop</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101178423</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX428">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Taser</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again

local WIRE_LENGTH = 30
local WIRE_SPEED = 20
local WIRE_THICKNESS = 0.1
local HIT_ZONE_HALF_SIZE = Vector3.new(0.5, 0.5, 0.5) / 2

local ONE_STEP = 1 / 30

local AIMING_CFRAME = CFrame.new(0.25, 0, 0.4, 0.8, 0, 0.6, 0, 1, 0, -0.6, 0, 0.8)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local StunScript = WaitForChild(script, &apos;Stun&apos;)
local ReadyAimAnimation = WaitForChild(script, &apos;ReadyAim2&apos;)

local StunGunLoopSound = WaitForChild(ToolHandle, &apos;StunGunLoop&apos;)

local OriginalToolGrip = Tool.Grip

local MyModel = nil
local MyHumanoid = nil
local CreatorTag = nil

local ReadyAimTrack = nil

local WireBases = {}

local Done = false

local BodyPosition = nil

-------------------------
--| Utility Functions |--
-------------------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function WeldInPlace(part0, part1, name, parent)
&#9;local weld = Instance.new(&apos;Weld&apos;)
&#9;weld.Part0 = part0
&#9;weld.Part1 = part1
&#9;weld.C0 = CFrame.new()
&#9;weld.C1 = part1.CFrame:inverse() * part0.CFrame
&#9;weld.Name = name or &apos;Weld&apos;
&#9;weld.Parent = parent or part0
&#9;return weld
end

------------------------
--| Helper Functions |--
------------------------

local function MakeWireBase(parentPart, weldOffset)
&#9;local wireBase = Instance.new(&apos;Part&apos;)
&#9;wireBase.Name = &quot;WireBase&quot;
&#9;wireBase.CanCollide = false
&#9;wireBase.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;wireBase.Size = Vector3.new(0.2, 0.2, 0.2) -- Intentional
&#9;wireBase.BottomSurface = Enum.SurfaceType.Smooth
&#9;wireBase.TopSurface = Enum.SurfaceType.Smooth

&#9;local weld = Instance.new(&apos;Weld&apos;, wireBase)
&#9;weld.Part0 = parentPart
&#9;weld.Part1 = wireBase
&#9;weld.C0 = CFrame.new(weldOffset)

&#9;local wire = Instance.new(&apos;BlockMesh&apos;, wireBase)
&#9;wire.Name = &apos;Wire&apos;
&#9;wire.Scale = Vector3.new(WIRE_THICKNESS, WIRE_THICKNESS, 0)

&#9;wireBase.Parent = parentPart
&#9;return wireBase
end

local function UnStick()
&#9;--print(&quot;UnStick&quot;)
&#9;if MyModel and MyHumanoid then
&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;if torso then
&#9;&#9;&#9;MyHumanoid.WalkSpeed = 16
&#9;&#9;&#9;if BodyPosition then
&#9;&#9;&#9;&#9;BodyPosition:Destroy()
&#9;&#9;&#9;&#9;BodyPosition = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function ShotComplete(playExtras)
&#9;--print(&quot;ShotComplete, playExtras:&quot;, playExtras)

&#9;if ReadyAimTrack then ReadyAimTrack:Stop() end
&#9;wait(0.1)
&#9;Tool.Grip = OriginalToolGrip
&#9;wait(0.1)
&#9;UnStick()

&#9;if playExtras then
&#9;&#9;--TODO: play reload animation
&#9;&#9;--TODO: play reload sound
&#9;end

&#9;wait(COOLDOWN)

&#9;Tool.Enabled = true
end

local function Stopped(hitPart)
&#9;--print(&quot;Stopped:&quot;, hitPart)
&#9;if Done then return end
&#9;Done = true

&#9;StunGunLoopSound:Stop()

&#9;if hitPart then
&#9;&#9;--TODO: play hit sound
&#9;&#9;--TODO: wires flash
&#9;&#9;local character, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if character ~= MyModel and humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local stunScriptClone = StunScript:Clone()
&#9;&#9;&#9;stunScriptClone.Parent = humanoid
&#9;&#9;&#9;stunScriptClone.Disabled = false
&#9;&#9;end
&#9;else
&#9;&#9;--TODO: play out of wire sound
&#9;&#9;--TODO: wires disappear
&#9;end

&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;local wire = wireBase:FindFirstChild(&apos;Wire&apos;)
&#9;&#9;if wire then
&#9;&#9;&#9;wire.Scale = Vector3.new(WIRE_THICKNESS, WIRE_THICKNESS, 0)
&#9;&#9;&#9;wire.Offset = Vector3.new()
&#9;&#9;end
&#9;end

&#9;ShotComplete(true)
end

local function FireWire(wireBase, targetPoint)
&#9;--print(&quot;FireWire:&quot;, wireBase, targetPoint)
&#9;if not wireBase or not targetPoint then return end
&#9;local weld = wireBase:FindFirstChild(&apos;Weld&apos;)
&#9;if weld then
&#9;&#9;--weld.C1 = CFrame.new(Vector3.new(), targetPoint - wireBase.Position)
&#9;&#9;wireBase.Anchored = true
&#9;&#9;weld:Destroy()
&#9;&#9;wireBase.CFrame = CFrame.new(wireBase.Position, targetPoint)

&#9;&#9;wait(0) -- Wtf
&#9;&#9;WeldInPlace(ToolHandle, wireBase, _, wireBase)
&#9;&#9;wireBase.Anchored = false
&#9;end
&#9;local wire = wireBase:FindFirstChild(&apos;Wire&apos;)
&#9;Done = false
&#9;Spawn(function()
&#9;&#9;while wireBase and wire and (wire.Scale.Z * wireBase.Size.Z) &lt; WIRE_LENGTH and not Done do
&#9;&#9;&#9;-- Check the end of the wire for a hit
&#9;&#9;&#9;local wireEndPoint = wireBase.CFrame * Vector3.new(0, 0, wire.Offset.Z * 2)
&#9;&#9;&#9;local ray = Ray.new(wireBase.Position, (wireEndPoint - wireBase.Position))
&#9;&#9;&#9;local part = Workspace:FindPartOnRay(ray, MyModel)
&#9;&#9;&#9;if part then
&#9;&#9;&#9;&#9;return Stopped(part)
&#9;&#9;&#9;else -- No hit, not out of wire, just keep going
&#9;&#9;&#9;&#9;local increment = Vector3.new(0, 0, WIRE_SPEED) -- How many 0.2 lengths each time
&#9;&#9;&#9;&#9;wire.Offset = wire.Offset - (increment * (wireBase.Size.Z / 2))
&#9;&#9;&#9;&#9;wire.Scale = wire.Scale + increment
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end
&#9;&#9;Stopped() -- Out of wire
&#9;end)
end

----------------------
--| Tool Functions |--
----------------------

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyModel)

&#9;-- Make top and bottom wire bases
&#9;local front = -ToolHandle.Size.Z / 2
&#9;table.insert(WireBases, MakeWireBase(ToolHandle, Vector3.new(0, -0.17, front)))
&#9;table.insert(WireBases, MakeWireBase(ToolHandle, Vector3.new(0, 0.17, front)))

&#9;if MyHumanoid then
&#9;&#9;-- Preload animations
&#9;&#9;ReadyAimTrack = MyHumanoid:LoadAnimation(ReadyAimAnimation)
&#9;end
end

local function OnActivated(targetOverride)
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Health &gt; 0 then
&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;if torso then
&#9;&#9;&#9;Tool.Enabled = false

&#9;&#9;&#9;-- Pick a target
&#9;&#9;&#9;local targetPosition = targetOverride or MyHumanoid.TargetPoint

&#9;&#9;&#9;-- Freeze our character
&#9;&#9;&#9;MyHumanoid.WalkSpeed = 0
&#9;&#9;&#9;BodyPosition = Instance.new(&apos;BodyPosition&apos;)
&#9;&#9;&#9;BodyPosition.maxForce = Vector3.new(1e6, 1e6, 1e6)
&#9;&#9;&#9;BodyPosition.position = torso.Position
&#9;&#9;&#9;DebrisService:AddItem(BodyPosition, 10)
&#9;&#9;&#9;BodyPosition.Parent = torso

&#9;&#9;&#9;-- Face the target horizontally
&#9;&#9;&#9;torso.CFrame = CFrame.new(torso.Position, Vector3.new(targetPosition.X, torso.Position.Y, targetPosition.Z))

&#9;&#9;&#9;-- Ready, aim...
&#9;&#9;&#9;if ReadyAimTrack then
&#9;&#9;&#9;&#9;ReadyAimTrack:Play()
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;Tool.Grip = AIMING_CFRAME
&#9;&#9;&#9;wait(0.1)

&#9;&#9;&#9;-- Fire!
&#9;&#9;&#9;StunGunLoopSound:Play()
&#9;&#9;&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;&#9;&#9;FireWire(wireBase, targetPosition)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;wireBase:Destroy()
&#9;end
&#9;WireBases = {}

&#9;-- Stop animations
&#9;if ReadyAimTrack then ReadyAimTrack:Stop() end

&#9;ShotComplete(false)
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
local nameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
nameTag.Name = &apos;weaponName&apos;
nameTag.Value = Tool.Name
local iconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
iconTag.Name = &apos;weaponIcon&apos;
iconTag.Value = Tool.TextureId
CreatorTag.Parent = StunScript

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX429">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Stun</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local STUN_TIME = 3 -- Seconds

local DAMAGE = 3
local DAMAGE_FREQUENCY = 0.4 -- Seconds

local ONE_STEP = 1 / 30

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Humanoid = script.Parent
local OriginalWalkSpeed = Humanoid.WalkSpeed
local HitBindable = Humanoid:FindFirstChild(&apos;Hit&apos;)

local ZapSound = WaitForChild(script, &apos;Zap&apos;)

local CreatorTag = WaitForChild(script, &apos;creator&apos;)

local StartTime = tick()
local LastDamageTime = StartTime

-----------------
--| Functions |--
-----------------

local function ApplyTag(target)
&#9;while target:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;target.creator:Destroy()
&#9;end

&#9;local creatorTagClone = CreatorTag:Clone()
&#9;DebrisService:AddItem(creatorTagClone, 4)
&#9;creatorTagClone.Parent = target
end

--------------------
--| Script Logic |--
--------------------

ZapSound.Parent = Humanoid.Torso

repeat
&#9;local now = tick()

&#9;Humanoid.WalkSpeed = 0

&#9;if now - LastDamageTime &gt; DAMAGE_FREQUENCY then
&#9;&#9;if ZapSound.Parent ~= script then
&#9;&#9;&#9;ZapSound:Play()
&#9;&#9;end
&#9;&#9;if HitBindable then -- (Battle-specific)
&#9;&#9;&#9;HitBindable:Invoke(DAMAGE, CreatorTag)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;ApplyTag(Humanoid)
&#9;&#9;&#9;Humanoid:TakeDamage(DAMAGE)
&#9;&#9;end
&#9;&#9;LastDamageTime = now
&#9;end

&#9;wait(ONE_STEP)
until now - StartTime &gt;= STUN_TIME

Humanoid.WalkSpeed = OriginalWalkSpeed

ZapSound:Destroy()
script:Destroy()
</ProtectedString>
							</Properties>
							<Item class="Sound" referent="RBX430">
								<Properties>
									<bool name="Looped">false</bool>
									<string name="Name">Zap</string>
									<float name="Pitch">1</float>
									<bool name="PlayOnRemove">false</bool>
									<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101180005</url></Content>
									<float name="Volume">0.5</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Animation" referent="RBX431">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101097290</url></Content>
								<string name="Name">ReadyAim2</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX432">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX433">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">GravityDisruptor</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX434">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.300000012</X>
							<Y>-0.200000003</Y>
							<Z>0.400000006</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">GravityDisruptor</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=101002061</url></Content>
						<string name="ToolTip">Gravity Disruptor</string>
					</Properties>
					<Item class="Part" referent="RBX435">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">1023</int>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX436">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101002082</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=101002108</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX437">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Charge</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101153932</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX438">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Burst</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101157919</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX439">
							<Properties>
								<bool name="Looped">true</bool>
								<string name="Name">Hum</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101158613</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX440">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 30

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent
local ToolHandle = Tool.Handle

local DisruptorScript = WaitForChild(script, &apos;DisruptorScript&apos;)

local ReleaseAnimation = WaitForChild(script, &apos;Release&apos;)

local ChargeSound = WaitForChild(ToolHandle, &apos;Charge&apos;)

local MyModel = nil
local MyHumanoid = nil

local BaseDevice = nil

local ReleaseTrack = nil

local OriginalWalkSpeed = 0

local StillEquipped = false

-----------------
--| Functions |--
-----------------

local function MakeBaseDevice()
&#9;local baseDevice = ToolHandle:Clone()
&#9;baseDevice.Name = &apos;Effect&apos;
&#9;baseDevice.FormFactor = Enum.FormFactor.Custom
&#9;baseDevice.Size = Vector3.new() -- As small as possible
&#9;baseDevice.Anchored = true

&#9;local childScriptClone = DisruptorScript:Clone()
&#9;childScriptClone.Parent = baseDevice
&#9;childScriptClone.Disabled = false

&#9;return baseDevice
end

local function Freeze()
&#9;if MyHumanoid and MyHumanoid.Torso then
&#9;&#9;MyHumanoid.WalkSpeed = 0
&#9;end
end

local function UnFreeze()
&#9;if MyHumanoid and MyHumanoid.Torso then
&#9;&#9;MyHumanoid.WalkSpeed = OriginalWalkSpeed
&#9;end
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)

&#9;OriginalWalkSpeed = MyHumanoid.WalkSpeed

&#9;-- Preload animation
&#9;ReleaseTrack = MyHumanoid:LoadAnimation(ReleaseAnimation)

&#9;StillEquipped = true
end

local function OnActivated()
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Torso and MyHumanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;if ReleaseTrack then
&#9;&#9;&#9;ReleaseTrack:Play()
&#9;&#9;end

&#9;&#9;Freeze()

&#9;&#9;ChargeSound:Play()

&#9;&#9;wait(1.4) -- Wait for animation to get to release part

&#9;&#9;if StillEquipped then
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;&#9;local cloneDevice = BaseDevice:Clone()
&#9;&#9;&#9;cloneDevice.CFrame = ToolHandle.CFrame
&#9;&#9;&#9;cloneDevice.Parent = Workspace

&#9;&#9;&#9;wait(1.6) -- Wait for animation to finish

&#9;&#9;&#9;UnFreeze()

&#9;&#9;&#9;wait(COOLDOWN)

&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;end

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;StillEquipped = false

&#9;UnFreeze()
&#9;ToolHandle.Transparency = 0

&#9;-- Stop all animations
&#9;if ReleaseTrack then ReleaseTrack:Stop() end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

BaseDevice = MakeBaseDevice()

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX441">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DisruptorScript</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TIME_TO_LIVE = 30

local ANTIGRAVITY_FACTOR = 1.1

local RADIUS = 15
local SPHERE_SCALE_TARGET_MAGNITUDE = Vector3.new(10, 10, 10).magnitude
local SPHERE_GROW_SPEED = 1

local SPHERE_MESH_ID = &apos;http://www.roblox.com/asset/?id=94736101&apos;
local SPHERE_TEXTURE_ID = &apos;http://www.roblox.com/asset/?id=101054992&apos;
local SPHERE_VERTEX_COLOR = Vector3.new(0.6, 0, 0.8)

local FIRE_COLOR = Color3.new(145/255, 46/255, 206/255)
local FIRE_COLOR_SECONDARY = Color3.new(23/255, 0/255, 198/255)

local RBX_GRAVITY = 196.2

local FORCE_NAME = &apos;Antigravity&apos;

local ONE_STEP = 1 / 30

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local Disruptor = script.Parent

local ForceRegistry = {}

-----------------
--| Functions |--
-----------------

-- Returns total mass of instance and all children
local function GetMassRecursive(instance)
&#9;local mass = 0
&#9;if instance:IsA(&apos;BasePart&apos;) then
&#9;&#9;mass = mass + instance:GetMass()
&#9;end
&#9;for _, child in pairs(instance:getChildren()) do
&#9;&#9;if child then
&#9;&#9;&#9;mass = mass + GetMassRecursive(child)
&#9;&#9;end
&#9;end
&#9;return mass
end

local function RegisterForce(part)
&#9;if not ForceRegistry[part] then
&#9;&#9;part.Velocity = part.Velocity * 0.9
&#9;&#9;local bodyForce = Instance.new(&apos;BodyForce&apos;)
&#9;&#9;bodyForce.Name = FORCE_NAME
&#9;&#9;bodyForce.force = Vector3.new(0, GetMassRecursive(part.Parent) * RBX_GRAVITY * ANTIGRAVITY_FACTOR, 0)
&#9;&#9;ForceRegistry[part] = bodyForce
&#9;&#9;bodyForce.Parent = part

&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Color = FIRE_COLOR
&#9;&#9;fire.SecondaryColor = FIRE_COLOR_SECONDARY
&#9;&#9;fire.Parent = part
&#9;end
end

local function DeRegisterForce(part)
&#9;local force = ForceRegistry[part]
&#9;if force then
&#9;&#9;force:Destroy()
&#9;&#9;ForceRegistry[part] = nil

&#9;&#9;local fire = part:FindFirstChild(&apos;Fire&apos;)
&#9;&#9;if fire then
&#9;&#9;&#9;fire:Destroy()
&#9;&#9;end
&#9;end
end

local function DeRegisterAllForces()
&#9;for part in pairs(ForceRegistry) do
&#9;&#9;DeRegisterForce(part)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

ContentProviderService:Preload(SPHERE_MESH_ID)
ContentProviderService:Preload(SPHERE_TEXTURE_ID)

Disruptor.CFrame = CFrame.new(Disruptor.Position)

-- Slowly rotate and rise into the air
local startTime = tick()
while tick() - startTime &lt; 3 do
&#9;Disruptor.CFrame = (Disruptor.CFrame * CFrame.Angles(0, 0.05, 0)) + Vector3.new(0, 0.1, 0)
&#9;wait(ONE_STEP)
end

local burstSound = Disruptor:FindFirstChild(&apos;Burst&apos;)
if burstSound then burstSound:Play() end

local humSound = Disruptor:FindFirstChild(&apos;Hum&apos;)
if humSound then humSound:Play() end

-- Turn into a sphere
Disruptor.Transparency = 0.5
local sphere = Disruptor:FindFirstChild(&apos;Mesh&apos;) or Instance.new(&apos;SpecialMesh&apos;)
--sphere.MeshType = Enum.MeshType.Sphere
sphere.MeshId = SPHERE_MESH_ID
sphere.TextureId = SPHERE_TEXTURE_ID
sphere.VertexColor = SPHERE_VERTEX_COLOR
sphere.Parent = Disruptor

Spawn(function()
&#9;-- Grow the sphere very quickly
&#9;--local scaleTarget = (1 / Disruptor.Size) * RADIUS * 2
&#9;--while sphere.Scale.magnitude &lt; scaleTarget.magnitude do
&#9;while sphere.Scale.magnitude &lt; SPHERE_SCALE_TARGET_MAGNITUDE do
&#9;&#9;sphere.Scale = sphere.Scale + Vector3.new(SPHERE_GROW_SPEED, SPHERE_GROW_SPEED, SPHERE_GROW_SPEED)
&#9;&#9;wait(ONE_STEP)
&#9;end
end)

-- Check for players entering and leaving
local startTime = tick()
while tick() - startTime &lt; TIME_TO_LIVE do
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local character = player.Character
&#9;&#9;if character then
&#9;&#9;&#9;local torso = character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;local distance = (torso.Position - Disruptor.Position).magnitude
&#9;&#9;&#9;&#9;if distance &lt;= RADIUS then -- Within range
&#9;&#9;&#9;&#9;&#9;RegisterForce(torso)
&#9;&#9;&#9;&#9;else -- Out of range
&#9;&#9;&#9;&#9;&#9;DeRegisterForce(torso)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;wait(ONE_STEP)
end

DeRegisterAllForces()
Disruptor:Destroy()
</ProtectedString>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX442">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101070520</url></Content>
								<string name="Name">Release</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX443">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Camera" referent="RBX444">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>-0.473832756</X>
								<Y>0.124247409</Y>
								<Z>-1.31150591</Z>
								<R00>-0.940500438</R00>
								<R01>0.0301559344</R01>
								<R02>-0.338451743</R02>
								<R10>-1.86264493e-009</R10>
								<R11>0.996054113</R11>
								<R12>0.08874809</R12>
								<R20>0.33979252</R20>
								<R21>0.0834676176</R21>
								<R22>-0.936789334</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">ThumbnailCamera</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX445">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Broom</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX446">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>-1</R22>
						</CoordinateFrame>
						<string name="Name">Broom</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99865835</url></Content>
						<string name="ToolTip">Clean Sweep</string>
					</Properties>
					<Item class="Part" referent="RBX447">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.600000024</X>
								<Y>6.00000095</Y>
								<Z>0.600000024</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX448">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99865889</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99865923</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX449">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Swing</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101164100</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX450">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Whack</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101166084</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="Script" referent="RBX451">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DAMAGE = 18

local COOLDOWN = 0.1

local WALKSPEED_BUFF = 8

local BLOWBACK_VELOCITY = 75

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local SwingSound = WaitForChild(ToolHandle, &apos;Swing&apos;)
local WhackSound = WaitForChild(ToolHandle, &apos;Whack&apos;)

local MyModel = nil
local MyHumanoid = nil

local HitPart = nil
local HitPartWeld = nil
local HitTable = {} -- List of victims damaged (per hit)

local CreatorTag = nil

-----------------
--| Functions |--
-----------------

-- Returns a character ancestor and its Humanoid, or nil
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function OnHit(otherPart)
&#9;if HitPart and otherPart then
&#9;&#9;local character, humanoid = FindCharacterAncestor(otherPart.Parent)
&#9;&#9;if character and character ~= MyModel and not HitTable[character] then
&#9;&#9;&#9;-- Tag and damage the victim
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(DAMAGE, CreatorTag)
&#9;&#9;&#9;&#9;HitTable[character] = 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;WhackSound:Play()

&#9;&#9;&#9;-- Whack em
&#9;&#9;&#9;local torso = humanoid.Torso
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;local bodyVelocity = Instance.new(&apos;BodyVelocity&apos;)
&#9;&#9;&#9;&#9;bodyVelocity.maxForce = Vector3.new(50000, 50000, 50000)
&#9;&#9;&#9;&#9;bodyVelocity.P = 25000
&#9;&#9;&#9;&#9;bodyVelocity.velocity = (MyHumanoid.Torso.CFrame.lookVector + Vector3.new(0, 0.5, 0)).unit * BLOWBACK_VELOCITY
&#9;&#9;&#9;&#9;DebrisService:AddItem(bodyVelocity, 0.2)
&#9;&#9;&#9;&#9;bodyVelocity.Parent = torso
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function MakeHitPart()
&#9;local hitPart = Instance.new(&apos;Part&apos;)
&#9;hitPart.Name = &apos;Effect&apos;
&#9;hitPart.CanCollide = false
&#9;hitPart.Transparency = 1
&#9;hitPart.FormFactor = Enum.FormFactor.Custom
&#9;hitPart.Size = Vector3.new(1, ToolHandle.Size.Y, 1)
&#9;hitPart.TopSurface = Enum.SurfaceType.Smooth
&#9;hitPart.BottomSurface = Enum.SurfaceType.Smooth
&#9;hitPart.Touched:connect(OnHit)

&#9;local hitPartWeld = Instance.new(&apos;Weld&apos;)
&#9;hitPartWeld.Part0 = ToolHandle
&#9;hitPartWeld.Part1 = hitPart
&#9;hitPartWeld.C1 = CFrame.new(Vector3.new(0, (ToolHandle.Size.Y / 2) - (hitPart.Size.Y / 2), 0))

&#9;return hitPart, hitPartWeld
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyModel)

&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed + WALKSPEED_BUFF
end

local function OnActivated()
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Torso and MyHumanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;SwingSound.Pitch = 1.2 + (math.random() * 0.2)
&#9;&#9;SwingSound:Play()

&#9;&#9;HitPartWeld.Parent = ToolHandle
&#9;&#9;HitPart.Parent = ToolHandle

&#9;&#9;wait(1.5 / 10) -- Wait for animation to finish

&#9;&#9;HitPart.Parent = nil
&#9;&#9;HitPartWeld.Parent = nil
&#9;&#9;HitTable = {}

&#9;&#9;wait(COOLDOWN)

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed - WALKSPEED_BUFF
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

HitPart, HitPartWeld = MakeHitPart()

CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos;
local weaponNameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = Tool.TextureId

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX452">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX453">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Animation</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local WHACK_SPEED = 10

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent

local BroomHoldIdleAnimation = WaitForChild(script, &apos;BroomHoldIdle&apos;)
local WhackAnimation = WaitForChild(script, &apos;WitchTemp&apos;)

local BroomHoldIdleTrack = nil
local WhackTrack = nil

-----------------
--| Functions |--
-----------------

local function OnEquipped()
&#9;local myModel = Tool.Parent
&#9;local humanoid = myModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then -- Preload animations
&#9;&#9;BroomHoldIdleTrack = humanoid:LoadAnimation(BroomHoldIdleAnimation)
&#9;&#9;WhackTrack = humanoid:LoadAnimation(WhackAnimation)
&#9;end
&#9;if BroomHoldIdleTrack then BroomHoldIdleTrack:Play() end
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;if WhackTrack then WhackTrack:Play(0, 1, WHACK_SPEED) end

&#9;&#9;-- End of Frame 0

&#9;&#9;Tool.Grip = Tool.Grip + Vector3.new(0, 1, 0) -- Stage 1

&#9;&#9;wait(0.5 / WHACK_SPEED) -- Wait until end of frame 1

&#9;&#9;Tool.Grip = Tool.Grip + Vector3.new(0, 1, 0) -- Stage 2

&#9;&#9;wait(1 / WHACK_SPEED) -- Wait for end of animation

&#9;&#9;wait(0.5 / WHACK_SPEED)

&#9;&#9;Tool.Grip = Tool.Grip - Vector3.new(0, 1, 0)

&#9;&#9;wait(0.5 / WHACK_SPEED)

&#9;&#9;Tool.Grip = Tool.Grip - Vector3.new(0, 1, 0)
&#9;end
end

local function OnUnequipped()
&#9;-- Stop animations
&#9;if BroomHoldIdleTrack then BroomHoldIdleTrack:Stop() end
&#9;if WhackTrack then WhackTrack:Stop() end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
						</Properties>
						<Item class="Animation" referent="RBX454">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101074752</url></Content>
								<string name="Name">BroomHoldIdle</string>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX455">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101078539</url></Content>
								<string name="Name">WitchTemp</string>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX456">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Maps</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX457">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">New Crossroads</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX458">
					<Properties>
						<string name="Name">SelectedImage</string>
						<int name="Value">105940341</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX459">
					<Properties>
						<string name="Name">UnselectedImage</string>
						<int name="Value">105975974</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX460">
					<Properties>
						<string name="Name">ModelID</string>
						<int name="Value">110083167</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX461">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Valley of Arches</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX462">
					<Properties>
						<string name="Name">SelectedImage</string>
						<int name="Value">106544537</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX463">
					<Properties>
						<string name="Name">UnselectedImage</string>
						<int name="Value">106544631</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX464">
					<Properties>
						<string name="Name">ModelID</string>
						<int name="Value">110083813</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX465">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Bloxburg</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX466">
					<Properties>
						<string name="Name">SelectedImage</string>
						<int name="Value">106543292</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX467">
					<Properties>
						<string name="Name">UnselectedImage</string>
						<int name="Value">106543359</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX468">
					<Properties>
						<string name="Name">ModelID</string>
						<int name="Value">110084199</int>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="Teams" referent="RBX469">
		<Properties>
			<string name="Name">Teams</string>
		</Properties>
	</Item>
	<Item class="ChangeHistoryService" referent="RBX470">
		<Properties>
			<string name="Name">ChangeHistoryService</string>
		</Properties>
	</Item>
</roblox>