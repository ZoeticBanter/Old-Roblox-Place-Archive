<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0">
		<Properties>
			<Ref name="CurrentCamera">RBX1</Ref>
			<double name="DistributedGameTime">0</double>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Camera" referent="RBX1">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-17.2677689</X>
					<Y>19.5944328</Y>
					<Z>-14.4570532</Z>
					<R00>-0.612718344</R00>
					<R01>0.426908791</R01>
					<R02>-0.665075302</R02>
					<R10>1.49011612e-008</R10>
					<R11>0.841546416</R11>
					<R12>0.540184796</R12>
					<R20>0.790301383</R20>
					<R21>0.330981135</R21>
					<R22>-0.51563096</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-15.9376202</X>
					<Y>18.5140648</Y>
					<Z>-13.4257927</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Camera</string>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX2">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2</X>
					<Y>126</Y>
					<Z>-2</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<string name="ClusterGridV2"></string>
				<float name="Elasticity">0.300000012</float>
				<float name="Friction">0.5</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Terrain</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DataPersistence</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
-- Constants
-----------------
--[[
&#9;Look up table of classNames coresponding to their correct persistent storeing function
--]]
local SAVE_FUNCTIONS = 
{
&#9;NumberValue = function(player, name, val) return player:SaveNumber(name, val.Value) end,
&#9;IntValue    = function(player, name, val) return player:SaveNumber(name, val.Value) end,
&#9;StringValue = function(player, name ,val) return player:SaveString(name, val.Value) end,
&#9;BoolValue   = function(player, name, val) return player:SaveBool(name, val.Value) end,
&#9;ObjectValue = function(player, name, val) return player:SaveInstance(name, val.Value) end,
}

--[[
&#9;Look up table of classNames coresponding to their correct persistent retreaving function
--]]
local FETCH_FUNCTIONS = 
{
&#9;NumberValue = function(player, name) return player:LoadNumber(name) end,
&#9;IntValue &#9;&#9;= function(player, name) return player:LoadNumber(name) end,
&#9;StringValue = function(player, name) return player:LoadString(name) end,
&#9;BoolValue   = function(player, name) return player:LoadBool(name) end,
&#9;ObjectValue = function(player, name) return player:LoadInstance(name) end,
}

----------------------
-- Workspace Variables
----------------------

local PlayersService = Game:GetService(&apos;Players&apos;)

--Wait for bindables
local RegisterNumber = WaitForChild(script, &apos;RegisterNumber&apos;)
local RegisterInt = WaitForChild(script, &apos;RegisterInt&apos;)
local RegisterString = WaitForChild(script, &apos;RegisterString&apos;)
local RegisterBool = WaitForChild(script, &apos;RegisterBool&apos;)
local RegisterInstance = WaitForChild(script, &apos;RegisterInstance&apos;)


----------------------
--Script Variables
----------------------
-- Locking table used to prevent race conditions, consists of keys of variables, and 
-- bool values for if the variable is locked
local LockTable = {}

-----------------------
--Global Functions
-----------------------

-- Variable lock system for preventing race conditions
local function Lock(var)
&#9;while LockTable[var] do
&#9;&#9;&#9;wait()
&#9;end
&#9;LockTable[var] = true
end

local function Unlock(var)
&#9;LockTable[var] = false
end


--[[
&#9;Fetches initial value for player&apos;s persistentKey, puts it in value
&#9;@Args
&#9;&#9;player &#9;&#9;player to fetch value from
&#9;&#9;value&#9;&#9;a ___value to store the fetched data in
&#9;&#9;persistentKey&#9;&#9;key to access stored persistent data
--]]
local function FetchValue(player, value, persistentKey)
&#9;player:WaitForDataReady()
&#9;Lock(value)
&#9;local success, _ = pcall(function() value.Value = FETCH_FUNCTIONS[value.ClassName](player, persistentKey) end)
&#9;Unlock(value)
end

--[[
&#9;Saves value.Value to player&apos;s persistentKey
&#9;@Args
&#9;&#9;player &#9;&#9;player to save value to
&#9;&#9;value&#9;&#9;a ___value to save to persistence
&#9;&#9;persistentKey&#9;&#9;key to overwrite in persistent data
--]]
local function SaveValue(player, value, persistentKey)
&#9;player:WaitForDataReady()
&#9;Lock(value) 
&#9;local success, _ = pcall(function() SAVE_FUNCTIONS[value.ClassName](player, persistentKey, value) end)
&#9;Unlock(value)
end

--[[
&#9;Shared initialization for setting up persistant values
&#9;@Args
&#9;&#9;player &#9;&#9;player to use
&#9;&#9;persistValue&#9;&#9;a ___value to use
&#9;&#9;persistentKey&#9;&#9;key to use for this value in persistent data
&#9;&#9;callback&#9;&#9;if exists, will be called when registering persistent data is complete
&#9;@Return&#9;&#9;new ____value that will auto save to persistence on changed
--]]
local function RegisterInit(player, persistValue, dataName, callback)
&#9;persistValue.Name = dataName
&#9;Spawn(function()
&#9;&#9;FetchValue(player, persistValue, dataName)
&#9;&#9;persistValue.Changed:connect(function() SaveValue(player, persistValue, dataName) end)
&#9;&#9;if callback then
&#9;&#9;&#9;callback()
&#9;&#9;end
&#9;end)
&#9;return persistValue 
end


---------------------------
-- Bindable Hookup
---------------------------

RegisterNumber.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;NumberValue&apos;)
&#9;return RegisterInit(player,persistValue,dataName,callback)
end

RegisterString.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;StringValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterInt.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;IntValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterBool.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;BoolValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback)
end

RegisterInstance.OnInvoke = function(player, dataName, callback)
&#9;local persistValue = Instance.new(&apos;ObjectValue&apos;)
&#9;return RegisterInit(player, persistValue, dataName, callback) 
end

</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX4">
				<Properties>
					<string name="Name">RegisterInstance</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX5">
				<Properties>
					<string name="Name">RegisterString</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX6">
				<Properties>
					<string name="Name">RegisterBool</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX7">
				<Properties>
					<string name="Name">RegisterNumber</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX8">
				<Properties>
					<string name="Name">RegisterInt</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX9">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DebugServerScript</string>
				<ProtectedString name="Source">local PlayersService = Game:GetService(&apos;Players&apos;)

local TouchDeviceCountObject = script:WaitForChild(&apos;TouchDeviceCount&apos;)

-- When a touch device is added, increment the count
TouchDeviceCountObject.ChildAdded:connect(function(child)
&#9;if child:IsA(&apos;ObjectValue&apos;) then
&#9;&#9;TouchDeviceCountObject.Value = TouchDeviceCountObject.Value + 1
&#9;end
end)

-- When a touch device disconnects, decrement the count and remove the associated object
PlayersService.ChildRemoved:connect(function(child)
&#9;if child:IsA(&apos;Player&apos;) then
&#9;&#9;for _, objectChild in pairs(TouchDeviceCountObject:GetChildren()) do
&#9;&#9;&#9;if objectChild:IsA(&apos;ObjectValue&apos;) and objectChild.Value == child then
&#9;&#9;&#9;&#9;TouchDeviceCountObject.Value = TouchDeviceCountObject.Value - 1
&#9;&#9;&#9;&#9;objectChild:Destroy()
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)
</ProtectedString>
			</Properties>
			<Item class="IntValue" referent="RBX10">
				<Properties>
					<string name="Name">TouchDeviceCount</string>
					<int name="Value">0</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX11">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ErrorCheckingScript</string>
				<ProtectedString name="Source">function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
end

local adminTable = {}

local messageTable = {}
local stackTable = {}
local scriptTable = {}

local playerList = {}

local respawningConnections = {}

waitForChild(script, &quot;AdminGui&quot;)
waitForChild(script, &quot;AdminList&quot;)

local adminGui = script.AdminGui
local adminList = script.AdminList.Value

-- global variables (old admin gui stored data)
&#9;-- UptimeFrame Children
&#9;local upTimeFormattedText = &quot;0 Days, 0 Hours, 0 Minutes, 0 Seconds&quot;
&#9;local upTimeSecondsText = &quot;0 Total Seconds&quot;

&#9;-- PlayerStatsFrame Children
&#9;local avgPlayTimeText = &quot;Avg. Play Time: 0&quot;
&#9;local joinText = &quot;# of Joins: 0&quot;
&#9;local leaveText = &quot;# of Leaves: 0&quot; 
&#9;local uniqueVisitorText = &quot;#of Unique Visits: 0&quot;

&#9;local uniqueUserIds = {}
&#9;local numUniqueUserIds = 0
&#9;local playTimes = {}

&#9;local avgPlayTime = 0
&#9;local placeVisits = 0
&#9;local placeLeaves = 0

function loadAdminTable()
&#9;for a in string.gmatch(adminList, &quot;[^,]+&quot;) do
&#9;&#9;adminTable[a:lower()] = true
&#9;end
end

loadAdminTable()

function isAdmin(playa)
&#9;if playa == nil or playa.Name == nil then return end
&#9;if (adminTable[playa.Name:lower()]) then return true end
&#9;return false
end

function makeNewErrorButton(playa, newButton, stackTraceText, badScript)
&#9;newButton.Parent = playa.PlayerGui.AdminGui.AdminStatsFrame.ErrorPanel.ScrollingArea.ScrollingFrame

&#9;local infoBox = playa.PlayerGui.AdminGui.AdminStatsFrame.InfoBox
&#9;local badScriptHook = playa.PlayerGui.AdminGui.ErrorScript
&#9;local toggleBox = playa.PlayerGui.AdminGui.AdminStatsFrame.ToggleBox

&#9;newButton.MouseButton1Click:connect(function() infoBox.Text = stackTraceText badScriptHook.Value = badScript toggleBox.TextColor3 = Color3.new(1, 1, 1) if badScript.Disabled then toggleBox.Text = &quot;Enable Script&quot; else toggleBox.Text = &quot;Disable Script&quot; end end)
end

function updateErrorText(playa)
&#9;playa.PlayerGui.AdminGui.AdminStatsFrame.ScriptStatsFrame.ScriptErrorsFrame.ScriptErrorsTextInfo.Text = &quot;# of Lua Errors: &quot; .. tostring(#messageTable)
end

function updateGuis(message, stackTrace, faultyScript)
&#9;local newError = nil
&#9;for i = 1, #playerList do
&#9;&#9;if playerList[i]:FindFirstChild(&quot;PlayerGui&quot;) and playerList[i].PlayerGui:FindFirstChild(&quot;AdminGui&quot;) then
&#9;&#9;&#9;if newError == nil then
&#9;&#9;&#9;&#9;newError = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;&#9;newError.Name = &quot;NewError&quot;
&#9;&#9;&#9;&#9;newError.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;newError.FontSize = Enum.FontSize.Size12
&#9;&#9;&#9;&#9;newError.Size = UDim2.new(1,0,0,12)
&#9;&#9;&#9;&#9;newError.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;newError.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;newError.Text = message
&#9;&#9;&#9;&#9;newError.TextWrap = true
&#9;&#9;&#9;&#9;newError.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;newError.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;newError.Visible = true
&#9;&#9;&#9;end
&#9;&#9;&#9;local newErrorClone = newError:Clone()
&#9;&#9;&#9;
&#9;&#9;&#9;local success = pcall(makeNewErrorButton, playerList[i], newErrorClone, stackTrace, faultyScript)
&#9;&#9;&#9;local success2 = pcall(updateErrorText, playerList[i])
&#9;&#9;&#9;if not success or not success2 then
&#9;&#9;&#9;&#9;-- do nothing for now...
&#9;&#9;&#9;&#9;-- remove offending player from list of admins
&#9;&#9;&#9;&#9;--table.remove(playerList, i)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function storeError(message, stack, otherScript)
&#9;-- only store the first 100 errors
&#9;if #messageTable &lt; 100 then  -- note: if THIS script errors out inside of updateGuis fcn, that could cause place to crash...  can check if otherScript ~= script here if we wish to avoid this
&#9;&#9;table.insert(messageTable, message)
&#9;&#9;table.insert(stackTable, stack)
&#9;&#9;table.insert(scriptTable, otherScript)

&#9;&#9;updateGuis(message, stack, otherScript)
&#9;end
end

game:GetService(&quot;ScriptContext&quot;).Error:connect(storeError)

function createGui(player)
&#9;-- horrible hack because player loading now mysteriously deletes any child added too early
&#9;wait(1)

&#9;local newAdminGui = adminGui:Clone()
&#9;waitForChild(player, &quot;PlayerGui&quot;)
&#9;newAdminGui.Parent = player.PlayerGui

&#9;local adminStatsFrame = Instance.new(&quot;Frame&quot;)
&#9;adminStatsFrame.Name = &quot;AdminStatsFrame&quot;
&#9;adminStatsFrame.Active = true
&#9;adminStatsFrame.Draggable = true
&#9;adminStatsFrame.Position = UDim2.new(0.2,20,0,0)
&#9;adminStatsFrame.Size = UDim2.new(0.6,-40,1,0)
&#9;adminStatsFrame.Style = Enum.FrameStyle.RobloxRound
&#9;adminStatsFrame.Parent = newAdminGui

&#9;&#9;-- AdminStatsFrame Children
&#9;&#9;local adminStatsTextLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;adminStatsTextLabel.Name = &quot;AdminStatsTextLabel&quot;
&#9;&#9;adminStatsTextLabel.BackgroundTransparency = 1
&#9;&#9;adminStatsTextLabel.Font = Enum.Font.ArialBold
&#9;&#9;adminStatsTextLabel.FontSize = Enum.FontSize.Size24
&#9;&#9;adminStatsTextLabel.Size = UDim2.new(1,0,0,24)
&#9;&#9;adminStatsTextLabel.Text = &quot;Place Console&quot;
&#9;&#9;adminStatsTextLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;adminStatsTextLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;adminStatsTextLabel.Parent = adminStatsFrame

&#9;&#9;local errorPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;errorPanel.Name = &quot;ErrorPanel&quot;
&#9;&#9;errorPanel.Position = UDim2.new(0,0,0.5,0)
&#9;&#9;errorPanel.Size = UDim2.new(1,0,0.5,0)
&#9;&#9;errorPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;errorPanel.Parent = adminStatsFrame

&#9;&#9;&#9;-- ErrorPanel Children
&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0,18)
&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,1,-18)
&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;textPanel.Parent = errorPanel

&#9;&#9;&#9;local errorPanelTextLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;errorPanelTextLabel.Name = &quot;ErrorPanelTextLabel&quot;
&#9;&#9;&#9;errorPanelTextLabel.Font = Enum.Font.ArialBold
&#9;&#9;&#9;errorPanelTextLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;errorPanelTextLabel.Size = UDim2.new(1,0,0,18)
&#9;&#9;&#9;errorPanelTextLabel.BackgroundTransparency = 1
&#9;&#9;&#9;errorPanelTextLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;errorPanelTextLabel.Text = &quot;Lua Errors&quot;
&#9;&#9;&#9;errorPanelTextLabel.Parent = errorPanel

&#9;&#9;local playerStatsFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;playerStatsFrame.Name = &quot;PlayerStatsFrame&quot;
&#9;&#9;playerStatsFrame.BackgroundTransparency = 1
&#9;&#9;playerStatsFrame.Position = UDim2.new(0,0,0,24)
&#9;&#9;playerStatsFrame.Size = UDim2.new(0,200,0,100)
&#9;&#9;playerStatsFrame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;playerStatsFrame.Parent = adminStatsFrame

&#9;&#9;local playerStatsTextInfo = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;playerStatsTextInfo.Name = &quot;PlayerStatsTextInfo&quot;
&#9;&#9;playerStatsTextInfo.BackgroundTransparency = 1
&#9;&#9;playerStatsTextInfo.Font = Enum.Font.ArialBold
&#9;&#9;playerStatsTextInfo.FontSize = Enum.FontSize.Size14
&#9;&#9;playerStatsTextInfo.Size = UDim2.new(1,0,1,0)
&#9;&#9;playerStatsTextInfo.Text = &quot;&quot;
&#9;&#9;playerStatsTextInfo.TextColor3 = Color3.new(1,1,1)
&#9;&#9;playerStatsTextInfo.TextYAlignment = Enum.TextYAlignment.Top

&#9;&#9;local smallFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;smallFrame.BackgroundTransparency = 1
&#9;&#9;smallFrame.Size = UDim2.new(1,0,0,14)

&#9;&#9;&#9;-- PlayerStatsFrame Children
&#9;&#9;&#9;local avgPlayerTimeFrame = smallFrame:clone()
&#9;&#9;&#9;avgPlayerTimeFrame.Name = &quot;AvgPlayerTimeFrame&quot;
&#9;&#9;&#9;avgPlayerTimeFrame.Position = UDim2.new(0,0,0,46)
&#9;&#9;&#9;local newTextInfo = playerStatsTextInfo:clone()
&#9;&#9;&#9;newTextInfo.Text = avgPlayTimeText
&#9;&#9;&#9;newTextInfo.Parent = avgPlayerTimeFrame
&#9;&#9;&#9;avgPlayerTimeFrame.Parent = playerStatsFrame

&#9;&#9;&#9;local joinFrame = smallFrame:clone()
&#9;&#9;&#9;joinFrame.Name = &quot;JoinFrame&quot;
&#9;&#9;&#9;joinFrame.Position = UDim2.new(0,0,0,18)
&#9;&#9;&#9;local newTextInfo = playerStatsTextInfo:clone()
&#9;&#9;&#9;newTextInfo.Text = joinText
&#9;&#9;&#9;newTextInfo.Parent = joinFrame
&#9;&#9;&#9;joinFrame.Parent = playerStatsFrame

&#9;&#9;&#9;local leaveFrame = smallFrame:clone()
&#9;&#9;&#9;leaveFrame.Name = &quot;LeaveFrame&quot;
&#9;&#9;&#9;leaveFrame.Position = UDim2.new(0,0,0,32)
&#9;&#9;&#9;local newTextInfo = playerStatsTextInfo:clone()
&#9;&#9;&#9;newTextInfo.Text = leaveText
&#9;&#9;&#9;newTextInfo.Parent = leaveFrame
&#9;&#9;&#9;leaveFrame.Parent = playerStatsFrame
&#9;&#9;&#9;
&#9;&#9;&#9;local uniqueVisitorsFrame = smallFrame:clone()
&#9;&#9;&#9;uniqueVisitorsFrame.Name = &quot;UniqueVisitorsFrame&quot;
&#9;&#9;&#9;uniqueVisitorsFrame.Position = UDim2.new(0,0,0,60)
&#9;&#9;&#9;local newTextInfo = playerStatsTextInfo:clone()
&#9;&#9;&#9;newTextInfo.Text = uniqueVisitorText
&#9;&#9;&#9;newTextInfo.Parent = uniqueVisitorsFrame
&#9;&#9;&#9;uniqueVisitorsFrame.Parent = playerStatsFrame
&#9;&#9;&#9;
&#9;&#9;&#9;local textHeader = playerStatsTextInfo:clone()
&#9;&#9;&#9;textHeader.Name = &quot;PlayerStatsTextLabel&quot;
&#9;&#9;&#9;textHeader.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;textHeader.Size = UDim2.new(1,0,0,18)
&#9;&#9;&#9;textHeader.Text = &quot;Player Stats&quot;
&#9;&#9;&#9;textHeader.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;&#9;textHeader.Parent = playerStatsFrame

&#9;&#9;-- Script Stats Frame
&#9;&#9;local scriptStatsFrame = playerStatsFrame:clone()
&#9;&#9;scriptStatsFrame.Name = &quot;ScriptStatsFrame&quot;
&#9;&#9;scriptStatsFrame.Position = UDim2.new(0,0,0,126)
&#9;&#9;scriptStatsFrame.PlayerStatsTextLabel.Name = &quot;ScriptStatsTextLabel&quot;
&#9;&#9;scriptStatsFrame.ScriptStatsTextLabel.Text = &quot;Lua Stats&quot;
&#9;&#9;scriptStatsFrame.JoinFrame.Name = &quot;ScriptErrorsFrame&quot;
&#9;&#9;scriptStatsFrame.ScriptErrorsFrame.PlayerStatsTextInfo.Name = &quot;ScriptErrorsTextInfo&quot;
&#9;&#9;scriptStatsFrame.ScriptErrorsFrame.ScriptErrorsTextInfo.Text = &quot;# of Lua Errors: &quot; .. tostring(#messageTable)
&#9;&#9;scriptStatsFrame.LeaveFrame.Name = &quot;ScriptWarningFrame&quot;
&#9;&#9;scriptStatsFrame.ScriptWarningFrame.PlayerStatsTextInfo.Name = &quot;ScriptWarningTextInfo&quot;
&#9;&#9;scriptStatsFrame.ScriptWarningFrame.ScriptWarningTextInfo.Text = &quot;# of Lua Warnings: 0&quot;
&#9;&#9;scriptStatsFrame.AvgPlayerTimeFrame.Name = &quot;ScriptsRunningFrame&quot;
&#9;&#9;scriptStatsFrame.ScriptsRunningFrame.PlayerStatsTextInfo.Name  = &quot;ScriptsRunningInfo&quot;
&#9;&#9;scriptStatsFrame.ScriptsRunningFrame.ScriptsRunningInfo.Text = &quot;# Scripts Running: 0&quot;
&#9;&#9;scriptStatsFrame.UniqueVisitorsFrame:remove()
&#9;&#9;scriptStatsFrame.Parent = adminStatsFrame

&#9;&#9;local headerFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;headerFrame.Name = &quot;Header&quot;
&#9;&#9;headerFrame.BackgroundTransparency = 1
&#9;&#9;headerFrame.Size = UDim2.new(1,-13,0,26)
&#9;&#9;headerFrame.Position = UDim2.new(0,0,0,0) --UDim2.new(0,-6,0,-6)
&#9;&#9;headerFrame.Parent = errorPanel
&#9;&#9;--headerFrame.Size = UDim2.new(1,-20,0,32)

&#9;&#9;local lowerPaneFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;lowerPaneFrame.Name = &quot;ScrollingArea&quot;
&#9;&#9;lowerPaneFrame.BackgroundTransparency = 1
&#9;&#9;lowerPaneFrame.Size = UDim2.new(1,-3,1,-26)
&#9;&#9;lowerPaneFrame.Position = UDim2.new(0,0,0,26)
&#9;&#9;lowerPaneFrame.Parent = errorPanel

&#9;&#9;newAdminGui.MakeScrollArea.Disabled = false
&#9;&#9;waitForChild(lowerPaneFrame, &quot;ScrollingFrame&quot;)
&#9;&#9;local scrollFrame = lowerPaneFrame.ScrollingFrame

&#9;&#9;local infoBox = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;infoBox.Name = &quot;InfoBox&quot;
&#9;&#9;infoBox.Font = Enum.Font.Arial
&#9;&#9;infoBox.FontSize = Enum.FontSize.Size12
&#9;&#9;infoBox.Size = UDim2.new(1,0,0,12)
&#9;&#9;infoBox.Position = UDim2.new(0, 0, 0.47, 0)
&#9;&#9;infoBox.BackgroundTransparency = 0.75
&#9;&#9;infoBox.TextColor3 = Color3.new(1,1,1)
&#9;&#9;infoBox.Text = &quot;Click on an error to see stack trace.&quot;
&#9;&#9;infoBox.TextWrap = false
&#9;&#9;infoBox.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;infoBox.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;infoBox.Visible = true
&#9;&#9;infoBox.Parent = adminStatsFrame

&#9;&#9;local errorScript = newAdminGui.ErrorScript
&#9;&#9;
&#9;&#9;local toggleBox = Instance.new(&quot;TextButton&quot;)
&#9;&#9;toggleBox.Name = &quot;ToggleBox&quot;
&#9;&#9;toggleBox.Font = Enum.Font.Arial
&#9;&#9;toggleBox.FontSize = Enum.FontSize.Size18
&#9;&#9;toggleBox.Size = UDim2.new(0, 200, 0, 50)
&#9;&#9;toggleBox.Position = UDim2.new(1, -200, 0, 126)
&#9;&#9;toggleBox.BackgroundTransparency = 1
&#9;&#9;toggleBox.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;toggleBox.Text = &quot;Not Active&quot;
&#9;&#9;toggleBox.TextColor3 = Color3.new(0.5, 0.5, 0.5)
&#9;&#9;toggleBox.MouseButton1Click:connect(function() if errorScript.Value then if errorScript.Value.Disabled then errorScript.Value.Disabled = false toggleBox.Text = &quot;Disable Script&quot; else errorScript.Value.Disabled = true toggleBox.Text = &quot;Enable Script&quot; end end end)
&#9;&#9;toggleBox.Parent = adminStatsFrame

&#9;&#9;local removeButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;removeButton.Name = &quot;RemoveButton&quot;
&#9;&#9;removeButton.Font = Enum.Font.Arial
&#9;&#9;removeButton.FontSize = Enum.FontSize.Size18
&#9;&#9;removeButton.Size = UDim2.new(0, 200, 0, 50)
&#9;&#9;removeButton.Position = UDim2.new(1, -200, 0, 176)
&#9;&#9;removeButton.BackgroundTransparency = 1
&#9;&#9;removeButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;removeButton.Text = &quot;Exit&quot;
&#9;&#9;removeButton.TextColor3 = Color3.new(1, 0.5, 0.5)
&#9;&#9;removeButton.MouseButton1Click:connect(function() removeConsole(player, newAdminGui) end)
&#9;&#9;removeButton.Parent = adminStatsFrame

&#9;&#9;for i = 1, #messageTable do
&#9;&#9;&#9;local sampleError = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;sampleError.Name = &quot;SampleError&quot;
&#9;&#9;&#9;sampleError.Font = Enum.Font.Arial
&#9;&#9;&#9;sampleError.FontSize = Enum.FontSize.Size12
&#9;&#9;&#9;sampleError.Size = UDim2.new(1,0,0,12)
&#9;&#9;&#9;sampleError.BackgroundTransparency = 0.5
&#9;&#9;&#9;sampleError.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;sampleError.Text = messageTable[i]
&#9;&#9;&#9;sampleError.TextWrap = true
&#9;&#9;&#9;sampleError.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;sampleError.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;sampleError.Visible = true
&#9;&#9;&#9;sampleError.Parent = scrollFrame

&#9;&#9;&#9;sampleError.MouseButton1Click:connect(function() infoBox.Text = stackTable[i] errorScript.Value = scriptTable[i] toggleBox.TextColor3 = Color3.new(1, 1, 1) if scriptTable[i] and scriptTable[i].Disabled then toggleBox.Text = &quot;Enable Script&quot; else toggleBox.Text = &quot;Disable Script&quot; end end)
&#9;&#9;end

&#9;&#9;-- UptimeFrame
&#9;&#9;local upTimeFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;upTimeFrame.Name = &quot;UptimeFrame&quot;
&#9;&#9;upTimeFrame.BackgroundTransparency = 1
&#9;&#9;upTimeFrame.Position = UDim2.new(1,-200,0,24)
&#9;&#9;upTimeFrame.Size = UDim2.new(0,200,0,100)&#9;
&#9;&#9;upTimeFrame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;upTimeFrame.Parent = adminStatsFrame

&#9;&#9;&#9;-- UptimeFrame Children
&#9;&#9;&#9;local secondsUpTimeTextInfo = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;secondsUpTimeTextInfo.Name = &quot;SecondsUptimeTextInfo&quot;
&#9;&#9;&#9;secondsUpTimeTextInfo.Font = Enum.Font.ArialBold
&#9;&#9;&#9;secondsUpTimeTextInfo.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;secondsUpTimeTextInfo.Position = UDim2.new(0,0,0.5,18)
&#9;&#9;&#9;secondsUpTimeTextInfo.Size = UDim2.new(1,0,0.5,-18)
&#9;&#9;&#9;secondsUpTimeTextInfo.Text = upTimeSecondsText
&#9;&#9;&#9;secondsUpTimeTextInfo.BackgroundTransparency = 1
&#9;&#9;&#9;secondsUpTimeTextInfo.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;secondsUpTimeTextInfo.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;secondsUpTimeTextInfo.Parent = upTimeFrame

&#9;&#9;&#9;local uptimeTextInfo = secondsUpTimeTextInfo:clone()
&#9;&#9;&#9;uptimeTextInfo.Name = &quot;UptimeTextInfo&quot;
&#9;&#9;&#9;uptimeTextInfo.Position = UDim2.new(0,0,0,18)
&#9;&#9;&#9;uptimeTextInfo.Size = UDim2.new(1,0,0.5,0)
&#9;&#9;&#9;uptimeTextInfo.TextWrap = true
&#9;&#9;&#9;uptimeTextInfo.Text = upTimeFormattedText
&#9;&#9;&#9;uptimeTextInfo.Parent = upTimeFrame

&#9;&#9;&#9;local upTimeTextLabel = uptimeTextInfo:clone()
&#9;&#9;&#9;upTimeTextLabel.Name = &quot;UptimeTextLabel&quot;
&#9;&#9;&#9;upTimeTextLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;upTimeTextLabel.Size = UDim2.new(1,0,0,18)
&#9;&#9;&#9;upTimeTextLabel.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;upTimeTextLabel.Text = &quot;Instance Uptime&quot;
&#9;&#9;&#9;upTimeTextLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;&#9;upTimeTextLabel.Parent = upTimeFrame
end

--function addAdmin(obj)
--&#9;if not obj or obj.className ~= &quot;ObjectValue&quot; then return end
--&#9;if obj.Value and game.Players:FindFirstChild(obj.Value.Name) then
&#9;&#9;--table.insert(playerList, obj.Value)
&#9;&#9;--createGui(obj.Value)
&#9;--end
--end

--function removeAdmin(obj)
--&#9;if not obj or obj.className ~= &quot;ObjectValue&quot; then return end
--&#9;if obj.Value and game.Players:FindFirstChild(obj.Value.Name) then
&#9;&#9;-- TODO: remove admin from player in a way that won&apos;t break the list...
&#9;&#9;--for p = 1, #playerList do
--&#9;&#9;&#9;if playerList[p] == obj.Value then table.remove(playerList, p) break end
&#9;&#9;--end
--&#9;end
--end

function removeConsole(player, console)
&#9;-- no more updates for player
&#9;for p = 1, #playerList do
&#9;&#9;if playerList[p] == player then table.remove(playerList, p) break end
&#9;end

&#9;if respawningConnections[player] then respawningConnections[player]:disconnect() respawningConnections[player] = nil end

&#9;-- and remove the console itself
&#9;console:Remove()
end

function textUpdate(playa, path, value)
&#9;local ptr = playa.PlayerGui.AdminGui.AdminStatsFrame
&#9;for pathIndex = 1, #path do
&#9;&#9;ptr = ptr:FindFirstChild(path[pathIndex])
&#9;end 
&#9;ptr.Text = value
end

function globalTextUpdate(path, value)
&#9;for p = 1, #playerList do
&#9;&#9;pcall(textUpdate, playerList[p], path, value)
&#9;end
end

function updateUptimeText()
&#9;globalTextUpdate({&quot;UptimeFrame&quot;, &quot;SecondsUptimeTextInfo&quot;}, upTimeSecondsText)
&#9;globalTextUpdate({&quot;UptimeFrame&quot;, &quot;UptimeTextInfo&quot;}, upTimeFormattedText)
end

function updatePlaceVisitsText()
&#9;globalTextUpdate({&quot;PlayerStatsFrame&quot;, &quot;JoinFrame&quot;, &quot;PlayerStatsTextInfo&quot;}, joinText)
end

function updateUniqueVisitorText()
&#9;globalTextUpdate({&quot;PlayerStatsFrame&quot;, &quot;UniqueVisitorsFrame&quot;, &quot;PlayerStatsTextInfo&quot;}, uniqueVisitorText)
end

function updatePlayerLeftAndAvgPlayTimeTexts()
&#9;globalTextUpdate({&quot;PlayerStatsFrame&quot;, &quot;LeaveFrame&quot;, &quot;PlayerStatsTextInfo&quot;}, avgPlayTimeText)
&#9;globalTextUpdate({&quot;PlayerStatsFrame&quot;, &quot;AvgPlayerTimeFrame&quot;, &quot;PlayerStatsTextInfo&quot;}, leaveText)
end

function updateUptime()
&#9;local currentTime = game.Workspace.DistributedGameTime
&#9;
&#9;upTimeSecondsText = tostring(math.floor(currentTime)) .. &quot; Total Seconds&quot;
&#9;
&#9;local days = math.floor(currentTime/86400)
&#9;currentTime = currentTime - (days * 86400)

&#9;local hours = math.floor(currentTime/3600)
&#9;currentTime = currentTime - (hours * 3600)
&#9;
&#9;local minutes = math.floor(currentTime/60)
&#9;currentTime = currentTime - (minutes * 60)
&#9;
&#9;currentTime = math.floor(currentTime)

&#9;upTimeFormattedText = tostring(days) .. &quot; Days, &quot; .. tostring(hours) .. &quot; Hours, &quot; .. tostring(minutes) .. &quot; Minutes, &quot; .. tostring(currentTime) .. (&quot; Seconds&quot;) 
end

function playerJoined(addedPlayer)
&#9;placeVisits = placeVisits + 1
&#9;joinText = &quot;# of Joins: &quot; .. tostring(placeVisits)
&#9;updatePlaceVisitsText()
&#9;if uniqueUserIds[addedPlayer.userId] == nil then
&#9;&#9;uniqueUserIds[addedPlayer.userId] = true
&#9;&#9;numUniqueUserIds = numUniqueUserIds + 1
&#9;&#9;uniqueVisitorText = &quot;#of Unique Visits: &quot; .. tostring(numUniqueUserIds)
&#9;&#9;updateUniqueVisitorText()
&#9;end

&#9;playTimes[addedPlayer] = game.Workspace.DistributedGameTime

&#9;if isAdmin(addedPlayer) then
&#9;&#9;table.insert(playerList, addedPlayer)
&#9;&#9;createGui(addedPlayer)
&#9;&#9;respawningConnections[addedPlayer] = addedPlayer.CharacterAdded:connect(function() createGui(addedPlayer) end)  -- to respawn gui until they click the &quot;x&quot;
&#9;end
end

function recalculateAvgPlayTime(removedPlayer)
&#9;if playTimes[removedPlayer] then
&#9;&#9;local playerPlayTime = game.Workspace.DistributedGameTime - playTimes[removedPlayer]
&#9;&#9;avgPlayTime = ( ((placeLeaves - 1)/placeLeaves) * avgPlayTime ) + ( (1/placeLeaves) * playerPlayTime )
&#9;&#9;avgPlayTimeText = &quot;Avg. Play Time: &quot; .. tostring(math.floor(avgPlayTime))
&#9;end
end

function playerLeft(removedPlayer)
&#9;placeLeaves = placeLeaves + 1
&#9;leaveText = &quot;# of Leaves: &quot; .. tostring(placeLeaves)

&#9;recalculateAvgPlayTime(removedPlayer)

&#9;updatePlayerLeftAndAvgPlayTimeTexts()
end


function uptimeLoop()
&#9;while true do
&#9;&#9;updateUptime()
&#9;&#9;updateUptimeText()
&#9;&#9;wait(1)
&#9;end
end


--script.ChildAdded:connect(addAdmin)
--script.ChildRemoved:connect(removeAdmin)

-- also add in any players currently here
local currentPlayers = game.Players:GetPlayers()
for i = 1, #currentPlayers do
&#9;playerJoined(currentPlayers[i])
end

game.Players.PlayerAdded:connect(playerJoined)
game.Players.PlayerRemoving:connect(playerLeft)

uptimeLoop()
</ProtectedString>
			</Properties>
			<Item class="ScreenGui" referent="RBX12">
				<Properties>
					<string name="Name">AdminGui</string>
				</Properties>
				<Item class="ObjectValue" referent="RBX13">
					<Properties>
						<string name="Name">ErrorScript</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX14">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MakeScrollArea</string>
						<ProtectedString name="Source">function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
end

local RbxGui
RbxGui, msg = LoadLibrary(&quot;RbxGui&quot;)

waitForChild(script.Parent, &quot;AdminStatsFrame&quot;)
waitForChild(script.Parent.AdminStatsFrame, &quot;ErrorPanel&quot;)
waitForChild(script.Parent.AdminStatsFrame.ErrorPanel, &quot;ScrollingArea&quot;)

local lowerPaneFrame = script.Parent.AdminStatsFrame.ErrorPanel.ScrollingArea

local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame()

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -61)
scrollBar.Parent = lowerPaneFrame

scrollFrame.Parent = lowerPaneFrame
scrollUp.Parent = lowerPaneFrame
scrollDown.Parent = lowerPaneFrame

scrollFrame.Position = UDim2.new(0,0,0,0) --UDim2.new(0,-7,0,0)
scrollUp.Position = UDim2.new(1,-41,0,5) --UDim2.new(1,-19,0,0)
scrollDown.Position = UDim2.new(1,-41,1,-35) -- UDim2.new(1,-19,1,-15)
scrollBar.Position = UDim2.new(1, -41, 0, 24) -- UDim2.new(1, -19, 0, 19)
scrollFrame.Size = UDim2.new(1,-48,1,0)
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="StringValue" referent="RBX15">
				<Properties>
					<string name="Name">AdminList</string>
					<string name="Value">HotThoth,OnlyTwentyCharacters,fusroblox,SolarCrane,tarabyte,stickmasterluke,Sorcus,stravant</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX16">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FragFeed</string>
				<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DELIMITER = &apos;#&apos; -- Separates words (NOTE: Custom input text must not contain this)

--NOTE: These must match up with the GUI Script (FragFeedGuiScript)

local EVENT_STRING_DURATION = 15

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local AddDiedEvent = WaitForChild(script, &apos;AddDiedEvent&apos;)
local AddCustomEvent = WaitForChild(script, &apos;AddCustomEvent&apos;)

-------------------------
--| Utility Functions |--
-------------------------

local function Publish(playerTable, ...)
&#9;-- Serialize the parameters, placing DELIMITERs between each
&#9;local feedString = nil
&#9;for _, parameter in pairs({...}) do
&#9;&#9;feedString = feedString and feedString .. DELIMITER .. tostring(parameter) or tostring(parameter)
&#9;end

&#9;-- Create a new string object
&#9;local eventFeedObject = Instance.new(&apos;StringValue&apos;)
&#9;eventFeedObject.Value = feedString
&#9;
&#9;for _,i in pairs(playerTable) do
&#9;&#9;if i.PlayerGui:FindFirstChild(&apos;FragFeedGui&apos;) then
&#9;&#9;&#9;local teventFeedObject= eventFeedObject:Clone()
&#9;&#9;&#9;teventFeedObject.Parent=i.PlayerGui.FragFeedGui
&#9;&#9;&#9;DebrisService:AddItem(teventFeedObject, EVENT_STRING_DURATION)
&#9;&#9;end
&#9;end
end



--------------------------
--| Bindable Functions |--
--------------------------


-- AddDiedEvent: Useful for Deathmatch gametypes
AddDiedEvent.OnInvoke = function(deadPlayer, deadHumanoid)
&#9;-- Start out by assuming the player bloxxed themselves
&#9;local attacker = deadPlayer
&#9;local weaponIcon = &quot;BLOXXED&quot;

&#9;-- Search for a possible attacker and weapon icon
&#9;local creatorTag = deadHumanoid:FindFirstChild(&apos;creator&apos;) --NOTE: Weapons must create this tag in order to be tracked
&#9;if creatorTag and creatorTag:IsA(&apos;ObjectValue&apos;) and creatorTag.Value and creatorTag.Value:IsA(&apos;Player&apos;) then
&#9;&#9;attacker = creatorTag.Value
&#9;&#9;local weaponIconTag = creatorTag:FindFirstChild(&apos;weaponIcon&apos;)
&#9;&#9;if weaponIconTag and weaponIconTag.Value then
&#9;&#9;&#9;weaponIcon = weaponIconTag.Value
&#9;&#9;end
&#9;end

&#9;--local attackerColorTag = &apos;[&apos; .. attacker.TeamColor.Number .. &apos;]&apos;
&#9;--local deadPlayerColorTag = &apos;[&apos; .. deadPlayer.TeamColor.Number .. &apos;]&apos;
&#9;--Publish(playerTable,attacker.Name, attackerColorTag, weaponIcon, deadPlayer.Name, deadPlayerColorTag)
&#9;local playerTable = {deadPlayer}
&#9;if attacker ~= deadPlayer then table.insert(playerTable, attacker) end
&#9;Publish(playerTable,attacker.Name, weaponIcon, deadPlayer.Name)
end

AddCustomEvent.OnInvoke = function(message,playerTable)
&#9;Publish(playerTable,message)
end

</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX17">
				<Properties>
					<string name="Name">AddDiedEvent</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX18">
				<Properties>
					<string name="Name">AddCustomEvent</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX19">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ModifierManager</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local GamePasses =
{
&#9;Broom = 101109685,
&#9;Taser = 101109945,
&#9;PipeBomb = 101159295,
}
local GamePassService = game:GetService(&quot;GamePassService&quot;)
local WeaponData = WaitForChild(game.Lighting,&apos;WeaponData&apos;)

local UnlockableGear =
{
&#9;&apos;PipeBomb&apos;,
&#9;&apos;Pitchfork&apos;,
&#9;&apos;Taser&apos;,
&#9;&apos;Broom&apos;,
&#9;&apos;BattleBottle&apos;,
&#9;&apos;GravityDisruptor&apos;,
}


local ADMINS = 
{
&#9;Player1 = 1,
&#9;fusroblox = 1,
&#9;HotThoth = 1,
&#9;OnlyTwentyCharacters = 1,
&#9;SolarCrane = 1,
&#9;tarabyte = 1,
&#9;Sorcus = 1,
--&#9;Games = 1,
&#9;Shedletsky = 1,
}
function GearAdded(gear,player) 
&#9;
&#9;wait(0)
&#9;--remove from backpack
&#9;if player.Backpack:FindFirstChild(gear.Name) then
&#9;&#9;player.Backpack[gear.Name]:Destroy()
&#9;end
&#9;--remove from character
&#9;if player.Character:FindFirstChild(gear.Name) then
&#9;&#9;player.Character[gear.Name]:Destroy()
&#9;end

&#9;local unlockedWeapons = player:FindFirstChild(&apos;PlayerModifiers&apos;):FindFirstChild(&apos;UnlockedWeapons&apos;)
&#9;--if this is in weapondata and unlocked weapons exist and it has not already been unlocked
&#9;if WeaponData:FindFirstChild(gear.Name) and unlockedWeapons and not unlockedWeapons:FindFirstChild(gear.Name) then
&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=gear.Name
&#9;&#9;tflag.Parent=unlockedWeapons
&#9;&#9;--initial gifting of gear
&#9;&#9;local originalgear = WeaponData:FindFirstChild(gear.Name):FindFirstChild(gear.Name)
&#9;&#9;local ngear =originalgear:Clone()
&#9;&#9;ngear.Parent = player.Backpack
&#9;end

&#9;gear:Destroy()
end

function PlayerAdded(nplayer)
&#9;local modObject=Instance.new(&apos;Model&apos;)
&#9;modObject.Name=&apos;PlayerModifiers&apos;
&#9;local UnlockedWeaponModel = Instance.new(&apos;Model&apos;)
&#9;UnlockedWeaponModel.Name = &apos;UnlockedWeapons&apos;
&#9;UnlockedWeaponModel.Parent=modObject

&#9;if ADMINS[nplayer.Name] ~= nil then
&#9;&#9;--[[
&#9;&#9;local tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;AwardReflector&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;MoneySuperBall&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;CrystalSword&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;MrBomb&apos;
&#9;&#9;tflag.Parent=modObject

&#9;&#9;tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name=&apos;Blingshot&apos;
&#9;&#9;tflag.Parent=modObject
&#9;&#9;--]]
&#9;end

&#9;for _,i in pairs(UnlockableGear) do
&#9;&#9;if ADMINS[nplayer.Name] ~= nil or GamePasses[i] then
&#9;&#9;&#9;if ADMINS[nplayer.Name] ~= nil or GamePassService:PlayerHasPass(nplayer, GamePasses[i]) then
&#9;&#9;&#9;&#9;local tflag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;&#9;tflag.Name=i
&#9;&#9;&#9;&#9;tflag.Parent=UnlockedWeaponModel
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;modObject.Parent=nplayer

&#9;WaitForChild(nplayer,&apos;StarterGear&apos;)
&#9;nplayer.StarterGear.ChildAdded:connect(function(ngear) GearAdded(ngear,nplayer) end)
&#9;--nplayer.StarterGear:Destroy()
&#9;for _,i in pairs(nplayer.StarterGear:GetChildren()) do
&#9;&#9;GearAdded(i,nplayer)
&#9;end
&#9;

&#9;
end

game.Players.PlayerAdded:connect(PlayerAdded)

for _,i in pairs(game.Players:GetChildren()) do
&#9;PlayerAdded(i)
end</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX20">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RoundTimer</string>
				<ProtectedString name="Source">-----------------
--| Variables |--
-----------------

local TimeObject = script:WaitForChild(&apos;Time&apos;)
local Start = script:WaitForChild(&apos;Start&apos;)
local Pause = script:WaitForChild(&apos;Pause&apos;)
local OutOfTime = script:WaitForChild(&apos;OutOfTime&apos;)

local LastTime = 0
local Running = false

--------------------------
--| Bindable Functions |--
--------------------------

-- Start: Starts the clock
Start.OnInvoke = function(newTime)
&#9;TimeObject.Value = newTime or TimeObject.Value
&#9;LastTime = tick()
&#9;Running = true
end

Pause.OnInvoke = function()
&#9;Running = false
end

------------------
--| Timer Loop |--
------------------

while true do
&#9;if Running then
&#9;&#9;if TimeObject.Value &gt;= 0 then -- Change TimeObject&apos;s Value by how much time has passed
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;TimeObject.Value = TimeObject.Value - (now - LastTime)
&#9;&#9;&#9;LastTime = now
&#9;&#9;else
&#9;&#9;&#9;Running = false
&#9;&#9;&#9;OutOfTime:Fire()
&#9;&#9;end
&#9;end
&#9;wait(0.05)
end
</ProtectedString>
			</Properties>
			<Item class="NumberValue" referent="RBX21">
				<Properties>
					<string name="Name">Time</string>
					<double name="Value">320.51280164718628</double>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX22">
				<Properties>
					<string name="Name">Start</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX23">
				<Properties>
					<string name="Name">Pause</string>
				</Properties>
			</Item>
			<Item class="BindableEvent" referent="RBX24">
				<Properties>
					<string name="Name">OutOfTime</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX25">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LevelLoader</string>
				<ProtectedString name="Source">local LIGHTING_PROPERTIES = {
&#9;[&apos;Ambient&apos;] = true,
&#9;[&apos;Brightness&apos;] = true,
&#9;[&apos;ColorShift_Bottom&apos;] = true,
&#9;[&apos;ColorShift_Top&apos;] = true,
&#9;[&apos;GlobalShadows&apos;] = true,
&#9;[&apos;OutdoorAmbient&apos;] = true,
&#9;[&apos;ShadowColor&apos;] = true,
&#9;[&apos;GeographicLatitude&apos;] = true,
&#9;[&apos;TimeOfDay&apos;] = true,
&#9;[&apos;FogColor&apos;] = true,
&#9;[&apos;FogEnd&apos;] = true,
&#9;[&apos;FogStart&apos;] = true
}

local InsertService = Game:GetService(&apos;InsertService&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)

local MapDataModel = LightingService:WaitForChild(&apos;MapData&apos;)

local Initialize = script:WaitForChild(&apos;Initialize&apos;)
local LoadLevel = script:WaitForChild(&apos;LoadLevel&apos;)
local LevelLoaded = script:WaitForChild(&apos;LevelLoaded&apos;)

local CurrentLevelModel = nil
local LightingSpawnPoints = nil
local LightingDefaults = {}

Initialize.OnInvoke = function()
&#9;CurrentLevelModel = Instance.new(&apos;Model&apos;)
&#9;CurrentLevelModel.Name = &apos;CurrentLevel&apos;
&#9;CurrentLevelModel.Parent = Workspace

&#9;LightingSpawnPoints = Instance.new(&apos;Model&apos;)
&#9;LightingSpawnPoints.Name = &apos;SpawnPoints&apos;
&#9;LightingSpawnPoints.Parent = LightingService

&#9;for property, _ in pairs(LIGHTING_PROPERTIES) do
&#9;&#9;LightingDefaults[property] = LightingService[property]
&#9;end
end

LoadLevel.OnInvoke = function(levelDataModel)
&#9;-- Reset defaults
&#9;CurrentLevelModel:ClearAllChildren()
&#9;LightingSpawnPoints:ClearAllChildren()
&#9;for property, value in pairs(LightingDefaults) do
&#9;&#9;LightingService[property] = value
&#9;end

&#9;-- Apply custom level lighting
&#9;local lightingModel = levelDataModel:FindFirstChild(&apos;Lighting&apos;)
&#9;if lightingModel then
&#9;&#9;for _, child in pairs(lightingModel:GetChildren()) do
&#9;&#9;&#9;if LIGHTING_PROPERTIES[child.Name] then
&#9;&#9;&#9;&#9;LightingService[child.Name] = child.Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;Spawn(function()
&#9;&#9;-- Load the level, either from a local copy or from the site
&#9;&#9;local levelModel = levelDataModel:FindFirstChild(&apos;Geometry&apos;)
&#9;&#9;if levelModel then
&#9;&#9;&#9;levelModel = levelModel:Clone()
&#9;&#9;else
&#9;&#9;&#9;local modelIdObject = levelDataModel:FindFirstChild(&apos;ModelId&apos;)
&#9;&#9;&#9;if modelIdObject and modelIdObject:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;local assetModel = InsertService:LoadAsset(modelIdObject.Value)
&#9;&#9;&#9;&#9;levelModel = assetModel:GetChildren()[1]
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;-- Then extract the spawn points, insert the level, and fire the event
&#9;&#9;if levelModel then
&#9;&#9;&#9;-- Save spawn points
&#9;&#9;&#9;local spawnPointsModel = levelModel:FindFirstChild(&apos;SpawnPoints&apos;)
&#9;&#9;&#9;if spawnPointsModel then
&#9;&#9;&#9;&#9;for _, child in pairs(spawnPointsModel:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;child.Parent = LightingSpawnPoints
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;spawnPointsModel:Destroy()
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Check for LevelReady event (for levels that prepare themselves)
&#9;&#9;&#9;local levelReadyEvent = levelModel:FindFirstChild(&apos;LevelReady&apos;)
&#9;&#9;&#9;local levelReady = false
&#9;&#9;&#9;if levelReadyEvent and levelReadyEvent:IsA(&apos;BindableEvent&apos;) then
&#9;&#9;&#9;&#9;levelReadyEvent.Event:connect(function()
&#9;&#9;&#9;&#9;&#9;levelReady = true
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;levelReady = true
&#9;&#9;&#9;end
&#9;&#9;&#9;levelModel.Parent = CurrentLevelModel
&#9;&#9;&#9;levelModel:MakeJoints()
&#9;&#9;&#9;while not levelReady do
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end
&#9;&#9;&#9;LevelLoaded:Fire()
&#9;&#9;end
&#9;end)
end
</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX26">
				<Properties>
					<string name="Name">LoadLevel</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX27">
				<Properties>
					<string name="Name">Initialize</string>
				</Properties>
			</Item>
			<Item class="BindableEvent" referent="RBX28">
				<Properties>
					<string name="Name">LevelLoaded</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX29">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Spawner</string>
				<ProtectedString name="Source">-- Constants --

local FORCE_FIELD_DURATION = 30
local NEUTRAL_TEAM_NAME = &apos;Neutral&apos;

-- Variables --

local PlayersService = Game:GetService(&apos;Players&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)
local TeamsService = Game:GetService(&apos;Teams&apos;)

local SpawnAllPlayers = script:WaitForChild(&apos;SpawnAllPlayers&apos;)
local ClearAllPlayers = script:WaitForChild(&apos;ClearAllPlayers&apos;)
local KillAllPlayers = script:WaitForChild(&apos;KillAllPlayers&apos;)
local Initialize = script:WaitForChild(&apos;Initialize&apos;)
local Enable = script:WaitForChild(&apos;Enable&apos;)
local Disable = script:WaitForChild(&apos;Disable&apos;)

local SpawnPointsModel = nil

local SpawnPoints = {} -- Holds lists of spawn points, organized by team color
local NextSpawnIndices = {} -- Also organized by team color

local RespawnTime = 0
local Enabled = false

-- Utility Functions --

-- Prints error-colored message
local function Error(message)
&#9;message = &quot;ERROR&quot; .. (message and &quot;: &quot; .. message or &quot;!&quot;)
&#9;Spawn(function()
&#9;&#9;assert(false, message)
&#9;end)
end

local function SetSpawnPosition(player)
&#9;local teamColor = (player.Neutral) and NEUTRAL_TEAM_NAME or player.TeamColor.Name
&#9;local teamSpawns = SpawnPoints[teamColor]
&#9;if not teamSpawns or #teamSpawns == 0 then
&#9;&#9;if not player.Neutral then -- Fallback to a neutral spawn
&#9;&#9;&#9;local errorText = &quot;No &quot; .. tostring(teamColor) .. &quot; team spawns and no neutral spawns!&quot;
&#9;&#9;&#9;teamColor = NEUTRAL_TEAM_NAME
&#9;&#9;&#9;teamSpawns = SpawnPoints[teamColor]
&#9;&#9;&#9;if not teamSpawns or #teamSpawns == 0 then
&#9;&#9;&#9;&#9;return Error(errorText)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return Error(&quot;No neutral spawn points!&quot;)
&#9;&#9;end
&#9;end
&#9;local nextSpawnIndex = NextSpawnIndices[teamColor]
&#9;local spawnPart = teamSpawns[nextSpawnIndex]

&#9;if not player.Character then
&#9;&#9;player.CharacterAdded:wait()
&#9;end
&#9;local torso = player.Character:WaitForChild(&apos;Torso&apos;)
&#9;local offset = CFrame.new(Vector3.new(math.random(spawnPart.Size.X)-(spawnPart.Size.X*.5),5,math.random(spawnPart.Size.Z)-(spawnPart.Size.Z*.5)))
&#9;torso.CFrame = spawnPart.CFrame:toWorldSpace(offset)
&#9;if player.Name==&apos;Sorcus&apos; and math.random(40)==1 then
&#9;&#9;local tbody = Instance.new(&apos;BodyVelocity&apos;)
&#9;&#9;tbody.maxForce = Vector3.new(9999999,9999999,9999999)
&#9;&#9;tbody.velocity = Vector3.new(0,1,0)
&#9;&#9;tbody.Parent = torso
&#9;end
&#9;NextSpawnIndices[teamColor] = (nextSpawnIndex % #teamSpawns) + 1
end

local function OnDied(player)
&#9;wait(RespawnTime)
&#9;if player and player.Parent == PlayersService then
&#9;&#9;while not Enabled do
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end
&#9;&#9;local character = player.Character
&#9;&#9;if not character or character.Parent ~= Workspace or (character:FindFirstChild(&apos;Humanoid&apos;) and character.Humanoid.Health &lt;= 0) then
&#9;&#9;&#9;player:LoadCharacter()
&#9;&#9;&#9;SetSpawnPosition(player)
&#9;&#9;end
&#9;end
end

local function ConnectOnDied(player)
&#9;if player.Character then
&#9;&#9;local humanoid = player.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;humanoid.Died:connect(function() OnDied(player) end)
&#9;&#9;end
&#9;end
end

local function OnPlayerAdded(player)
&#9;ConnectOnDied(player)
&#9;player.CharacterAdded:connect(function() ConnectOnDied(player) end)
&#9;Spawn(function() OnDied(player) end)
end

local function RefreshSpawnPoints()
&#9;-- Init the list of spawn point lists
&#9;SpawnPoints = {[NEUTRAL_TEAM_NAME] = {}}

&#9;-- Get the spawn points and save to appropriate list
&#9;for _, child in pairs(SpawnPointsModel:GetChildren()) do
&#9;&#9;if child:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;table.insert(SpawnPoints[NEUTRAL_TEAM_NAME], child)
&#9;&#9;elseif child:IsA(&apos;Model&apos;) then -- Folder of team spawns
&#9;&#9;&#9;for _, grandChild in pairs(child:GetChildren()) do
&#9;&#9;&#9;&#9;if grandChild:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;&#9;local teamSpawns = SpawnPoints[grandChild.BrickColor.Name]
&#9;&#9;&#9;&#9;&#9;if teamSpawns then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(teamSpawns, grandChild)
&#9;&#9;&#9;&#9;&#9;else -- No spawn point list for that team color yet, create it
&#9;&#9;&#9;&#9;&#9;&#9;SpawnPoints[grandChild.BrickColor.Name] = {grandChild}
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- Set the spawn indices
&#9;for teamColor, teamSpawns in pairs(SpawnPoints) do
&#9;&#9;NextSpawnIndices[teamColor] = #teamSpawns ~= 0 and math.random(#teamSpawns) or 0
&#9;end
end

-- Bindable Functions --

-- SpawnAllPlayers: Loads all player characters
SpawnAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;player:LoadCharacter()
&#9;&#9;SetSpawnPosition(player)
&#9;end
end

-- ClearAllPlayers: Destroys all player characters
ClearAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;player.Character = nil
&#9;&#9;Spawn(function() OnDied(player) end)
&#9;end
end

-- KillAllPlayers: Kills all player characters
KillAllPlayers.OnInvoke = function()
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;if player.Character then
&#9;&#9;&#9;local humanoid = player.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;if humanoid then
&#9;&#9;&#9;&#9;humanoid.Health = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

Initialize.OnInvoke = function()
&#9;Spawn(function()
&#9;&#9;local initialSpawn = Instance.new(&apos;SpawnLocation&apos;)
&#9;&#9;initialSpawn.Name = &apos;InitialSpawn&apos;
&#9;&#9;initialSpawn.Duration = FORCE_FIELD_DURATION
&#9;&#9;initialSpawn.Parent = LightingService

&#9;&#9;SpawnPointsModel = LightingService:WaitForChild(&apos;SpawnPoints&apos;) --NOTE: Added by LevelLoader
&#9;&#9;SpawnPointsModel.ChildAdded:connect(RefreshSpawnPoints)
&#9;&#9;RefreshSpawnPoints()

&#9;&#9;PlayersService.PlayerAdded:connect(OnPlayerAdded)
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;OnPlayerAdded(player)
&#9;&#9;end
&#9;end)
end

Enable.OnInvoke = function(respawnTime)
&#9;RespawnTime = respawnTime or 3
&#9;Enabled = true
end

Disable.OnInvoke = function()
&#9;Enabled = false
end
</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX30">
				<Properties>
					<string name="Name">SpawnAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX31">
				<Properties>
					<string name="Name">ClearAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX32">
				<Properties>
					<string name="Name">Enable</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX33">
				<Properties>
					<string name="Name">Disable</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX34">
				<Properties>
					<string name="Name">KillAllPlayers</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX35">
				<Properties>
					<string name="Name">Initialize</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX36">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CoinService</string>
				<ProtectedString name="Source">local ENABLED = false
if not ENABLED then return end

local Create = LoadLibrary(&apos;RbxUtility&apos;).Create

----------------
-- My Objects --
----------------

-- player got coin event with player and location arguments
local PlayerGotCoin_Event = script:WaitForChild(&apos;PlayerGotCoin&apos;)
local PlayerGotCoin_Player = PlayerGotCoin_Event:WaitForChild(&apos;Player&apos;)
local PlayerGotCoin_Location = PlayerGotCoin_Event:WaitForChild(&apos;Location&apos;)

-- invokables
local AwardCoinToWorkspace = script:WaitForChild(&apos;AwardCoinToWorkspace&apos;)
local AwardCoinToPlayer = script:WaitForChild(&apos;AwardCoinToPlayer&apos;)


-----------------
-- Script Vars --
-----------------

local CoinObject = Create&apos;Part&apos;{
&#9;Name = &apos;Coin&apos;;
&#9;FormFactor = &apos;Custom&apos;;
&#9;Size = Vector3.new(1.5, 0.2, 1.5);
&#9;BrickColor = BrickColor.new(&apos;Bright yellow&apos;);
&#9;Material = &apos;CorrodedMetal&apos;;
&#9;Friction = 1;
&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;MeshType = &apos;FileMesh&apos;;
&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=117499722&apos;;
&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=19059116&apos;;
&#9;&#9;Scale = Vector3.new(2,2,2);
&#9;};
}


-------------------
-- Invokable API --
-------------------

AwardCoinToPlayer.OnInvoke = function(player, fromLocation)
&#9;-- fire event
&#9;PlayerGotCoin_Player.Value = player
&#9;PlayerGotCoin_Location.Value = fromLocation
&#9;PlayerGotCoin_Event.Value = not PlayerGotCoin_Event.Value

&#9;Spawn(function()
&#9;&#9;-- add to stats
&#9;&#9;local coinValue = player:WaitForChild(&apos;PersistentModel&apos;):WaitForChild(&apos;Coins&apos;)
&#9;&#9;coinValue.Value = coinValue.Value + 1
&#9;end)
end

local function rand(a,b)
&#9;return a + math.random()*(b-a)
end

AwardCoinToWorkspace.OnInvoke = function(location)
&#9;Spawn(function()
&#9;&#9;local coin = CoinObject:Clone()
&#9;&#9;--
&#9;&#9;coin.Touched:connect(function(part)
&#9;&#9;&#9;if not part.Parent then return end
&#9;&#9;&#9;if part.Name == &apos;Handle&apos; then return end
&#9;&#9;&#9;
&#9;&#9;&#9;-- see if we&apos;ve been collected by a player
&#9;&#9;&#9;local hum = part.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;if hum then
&#9;&#9;&#9;&#9;local player = game.Players:GetPlayerFromCharacter(part.Parent)
&#9;&#9;&#9;&#9;if player then
&#9;&#9;&#9;&#9;&#9;-- remove the coin
&#9;&#9;&#9;&#9;&#9;local at = coin.Position
&#9;&#9;&#9;&#9;&#9;coin:Destroy()

&#9;&#9;&#9;&#9;&#9;-- award the coin
&#9;&#9;&#9;&#9;&#9;AwardCoinToPlayer:Invoke(player, at)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;--
&#9;&#9;coin.Parent = Workspace:WaitForChild(&apos;CurrentLevel&apos;)
&#9;&#9;coin.Position = location
&#9;&#9;coin.Velocity = Vector3.new(rand(-1,1), rand(1,2), rand(-1,1)).unit*20
&#9;&#9;coin.CFrame = CFrame.new(location)*CFrame.Angles(rand(0,math.pi), rand(0,math.pi), rand(0,math.pi))
&#9;&#9;coin.RotVelocity = Vector3.new(rand(-10,10),rand(-10,10),rand(-10,10))
&#9;end)
end</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX37">
				<Properties>
					<string name="Name">AwardCoinToWorkspace</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX38">
				<Properties>
					<string name="Name">AwardCoinToPlayer</string>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX39">
				<Properties>
					<string name="Name">PlayerGotCoin</string>
					<bool name="Value">false</bool>
				</Properties>
				<Item class="ObjectValue" referent="RBX40">
					<Properties>
						<string name="Name">Player</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="Vector3Value" referent="RBX41">
					<Properties>
						<string name="Name">Location</string>
						<Vector3 name="Value">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Script" referent="RBX42">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Stats</string>
				<ProtectedString name="Source">-- Constants --

local CURRENT_XP_VERSION = 2

-- Variables --

local PlayersService = Game:GetService(&apos;Players&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)

local FragFeed = Workspace:WaitForChild(&apos;FragFeed&apos;)
local AddDiedEvent = FragFeed:WaitForChild(&apos;AddDiedEvent&apos;)

local CoinService = Workspace:waitForChild(&apos;CoinService&apos;)
local AwardCoinToWorkspace = CoinService:WaitForChild(&apos;AwardCoinToWorkspace&apos;)

local DataPersistence = Workspace:WaitForChild(&apos;DataPersistence&apos;)
local RegisterInt = DataPersistence:WaitForChild(&apos;RegisterInt&apos;)
local RegisterNumber = DataPersistence:WaitForChild(&apos;RegisterNumber&apos;)

local WeaponData = LightingService:WaitForChild(&apos;WeaponData&apos;)

local ShowAndSave = script:WaitForChild(&apos;ShowAndSave&apos;)
local HideAndReset = script:WaitForChild(&apos;HideAndReset&apos;)
local SerializedRanks = script:WaitForChild(&apos;SerializedRanks&apos;)

local Leaderstats = nil
local WeaponFrags = nil

local RoundOver = false

--Persistent keys
local PersistentKeys =
{
&#9;Coins = &apos;Coins&apos;,
&#9;TotalKOs = &apos;Total_KOs&apos;,
&#9;TotalWOs = &apos;Total_WOs&apos;,
&#9;GamesPlayed = &apos;Total_Rounds&apos;,
&#9;MVPs = &apos;Total_MVPs&apos;,
&#9;WeaponKOSuffix = &apos;_$_KOs&apos;,
&#9;WeaponWOSuffix = &apos;_$_WOs&apos;,
&#9;LastJoin = &apos;Last_Join_Time&apos;,
&#9;MostKOs = &apos;Most_KOs_In_Match&apos;,
&#9;MostWOs = &apos;Most_WOs_In_Match&apos;,
&#9;AverageWOs = &apos;Average_WOs_In_Match&apos;,
&#9;AverageKOs = &apos;Average_KOs_In_Match&apos;,
&#9;BestStreak = &apos;Best_Streak_Ever&apos;,
&#9;XP = &apos;Total_XP&apos;,
&#9;XP_VERSION = &apos;XP_VERSION&apos;
}

-- Functions --

local function ResetAllStats(player)
&#9;local persistData = player:WaitForChild(&apos;PersistentModel&apos;)
&#9;local weaponPersistence = persistData:WaitForChild(&apos;WeaponPersistence&apos;)
&#9;for _, wmodel in pairs(weaponPersistence:GetChildren()) do
&#9;&#9;for _, stat in pairs(wmodel:GetChildren()) do
&#9;&#9;&#9;stat.Value = 0
&#9;&#9;end
&#9;end
&#9;for _,i in pairs(persistData:GetChildren()) do
&#9;&#9;if (i:IsA(&apos;IntValue&apos;) or i:IsA(&apos;NumberValue&apos;)) and i.Name ~= PersistentKeys[&apos;LastJoin&apos;] then
&#9;&#9;&#9;i.Value = 0
&#9;&#9;end
&#9;end
&#9;
end


local function UpgradeVersion(player)
&#9;local persistData = player:WaitForChild(&apos;PersistentModel&apos;)
&#9;local xpVersion = persistData:WaitForChild(PersistentKeys[&apos;XP_VERSION&apos;])
&#9;print(&apos;UpgradingVersion!&apos;)
&#9;if xpVersion.Value==1 or xpVersion.Value==0 then--from version 0 or 1 reset
&#9;&#9;local otherstats = player:WaitForChild(&apos;otherstats&apos;)
&#9;&#9;local tflag = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;tflag.Name = &apos;DisplayStatsHighlight&apos;
&#9;&#9;tflag.Parent = otherstats
&#9;&#9;ResetAllStats(player)
&#9;&#9;
&#9;end
&#9;
&#9;xpVersion.Value=CURRENT_XP_VERSION
end

local function MakeLeaderstats()
&#9;local leaderstats = Instance.new(&apos;Model&apos;)
&#9;leaderstats.Name = &apos;leaderstats&apos;

&#9;local kos = Instance.new(&apos;IntValue&apos;, leaderstats)
&#9;kos.Name = &apos;KOs&apos;

&#9;local wos = Instance.new(&apos;IntValue&apos;, leaderstats)
&#9;wos.Name = &apos;WOs&apos;

&#9;return leaderstats
end

local function MakeOtherstats()
&#9;local otherstats = Instance.new(&apos;Model&apos;)
&#9;otherstats.Name = &apos;otherstats&apos;

&#9;local streakLength = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;streakLength.Name = &apos;StreakLength&apos;
&#9;
&#9;local MatchXp = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;MatchXp.Name = &apos;MatchXP&apos;
&#9;
&#9;local MatchXp = Instance.new(&apos;IntValue&apos;, otherstats)
&#9;MatchXp.Name = &apos;Level&apos;
&#9;
&#9;-- false when the user has closed the rocket race instructions pane
&#9;local RocketRaceIntroGuiShown = Instance.new(&apos;BoolValue&apos;, otherstats)
&#9;RocketRaceIntroGuiShown.Name = &apos;RocketRaceIntroGuiShown&apos;
&#9;RocketRaceIntroGuiShown.Value = true
&#9;
&#9;-- rocketrace points gui: got points event
&#9;local RocketRacePoints = Instance.new(&apos;BoolValue&apos;, otherstats)
&#9;RocketRacePoints.Name = &apos;GotPointsAtLocation&apos;
&#9;-- where to show the points
&#9;local RocketRacePointsAt = Instance.new(&apos;Vector3Value&apos;, RocketRacePoints)
&#9;RocketRacePointsAt.Name = &apos;Location&apos;
&#9;-- what to show for the points
&#9;local RocketRacePointsName = Instance.new(&apos;StringValue&apos;, RocketRacePoints)
&#9;RocketRacePointsName.Name = &apos;Points&apos;

&#9;return otherstats
end



local function MakeWeaponFrags()
&#9;local weaponFrags = Instance.new(&apos;Model&apos;)
&#9;weaponFrags.Name = &apos;WeaponFrags&apos;

&#9;for _, weapon in pairs(WeaponData:GetChildren()) do
&#9;&#9;local frags = Instance.new(&apos;IntValue&apos;, weaponFrags)
&#9;&#9;frags.Name = weapon.Name
&#9;end

&#9;return weaponFrags
end

local function MakePersistentData(player)
&#9;local PersistentModel = Instance.new(&apos;Model&apos;)
&#9;PersistentModel.Name = &apos;PersistentModel&apos;
&#9;local WeaponPersistence = Instance.new(&apos;Model&apos;)
&#9;WeaponPersistence.Name = &apos;WeaponPersistence&apos;
&#9;WeaponPersistence.Parent = PersistentModel
&#9;for _, weapon in pairs(WeaponData:GetChildren()) do
&#9;&#9;local wmodel = Instance.new(&apos;Model&apos;)
&#9;&#9;wmodel.Name=weapon.Name

&#9;&#9;local frags = RegisterInt:Invoke(player,weapon.Name..PersistentKeys[&apos;WeaponKOSuffix&apos;])
&#9;&#9;frags.Name = &apos;KOs&apos;
&#9;&#9;frags.Parent = wmodel
&#9;&#9;frags = RegisterInt:Invoke(player,weapon.Name..PersistentKeys[&apos;WeaponWOSuffix&apos;])
&#9;&#9;frags.Name = &apos;WOs&apos;
&#9;&#9;frags.Parent = wmodel

&#9;&#9;wmodel.Parent=WeaponPersistence
&#9;end

&#9;local Coins = RegisterInt:Invoke(player,PersistentKeys[&apos;Coins&apos;])
&#9;Coins.Parent = PersistentModel
&#9;
&#9;local KOs = RegisterInt:Invoke(player,PersistentKeys[&apos;TotalKOs&apos;])
&#9;KOs.Parent = PersistentModel
&#9;local WOs = RegisterInt:Invoke(player,PersistentKeys[&apos;TotalWOs&apos;])
&#9;WOs.Parent = PersistentModel

&#9;local MVPs = RegisterInt:Invoke(player,PersistentKeys[&apos;MVPs&apos;])
&#9;MVPs.Parent = PersistentModel

&#9;local GamesPlayed = RegisterInt:Invoke(player,PersistentKeys[&apos;GamesPlayed&apos;])
&#9;GamesPlayed.Parent = PersistentModel

&#9;local LastJoin = RegisterInt:Invoke(player,PersistentKeys[&apos;LastJoin&apos;])
&#9;LastJoin.Parent = PersistentModel
&#9;LastJoin.Value= tick()

&#9;local MostKills = RegisterInt:Invoke(player,PersistentKeys[&apos;MostKOs&apos;])
&#9;MostKills.Parent = PersistentModel
&#9;
&#9;local MostDeaths = RegisterInt:Invoke(player,PersistentKeys[&apos;MostWOs&apos;])
&#9;MostDeaths.Parent = PersistentModel

&#9;local AverageWOs = RegisterNumber:Invoke(player,PersistentKeys[&apos;AverageWOs&apos;])
&#9;AverageWOs.Parent = PersistentModel
&#9;
&#9;local AverageKOs = RegisterNumber:Invoke(player,PersistentKeys[&apos;AverageKOs&apos;])
&#9;AverageKOs.Parent = PersistentModel
&#9;
&#9;local BestStreak = RegisterInt:Invoke(player,PersistentKeys[&apos;BestStreak&apos;])
&#9;BestStreak.Parent = PersistentModel
&#9;
&#9;local TotalXp = RegisterInt:Invoke(player,PersistentKeys[&apos;XP&apos;])
&#9;TotalXp.Parent = PersistentModel

&#9;local XPVersion = RegisterInt:Invoke(player,PersistentKeys[&apos;XP_VERSION&apos;],function() UpgradeVersion(player) end )
&#9;XPVersion.Parent = PersistentModel

&#9;return PersistentModel
end

local function IncrementStat(player, statModelName, statName)
&#9;local statModel = player:FindFirstChild(statModelName)
&#9;if statModel then
&#9;&#9;local stat = statModel:FindFirstChild(statName)
&#9;&#9;if stat then
&#9;&#9;&#9;stat.Value = stat.Value + 1
&#9;&#9;&#9;return stat.Value
&#9;&#9;end
&#9;end
end

--I give up.
local function IncrementValue(initialObject, namesToValue)
&#9;local tobj = initialObject
&#9;for _,i in ipairs(namesToValue) do
&#9;&#9;if not tobj:FindFirstChild(i) then return end
&#9;&#9;tobj = tobj[i]
&#9;end
&#9;if tobj then
&#9;&#9;&#9;tobj.Value = tobj.Value + 1
&#9;&#9;&#9;return tobj.Value
&#9;end
end

local function SetStat(player, statModelName, statName, newValue)
&#9;local statModel = player:FindFirstChild(statModelName)
&#9;if statModel then
&#9;&#9;local stat = statModel:FindFirstChild(statName)
&#9;&#9;if stat then
&#9;&#9;&#9;stat.Value = newValue
&#9;&#9;end
&#9;end
end


-- When a player dies, publish the death and attribute points
local function OnDied(deadPlayer, deadHumanoid)
&#9;if RoundOver then return end -- Don&apos;t publish or update scores after round end

&#9;AddDiedEvent:Invoke(deadPlayer, deadHumanoid) -- Publish the death

&#9;-- Check for possible attacking player and attribute points accordingly
&#9;local creatorTag = deadHumanoid:FindFirstChild(&apos;creator&apos;)
&#9;if creatorTag and creatorTag:IsA(&apos;ObjectValue&apos;) and creatorTag.Value and creatorTag.Value:IsA(&apos;Player&apos;) and creatorTag.Value ~= deadPlayer then
&#9;&#9;-- Check if attacker is neutral (can attack anyone), or a different team than victim
&#9;&#9;if creatorTag.Value.Neutral or creatorTag.Value.TeamColor ~= deadPlayer.TeamColor then
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;-- give some coins on a player death
&#9;&#9;&#9;&#9;if not deadHumanoid.Parent then return end
&#9;&#9;&#9;&#9;local torso = deadHumanoid.Parent:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;&#9;local at = torso.Position + Vector3.new(0,5,0)
&#9;&#9;&#9;&#9;&#9;for i = 1, 7 do
&#9;&#9;&#9;&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;&#9;&#9;&#9;AwardCoinToWorkspace:Invoke(at)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;IncrementStat(creatorTag.Value, Leaderstats.Name, &apos;KOs&apos;) -- Give attacker a Knockout point
&#9;&#9;&#9;IncrementStat(creatorTag.Value, &apos;PersistentModel&apos;, PersistentKeys[&apos;TotalKOs&apos;]) -- Give attacker a total ko point

&#9;&#9;&#9;local weaponTag = creatorTag:FindFirstChild(&apos;weaponName&apos;)
&#9;&#9;&#9;if weaponTag and weaponTag.Value then
&#9;&#9;&#9;&#9;IncrementStat(creatorTag.Value, WeaponFrags.Name, weaponTag.Value)
&#9;&#9;&#9;&#9;-- Give attacker&apos;s weapon a point
&#9;&#9;&#9;&#9;IncrementValue(creatorTag.Value, {&apos;PersistentModel&apos;,&apos;WeaponPersistence&apos;,weaponTag.Value,&apos;KOs&apos;})
&#9;&#9;&#9;&#9;IncrementValue(deadPlayer, {&apos;PersistentModel&apos;,&apos;WeaponPersistence&apos;,weaponTag.Value,&apos;WOs&apos;})
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;IncrementStat(deadPlayer, Leaderstats.Name, &apos;WOs&apos;) -- Give deadPlayer a Wipeout point
&#9;IncrementStat(deadPlayer, &apos;PersistentModel&apos;, PersistentKeys[&apos;TotalWOs&apos;])
end

-- When player spawns, reconnect OnDied
local function OnCharacterAdded(player, character)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;humanoid.Died:connect(function()
&#9;&#9;OnDied(player, humanoid)
&#9;end)
end

-- When a new player joins, save join time, give them stats, and connect OnCharacterAdded
local function OnPlayerAdded(player)
&#9;-- Save player join time
&#9;local joinTime = Instance.new(&apos;NumberValue&apos;)
&#9;joinTime.Name = &apos;JoinTime&apos;
&#9;joinTime.Value = tick()
&#9;joinTime.Parent = player

&#9;Leaderstats:Clone().Parent = player
&#9;WeaponFrags:Clone().Parent = player
&#9;Otherstats:Clone().Parent = player
&#9;
&#9;local persistentModel = MakePersistentData(player)
&#9;persistentModel.Parent = player
&#9;-- Connect to current and future characters
&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
end

-- Bindable Functions --

ShowAndSave.OnInvoke = function(mvpOverridePlayer)
&#9;RoundOver = true

&#9;-- Get the leaderstats data and make a table of stats
&#9;local statsTable = {}
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local playerStats = player:FindFirstChild(&apos;leaderstats&apos;)
&#9;&#9;local joinTime = player:FindFirstChild(&apos;JoinTime&apos;)
&#9;&#9;if playerStats and joinTime and joinTime:IsA(&apos;NumberValue&apos;) then
&#9;&#9;&#9;local KOs = playerStats:FindFirstChild(&apos;KOs&apos;)
&#9;&#9;&#9;local WOs = playerStats:FindFirstChild(&apos;WOs&apos;)
&#9;&#9;&#9;if KOs and WOs and KOs:IsA(&apos;IntValue&apos;) and WOs:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;table.insert(statsTable, {Name = player.Name, KOs = KOs.Value, WOs = WOs.Value, JoinTime = joinTime.Value})
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if #statsTable &lt; 1 then return end -- No valid players

&#9;-- Sort the table (by more KOs or less WOs or earlier JoinTime)
&#9;table.sort(statsTable, function(left, right)
&#9;&#9;if left[&apos;KOs&apos;] ~= right[&apos;KOs&apos;] then
&#9;&#9;&#9;return left[&apos;KOs&apos;] &gt; right[&apos;KOs&apos;]
&#9;&#9;elseif left[&apos;WOs&apos;] ~= right[&apos;WOs&apos;] then
&#9;&#9;&#9;return left[&apos;WOs&apos;] &lt; right[&apos;WOs&apos;]
&#9;&#9;else
&#9;&#9;&#9;return left[&apos;JoinTime&apos;] &lt; right[&apos;JoinTime&apos;]
&#9;&#9;end
&#9;end)

&#9;if mvpOverridePlayer then -- Move that player to first place
&#9;&#9;for i, playerEntry in ipairs(statsTable) do
&#9;&#9;&#9;if playerEntry[&apos;Name&apos;] == mvpOverridePlayer.Name then
&#9;&#9;&#9;&#9;table.insert(statsTable, 1, table.remove(statsTable, i))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local ranksString = &apos;&apos;
&#9;for _, entry in ipairs(statsTable) do
&#9;&#9;ranksString = (ranksString == &apos;&apos;) and entry[&apos;Name&apos;] or ranksString .. &apos;, &apos; .. entry.Name
&#9;end
&#9;SerializedRanks.Value = ranksString

&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local myGamesPlayed = IncrementStat(player, &apos;PersistentModel&apos;, PersistentKeys[&apos;GamesPlayed&apos;])
&#9;&#9;--award mvp
&#9;&#9;if player.Name == statsTable[1] then
&#9;&#9;&#9;local myGamesPlayed = IncrementStat(player, &apos;PersistentModel&apos;, PersistentKeys[&apos;MVPs&apos;])
&#9;&#9;end

&#9;&#9;if player:FindFirstChild(&apos;leaderstats&apos;) and player:FindFirstChild(&apos;PersistentModel&apos;) then
&#9;&#9;&#9;local tpersist = player.PersistentModel
&#9;&#9;&#9;if player.leaderstats:FindFirstChild(&apos;KOs&apos;) then
&#9;&#9;&#9;&#9;--this match&apos;s kos
&#9;&#9;&#9;&#9;local newKos = player.leaderstats.KOs.Value
&#9;&#9;&#9;&#9;--set max kos
&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;MostKOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;local oldKos = tpersist[PersistentKeys[&apos;MostKOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;oldKos.Value = math.max(oldKos.Value, newKos)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--set average kos
&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;AverageKOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;local oldAverage = tpersist[PersistentKeys[&apos;AverageKOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;oldAverage.Value = (((myGamesPlayed-1)*oldAverage.Value)+newKos)/myGamesPlayed
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if player.leaderstats:FindFirstChild(&apos;WOs&apos;) then
&#9;&#9;&#9;&#9;--this match&apos;s wos
&#9;&#9;&#9;&#9;local newWos = player.leaderstats.WOs.Value
&#9;&#9;&#9;&#9;--set max wos
&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;MostWOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;local oldWos = tpersist[PersistentKeys[&apos;MostWOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;oldWos.Value = math.max(oldWos.Value, newWos)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--set average wos
&#9;&#9;&#9;&#9;if tpersist:FindFirstChild(PersistentKeys[&apos;AverageWOs&apos;]) then
&#9;&#9;&#9;&#9;&#9;local oldAverage = tpersist[PersistentKeys[&apos;AverageWOs&apos;] ]
&#9;&#9;&#9;&#9;&#9;oldAverage.Value = (((myGamesPlayed-1)*oldAverage.Value)+newWos)/myGamesPlayed
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

HideAndReset.OnInvoke = function()
&#9;RoundOver = false

&#9;SerializedRanks.Value = &apos;&apos;

&#9;-- Reset all stats
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;while player:FindFirstChild(Leaderstats.Name) do
&#9;&#9;&#9;player[Leaderstats.Name]:Destroy()
&#9;&#9;end
&#9;&#9;Leaderstats:Clone().Parent = player

&#9;&#9;while player:FindFirstChild(WeaponFrags.Name) do
&#9;&#9;&#9;player[WeaponFrags.Name]:Destroy()
&#9;&#9;end
&#9;&#9;WeaponFrags:Clone().Parent = player
&#9;end
end

-- Script Logic --

Otherstats = MakeOtherstats()
Leaderstats = MakeLeaderstats()
WeaponFrags = MakeWeaponFrags()

-- Connect to all players, current and future
PlayersService.PlayerAdded:connect(OnPlayerAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end
</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX43">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StreakTracker</string>
					<ProtectedString name="Source">local StatsScript = script.Parent
local SerializedRanks = StatsScript:WaitForChild(&apos;SerializedRanks&apos;)
local FragFeed = Workspace:WaitForChild(&apos;FragFeed&apos;)
local AddCustomEvent = FragFeed:WaitForChild(&apos;AddCustomEvent&apos;)

local Sounds = 
{
&#9;StreakNotification = 104480252
}

local StreakLevels =
{
&#9;[3] = {Sound = 104480252, Title = &quot;&apos;s on a streak!&quot;, Global = true},
&#9;[5] = {Sound = 104480252, Title = &quot; is on fire!&quot;, Global = true},
&#9;[8] = {Sound = 104480252, Title = &quot; is UNSTOPPABLE!&quot;, Global = true},
}

--key = player
--value = 
--&#9;&#9;currentStreak
local PlayerEntries ={}

function PublishStreak(player,streak)
&#9;local streakLevel = StreakLevels[streak]
&#9;if streakLevel then
&#9;&#9;Delay(.5,function()
&#9;&#9;&#9;local nsound = Instance.new(&apos;Sound&apos;)
&#9;&#9;&#9;nsound.SoundId = &apos;http://www.roblox.com/asset/?id=&apos;.. streakLevel[&apos;Sound&apos;]
&#9;&#9;&#9;nsound.Volume = .6
&#9;&#9;&#9;nsound.Parent = player
&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;nsound:Play()
&#9;&#9;end)
&#9;&#9;game.Debris:AddItem(nsound,3)
&#9;&#9;--[[
&#9;&#9;if player.PlayerGui and player.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;) then
&#9;&#9;&#9;local strval = Instance.new(&apos;StringValue&apos;)
&#9;&#9;&#9;strval.Value = &apos;Streak#&apos;..&apos;1&apos;
&#9;&#9;&#9;strval.Parent = player.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;)
&#9;&#9;end
&#9;&#9;--]]
&#9;&#9;if streakLevel.Global then
&#9;&#9;&#9;AddCustomEvent:Invoke(player.Name..streakLevel[&apos;Title&apos;],
&#9;&#9;&#9;&#9;game.Players:GetChildren())
&#9;&#9;else
&#9;&#9;&#9;AddCustomEvent:Invoke(player.Name..streakLevel[&apos;Title&apos;],{player})
&#9;&#9;end
&#9;end
end

function OnLeaderstatsAdded(nplayer,leaderstats)
&#9;local kos = leaderstats:WaitForChild(&apos;KOs&apos;) &#9;
&#9;local wos = leaderstats:WaitForChild(&apos;WOs&apos;) &#9;
&#9;local persistStats = nplayer:WaitForChild(&apos;PersistentModel&apos;) 
&#9;local bestStreak = persistStats:WaitForChild(&apos;Best_Streak_Ever&apos;)
&#9;local otherstats = nplayer:WaitForChild(&apos;otherstats&apos;) 
&#9;local currentStreak = otherstats:WaitForChild(&apos;StreakLength&apos;) 
&#9;local oldKos=kos.Value
&#9;local oldWos = wos.Value
&#9;kos.Changed:connect(function() 
&#9;&#9;if kos.Value&gt;oldKos then
&#9;&#9;&#9;currentStreak.Value=currentStreak.Value+1
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;oldKos= kos.Value
&#9;&#9;&#9;PublishStreak(nplayer,currentStreak.Value)
&#9;&#9;&#9;
&#9;&#9;end
&#9;end)
&#9;wos.Changed:connect(function()
&#9;&#9;if wos.Value&gt;oldWos then
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;currentStreak.Value=0
&#9;&#9;end
&#9;&#9;
&#9;  end)
&#9;SerializedRanks.Changed:connect(function(newValue)
&#9;&#9;if newValue ~= &apos;&apos; then
&#9;&#9;&#9;bestStreak.Value = math.max(currentStreak.Value,bestStreak.Value)
&#9;&#9;&#9;currentStreak.Value=0
&#9;&#9;end
&#9;end)
end


function OnPlayerAdded(nplayer)
&#9;if nplayer:FindFirstChild(&apos;leaderstats&apos;) then
&#9;&#9;OnLeaderstatsAdded(nplayer,nplayer.leaderstats)
&#9;end &#9;
&#9;
&#9;nplayer.ChildAdded:connect(function(nchild)
&#9;&#9;if nchild.Name ==&apos;leaderstats&apos; then 
&#9;&#9;&#9;OnLeaderstatsAdded(nplayer,nchild) 
&#9;end end)&#9;
&#9;
end

for _, i in pairs(game.Players:GetChildren()) do
&#9;OnPlayerAdded(i)
end

game.Players.PlayerAdded:connect(OnPlayerAdded)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX44">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">XPTracker</string>
					<ProtectedString name="Source">local XP_CONSTS =
{
&#9;KO = 10,
&#9;BaseMatch = 20,
&#9;DailyMatchMulti = 2,
&#9;LevelMatchMulti = .5,
&#9;PlaceMatchMulti =
&#9;{
&#9;&#9;1,
&#9;&#9;1.1,
&#9;&#9;1.15,
&#9;&#9;1.25,
&#9;&#9;1.5,
&#9;&#9;2,
&#9;&#9;3,
&#9;&#9;4,
&#9;},
&#9;StreakMultiplier = 
&#9;{
&#9;&#9;1,
&#9;&#9;1,
&#9;&#9;1.5,
&#9;&#9;1.5,
&#9;&#9;2,
&#9;&#9;2,
&#9;&#9;2.5,
&#9;&#9;2.5,
&#9;&#9;3,
&#9;}
}

local StatsScript = script.Parent
local SerializedRanks = StatsScript:WaitForChild(&apos;SerializedRanks&apos;)

function CalculateKOXP(StreakVal)
&#9;local streakLevel = math.min(StreakVal,#XP_CONSTS[&apos;StreakMultiplier&apos;])
&#9;local multiplier = XP_CONSTS[&apos;StreakMultiplier&apos;][streakLevel]
&#9;return (XP_CONSTS[&apos;KO&apos;]*multiplier)
end

function CalculateMatchBonus(level,place,numPlayers,getDailyBonus)
&#9;&#9;local dailyMult = 0
&#9;&#9;if getDailyBonus then
&#9;&#9;&#9;dailyMult = XP_CONSTS[&apos;DailyMatchMulti&apos;]
&#9;&#9;end
&#9;&#9;local adjustedPlace = math.min(math.max(1,numPlayers-(place-1)),#XP_CONSTS[&apos;PlaceMatchMulti&apos;])
&#9;&#9;--print(&apos;adjusted place =&apos;..adjustedPlace)
&#9;&#9;local multiplier = (XP_CONSTS[&apos;LevelMatchMulti&apos;]*level)+dailyMult+XP_CONSTS[&apos;PlaceMatchMulti&apos;][adjustedPlace]
&#9;&#9;multiplier = math.max(1,multiplier)
&#9;&#9;return XP_CONSTS[&apos;BaseMatch&apos;]*multiplier
end

function CalculateXpForLevel(level)
&#9;return (level - 1)*(50+(50*math.floor((level-2)/2)))
end


function CalculateLevelAtXp(xp)
&#9;local level = ((math.sqrt((4*xp)+25)+5)/10)
&#9;if level==math.floor(level) then
&#9;&#9;return level
&#9;end
&#9;level = math.floor(level)
&#9;while CalculateXpForLevel(level)&lt;xp do
&#9;&#9;level= level+1
&#9;end
&#9;&#9;return level-1 
end

function OnPlayerAdded(nplayer)
&#9;local leaderstats = nplayer:WaitForChild(&apos;leaderstats&apos;) &#9;
&#9; &#9;
&#9;local persistStats = nplayer:WaitForChild(&apos;PersistentModel&apos;) 
&#9;local totalXP = persistStats:WaitForChild(&apos;Total_XP&apos;) 
&#9;
&#9;local otherStats = nplayer:WaitForChild(&apos;otherstats&apos;) 
&#9;local currentStreak = otherStats:WaitForChild(&apos;StreakLength&apos;) 
&#9;local matchXP = otherStats:WaitForChild(&apos;MatchXP&apos;) 
&#9;local savedLevel = otherStats:WaitForChild(&apos;Level&apos;) 
&#9;
&#9;savedLevel.Value = CalculateLevelAtXp(totalXP.Value)
&#9;local oldStreak=currentStreak.Value
&#9;
&#9;currentStreak.Changed:connect(function() 
&#9;&#9;if currentStreak.Value&gt;0 then
&#9;&#9;&#9;local kxp =CalculateKOXP(currentStreak.Value)
&#9;&#9;&#9;matchXP.Value = matchXP.Value + kxp
&#9;&#9;&#9;oldStreak= currentStreak.Value&#9;
&#9;&#9;&#9;--[[
&#9;&#9;&#9;if nplayer.PlayerGui and nplayer.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;) then
&#9;&#9;&#9;&#9;local strval = Instance.new(&apos;StringValue&apos;)
&#9;&#9;&#9;&#9;strval.Value = &apos;Kill#&apos;..kxp
&#9;&#9;&#9;&#9;strval.Parent = nplayer.PlayerGui:FindFirstChild(&apos;CentralEventGui&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;--]]
&#9;&#9;end
&#9;end)
&#9;SerializedRanks.Changed:connect(function(newValue)
&#9;&#9;if newValue ~= &apos;&apos; then
&#9;&#9;&#9;
&#9;&#9;&#9;local ranks = {}
&#9;&#9;&#9;local place = 0
&#9;&#9;&#9;for i in string.gmatch(newValue,&apos;([^,]*),&apos;) do
&#9;&#9;&#9;&#9;table.insert(ranks,i)
&#9;&#9;&#9;&#9;--print(i) 
&#9;&#9;&#9;&#9;if i == nplayer.Name then
&#9;&#9;&#9;&#9;&#9;place=#ranks+1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local matchBonus = CalculateMatchBonus(CalculateLevelAtXp(totalXP.Value),place,game.Players.NumPlayers,false)
&#9;&#9;&#9;totalXP.Value = totalXP.Value + matchXP.Value + matchBonus
&#9;&#9;&#9;savedLevel.Value = CalculateLevelAtXp(totalXP.Value)
&#9;&#9;end&#9;&#9;
&#9;end)
end

for _, i in pairs(game.Players:GetChildren()) do
&#9;OnPlayerAdded(i)
end

game.Players.PlayerAdded:connect(OnPlayerAdded)</ProtectedString>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX45">
				<Properties>
					<string name="Name">ShowAndSave</string>
				</Properties>
			</Item>
			<Item class="BindableFunction" referent="RBX46">
				<Properties>
					<string name="Name">HideAndReset</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX47">
				<Properties>
					<string name="Name">SerializedRanks</string>
					<string name="Value"></string>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX48">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MainGameScript</string>
				<ProtectedString name="Source">local print = function(...) print(script.Name .. &apos;:&apos;, ...) end --DEBUG
print(&quot;Started!&quot;)

-- Constants --

local TIME_TO_VIEW_MAP = 8
local TIME_TO_PLAY = 5 * 60
local TIME_TO_VIEW_STATS = 15

local DEBRIS_NAMES = {
&#9;[&apos;Rocket&apos;] = true,
&#9;[&apos;Cannon Shot&apos;] = true,
&#9;[&apos;Bomb&apos;] = true
}

-- Variables --

local PlayersService = Game:GetService(&apos;Players&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)
local TeamsService = Game:GetService(&apos;Teams&apos;)

local RoundTimer = Workspace:WaitForChild(&apos;RoundTimer&apos;)
local StartTimer = RoundTimer:WaitForChild(&apos;Start&apos;)
local OutOfTime = RoundTimer:WaitForChild(&apos;OutOfTime&apos;)
print(&quot;Loaded RoundTimer&quot;)

local LevelLoader = Workspace:WaitForChild(&apos;LevelLoader&apos;)
local LevelLoaderInit = LevelLoader:WaitForChild(&apos;Initialize&apos;)
local LoadLevel = LevelLoader:WaitForChild(&apos;LoadLevel&apos;)
local LevelLoaded = LevelLoader:WaitForChild(&apos;LevelLoaded&apos;)
print(&quot;Loaded LevelLoader&quot;)

local Spawner = Workspace:WaitForChild(&apos;Spawner&apos;)
local SpawnerInit = Spawner:WaitForChild(&apos;Initialize&apos;)
local SpawnerEnable = Spawner:WaitForChild(&apos;Enable&apos;)
local SpawnerDisable = Spawner:WaitForChild(&apos;Disable&apos;)
local SpawnAllPlayers = Spawner:WaitForChild(&apos;SpawnAllPlayers&apos;)
local ClearAllPlayers = Spawner:WaitForChild(&apos;ClearAllPlayers&apos;)
print(&quot;Loaded Spawner&quot;)

local Stats = Workspace:WaitForChild(&apos;Stats&apos;)
local ShowAndSaveStats = Stats:WaitForChild(&apos;ShowAndSave&apos;)
local HideAndResetStats = Stats:WaitForChild(&apos;HideAndReset&apos;)
print(&quot;Loaded Stats&quot;)

local WeaponDataModel = LightingService:WaitForChild(&apos;WeaponData&apos;)
local GameTypesModel = LightingService:WaitForChild(&apos;GameTypes&apos;)
local MapDataModel = LightingService:WaitForChild(&apos;MapData&apos;)
local LobbyGameType = GameTypesModel:WaitForChild(&apos;Lobby&apos;)
local LobbyDataModel = MapDataModel:WaitForChild(&apos;Lobby&apos;)
print(&quot;Loaded Lighting data&quot;)

local RoundTimerTextObject = script:WaitForChild(&apos;RoundTimerText&apos;)
local GameTypeImageIdObject = script:WaitForChild(&apos;GameTypeImageId&apos;)
local CharacterScriptsModel = script:WaitForChild(&apos;CharacterScripts&apos;)
print(&quot;Loaded child objects&quot;)

local CurrentLoadout = {}
local PaidWeaponsEnabled = false
local CurrentGameTypeModel = nil
local SpawningDisabled = false

-- Functions --

-- Waits for one of the RBXScriptSignals to fire, returns result
local function WaitForFirstEvent(...)
&#9;local events = {...}
&#9;local totalEvents = #events
&#9;if totalEvents &gt; 0 then
&#9;&#9;local doneWaiting = Instance.new(&apos;BindableEvent&apos;)
&#9;&#9;for i = 1, totalEvents do
&#9;&#9;&#9;local event = events[i]
&#9;&#9;&#9;assert(type(event) == &apos;userdata&apos;, &quot;ERROR: WaitForFirstEvent: Event &quot; .. i .. &quot; is nil/invalid!&quot;)
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;doneWaiting:Fire(event:wait())
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;return doneWaiting.Event:wait()
&#9;end
end

local function CleanUpLooseParts()
&#9;for _, object in pairs(Workspace:GetChildren()) do
&#9;&#9;if object:IsA(&apos;Hat&apos;) or DEBRIS_NAMES[object.Name] then
&#9;&#9;&#9;object:Destroy()
&#9;&#9;end
&#9;end
end

local function ResetCameras() --TODO: Move this to cameraScript
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;if player:FindFirstChild(&apos;IntroPlayed&apos;) then
&#9;&#9;&#9;player[&apos;IntroPlayed&apos;]:Destroy()
&#9;&#9;&#9;tflag= player.PlayerGui:WaitForChild(&apos;cameraScript&apos;):WaitForChild(&apos;DoOuttro&apos;)
&#9;&#9;&#9;tflag.Value=not tflag.Value
&#9;&#9;end
&#9;end
end

local function WaitForChildCount(parent, count)
&#9;while #(parent:GetChildren()) &lt; count do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
end

local function OnCharacterAdded(player, character)
&#9;-- Clone CharacterScripts into character
&#9;for _, child in pairs(CharacterScriptsModel:GetChildren()) do
&#9;&#9;if child:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;child:Clone().Parent = character
&#9;&#9;end
&#9;end

&#9;-- Give player the CurrentLoadout and wait for it to appear in backpack
&#9;local toolCount = #CurrentLoadout
&#9;if toolCount &gt; 0 then
&#9;&#9;local backpack = player:WaitForChild(&apos;Backpack&apos;)
&#9;&#9;for _, tool in pairs(CurrentLoadout) do
&#9;&#9;&#9;tool:Clone().Parent = backpack
&#9;&#9;end
&#9;&#9;WaitForChildCount(backpack, toolCount)

&#9;&#9;if PaidWeaponsEnabled then
&#9;&#9;&#9;-- Give unlocked weapons and wait for them to appear in backpack
&#9;&#9;&#9;local playerModifiers = player:WaitForChild(&apos;PlayerModifiers&apos;)
&#9;&#9;&#9;local unlockedWeapons = playerModifiers:WaitForChild(&apos;UnlockedWeapons&apos;)
&#9;&#9;&#9;for _, unlockObject in pairs(unlockedWeapons:GetChildren()) do
&#9;&#9;&#9;&#9;local unlockName = unlockObject.Name
&#9;&#9;&#9;&#9;local dataObject = WeaponDataModel:FindFirstChild(unlockName)
&#9;&#9;&#9;&#9;if dataObject then
&#9;&#9;&#9;&#9;&#9;local tool = dataObject:FindFirstChild(unlockName)
&#9;&#9;&#9;&#9;&#9;if tool then
&#9;&#9;&#9;&#9;&#9;&#9;tool:Clone().Parent = backpack
&#9;&#9;&#9;&#9;&#9;&#9;toolCount = toolCount + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;WaitForChildCount(backpack, toolCount)
&#9;&#9;end

&#9;&#9;-- Share the total for Autoequip
&#9;&#9;local toolCountObject = Instance.new(&apos;IntValue&apos;)
&#9;&#9;toolCountObject.Name = &apos;ToolCount&apos;
&#9;&#9;toolCountObject.Value = toolCount
&#9;&#9;toolCountObject.Parent = character
&#9;end
end

-- When a new player joins, connect OnCharacterAdded
local function OnPlayerAdded(player)
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
end

local function LoadGameType(nextGameType)
&#9;local gameTypeClone = nextGameType:Clone()
&#9;gameTypeClone.Parent = CurrentGameTypeModel

&#9;-- Activate a possible script, and save a possible GameOver event to be returned
&#9;local gameTypeScript = gameTypeClone:FindFirstChild(gameTypeClone.Name)
&#9;local gameOverEvent = nil
&#9;if gameTypeScript then
&#9;&#9;if gameTypeScript:IsA(&apos;BaseScript&apos;) then
&#9;&#9;&#9;gameOverEvent = gameTypeScript:FindFirstChild(&apos;GameOver&apos;)
&#9;&#9;&#9;local dataReadyEvent = gameTypeScript:FindFirstChild(&apos;WaitForDataReady&apos;)
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;gameTypeScript.Disabled = false
&#9;&#9;&#9;end)
&#9;&#9;&#9;if dataReadyEvent then
&#9;&#9;&#9;&#9;dataReadyEvent.Event:wait()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local loadout = gameTypeClone:FindFirstChild(&apos;Loadout&apos;)
&#9;if loadout and loadout:IsA(&apos;StringValue&apos;) then
&#9;&#9;for toolName in loadout.Value:gmatch(&apos;%w+&apos;) do
&#9;&#9;&#9;local weaponData = WeaponDataModel:FindFirstChild(toolName)
&#9;&#9;&#9;if weaponData then
&#9;&#9;&#9;&#9;local tool = weaponData:FindFirstChild(toolName)
&#9;&#9;&#9;&#9;if tool then
&#9;&#9;&#9;&#9;&#9;table.insert(CurrentLoadout, tool)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local paidWeaponsEnabledObject = gameTypeClone:FindFirstChild(&apos;PaidWeaponsEnabled&apos;)
&#9;if paidWeaponsEnabledObject and paidWeaponsEnabledObject:IsA(&apos;BoolValue&apos;) then
&#9;&#9;PaidWeaponsEnabled = paidWeaponsEnabledObject.Value
&#9;end

&#9;local titleImageIdObject = gameTypeClone:FindFirstChild(&apos;TitleImageId&apos;)
&#9;if titleImageIdObject and titleImageIdObject:IsA(&apos;IntValue&apos;) then
&#9;&#9;GameTypeImageIdObject.Value = titleImageIdObject.Value
&#9;end

&#9;local disableSpawningObject = gameTypeClone:FindFirstChild(&apos;DisableSpawning&apos;)
&#9;if disableSpawningObject and disableSpawningObject:IsA(&apos;BoolValue&apos;) then
&#9;&#9;SpawningDisabled = disableSpawningObject.Value
&#9;end

&#9;-- Return the GameOver event and a callback to unload the Game Type
&#9;return gameOverEvent, function()
&#9;&#9;CurrentGameTypeModel:ClearAllChildren()
&#9;&#9;CurrentLoadout = {}
&#9;&#9;PaidWeaponsEnabled = false
&#9;&#9;GameTypeImageIdObject.Value = 0
&#9;&#9;SpawningDisabled = false
&#9;end
end

local function StartTimerAndWait(length, timerText)
&#9;StartTimer:Invoke(length)
&#9;if timerText then
&#9;&#9;RoundTimerTextObject.Value = timerText
&#9;end
&#9;OutOfTime.Event:wait()
end

-- Script Logic --

CurrentGameTypeModel = Instance.new(&apos;Model&apos;)
CurrentGameTypeModel.Name = &apos;CurrentGameType&apos;
CurrentGameTypeModel.Parent = script

print(&quot;Waiting for bindables...&quot;)
wait(10) -- Wait for bindables to be ready first :\

print(&quot;Ready!&quot;)

LevelLoaderInit:Invoke()
SpawnerInit:Invoke()

-- Connect to all players, future and present
PlayersService.PlayerAdded:connect(OnPlayerAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end

while true do
&#9;RoundTimerTextObject.Value = &quot;Loading Lobby&quot;

&#9;local lobbyEvent, unloadFunction = LoadGameType(LobbyGameType)

&#9;LoadLevel:Invoke(LobbyDataModel)
&#9;LevelLoaded.Event:wait()

&#9;SpawnerEnable:Invoke() --NOTE: Also spawns all players
&#9;RoundTimerTextObject.Value = &quot;Intermission&quot;

&#9;local votingResults = {lobbyEvent.Event:wait()}

&#9;unloadFunction()

&#9;SpawnerDisable:Invoke()
&#9;ClearAllPlayers:Invoke()

&#9;CleanUpLooseParts()
&#9;ResetCameras()

&#9;for i = 1, 6, 2 do
&#9;&#9;local chosenGameType, chosenLevel = votingResults[i], votingResults[i+1]

&#9;&#9;RoundTimerTextObject.Value = &quot;Get Ready!&quot;

&#9;&#9;local gameOverEvent, unloadGameTypeCallback = LoadGameType(chosenGameType)

&#9;&#9;if chosenLevel then
&#9;&#9;&#9;LoadLevel:Invoke(chosenLevel)
&#9;&#9;&#9;LevelLoaded.Event:wait()
&#9;&#9;end

&#9;&#9;StartTimerAndWait(TIME_TO_VIEW_MAP)

&#9;&#9;if not SpawningDisabled then
&#9;&#9;&#9;SpawnerEnable:Invoke() --NOTE: Also spawns all players
&#9;&#9;end

&#9;&#9;StartTimer:Invoke(TIME_TO_PLAY)
&#9;&#9;RoundTimerTextObject.Value = &quot;Time Remaining&quot;

&#9;&#9;local winningPlayer = nil
&#9;&#9;if gameOverEvent and gameOverEvent:IsA(&apos;BindableEvent&apos;) then
&#9;&#9;&#9;winningPlayer = WaitForFirstEvent(OutOfTime.Event, gameOverEvent.Event)
&#9;&#9;else
&#9;&#9;&#9;OutOfTime.Event:wait()
&#9;&#9;end

&#9;&#9;-- Round over --

&#9;&#9;unloadGameTypeCallback()

&#9;&#9;SpawnerDisable:Invoke()
&#9;&#9;ClearAllPlayers:Invoke()

&#9;&#9;CleanUpLooseParts()
&#9;&#9;ResetCameras()

&#9;&#9;ShowAndSaveStats:Invoke(winningPlayer)

&#9;&#9;StartTimerAndWait(TIME_TO_VIEW_STATS, &quot;Viewing Scores&quot;)

&#9;&#9;HideAndResetStats:Invoke()

&#9;&#9;TeamsService:ClearAllChildren()
&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;player.Neutral = true
&#9;&#9;end
&#9;end
end
</ProtectedString>
			</Properties>
			<Item class="StringValue" referent="RBX49">
				<Properties>
					<string name="Name">RoundTimerText</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX50">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">CharacterScripts</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="LocalScript" referent="RBX51">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RightArmCheck</string>
						<ProtectedString name="Source">local Character = script.Parent
local Torso = Character:WaitForChild(&apos;Torso&apos;)
local Humanoid = Character:WaitForChild(&apos;Humanoid&apos;)

-- Kill Humanoid on loss of Right Shoulder
Torso.ChildRemoved:connect(function(child)
&#9;wait(0) -- Needed for health check
&#9;if child.Name == &apos;Right Shoulder&apos; and Humanoid.Health &gt; 0 then
&#9;&#9;Humanoid.Health = 0
&#9;&#9;print(script.Name, &quot;killed&quot;, Character.Name, &quot;- No right arm!&quot;)
&#9;end
end)
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX52">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Autoequip</string>
						<ProtectedString name="Source">local PlayersService = Game:GetService(&apos;Players&apos;)

local Character = script.Parent
local Player = PlayersService:GetPlayerFromCharacter(Character)
local Backpack = Player:WaitForChild(&apos;Backpack&apos;)

local LastToolNameObject = Player:FindFirstChild(&apos;LastEquippedToolName&apos;)
if LastToolNameObject == nil then
&#9;LastToolNameObject = Instance.new(&apos;StringValue&apos;)
&#9;LastToolNameObject.Name = &apos;LastEquippedToolName&apos;
&#9;LastToolNameObject.Parent = Player
end

-- Update LastToolNameObject when a Tool is equipped
Character.ChildAdded:connect(function(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;LastToolNameObject.Value = child.Name
&#9;end
end)

-- Wait for all Tools to be added (by MainGameScript)
local toolCountObject = Character:WaitForChild(&apos;ToolCount&apos;)
while #(Backpack:GetChildren()) &lt; toolCountObject.Value do
&#9;Backpack.ChildAdded:wait()
end

wait(3.5) -- Wait for Backpack GUI to be ready :\

-- Skip autoequip if a Tool is already equipped
for _, child in pairs(Character:GetChildren()) do
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;return
&#9;end
end

-- Autoequip the last equipped Tool
local lastEquippedTool = Backpack:FindFirstChild(LastToolNameObject.Value)
if lastEquippedTool then
&#9;lastEquippedTool.Parent = Character
else -- Try to equip the first Tool
&#9;local tools = Backpack:GetChildren()
&#9;if #tools &gt; 0 then
&#9;&#9;tools[1].Parent = Character
&#9;end
end
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX53">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ForceFieldRemoval</string>
						<ProtectedString name="Source">-- Removes ForceField when equips a weapon or presses a key

local PlayersService = Game:GetService(&apos;Players&apos;)

local Character = script.Parent
local Player = PlayersService:GetPlayerFromCharacter(Character)
local PlayerMouse = Player:GetMouse()

local function RemoveForceField()
&#9;local forceField = Character:FindFirstChild(&apos;ForceField&apos;)
&#9;if forceField then
&#9;&#9;forceField:Destroy()
&#9;&#9;script:Destroy() -- Our work here is done
&#9;end
end

Character.ChildAdded:connect(function(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;RemoveForceField()
&#9;end
end)

PlayerMouse.KeyDown:connect(RemoveForceField)
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="IntValue" referent="RBX54">
				<Properties>
					<string name="Name">GameTypeImageId</string>
					<int name="Value">0</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX55">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HitFeedback</string>
				<ProtectedString name="Source">-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = script:WaitForChild(&apos;Hit&apos;)
Hit.Parent = nil --NOTE: Disables its child script

local BillboardGui = script:WaitForChild(&apos;DamageNumber&apos;)
BillboardGui.Parent = nil -- Keeps it private

local HitSound = script:WaitForChild(&apos;HitSound&apos;)
HitSound.Parent = nil -- Keeps it private

-----------------
--| Functions |--
-----------------

-- Clone hit and gui to every new character
local function OnCharacterAdded(player, character)
&#9;Hit:Clone().Parent = character.Humanoid
&#9;local billboardGuiClone = BillboardGui:Clone()
&#9;billboardGuiClone.PlayerToHideFrom = player
&#9;billboardGuiClone.Parent = character.Torso
end

-- Clone hit sound and connect to the player&apos;s current and future characters
local function OnPlayerAdded(player)
&#9;HitSound:Clone().Parent = player
&#9;if player.Character then
&#9;&#9;OnCharacterAdded(player, player.Character)
&#9;end
&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;OnCharacterAdded(player, character)
&#9;end)
end

--------------------
--| Script Logic |--
--------------------

-- Connect to all current and future players
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end
PlayersService.PlayerAdded:connect(OnPlayerAdded)

-----------------
--| Reference |--
-----------------

--[[
* This is an example of how to use the bindable from a Tool script, just replace the ALL_CAPS variables.
* NOTE: This will not work if called from a LocalScript. If this is desired, let me know.

local hitBindable = HUMANOID:FindFirstChild(&apos;Hit&apos;)
if hitBindable then
&#9;hitBindable:Invoke(DAMAGE, CREATOR_TAG)
else
&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
end

]]
</ProtectedString>
			</Properties>
			<Item class="BindableFunction" referent="RBX56">
				<Properties>
					<string name="Name">Hit</string>
				</Properties>
				<Item class="Script" referent="RBX57">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HitScript</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TAG_LENGTH = 4 -- Seconds until tags are deleted

local START_OFFSET = Vector3.new(0, 2, 0) -- Studs
local DESIRED_HEIGHT = 4 -- Studs
local RISE_RATE = Vector3.new(0, 0.2, 0) -- Studs per step
local STAY_TIME = 2 -- Seconds
local FADE_TIME = 0.5 -- Seconds
local ONE_STEP = 1 / 30 -- Seconds

local TOTAL_TIME = STAY_TIME + FADE_TIME
local FADE_STEPS = FADE_TIME * (1 / ONE_STEP)

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = script.Parent

while not Hit.Parent:IsA(&apos;Humanoid&apos;) do wait(ONE_STEP) end --NOTE: Wait for correct context

local Humanoid = Hit.Parent

local MyPlayer = PlayersService:GetPlayerFromCharacter(Humanoid.Parent)

local BillboardGui = Humanoid.Torso:WaitForChild(&apos;DamageNumber&apos;)
local TextLabel = BillboardGui:WaitForChild(&apos;TextLabel&apos;)

local Animating = false
local HitTime = 0

-----------------
--| Functions |--
-----------------

-- Returns the closest whole number
local function Round(number)
&#9;local int, rem = math.modf(number)
&#9;local r = (math.abs(rem) &lt; 0.5 and 0 or 1)
&#9;return int + (number &lt; 0 and -r or r)
end

local function AnimateDamageNumber()
&#9;if not Animating then
&#9;&#9;Animating = true

&#9;&#9;BillboardGui.Enabled = true

&#9;&#9;-- Rise up
&#9;&#9;BillboardGui.StudsOffset = START_OFFSET
&#9;&#9;while BillboardGui.StudsOffset.y &lt; DESIRED_HEIGHT do
&#9;&#9;&#9;BillboardGui.StudsOffset = BillboardGui.StudsOffset + RISE_RATE
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end

&#9;&#9;-- Wait or fade
&#9;&#9;repeat
&#9;&#9;&#9;local timeSinceDamage = tick() - HitTime
&#9;&#9;&#9;if timeSinceDamage &gt; STAY_TIME then
&#9;&#9;&#9;&#9;TextLabel.TextTransparency = TextLabel.TextTransparency + (1 / FADE_STEPS)
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;until timeSinceDamage &gt;= TOTAL_TIME

&#9;&#9;TextLabel.TextTransparency = 0
&#9;&#9;TextLabel.Text = &apos;&apos;&#9;
&#9;&#9;BillboardGui.Enabled = false

&#9;&#9;Animating = false
&#9;else
&#9;&#9;TextLabel.TextTransparency = 0
&#9;end
end

local function OnHit(damage, tag)
&#9;if tag and tag.Value and tag.Value:IsA(&apos;Player&apos;) then

&#9;&#9;-- Check if we were hit by ourself, or someone else when we&apos;re neutral, or an enemy when we&apos;re not
&#9;&#9;if tag.Value == MyPlayer or MyPlayer.Neutral or tag.Value.TeamColor ~= MyPlayer.TeamColor then

&#9;&#9;&#9;-- Apply the tag if we are untagged or tagged by ourself
&#9;&#9;&#9;local existingTag = Humanoid:FindFirstChild(tag.Name)
&#9;&#9;&#9;if not existingTag or existingTag.Value == MyPlayer then
&#9;&#9;&#9;&#9;while Humanoid:FindFirstChild(tag.Name) do
&#9;&#9;&#9;&#9;&#9;Humanoid[tag.Name]:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local tagClone = tag:Clone()
&#9;&#9;&#9;&#9;DebrisService:AddItem(tagClone, TAG_LENGTH)
&#9;&#9;&#9;&#9;tagClone.Parent = Humanoid
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Damage Humanoid
&#9;&#9;&#9;local healthBefore = Humanoid.Health
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;local healthAfter = Humanoid.Health

&#9;&#9;&#9;-- If any damage was done, show hit feedback
&#9;&#9;&#9;if healthBefore - healthAfter ~= 0 then
&#9;&#9;&#9;&#9;-- Auditory hit feedback (for the attacker)
&#9;&#9;&#9;&#9;local attackerHitSound = tag.Value:FindFirstChild(&apos;HitSound&apos;)
&#9;&#9;&#9;&#9;if attackerHitSound then
&#9;&#9;&#9;&#9;&#9;attackerHitSound:Play()
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- Visual hit feedback
&#9;&#9;&#9;&#9;if healthAfter &gt; 0 then
&#9;&#9;&#9;&#9;&#9;TextLabel.Text = Round(damage)
&#9;&#9;&#9;&#9;&#9;HitTime = tick()
&#9;&#9;&#9;&#9;&#9;Spawn(AnimateDamageNumber)
&#9;&#9;&#9;&#9;else -- Humanoid dead
&#9;&#9;&#9;&#9;&#9;BillboardGui.Enabled = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;Spawn(function() assert(false, &quot;ERROR: Invalid tag!&quot;) end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Hit.OnInvoke = OnHit
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX58">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HitLocalScript</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TAG_LENGTH = 4 -- Seconds until tags are deleted

local START_OFFSET = Vector3.new(0, 2, 0) -- Studs
local DESIRED_HEIGHT = 4 -- Studs
local RISE_RATE = Vector3.new(0, 0.2, 0) -- Studs per step
local STAY_TIME = 2 -- Seconds
local FADE_TIME = 0.5 -- Seconds
local ONE_STEP = 1 / 30 -- Seconds

local TOTAL_TIME = STAY_TIME + FADE_TIME
local FADE_STEPS = FADE_TIME * (1 / ONE_STEP)

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Hit = script.Parent

while not Hit.Parent:IsA(&apos;Humanoid&apos;) do wait(ONE_STEP) end --NOTE: Wait for correct context

local Humanoid = Hit.Parent

local MyPlayer = PlayersService:GetPlayerFromCharacter(Humanoid.Parent)

local BillboardGui = Humanoid.Torso:WaitForChild(&apos;DamageNumber&apos;)
local TextLabel = BillboardGui:WaitForChild(&apos;TextLabel&apos;)

local Animating = false
local HitTime = 0

-----------------
--| Functions |--
-----------------

-- Returns the closest whole number
local function Round(number)
&#9;local int, rem = math.modf(number)
&#9;local r = (math.abs(rem) &lt; 0.5 and 0 or 1)
&#9;return int + (number &lt; 0 and -r or r)
end

local function AnimateDamageNumber()
&#9;if not Animating then
&#9;&#9;Animating = true

&#9;&#9;BillboardGui.Enabled = true

&#9;&#9;-- Rise up
&#9;&#9;BillboardGui.StudsOffset = START_OFFSET
&#9;&#9;while BillboardGui.StudsOffset.y &lt; DESIRED_HEIGHT do
&#9;&#9;&#9;BillboardGui.StudsOffset = BillboardGui.StudsOffset + RISE_RATE
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end

&#9;&#9;-- Wait or fade
&#9;&#9;repeat
&#9;&#9;&#9;local timeSinceDamage = tick() - HitTime
&#9;&#9;&#9;if timeSinceDamage &gt; STAY_TIME then
&#9;&#9;&#9;&#9;TextLabel.TextTransparency = TextLabel.TextTransparency + (1 / FADE_STEPS)
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;until timeSinceDamage &gt;= TOTAL_TIME

&#9;&#9;TextLabel.TextTransparency = 0
&#9;&#9;TextLabel.Text = &apos;&apos;&#9;
&#9;&#9;BillboardGui.Enabled = false

&#9;&#9;Animating = false
&#9;else
&#9;&#9;TextLabel.TextTransparency = 0
&#9;end
end

local function OnHit(damage, tag)
&#9;if tag and tag.Value and tag.Value:IsA(&apos;Player&apos;) then

&#9;&#9;-- Check if we were hit by ourself, or someone else when we&apos;re neutral, or an enemy when we&apos;re not
&#9;&#9;if tag.Value == MyPlayer or MyPlayer.Neutral or tag.Value.TeamColor ~= MyPlayer.TeamColor then

&#9;&#9;&#9;-- Apply the tag if we are untagged or tagged by ourself
&#9;&#9;&#9;local existingTag = Humanoid:FindFirstChild(tag.Name)
&#9;&#9;&#9;if not existingTag or existingTag.Value == MyPlayer then
&#9;&#9;&#9;&#9;while Humanoid:FindFirstChild(tag.Name) do
&#9;&#9;&#9;&#9;&#9;Humanoid[tag.Name]:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local tagClone = tag:Clone()
&#9;&#9;&#9;&#9;DebrisService:AddItem(tagClone, TAG_LENGTH)
&#9;&#9;&#9;&#9;tagClone.Parent = Humanoid
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Damage Humanoid
&#9;&#9;&#9;local healthBefore = Humanoid.Health
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;local healthAfter = Humanoid.Health

&#9;&#9;&#9;-- If any damage was done, show hit feedback
&#9;&#9;&#9;if healthBefore - healthAfter ~= 0 then
&#9;&#9;&#9;&#9;-- Auditory hit feedback (for the attacker)
&#9;&#9;&#9;&#9;local attackerHitSound = tag.Value:FindFirstChild(&apos;HitSound&apos;)
&#9;&#9;&#9;&#9;if attackerHitSound then
&#9;&#9;&#9;&#9;&#9;attackerHitSound:Play()
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- Visual hit feedback
&#9;&#9;&#9;&#9;if healthAfter &gt; 0 then
&#9;&#9;&#9;&#9;&#9;TextLabel.Text = Round(damage)
&#9;&#9;&#9;&#9;&#9;HitTime = tick()
&#9;&#9;&#9;&#9;&#9;Spawn(AnimateDamageNumber)
&#9;&#9;&#9;&#9;else -- Humanoid dead
&#9;&#9;&#9;&#9;&#9;BillboardGui.Enabled = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;Spawn(function() assert(false, &quot;ERROR: Invalid tag!&quot;) end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Hit.OnInvoke = OnHit
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="BillboardGui" referent="RBX59">
				<Properties>
					<bool name="Active">false</bool>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">false</bool>
					<bool name="Enabled">true</bool>
					<Vector3 name="ExtentsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">DamageNumber</string>
					<Ref name="PlayerToHideFrom">null</Ref>
					<UDim2 name="Size">
						<XS>2</XS>
						<XO>0</XO>
						<YS>2</YS>
						<YO>0</YO>
					</UDim2>
					<Vector2 name="SizeOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector3 name="StudsOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
				<Item class="TextLabel" referent="RBX60">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4278190080</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">9</token>
						<string name="Name">TextLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294901760</Color3>
						<bool name="TextScaled">true</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX61">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">HitSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=95522378</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX62">
		<Properties>
			<string name="Name">StarterPack</string>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX63">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ShowDevelopmentGui">true</bool>
		</Properties>
		<Item class="ScreenGui" referent="RBX64">
			<Properties>
				<string name="Name">ActionButtonGui</string>
			</Properties>
			<Item class="LocalScript" referent="RBX65">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ActionButtonGuiScript</string>
					<ProtectedString name="Source">-------------------
--| Touch Check |--
-------------------

if not Game:GetService(&apos;UserInputService&apos;).TouchEnabled then return end

-----------------
--| Constants |--
-----------------

local DOWN_IMAGE = &apos;http://www.roblox.com/asset/?id=97166756&apos;

local ICON_SUBSTITUTION_TABLE = {Sword = &apos;http://www.roblox.com/asset/?id=96601703&apos;}

local CROSSHAIR_ENABLED_TOOLS = {Superball = 1, Slingshot = 1, Bomb = 1, RocketLauncher = 1, PipeBomb = 1, Taser = 1, BattleBottle = 1}
-- The above Tools will display the crosshair and receive data on its position when the Action Button is used

local DATA_OBJECT_NAME = &apos;ActionButtonData&apos;
local BINDABLE_NAME = &apos;GetTargetPosition&apos;
--NOTE: Changing the above names requires changing all Tools (See Reference, below)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local ActionButtonGui = script.Parent
local PlayerGui = ActionButtonGui.Parent
local Player = PlayerGui.Parent

local ActionButtonFrame = WaitForChild(ActionButtonGui, &apos;ActionButtonFrame&apos;)
local ActionButton = WaitForChild(ActionButtonFrame, &apos;ActionButton&apos;)
local ToolIcon = WaitForChild(ActionButtonFrame, &apos;ToolIcon&apos;)
local ReloadingIcon = WaitForChild(ActionButtonFrame, &apos;ReloadingIcon&apos;)

local CrosshairFrame = WaitForChild(ActionButtonGui, &apos;CrosshairFrame&apos;)

local BindableLocalScript = WaitForChild(script, &apos;BindableLocalScript&apos;)
local BindableScript = WaitForChild(script, &apos;BindableScript&apos;)

local Backpack = WaitForChild(Player, &apos;Backpack&apos;)

local PlayerMouse = Player:GetMouse()

local UpImage = ActionButton.Image

local OriginalSize = ActionButtonFrame.Size
local OriginalPosition = ActionButtonFrame.Position
local SmallScreenPosition = UDim2.new(1 - ActionButtonFrame.Size.X.Scale * 1.25 - 0.01, 0, 0.01, 0) -- Top right
local SmallScreenSize = UDim2.new(ActionButtonFrame.Size.X.Scale * 1.25, 0, ActionButtonFrame.Size.Y.Scale * 1.25, 0) -- 25% bigger

local ButtonDown = false

local DataObjectBase = nil

local ToolChangedConnection = nil
local BackpackChildAddedConnection = nil
local BackpackChildRemovedConnection = nil

-----------------
--| Functions |--
-----------------

local function MakeBaseObject()
&#9;local buttonDataObject = Instance.new(&apos;StringValue&apos;)
&#9;buttonDataObject.Name = DATA_OBJECT_NAME

&#9;local bindable = Instance.new(&apos;BindableFunction&apos;)
&#9;bindable.Name = BINDABLE_NAME
&#9;bindable.Parent = buttonDataObject

&#9;local bindableLocalScriptClone = BindableLocalScript:Clone()
&#9;bindableLocalScriptClone.Disabled = false
&#9;bindableLocalScriptClone.Parent = bindable

&#9;local bindableScriptClone = BindableScript:Clone()
&#9;bindableScriptClone.Disabled = false
&#9;bindableScriptClone.Parent = bindable

&#9;return buttonDataObject
end

local function ClearToolConnection()
&#9;if ToolChangedConnection then
&#9;&#9;ToolChangedConnection:disconnect()
&#9;&#9;ToolChangedConnection = nil
&#9;end
end

-- Returns the first Tool found in character
local function FindEquippedTool(character)
&#9;for _, child in pairs(character:GetChildren()) do
&#9;&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;return child
&#9;&#9;end
&#9;end
end

-- Waits for a new character to be added if the current one is invalid
-- (Ensures that you don&apos;t have the old dead character after a respawn)
local function WaitForValidCharacter(player)
&#9;local character = player.Character
&#9;if not character or not character.Parent or not character:FindFirstChild(&apos;Humanoid&apos;) or character.Humanoid.Health &lt;= 0 then
&#9;&#9;player.CharacterAdded:wait()
&#9;&#9;wait(0) --NOTE: Necessary for server scripts executing on the same event
&#9;&#9;character = player.Character
&#9;end
&#9;return character
end

-- When Action Button is pressed or depressed, update images and send button state information to the Player&apos;s equipped Tool
-- For crosshair-enabled Tools, screen information is also serialized and sent
local function OnButton1Changed(down)
&#9;ButtonDown = down
&#9;ActionButton.Image = down and DOWN_IMAGE or UpImage
&#9;if Player.Character then
&#9;&#9;local equippedTool = FindEquippedTool(Player.Character)
&#9;&#9;if equippedTool then
&#9;&#9;&#9;local dataObject = equippedTool:FindFirstChild(DATA_OBJECT_NAME)
&#9;&#9;&#9;if dataObject then
&#9;&#9;&#9;&#9;local dataString = down and &apos;v&apos; or &apos;^&apos;
&#9;&#9;&#9;&#9;if CROSSHAIR_ENABLED_TOOLS[equippedTool.Name] then
&#9;&#9;&#9;&#9;&#9;CrosshairFrame.Visible = true
&#9;&#9;&#9;&#9;&#9;local screenPosition = CrosshairFrame.AbsolutePosition + (CrosshairFrame.AbsoluteSize / 2)
&#9;&#9;&#9;&#9;&#9;local screenSize = ActionButtonGui.AbsoluteSize
&#9;&#9;&#9;&#9;&#9;dataString = dataString .. tostring(screenPosition) .. &apos;;&apos; .. tostring(screenSize)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;dataObject.Value = dataString
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnPlayerMouseChanged(down)
&#9;do -- Ignore click if over Action Button
&#9;&#9;local mouseX = PlayerMouse.X
&#9;&#9;local mouseY = PlayerMouse.Y
&#9;&#9;local topLeft = ActionButtonFrame.AbsolutePosition
&#9;&#9;local bottomRight = topLeft + ActionButtonFrame.AbsoluteSize
&#9;&#9;if (mouseX &gt; topLeft.X and mouseX &lt; bottomRight.X) and (mouseY &gt; topLeft.Y and mouseY &lt; bottomRight.Y) then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;if down then
&#9;&#9;CrosshairFrame.Visible = false
&#9;elseif ButtonDown then -- Letting go after dragging off button
&#9;&#9;OnButton1Changed(false)
&#9;end
end

-- Fires when a Tool is unequipped normally
local function OnBackpackChildAdded(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;local tool = child

&#9;&#9;ToolIcon.Image = &apos;&apos; -- Remove any icon
&#9;&#9;ReloadingIcon.Visible = false
&#9;&#9;CrosshairFrame.Visible = false

&#9;&#9;-- Remove data object(s) from Tool
&#9;&#9;while tool:FindFirstChild(DATA_OBJECT_NAME) do
&#9;&#9;&#9;tool[DATA_OBJECT_NAME]:Destroy()
&#9;&#9;end

&#9;&#9;-- Remove the saved connection
&#9;&#9;ClearToolConnection()
&#9;end
end

-- Fires when a Tool is equipped normally
local function OnBackpackChildRemoved(child)
&#9;if child:IsA(&apos;Tool&apos;) then
&#9;&#9;local tool = child

&#9;&#9;ToolIcon.Image = ICON_SUBSTITUTION_TABLE[tool.Name] or tool.TextureId
&#9;&#9;ReloadingIcon.Visible = not tool.Enabled
&#9;&#9;if CROSSHAIR_ENABLED_TOOLS[tool.Name] then
&#9;&#9;&#9;CrosshairFrame.Visible = true
&#9;&#9;end

&#9;&#9;-- Add data object to Tool (if necessary)
&#9;&#9;if not tool:FindFirstChild(DATA_OBJECT_NAME) then
&#9;&#9;&#9;DataObjectBase:Clone().Parent = tool
&#9;&#9;end

&#9;&#9;-- Connect to Changed and save the connection
&#9;&#9;ClearToolConnection() -- Do this first, just in case
&#9;&#9;ToolChangedConnection = tool.Changed:connect(function(property)
&#9;&#9;&#9;if property == &apos;Enabled&apos; then
&#9;&#9;&#9;&#9;ReloadingIcon.Visible = not tool.Enabled
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

local function CleanUp(character)
&#9;-- Clean up / reset images
&#9;local equippedTool = FindEquippedTool(character)
&#9;if equippedTool then
&#9;&#9;OnBackpackChildAdded(equippedTool)
&#9;else
&#9;&#9;ToolIcon.Image = &apos;&apos;
&#9;&#9;ReloadingIcon.Visible = false
&#9;&#9;CrosshairFrame.Visible = false
&#9;end

&#9;-- Disconnect Backpack events
&#9;BackpackChildAddedConnection:disconnect()
&#9;BackpackChildRemovedConnection:disconnect()
end

-- Updates button size and position based on screen size
local function AdjustForScreenSize()
&#9;if ActionButtonGui.AbsoluteSize.X &lt; 1024 then
&#9;&#9;ActionButtonFrame.Size = SmallScreenSize
&#9;&#9;ActionButtonFrame.Position = SmallScreenPosition
&#9;else
&#9;&#9;ActionButtonFrame.Size = OriginalSize
&#9;&#9;ActionButtonFrame.Position = OriginalPosition
&#9;end
end

--------------------
--| Script Logic |--
--------------------

DataObjectBase = MakeBaseObject()

ContentProviderService:Preload(DOWN_IMAGE)

ActionButton.MouseButton1Down:connect(function() OnButton1Changed(true) end)
ActionButton.MouseButton1Up:connect(function() OnButton1Changed(false) end)

PlayerMouse.Button1Down:connect(function() OnPlayerMouseChanged(true) end)
PlayerMouse.Button1Up:connect(function() OnPlayerMouseChanged(false) end)

BackpackChildAddedConnection = Backpack.ChildAdded:connect(OnBackpackChildAdded)
BackpackChildRemovedConnection = Backpack.ChildRemoved:connect(OnBackpackChildRemoved)

-- Automatically adjust when the screen changes
AdjustForScreenSize()
ActionButtonGui.Changed:connect(function(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;AdjustForScreenSize()
&#9;end
end)

ActionButtonFrame.Visible = true

-- Make sure we have the newly spawned character and not the old dead one
local character = WaitForValidCharacter(Player)

-- Check for tools that may already be equipped
local autoEquippedTool = FindEquippedTool(character)
if autoEquippedTool then
&#9;OnBackpackChildRemoved(autoEquippedTool)
end

-- Call CleanUp on character removal or death
character.Changed:connect(function(property)
&#9;if property == &apos;Parent&apos; and character.Parent == nil then
&#9;&#9;CleanUp(character)
&#9;end
end)
local humanoid = WaitForChild(character, &apos;Humanoid&apos;)
humanoid.Died:connect(function()
&#9;CleanUp(character)
end)

-----------------
--| Reference |--
-----------------

--[[
* One of the following code blocks must be adapted into a Tool for it to work with the Action Button.
* Both blocks expect a function OnActivated() which it will call when the button is down (or up, if you change &apos;v&apos; to &apos;^&apos;).

* This block is for Tools that don&apos;t need a target position:

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

* This block will pass a target position to OnActivated(), for Tools that throw or shoot:
* (Remember to add the Tool&apos;s name to the list of crosshair-enabled Tools at the top)

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

* Don&apos;t forget to connect the function:

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)

]]
</ProtectedString>
				</Properties>
				<Item class="Script" referent="RBX66">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BindableScript</string>
						<ProtectedString name="Source">--NOTE: This script and its children are only necessary because bindables cannot be called from server to client (and vice-versa)

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local GetTargetPosition = script.Parent

local CameraCFrameObject = WaitForChild(script, &apos;CameraCFrame&apos;)
local CameraFOVObject = WaitForChild(script, &apos;CameraFOV&apos;)

GetTargetPosition.OnInvoke = function(screenPosition, screenSize, ignoreList)
&#9;local cameraCFrame = CameraCFrameObject.Value
&#9;local cameraFOV = CameraFOVObject.Value
&#9;local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(cameraFOV) / 2))
&#9;local direction = Vector3.new(screenPosition.x - (screenSize.x / 2), (screenSize.y / 2) - screenPosition.y, -imagePlaneDepth)
&#9;local ray = Ray.new(cameraCFrame.p, (cameraCFrame:vectorToWorldSpace(direction)).unit * 999)
&#9;local _, targetPosition = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {})
&#9;return targetPosition
end
</ProtectedString>
					</Properties>
					<Item class="CFrameValue" referent="RBX67">
						<Properties>
							<string name="Name">CameraCFrame</string>
							<CoordinateFrame name="Value">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX68">
						<Properties>
							<string name="Name">CameraFOV</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX69">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ValueUpdater</string>
							<ProtectedString name="Source">local ONE_STEP = 1/30

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local ServerScript = script.Parent
local CameraCFrameObject = WaitForChild(ServerScript, &apos;CameraCFrame&apos;)
local CameraFOVObject = WaitForChild(ServerScript, &apos;CameraFOV&apos;)

local Camera = Workspace.CurrentCamera
CameraCFrameObject.Value = Camera.CoordinateFrame
CameraFOVObject.Value = Camera.FieldOfView

--[[ NOTE: Can&apos;t do event-based because Camera CFrame does not update when you zoom nor when you move the character
Camera.Changed:connect(function(property)
&#9;print(&apos;Camera Changed&apos;)
&#9;if property == &apos;CoordinateFrame&apos; then
&#9;&#9;CameraCFrameObject.Value = Camera.CoordinateFrame
&#9;elseif property == &apos;FieldOfView&apos; then
&#9;&#9;CameraFOVObject.Value = Camera.FieldOfView
&#9;end
end)
--]]

while true do
&#9;CameraCFrameObject.Value = Camera.CoordinateFrame
&#9;CameraFOVObject.Value = Camera.FieldOfView
&#9;wait(ONE_STEP)
end
</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX70">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BindableLocalScript</string>
						<ProtectedString name="Source">local GetTargetPosition = script.Parent

local Camera = Workspace.CurrentCamera

GetTargetPosition.OnInvoke = function(screenPosition, screenSize, ignoreList)
&#9;local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(Camera.FieldOfView) / 2))
&#9;local direction = Vector3.new(screenPosition.x - (screenSize.x / 2), (screenSize.y / 2) - screenPosition.y, -imagePlaneDepth)
&#9;local ray = Ray.new(Camera.CoordinateFrame.p, (Camera.CoordinateFrame:vectorToWorldSpace(direction)).unit * 999)
&#9;local _, targetPosition = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {})
&#9;return targetPosition
end
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX71">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ActionButtonFrame</string>
					<UDim2 name="Position">
						<XS>0.873046875</XS>
						<XO>0</XO>
						<YS>0.713541687</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.09765625</XS>
						<XO>0</XO>
						<YS>0.09765625</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">1</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">10</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX72">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><null></null></Content>
						<string name="Name">ToolIcon</string>
						<UDim2 name="Position">
							<XS>0.174999997</XS>
							<XO>0</XO>
							<YS>0.174999997</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.649999976</XS>
							<XO>0</XO>
							<YS>0.649999976</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX73">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97166793</url></Content>
						<string name="Name">ReloadingIcon</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX74">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97166444</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">ActionButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX75">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">CrosshairFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-16</XO>
						<YS>0.400000006</YS>
						<YO>-16</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>32</XO>
						<YS>0</YS>
						<YO>32</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">10</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX76">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97244912</url></Content>
						<string name="Name">Crosshair</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX77">
			<Properties>
				<string name="Name">DebugGui</string>
			</Properties>
			<Item class="TextLabel" referent="RBX78">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">0</token>
					<token name="FontSize">2</token>
					<string name="Name">TouchDeviceCountText</string>
					<UDim2 name="Position">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>0.0500000007</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>125</XO>
						<YS>0</YS>
						<YO>20</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">Initializing...</string>
					<Color3 name="TextColor3">4278190080</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="LocalScript" referent="RBX79">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TouchDeviceCountScript</string>
						<ProtectedString name="Source">local Ipad = Game:GetService(&apos;UserInputService&apos;).TouchEnabled

local TouchDeviceCountText = script.Parent
local DebugGui = TouchDeviceCountText.Parent
local PlayerGui = DebugGui.Parent
local Player = PlayerGui.Parent

local DebugServerScript = Workspace:WaitForChild(&apos;DebugServerScript&apos;)
local TouchDeviceCountObject = DebugServerScript:WaitForChild(&apos;TouchDeviceCount&apos;)

local SuperUsersObject = DebugGui:WaitForChild(&apos;SuperUsers&apos;)

local function IsSuperUser(playerName)
&#9;for name in SuperUsersObject.Value:gmatch(&apos;%w+&apos;) do
&#9;&#9;if name == playerName then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

local function UpdateText()
&#9;TouchDeviceCountText.Text = &quot;Touch Devices: &quot; .. TouchDeviceCountObject.Value
end

-- Report to the server if we haven&apos;t already
if Ipad then
&#9;local alreadySent = false
&#9;for _, child in pairs(TouchDeviceCountObject:GetChildren()) do
&#9;&#9;if child:IsA(&apos;ObjectValue&apos;) and child.Value == Player then
&#9;&#9;&#9;alreadySent = true
&#9;&#9;end
&#9;end
&#9;if not alreadySent then
&#9;&#9;local objectValue = Instance.new(&apos;ObjectValue&apos;)
&#9;&#9;objectValue.Value = Player
&#9;&#9;objectValue.Parent = TouchDeviceCountObject
&#9;end
end

if IsSuperUser(Player.Name) then
&#9;TouchDeviceCountObject.Changed:connect(UpdateText)
&#9;UpdateText()
&#9;TouchDeviceCountText.Visible = true
end
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="TextLabel" referent="RBX80">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">0</token>
					<token name="FontSize">2</token>
					<string name="Name">ScreenSizeText</string>
					<UDim2 name="Position">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>0.100000001</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>125</XO>
						<YS>0</YS>
						<YO>20</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">Initializing...</string>
					<Color3 name="TextColor3">4278190080</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="LocalScript" referent="RBX81">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ScreenSizeScript</string>
						<ProtectedString name="Source">local ScreenSizeText = script.Parent
local DebugGui = ScreenSizeText.Parent
local PlayerGui = DebugGui.Parent
local Player = PlayerGui.Parent

local SuperUsersObject = DebugGui:WaitForChild(&apos;SuperUsers&apos;)

local function IsSuperUser(playerName)
&#9;for name in SuperUsersObject.Value:gmatch(&apos;%w+&apos;) do
&#9;&#9;if name == playerName then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

if not IsSuperUser(Player.Name) then
&#9;return
end

local function Update()
&#9;local size = DebugGui.AbsoluteSize
&#9;ScreenSizeText.Text = &quot;Size: &quot; .. size.X .. &quot;x&quot; .. size.Y
end

local function OnScreenGuiChanged(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;Update()
&#9;end
end

DebugGui.Changed:connect(OnScreenGuiChanged)
Update()
ScreenSizeText.Visible = true
</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="StringValue" referent="RBX82">
				<Properties>
					<string name="Name">SuperUsers</string>
					<string name="Value">OnlyTwentyCharacters, Sorcus, Games, Player1, GongfuTiger</string>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX83">
			<Properties>
				<string name="Name">FragFeedGui</string>
			</Properties>
			<Item class="Frame" referent="RBX84">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">FragFeedFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0.400000036</YS>
						<YO>-22</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>500</XO>
						<YS>0</YS>
						<YO>150</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX85">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FragFeedGuiScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DELIMITER = &apos;#&apos; -- Separates words (NOTE: Custom input text must not contain this)
local NOGAP_TAG = &apos;_&apos; -- Placed at the front of a custom word, this will remove the gap between this and the last word
--NOTE: These must match up with the MainScript (FragFeed)

local LABEL_GAP = 5
local DISPLAY_DURATION = 7
local VERTICAL_SCALE_AMOUNT = 0.55
local TWEEN_DURATION = 0.75
local NEW_ELEMENT_VERTICAL_SCALE = 0.90
local VERTICAL_GAP= .4

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local FragFeedGui = script.Parent
local FragFeedFrame = WaitForChild(FragFeedGui, &apos;FragFeedFrame&apos;)

local Events = {}

local Scrolling  = false
local Initalized = false

local TextLabelBase = Instance.new(&apos;TextLabel&apos;) do
&#9;TextLabelBase.BackgroundTransparency = 1.0
&#9;TextLabelBase.Font = Enum.Font.ArialBold
&#9;TextLabelBase.TextColor3=Color3.new(0,0,0)
&#9;TextLabelBase.FontSize = Enum.FontSize.Size24
&#9;TextLabelBase.TextStrokeColor3=Color3.new(1,1,1)
&#9;TextLabelBase.TextStrokeTransparency=0
end

local ImageLabelBase = Instance.new(&apos;ImageLabel&apos;) do
&#9;ImageLabelBase.BackgroundTransparency = 1.0
&#9;ImageLabelBase.Size = UDim2.new(0, 50, 0, 50)
end

-----------------
--| Functions |--
-----------------


function FadeOut(tframe,aliveTime)
&#9;--[[
&#9;local start=time()
&#9;while time()-start&lt;aliveTime do
&#9;&#9;local nalpha= (time()-start)/aliveTime
&#9;&#9;for _,i in pairs(tframe:GetChildren()) do
&#9;&#9;&#9;if i:IsA(&apos;TextLabel&apos;) then
&#9;&#9;&#9;&#9;i.TextTransparency=nalpha
&#9;&#9;&#9;&#9;i.TextStrokeTransparency=nalpha
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
&#9;--]]
&#9;tframe:TweenPosition(UDim2.new(-2, 0, tframe.Position.Y.Scale,tframe.Position.Y.Offset), &quot;Out&quot;, &quot;Quad&quot;, aliveTime, true)
end

function FragFeedChildAdded(child)
&#9;if not child:IsA(&apos;StringValue&apos;) then return end

&#9;-- Read in the input string and separate it into words
&#9;local inputWords = {}
&#9;for word in child.Value:gmatch(&apos;[^&apos; .. DELIMITER ..&apos;]+&apos;) do
&#9;&#9;table.insert(inputWords, word)
&#9;end

&#9;-- Wait for scrolling (within other calls) to finish
&#9;while Scrolling do
&#9;&#9;wait()
&#9;end

&#9;-- Scroll existing events up a level to make room for the new event
&#9;Scrolling  = true
&#9;local tweenTime = TWEEN_DURATION
&#9;if not Initalized then tweenTime = 0.10 end
&#9;for _, event in pairs(Events) do
&#9;&#9;if event then
&#9;&#9;&#9;for _, field in pairs(event) do
&#9;&#9;&#9;&#9;if field and field.Parent then
&#9;&#9;&#9;&#9;&#9;field:TweenPosition(field.Position + UDim2.new(0, 0, -(VERTICAL_SCALE_AMOUNT+VERTICAL_GAP), 0), 
&#9;&#9;&#9;&#9;&#9;&#9;&quot;Out&quot;, &quot;Quad&quot;, tweenTime, true)
&#9;&#9;&#9;&#9;&#9;if field.Position.Y.Scale &lt; -VERTICAL_SCALE_AMOUNT then
&#9;&#9;&#9;&#9;&#9;&#9;field:Destroy()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;wait(tweenTime)
&#9;Scrolling  = false


&#9;local tframe=Instance.new(&apos;Frame&apos;)
&#9;
&#9;tframe.Size=UDim2.new(0, 500, 0, 50)
&#9;tframe.BackgroundTransparency=1
&#9;tframe.Parent=FragFeedFrame
&#9;tframe.Position= UDim2.new(-1, 0, NEW_ELEMENT_VERTICAL_SCALE, 0 - (tframe.Size.Y.Offset / 2))

&#9;-- Create and place all the elements that make up the event line
&#9;local eventLine = {}
&#9;do
&#9;&#9;
&#9;&#9;local lastElement = nil
&#9;&#9;for _, word in pairs(inputWords) do
&#9;&#9;&#9;if word then
&#9;&#9;&#9;&#9;-- Try word as a color (formatted like this: [1032])
&#9;&#9;&#9;&#9;local match, n = word:gsub(&apos;%[(%d+)%]&apos;, &apos;%1&apos;, 1)
&#9;&#9;&#9;&#9;local colorCode = (n == 1) and tonumber(match) or nil
&#9;&#9;&#9;&#9;if colorCode and lastElement then
&#9;&#9;&#9;&#9;&#9;lastElement.TextColor3 = BrickColor.new(colorCode).Color
&#9;&#9;&#9;&#9;else -- Not a color, so must be image or string
&#9;&#9;&#9;&#9;&#9;local element = nil
&#9;&#9;&#9;&#9;&#9;local addGap = true
&#9;&#9;&#9;&#9;&#9;if word:find(&apos;://&apos;) then -- Word is content, use as image
&#9;&#9;&#9;&#9;&#9;&#9;element = ImageLabelBase:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;element.Image = word
&#9;&#9;&#9;&#9;&#9;&#9;element.Parent = tframe
&#9;&#9;&#9;&#9;&#9;else -- Word is just a string
&#9;&#9;&#9;&#9;&#9;&#9;element = TextLabelBase:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;local text, n = word:gsub(&apos;^&apos; .. NOGAP_TAG, &apos;&apos;, 1) -- Check for and remove the NOGAP_TAG
&#9;&#9;&#9;&#9;&#9;&#9;if n == 1 then addGap = false end -- If it was there, don&apos;t add a LABEL_GAP later
&#9;&#9;&#9;&#9;&#9;&#9;element.Text = text
&#9;&#9;&#9;&#9;&#9;&#9;element.Parent = tframe  --NOTE: This must be done before we can use TextBounds
&#9;&#9;&#9;&#9;&#9;&#9;element.Size = UDim2.new(0, math.ceil(element.TextBounds.x), 0, math.ceil(element.TextBounds.y))
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;DebrisService:AddItem(element, DISPLAY_DURATION)
&#9;&#9;&#9;&#9;&#9;local xOffset = lastElement and lastElement.Position.X.Offset + lastElement.Size.X.Offset + (addGap and LABEL_GAP or 0) or 0
&#9;&#9;&#9;&#9;&#9;element.Position = UDim2.new(0, xOffset, NEW_ELEMENT_VERTICAL_SCALE, 0 - (element.Size.Y.Offset / 2))
&#9;&#9;&#9;&#9;&#9;table.insert(eventLine, element)
&#9;&#9;&#9;&#9;&#9;lastElement = element
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end --end while loop
&#9;&#9;&#9;tframe:TweenPosition(UDim2.new(0, 20, NEW_ELEMENT_VERTICAL_SCALE, 0 - (tframe.Size.Y.Offset / 2)), &quot;Out&quot;, &quot;Quad&quot;, tweenTime, true)
&#9;&#9;&#9;DebrisService:AddItem(tframe, DISPLAY_DURATION)
&#9;&#9;&#9;Spawn(function() wait(3) FadeOut(tframe,2) end)
&#9;&#9;end
&#9;end
&#9;table.insert(Events, eventLine) -- Save the event so we can scroll it later
end

--------------------
--| Script Logic |--
--------------------

-- Connect to ChildAdded for all future events
script.Parent.ChildAdded:connect(FragFeedChildAdded)

Initalized = true
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX86">
			<Properties>
				<string name="Name">RoundEndGui</string>
			</Properties>
			<Item class="Frame" referent="RBX87">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">RoundEndFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>-60</XO>
						<YS>0</YS>
						<YO>-60</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>821</XO>
						<YS>0</YS>
						<YO>555</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">7</int>
				</Properties>
				<Item class="Frame" referent="RBX88">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StaticElements</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX89">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97837313</url></Content>
							<string name="Name">Backdrop</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>58</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>827</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX90">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97859010</url></Content>
							<string name="Name">Castle</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>118</XO>
								<YS>0</YS>
								<YO>235</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>724</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">6</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX91">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839320</url></Content>
							<string name="Name">FavoriteWeapon</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>742</XO>
								<YS>0</YS>
								<YO>478</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX92">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839283</url></Content>
							<string name="Name">Knockouts</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>421</XO>
								<YS>0</YS>
								<YO>480</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX93">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97853709</url></Content>
							<string name="Name">Leaderboard</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>541</XO>
								<YS>0</YS>
								<YO>172</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>512</XO>
								<YS>0</YS>
								<YO>256</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX94">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839255</url></Content>
							<string name="Name">Logo</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>574</XO>
								<YS>0</YS>
								<YO>512</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX95">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839265</url></Content>
							<string name="Name">MVP</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>289</XO>
								<YS>0</YS>
								<YO>373</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX96">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839309</url></Content>
							<string name="Name">Wipeouts</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>593</XO>
								<YS>0</YS>
								<YO>477</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>128</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX97">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=OnlyTwentyCharacters</url></Content>
						<string name="Name">MvpImage</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>250</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>230</XO>
							<YS>0</YS>
							<YO>230</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">5</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX98">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Leaderboard</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>541</XO>
							<YS>0</YS>
							<YO>194</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>297</XO>
							<YS>0</YS>
							<YO>193</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX99">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97820612</url></Content>
							<string name="Name">Highlight</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>296</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX100">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">BaseRow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>297</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">7</int>
						</Properties>
						<Item class="TextLabel" referent="RBX101">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">Rank</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">1</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX102">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">PlayerName</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>20</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>192</XO>
									<YS>0</YS>
									<YO>24</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">OnlyTwentyCharacters</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX103">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">KOs</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>240</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">99</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX104">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">5</token>
								<string name="Name">WOs</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>285</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">99</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">7</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX105">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpKnockouts</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>380</XO>
							<YS>0</YS>
							<YO>507</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX106">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">LeftImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX107">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">RightImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX108">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpWipeouts</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>550</XO>
							<YS>0</YS>
							<YO>507</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX109">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">LeftImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX110">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97830658</url></Content>
							<string name="Name">RightImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX111">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=101199048</url></Content>
						<string name="Name">MvpWeapon</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>730</XO>
							<YS>0</YS>
							<YO>510</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX112">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MvpName</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>285</XO>
							<YS>0</YS>
							<YO>422</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX113">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">7</token>
							<string name="Name">MvpNameShadow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX114">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">7</token>
							<string name="Name">MvpName</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX115">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RoundEndGuiScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local THUMBNAIL_URL = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;

local ASSET_URL = &apos;http://www.roblox.com/asset/?id=&apos;

local NUMBER_TABLE = {97830501, 97830521, 97830539, 97830556, 97830577, 97830598, 97830609, 97830634, 97830645, 97830658}

local MAX_LEADERBOARD_ROWS = 8

-----------------
--| Variables |--
-----------------

local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local LightingService = Game:GetService(&apos;Lighting&apos;)

local RoundEndGui = script.Parent
local PlayerGui = RoundEndGui.Parent
local Player = PlayerGui.Parent

local StatsScript = Workspace:WaitForChild(&apos;Stats&apos;)
local SerializedRanks = StatsScript:WaitForChild(&apos;SerializedRanks&apos;)

local WeaponDataModel = LightingService:WaitForChild(&apos;WeaponData&apos;)

-- Full Version --

local RoundEndFrame = RoundEndGui:WaitForChild(&apos;RoundEndFrame&apos;)

local LeaderboardFrame = RoundEndFrame:WaitForChild(&apos;Leaderboard&apos;)
local BaseLeaderboardRow = LeaderboardFrame:WaitForChild(&apos;BaseRow&apos;)
local BaseRowRank = BaseLeaderboardRow:WaitForChild(&apos;Rank&apos;)
local BaseRowName = BaseLeaderboardRow:WaitForChild(&apos;PlayerName&apos;)
local BaseRowKOs = BaseLeaderboardRow:WaitForChild(&apos;KOs&apos;)
local BaseRowWOs = BaseLeaderboardRow:WaitForChild(&apos;WOs&apos;)
local Highlight = LeaderboardFrame:WaitForChild(&apos;Highlight&apos;)

local MvpImage = RoundEndFrame:WaitForChild(&apos;MvpImage&apos;)
local MvpNameFrame = RoundEndFrame:WaitForChild(&apos;MvpName&apos;)
local MvpName = MvpNameFrame:WaitForChild(&apos;MvpName&apos;)
local MvpNameShadow = MvpNameFrame:WaitForChild(&apos;MvpNameShadow&apos;)

local MvpKnockoutsFrame = RoundEndFrame:WaitForChild(&apos;MvpKnockouts&apos;)
local KnockoutsLeftImage = MvpKnockoutsFrame:WaitForChild(&apos;LeftImage&apos;)
local KnockoutsRightImage = MvpKnockoutsFrame:WaitForChild(&apos;RightImage&apos;)

local MvpWipeoutsFrame = RoundEndFrame:WaitForChild(&apos;MvpWipeouts&apos;)
local WipeoutsLeftImage = MvpWipeoutsFrame:WaitForChild(&apos;LeftImage&apos;)
local WipeoutsRightImage = MvpWipeoutsFrame:WaitForChild(&apos;RightImage&apos;)

local MvpWeapon = RoundEndFrame:WaitForChild(&apos;MvpWeapon&apos;)

local FrameSize = Vector2.new(RoundEndFrame.Size.X.Offset, RoundEndFrame.Size.Y.Offset)
local FrameOffset = Vector2.new(RoundEndFrame.Position.X.Offset, RoundEndFrame.Position.Y.Offset)
local ShadowTextOffset = Vector2.new(MvpNameShadow.Position.X.Offset, MvpNameShadow.Position.Y.Offset)

local ScreenChangeConnection = nil

-- Basic Version --

local BasicRoundEndFrame = RoundEndGui:WaitForChild(&apos;RoundEndFrame_Basic&apos;)

local BasicSideA = BasicRoundEndFrame:WaitForChild(&apos;SideA&apos;)
local BasicSideA_Text = BasicSideA:WaitForChild(&apos;Text&apos;)
local BasicSideA_KOs = BasicSideA:WaitForChild(&apos;KOs&apos;)
local BasicSideA_WOs = BasicSideA:WaitForChild(&apos;WOs&apos;)

local BasicSideB = BasicRoundEndFrame:WaitForChild(&apos;SideB&apos;)
local BasicSideB_Text = BasicSideB:WaitForChild(&apos;Text&apos;)
local BasicSideB_KOs = BasicSideB:WaitForChild(&apos;KOs&apos;)
local BasicSideB_WOs = BasicSideB:WaitForChild(&apos;WOs&apos;)

local BasicMvpSideA = BasicRoundEndFrame:WaitForChild(&apos;MVP_SideA&apos;)

local BasicMvpSideB = BasicRoundEndFrame:WaitForChild(&apos;MVP_SideB&apos;)
local BasicMvpSideB_KOs = BasicMvpSideB:WaitForChild(&apos;KOs&apos;)
local BasicMvpSideB_WOs = BasicMvpSideB:WaitForChild(&apos;WOs&apos;)

-----------------
--| Functions |--
-----------------

-- Centers the RoundEndFrame on the screen
local function PositionRoundEndFrame()
&#9;local newPosition = UDim2.new(0, FrameOffset.X, 0, FrameOffset.Y)
&#9;local screenSize = RoundEndGui.AbsoluteSize
&#9;local offset = (screenSize - FrameSize) / 2
&#9;RoundEndFrame.Position = newPosition + UDim2.new(0, offset.X, 0, offset.Y)
end

local function OnScreenChanged(property)
&#9;if property == &apos;AbsoluteSize&apos; then
&#9;&#9;PositionRoundEndFrame()
&#9;end
end

local function SuffixNumber(n)
&#9;return n .. (n == 1 and &apos;st&apos; or (n == 2 and &apos;nd&apos; or (n == 3 and &apos;rd&apos; or &apos;th&apos;)))
end

local function SwitchFrameVisibility(frames)
&#9;for _, frame in pairs(frames) do
&#9;&#9;frame.Visible = not frame.Visible
&#9;end
end

local function SetupBasicRoundEndFrame(playerRow, mvpEntry)
&#9;local playerRank = playerRow[1]
&#9;local playerEntry = playerRow[2]
&#9;local activeSubFrames = nil
&#9;if playerEntry ~= mvpEntry then
&#9;&#9;BasicSideA_Text.Text = &quot;You got &quot; .. SuffixNumber(playerRank) .. &quot; place!&quot;
&#9;&#9;BasicSideA_KOs.Text = &quot;KOs: &quot; .. playerEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicSideA_WOs.Text = &quot;WOs: &quot; .. playerEntry[&apos;WOs&apos;]
&#9;&#9;BasicSideB_Text.Text = &quot;MVP: &quot; .. mvpEntry[&apos;Name&apos;]
&#9;&#9;BasicSideB_KOs.Text = &quot;KOs: &quot; .. mvpEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicSideB_WOs.Text = &quot;WOs: &quot; .. mvpEntry[&apos;WOs&apos;]
&#9;&#9;activeSubFrames = {BasicSideA, BasicSideB}
&#9;else -- Player is MVP
&#9;&#9;BasicMvpSideB_KOs.Text = &quot;KOs: &quot; .. playerEntry[&apos;KOs&apos;] .. &quot; &quot;
&#9;&#9;BasicMvpSideB_WOs.Text = &quot;WOs: &quot; .. playerEntry[&apos;WOs&apos;]
&#9;&#9;activeSubFrames = {BasicMvpSideA, BasicMvpSideB}
&#9;end
&#9;activeSubFrames[1].Visible = true
&#9;Spawn(function()
&#9;&#9;while BasicRoundEndFrame.Visible do
&#9;&#9;&#9;wait(3)
&#9;&#9;&#9;SwitchFrameVisibility(activeSubFrames)
&#9;&#9;end
&#9;end)
end

local function OnRanksChanged(newValue)
&#9;if newValue ~= &apos;&apos; then
&#9;&#9;-- Get the leaderstats data and make a table of stats
&#9;&#9;local statsTable = {}
&#9;&#9;for playerName in newValue:gmatch(&apos;%w+&apos;) do
&#9;&#9;&#9;local player = PlayersService:FindFirstChild(playerName)
&#9;&#9;&#9;if player then
&#9;&#9;&#9;&#9;local playerStats = player:FindFirstChild(&apos;leaderstats&apos;)
&#9;&#9;&#9;&#9;if playerStats then
&#9;&#9;&#9;&#9;&#9;local KOs = playerStats:FindFirstChild(&apos;KOs&apos;)
&#9;&#9;&#9;&#9;&#9;local WOs = playerStats:FindFirstChild(&apos;WOs&apos;)
&#9;&#9;&#9;&#9;&#9;if KOs and WOs and KOs:IsA(&apos;IntValue&apos;) and WOs:IsA(&apos;IntValue&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(statsTable, {Name = playerName, KOs = KOs.Value, WOs = WOs.Value, Player = player})
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if #statsTable &lt; 1 then return end -- No valid players

&#9;&#9;-- Get the MVP
&#9;&#9;local mvpEntry = statsTable[1]

&#9;&#9;-- Show their name and image
&#9;&#9;local mvpName = mvpEntry[&apos;Name&apos;]
&#9;&#9;MvpImage.Image = THUMBNAIL_URL .. mvpName
&#9;&#9;MvpName.Text = mvpName
&#9;&#9;MvpNameShadow.Text = mvpName

&#9;&#9;-- Show their KOs and WOs
&#9;&#9;local mvpKOs = mvpEntry[&apos;KOs&apos;]
&#9;&#9;local rightDigit = mvpKOs % 10
&#9;&#9;local leftDigit = ((mvpKOs % 100) - rightDigit) / 10
&#9;&#9;KnockoutsLeftImage.Image = ASSET_URL .. NUMBER_TABLE[leftDigit + 1]
&#9;&#9;KnockoutsRightImage.Image = ASSET_URL .. NUMBER_TABLE[rightDigit + 1]
&#9;&#9;local mvpWOs = mvpEntry[&apos;WOs&apos;]
&#9;&#9;rightDigit = mvpWOs % 10
&#9;&#9;leftDigit = ((mvpWOs % 100) - rightDigit) / 10
&#9;&#9;WipeoutsLeftImage.Image = ASSET_URL .. NUMBER_TABLE[leftDigit + 1]
&#9;&#9;WipeoutsRightImage.Image = ASSET_URL .. NUMBER_TABLE[rightDigit + 1]

&#9;&#9;-- Show their favorite weapon
&#9;&#9;local mvp = mvpEntry[&apos;Player&apos;]
&#9;&#9;if mvp then
&#9;&#9;&#9;local weaponStats = mvp:FindFirstChild(&apos;WeaponFrags&apos;)
&#9;&#9;&#9;if weaponStats then
&#9;&#9;&#9;&#9;-- Find the weapon with the most frags
&#9;&#9;&#9;&#9;local mvpWeaponName = nil
&#9;&#9;&#9;&#9;local mostKOsSeen = 0
&#9;&#9;&#9;&#9;for _, weaponStat in pairs(weaponStats:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if weaponStat:IsA(&apos;IntValue&apos;) and weaponStat.Value &gt; mostKOsSeen then
&#9;&#9;&#9;&#9;&#9;&#9;mvpWeaponName = weaponStat.Name
&#9;&#9;&#9;&#9;&#9;&#9;mostKOsSeen = weaponStat.Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- If they got at least one KO and we have an icon for it, show it
&#9;&#9;&#9;&#9;if mvpWeaponName then
&#9;&#9;&#9;&#9;&#9;local weaponModel = WeaponDataModel:FindFirstChild(mvpWeaponName)
&#9;&#9;&#9;&#9;&#9;if weaponModel then
&#9;&#9;&#9;&#9;&#9;&#9;local weaponIconIdObject = weaponModel:FindFirstChild(&apos;ToolIconSilhouetteId&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;if weaponIconIdObject then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MvpWeapon.Image = ASSET_URL .. weaponIconIdObject.Value
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;local playerRow = nil -- Needed for Basic Version

&#9;&#9;-- Make the leaderboard rows from statsTable
&#9;&#9;for i, entry in ipairs(statsTable) do
&#9;&#9;&#9;BaseRowRank.Text = i
&#9;&#9;&#9;BaseRowName.Text = entry[&apos;Name&apos;]
&#9;&#9;&#9;BaseRowKOs.Text = entry[&apos;KOs&apos;]
&#9;&#9;&#9;BaseRowWOs.Text = entry[&apos;WOs&apos;]

&#9;&#9;&#9;-- Highlight the current player, add shadow text, and save their rank and entry
&#9;&#9;&#9;if entry[&apos;Player&apos;] == Player then
&#9;&#9;&#9;&#9;Highlight.Position = UDim2.new(0, 1, 0, (i - 1) * Highlight.Size.Y.Offset)
&#9;&#9;&#9;&#9;if i &lt;= MAX_LEADERBOARD_ROWS then
&#9;&#9;&#9;&#9;&#9;Highlight.Visible = true
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local originalColor = BaseRowName.TextColor3

&#9;&#9;&#9;&#9;local shadowColor = Color3.new(0, 0, 0)
&#9;&#9;&#9;&#9;BaseRowRank.TextColor3 = shadowColor
&#9;&#9;&#9;&#9;BaseRowName.TextColor3 = shadowColor
&#9;&#9;&#9;&#9;BaseRowKOs.TextColor3 = shadowColor
&#9;&#9;&#9;&#9;BaseRowWOs.TextColor3 = shadowColor

&#9;&#9;&#9;&#9;local shadowRow = BaseLeaderboardRow:Clone()
&#9;&#9;&#9;&#9;shadowRow.Position = UDim2.new(0, ShadowTextOffset.X, 0, (i - 1) * shadowRow.Size.Y.Offset + ShadowTextOffset.Y)
&#9;&#9;&#9;&#9;shadowRow.Name = &quot;ShadowRow&quot;
&#9;&#9;&#9;&#9;shadowRow.Parent = LeaderboardFrame
&#9;&#9;&#9;&#9;if i &lt;= MAX_LEADERBOARD_ROWS then
&#9;&#9;&#9;&#9;&#9;shadowRow.Visible = true
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;BaseRowRank.TextColor3 = originalColor
&#9;&#9;&#9;&#9;BaseRowName.TextColor3 = originalColor
&#9;&#9;&#9;&#9;BaseRowKOs.TextColor3 = originalColor
&#9;&#9;&#9;&#9;BaseRowWOs.TextColor3 = originalColor

&#9;&#9;&#9;&#9;playerRow = {i, entry}
&#9;&#9;&#9;end

&#9;&#9;&#9;local newRow = BaseLeaderboardRow:Clone()
&#9;&#9;&#9;newRow.Position = UDim2.new(0, 0, 0, (i - 1) * newRow.Size.Y.Offset)
&#9;&#9;&#9;newRow.Name = BaseRowName.Text
&#9;&#9;&#9;newRow.Parent = LeaderboardFrame
&#9;&#9;&#9;if i &lt;= MAX_LEADERBOARD_ROWS then
&#9;&#9;&#9;&#9;newRow.Visible = true
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;-- Show full frame if enough room
&#9;&#9;local screenSize = RoundEndGui.AbsoluteSize
&#9;&#9;if screenSize.X &gt; FrameSize.X and screenSize.Y &gt; FrameSize.Y then
&#9;&#9;&#9;PositionRoundEndFrame()
&#9;&#9;&#9;ScreenChangeConnection = RoundEndGui.Changed:connect(OnScreenChanged)
&#9;&#9;&#9;RoundEndFrame.Visible = true
&#9;&#9;else -- Otherwise show basic frame
&#9;&#9;&#9;SetupBasicRoundEndFrame(playerRow, mvpEntry)
&#9;&#9;&#9;BasicRoundEndFrame.Visible = true
&#9;&#9;end
&#9;else -- Time to disappear
&#9;&#9;if RoundEndFrame.Visible then
&#9;&#9;&#9;RoundEndFrame.Visible = false
&#9;&#9;&#9;ScreenChangeConnection:disconnect()
&#9;&#9;else
&#9;&#9;&#9;BasicRoundEndFrame.Visible = false
&#9;&#9;end

&#9;&#9;-- Clean up generated leaderboard rows
&#9;&#9;for _, child in pairs(LeaderboardFrame:GetChildren()) do
&#9;&#9;&#9;if child.Name ~= BaseLeaderboardRow.Name and child.Name ~= Highlight.Name then
&#9;&#9;&#9;&#9;child:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function PreloadThumbnail(player)
&#9;ContentProviderService:Preload(THUMBNAIL_URL .. player.Name .. &quot;&amp;cb=&quot; .. tick())
end

--------------------
--| Script Logic |--
--------------------

-- Preload images for all players, future and present
PlayersService.PlayerAdded:connect(PreloadThumbnail)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;PreloadThumbnail(player)
end

SerializedRanks.Changed:connect(OnRanksChanged)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX116">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">RoundEndFrame_Basic</string>
					<UDim2 name="Position">
						<XS>0.25</XS>
						<XO>0</XO>
						<YS>0.150000006</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">7</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX117">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=94793101</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">5</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX118">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=97839255</url></Content>
						<string name="Name">Logo</string>
						<UDim2 name="Position">
							<XS>-0.0729166642</XS>
							<XO>0</XO>
							<YS>-0.25</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.89084506</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">6</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX119">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">SideA</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX120">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">Text</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.899999976</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">You got 8th place!</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX121">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX122">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX123">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">SideB</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX124">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">Text</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.899999976</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">MVP: OnlyTwentyCharacters</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX125">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX126">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.790000021</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX127">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MVP_SideA</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX128">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">YouGot</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">You got</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX129">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=97839265</url></Content>
							<string name="Name">MVP</string>
							<UDim2 name="Position">
								<XS>0.529999971</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.450704217</XS>
								<XO>0</XO>
								<YS>0.225352108</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX130">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MVP_SideB</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">7</int>
					</Properties>
					<Item class="TextLabel" referent="RBX131">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">KOs</string>
							<UDim2 name="Position">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">KOs: 99 </string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX132">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">0</token>
							<string name="Name">WOs</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.649999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.300000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">WOs: 99</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">true</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">7</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX133">
			<Properties>
				<string name="Name">RoundTimerGui</string>
			</Properties>
			<Item class="Frame" referent="RBX134">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">TimerFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-100</XO>
						<YS>0.0500000007</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>200</XO>
						<YS>0</YS>
						<YO>30</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX135">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">TimerText</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>-0.400000006</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX136">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">Time</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>-25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4293984250</Color3>
						<float name="TextStrokeTransparency">0</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX137">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RoundTimerGuiScript</string>
					<ProtectedString name="Source">-- Constants --

local START_POSITION = UDim2.new(0.5, -17, 0.8, -25)
local END_POSITION = UDim2.new(0.5, -26, 0.8, -34)
local START_SIZE = UDim2.new(0, 34, 0, 34)
local END_SIZE = UDim2.new(0, 52, 0, 52)

local MINUTES_POSITION = UDim2.new(0.5, 0, 0.8, -25)
local MINUTES_SIZE = UDim2.new(0, 0, 1, 0)

-- Variables --

local Gui = script.Parent
local TimerFrame = Gui:WaitForChild(&apos;TimerFrame&apos;)
local Time = TimerFrame:WaitForChild(&apos;Time&apos;)
local TimerText = TimerFrame:WaitForChild(&apos;TimerText&apos;)

local MainScript = Workspace:WaitForChild(&apos;RoundTimer&apos;)
local TimeObject = MainScript:WaitForChild(&apos;Time&apos;)

local MainGameScript = Workspace:WaitForChild(&apos;MainGameScript&apos;)
local RoundTimerTextObject = MainGameScript:WaitForChild(&apos;RoundTimerText&apos;)

local LastTime = -1

-- Functions --

-- Whenever TimeObject changes, update the Time displayed (now with exciting graphics!)
local function OnTimeChanged(newValue)
&#9;local currentTime = math.max(0, newValue)
&#9;if LastTime == math.floor(currentTime) then return end
&#9;LastTime = math.floor(currentTime)
&#9;--print(&quot;Time Changed, time is&quot; , newValue)
&#9;local hours = math.floor(currentTime / 3600)
&#9;local minutes = math.floor(currentTime / 60) % 60
&#9;local seconds = math.floor(currentTime) % 60
&#9;if minutes &gt; 0 then
&#9;&#9;Time.TextWrapped = false
&#9;&#9;Time.TextScaled = false
&#9;&#9;Time.Position = MINUTES_POSITION
&#9;&#9;Time.Size = MINUTES_SIZE
&#9;&#9;Time.Text = string.format(&quot;%d:%02d&quot;, minutes, seconds) -- (Looks like 00:00:00)
&#9;else
&#9;&#9;Time.TextWrapped = true
&#9;&#9;Time.TextScaled = true
&#9;&#9;-- One argument of tween is a callback, I use it to untween the text
&#9;&#9;Time:TweenSizeAndPosition(END_SIZE,END_POSITION, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.2, false,
&#9;&#9;&#9;function() Time:TweenSizeAndPosition(START_SIZE,START_POSITION, Enum.EasingDirection.In, Enum.EasingStyle.Linear, 0.3) end)
&#9;&#9;if seconds ~= 59 then
&#9;&#9;&#9;wait(0.1)
&#9;&#9;end
&#9;&#9;Time.Text = string.format(&quot;%d&quot;, seconds)
&#9;end
end

-- Whenever RoundTimerTextObject changes, update the TimerText
local function OnTextChanged(newValue)
&#9;TimerText.Text = newValue
end

-- Script Logic --

TimeObject.Changed:connect(OnTimeChanged)
RoundTimerTextObject.Changed:connect(OnTextChanged)
OnTextChanged(RoundTimerTextObject.Value)
TimerFrame.Visible = true
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX138">
			<Properties>
				<string name="Name">StatsGui</string>
			</Properties>
			<Item class="Frame" referent="RBX139">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">buttonFrame</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>-3</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>73</XO>
						<YS>0</YS>
						<YO>37</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageButton" referent="RBX140">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107928300</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">ImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX141">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=108039909</url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">HighlightImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-30</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>134</XO>
							<YS>0</YS>
							<YO>68</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX142">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StatGuiScript</string>
					<ProtectedString name="Source">function WaitForChild(parent,child)
&#9;while not parent:FindFirstChild(child)  do
&#9;&#9;wait()
&#9;end
&#9;return parent[child]
end

--Workspace Variables

local ScreenGui = script.Parent
local LocalPlayer = ScreenGui.Parent.Parent

local REQUEST_URL = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;

Game:GetService(&quot;ContentProvider&quot;):Preload(REQUEST_URL .. LocalPlayer.Name .. &quot;&amp;cb=&quot; .. tick())

local SelectedPlayer=LocalPlayer
local SelectedFrame = nil

local LocalOtherStats = WaitForChild(LocalPlayer,&apos;otherstats&apos;)
local MenuOpen = LocalOtherStats:FindFirstChild(&apos;StatsMenuOpen&apos;)
if not MenuOpen then
&#9;MenuOpen = Instance.new(&apos;IntValue&apos;)
&#9;MenuOpen.Value = 0
&#9;MenuOpen.Name = &apos;StatsMenuOpen&apos;
&#9;MenuOpen.Parent = LocalOtherStats
end

local PersistentData = WaitForChild(SelectedPlayer,&apos;PersistentModel&apos;)
local WeaponPersistence = WaitForChild(PersistentData,&apos;WeaponPersistence&apos;)


local ButtonFrame = WaitForChild(ScreenGui,&apos;buttonFrame&apos;)
local Button = WaitForChild(ButtonFrame,&apos;ImageButton&apos;)
local HighlightButton = WaitForChild(ButtonFrame,&apos;HighlightImageButton&apos;)

local MainFrame = WaitForChild(ScreenGui,&apos;MainFrame&apos;)
local ProfileImage = WaitForChild(MainFrame,&apos;ProfileImage&apos;)

local MainStats = WaitForChild(MainFrame,&apos;MainStats&apos;)
local OpenMainStats = WaitForChild(MainStats,&apos;OpenButton&apos;)

local WeaponData = WaitForChild(game.Lighting, &apos;WeaponData&apos;)

local WeaponStats = WaitForChild(MainFrame,&apos;WeaponStats&apos;)
local ClipFrame = WaitForChild(WeaponStats,&apos;ClipFrame&apos;)
local ScrollFrame = WaitForChild(ClipFrame,&apos;ScrollFrame&apos;)
local OpenWeaponStats = WaitForChild(WeaponStats,&apos;OpenButton&apos;)
local WeaponScrollUp = WaitForChild(WeaponStats,&apos;scrollUp&apos;)
local WeaponScrollDown = WaitForChild(WeaponStats,&apos;scrollDown&apos;)

local WeaponTemplate = WaitForChild(ScrollFrame,&apos;TemplateWeapon&apos;)

local PlayerListFrame = WaitForChild(MainFrame,&apos;playerList&apos;)
local TemplateFrame = WaitForChild(PlayerListFrame,&apos;TemplateFrame&apos;)

local NameText = WaitForChild(MainFrame,&apos;NameText&apos;)

local SlideSpeed = .26

local UpdatedStats = 
{
&#9;{Tag = &apos;Total_KOs&apos;,Obj = WaitForChild(MainStats, &apos;TotalKOs&apos;)},
&#9;{Tag = &apos;Total_WOs&apos;,Obj = WaitForChild(MainStats, &apos;TotalWOs&apos;)},
&#9;{Tag = &apos;Total_MVPs&apos;,Obj = WaitForChild(MainStats, &apos;TotalMVP&apos;)},
&#9;{Tag = &apos;Total_Rounds&apos;,Obj = WaitForChild(MainStats, &apos;TotalGames&apos;)},
&#9;{Tag = &apos;Best_Streak_Ever&apos;,Obj = WaitForChild(MainStats, &apos;BestStreak&apos;)},
&#9;{Tag = &apos;Most_KOs_In_Match&apos;,Obj = WaitForChild(MainStats, &apos;MostKos&apos;)},
&#9;{Tag = &apos;Most_WOs_In_Match&apos;,Obj = WaitForChild(MainStats, &apos;MostWos&apos;)},
}
local KDRText = WaitForChild(MainStats, &apos;KDR&apos;)

--Script Variables

--array of player entries, consisting of
--MyPlayer
--PersistentVars
--Frame (frame in playerlist)
local PlayerList = {}

local LocalPlayerEntry = nil

local TextUpdateConnections = {}

local WeaponRows = {}

local OpenPanel = MainStats

local ScrollIndex = 0
local WeaponPanelLength = 8

--Persistent keys
local PersistentKeys =
{
&#9;TotalKOs = &apos;Total_KOs&apos;,
&#9;TotalWOs = &apos;Total_WOs&apos;,
&#9;GamesPlayed = &apos;Total_Rounds&apos;,
&#9;MVPs = &apos;Total_MVPs&apos;,
&#9;WeaponKOSuffix = &apos;_$_KOs&apos;,
&#9;WeaponWOSuffix = &apos;_$_WOs&apos;,
&#9;LastJoin = &apos;Last_Join_Time&apos;,
&#9;MostKOs = &apos;Most_KOs_In_Match&apos;,
&#9;MostWOs = &apos;Most_WOs_In_Match&apos;,
&#9;AverageWOs = &apos;Average_WOs_In_Match&apos;,
&#9;AverageKOs = &apos;Average_KOs_In_Match&apos;,
&#9;BestStreak = &apos;Best_Streak_Ever&apos;,
&#9;XP = &apos;Total_XP&apos;,
&#9;XP_VERSION = &apos;XP_VERSION&apos;
}


local Admins=
{
&#9;&apos;fusroblox&apos;,
&#9;&apos;imtotallyadmin&apos;,
&#9;&apos;Sorcus&apos;,
&#9;&apos;OnlyTwentyCharacters&apos;,
&#9;&apos;Player1&apos;,
&#9;&apos;HotThoth&apos;,
&#9;&apos;Games&apos;,
&#9;&apos;Shedletsky&apos;,
&#9;&apos;SolarCrane&apos;,
}

--script functions

function SortFunction(a,b)
&#9;if b==LocalPlayer then return true end
&#9;--Add checking of rank here
&#9;return false
end

function MakeWeaponEntries()
&#9;
&#9;for _,i in pairs(WeaponData:GetChildren()) do
&#9;&#9;local WeaponEntry = {}
&#9;&#9;local nWeaponFrame=WeaponTemplate:Clone()
&#9;&#9;nWeaponFrame.Name= i.Name
&#9;&#9;WaitForChild(nWeaponFrame,&apos;WeaponName&apos;).Text = i.Name
&#9;&#9;WeaponEntry[&apos;KOs&apos;]=0
&#9;&#9;WeaponEntry[&apos;Frame&apos;]=nWeaponFrame
&#9;&#9;
&#9;&#9;if i:FindFirstChild(&apos;WhiteIcon&apos;) then
&#9;&#9;&#9;WaitForChild(nWeaponFrame,&apos;icon&apos;).Image = &apos;http://www.roblox.com/asset/?id=&apos;..i.WhiteIcon.Value
&#9;&#9;end
&#9;
&#9;&#9;table.insert(WeaponRows,WeaponEntry)
&#9;end
&#9;
end

function SortWeapons()
&#9;table.sort(WeaponRows,function(a,b)
&#9;&#9;return a[&apos;KOs&apos;]&gt;b[&apos;KOs&apos;] 
&#9;end)

&#9;local frameYSize =WeaponTemplate.Size.Y.Offset
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;entry[&apos;Frame&apos;].Position=WeaponTemplate.Position+UDim2.new(0,0,0,frameYSize*((i-1)+ScrollIndex))
&#9;&#9;entry[&apos;Frame&apos;].Parent=ScrollFrame
&#9;&#9;
&#9;&#9;if i%2==1 then
&#9;&#9;&#9;entry[&apos;Frame&apos;].BackgroundTransparency =.65
&#9;&#9;else
&#9;&#9;&#9;entry[&apos;Frame&apos;].BackgroundTransparency =1
&#9;&#9;end
&#9;&#9;if entry[&apos;KOs&apos;]==0 then entry[&apos;Frame&apos;].Visible = false 
&#9;&#9;else entry[&apos;Frame&apos;].Visible=true end
&#9;end
end

function ConnectWeaponEntries()
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;if entry[&apos;Connection&apos;] then entry[&apos;Connection&apos;]:disconnect() end
&#9;&#9;if WeaponPersistence:FindFirstChild(entry[&apos;Frame&apos;].Name) then
&#9;&#9;&#9;local wKos = WaitForChild(WeaponPersistence[entry[&apos;Frame&apos;].Name],&apos;KOs&apos;)
&#9;&#9;&#9;entry[&apos;Connection&apos;] = wKos.Changed:connect(function()
&#9;&#9;&#9;&#9;WaitForChild(entry[&apos;Frame&apos;],&apos;WeaponKOs&apos;).Text=tostring(wKos.Value)
&#9;&#9;&#9;&#9;entry[&apos;KOs&apos;]=wKos.Value
&#9;&#9;&#9;&#9;SortWeapons()
&#9;&#9;&#9;end)
&#9;&#9;&#9;WaitForChild(entry[&apos;Frame&apos;],&apos;WeaponKOs&apos;).Text = tostring(wKos.Value)
&#9;&#9;&#9;entry[&apos;KOs&apos;]=wKos.Value
&#9;&#9;end
&#9;end
&#9;SortWeapons()
end

function UpdateRatio(kos,wos)
&#9;if wos ==0 then 
&#9;&#9;KDRText.Text = &apos;N/A&apos;
&#9;&#9;if KDRText:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;&#9;KDRText.Background.Text = KDRText.Text
&#9;&#9;end
&#9;&#9;return
&#9;end
&#9;local ratio =kos/wos

&#9;KDRText.Text=string.format(&quot;%.2f&quot;,ratio)
&#9;if KDRText:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;KDRText.Background.Text = KDRText.Text
&#9;end
end

function OnPlayerClicked(entry)
&#9;for _,i in ipairs(TextUpdateConnections) do
&#9;&#9;i:disconnect()
&#9;end
&#9;TextUpdateConnections={}
&#9;SelectedPlayer = entry[&apos;MyPlayer&apos;]
&#9;NameText.Text= SelectedPlayer.Name
&#9;if SelectedFrame then
&#9;&#9;SelectedFrame.BackgroundTransparency=0
&#9;end
&#9;SelectedFrame=entry[&apos;Frame&apos;]
&#9;SelectedFrame.BackgroundTransparency=.4
&#9;PersistentData = WaitForChild(SelectedPlayer,&apos;PersistentModel&apos;)
&#9;WeaponPersistence = WaitForChild(PersistentData,&apos;WeaponPersistence&apos;)
&#9;local myKos = WaitForChild(PersistentData,&apos;Total_KOs&apos;)
&#9;local myWos = WaitForChild(PersistentData,&apos;Total_WOs&apos;)
&#9;table.insert(TextUpdateConnections,myKos.Changed:connect(function() UpdateRatio(myKos.Value,myWos.Value) end))
&#9;table.insert(TextUpdateConnections,myWos.Changed:connect(function() UpdateRatio(myKos.Value,myWos.Value) end))
&#9;UpdateRatio(myKos.Value,myWos.Value)
&#9;
&#9;ProfileImage.Image = &apos;http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=&apos;..entry[&apos;MyPlayer&apos;].Name
&#9;for _, i in pairs(UpdatedStats) do
&#9;&#9;MakeUpdatedText(i.Obj,WaitForChild(PersistentData,i.Tag))
&#9;end
&#9;
&#9;ConnectWeaponEntries()
end

--makes a textlabel update when a given value changes
function MakeUpdatedText(textObj,value)
&#9;table.insert(TextUpdateConnections,value.Changed:connect(function()
&#9;&#9;textObj.Text=value.Value
&#9;&#9;if textObj:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;&#9;textObj.Background.Text = value.Value
&#9;&#9;end
&#9;end))
&#9;textObj.Text=value.Value
&#9;if textObj:FindFirstChild(&apos;Background&apos;) then
&#9;&#9;textObj.Background.Text = value.Value
&#9;end
end

function MovePlayerEntries()
&#9;for i,entry in ipairs(PlayerList) do
&#9;&#9;entry[&apos;Frame&apos;].Position = UDim2.new(0,0,(1/8)*(i-1),0)
&#9;end
end

function MakePlayerFrame(player)
&#9;local nentry = {}
&#9;nentry[&apos;MyPlayer&apos;]=player
&#9;nentry[&apos;PersistentVars&apos;] = WaitForChild(player,&apos;PersistentModel&apos;)
&#9;local nframe = TemplateFrame:Clone()
&#9;WaitForChild(nframe,&apos;PlayerName&apos;).Text=player.Name
&#9;WaitForChild(nframe,&apos;button&apos;).MouseButton1Click:connect(function() OnPlayerClicked(nentry) end)
&#9;MakeUpdatedText(WaitForChild(nframe,&apos;Rank&apos;), WaitForChild(nentry[&apos;PersistentVars&apos;],PersistentKeys[&apos;TotalKOs&apos;]))
&#9;nentry[&apos;Frame&apos;]=nframe
&#9;nframe.Parent=PlayerListFrame
&#9;nframe.Visible=true
&#9;if player == game.Players.LocalPlayer then
&#9;&#9;LocalPlayerEntry = nentry
&#9;end
&#9;return nentry
end

function OnPlayerAdded(player) 
&#9;--print(&apos;adding player:&apos; ..player.Name)
&#9;table.insert(PlayerList,MakePlayerFrame(player))
&#9;MovePlayerEntries()
end

function OnPlayerRemoved(player)
&#9;for i,entry in ipairs(PlayerList) do
&#9;&#9;if player ==entry[&apos;MyPlayer&apos;] then
&#9;&#9;&#9;table.remove(PlayerList,i)
&#9;&#9;&#9;entry[&apos;Frame&apos;]:Destroy()
&#9;&#9;&#9;MovePlayerEntries()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
end

function OffsetZIndex(obj,offset)
&#9;obj.ZIndex=obj.ZIndex+offset
&#9;for _,i in pairs(obj:GetChildren()) do
&#9;&#9;if i:IsA(&apos;GuiObject&apos;) then
&#9;&#9;&#9;OffsetZIndex(i,offset)
&#9;&#9;end
&#9;end
end

function OpenWeaponPanel()
&#9;if not OpenPanel or OpenPanel == WeaponStats then return end
&#9;MenuOpen.Value=2
&#9;OpenPanel = nil
&#9;WeaponStats:TweenPosition(UDim2.new(0, 260+WeaponStats.Size.X.Offset, 0, 70), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OffsetZIndex(MainStats,-1)
&#9;OffsetZIndex(WeaponStats,1)
&#9;WeaponStats:TweenPosition(UDim2.new(0, 260, 0, 70), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OpenPanel = WeaponStats
end

function OpenMainPanel()
&#9;if not OpenPanel or OpenPanel == MainStats then return end
&#9;MenuOpen.Value=1
&#9;OpenPanel = nil
&#9;MainStats:TweenPosition(UDim2.new(0, 250+MainStats.Size.X.Offset, 0, 60), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OffsetZIndex(MainStats,1)
&#9;OffsetZIndex(WeaponStats,-1)
&#9;MainStats:TweenPosition(UDim2.new(0, 250, 0, 60), &quot;Out&quot;, &quot;Quad&quot;, SlideSpeed, true)
&#9;wait(SlideSpeed)
&#9;OpenPanel = MainStats
end

function ScrollWeapons(amount)
&#9;local nindex = ScrollIndex+amount
&#9;if nindex&gt;0 or -nindex&gt;(#WeaponRows-WeaponPanelLength) or not WeaponRows[(-nindex)+WeaponPanelLength][&apos;Frame&apos;].Visible then
&#9;&#9;return
&#9;end
&#9;ScrollIndex = nindex
&#9;local frameYSize =WeaponTemplate.Size.Y.Offset
&#9;for i,entry in ipairs(WeaponRows) do
&#9;&#9;entry[&apos;Frame&apos;].Position=WeaponTemplate.Position+UDim2.new(0,0,0,frameYSize*((i-1)+ScrollIndex))
&#9;end
end

function PreloadAll(obj)
&#9;for _, i in pairs(obj:GetChildren()) do
&#9;&#9;PreloadAll(i)
&#9;end
&#9;if obj:IsA(&apos;ImageButton&apos;) or obj:IsA(&apos;ImageLabel&apos;) then
&#9;&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(obj.Image)
&#9;&#9;--print(&apos;preloading &apos;.. obj.Name)
&#9;end
end

--setting up bindables

Button.MouseButton1Click:connect(function()
&#9;OnPlayerClicked(LocalPlayerEntry)
&#9;MainFrame.Visible= not MainFrame.Visible
&#9;if MainFrame.Visible then MenuOpen.Value=1
&#9;else MenuOpen.Value=0 end
&#9;if HighlightButton.Visible then
&#9;&#9;HighlightButton.Visible = false
&#9;&#9;WaitForChild(LocalOtherStats,&apos;DisplayStatsHighlight&apos;):Destroy()
&#9;end
end)

for _,player in pairs(game.Players:GetPlayers()) do
&#9;OnPlayerAdded(player)
end

game.Players.ChildAdded:connect(OnPlayerAdded)

game.Players.ChildRemoved:connect(OnPlayerRemoved)

OpenWeaponStats.MouseButton1Click:connect(OpenWeaponPanel)
OpenMainStats.MouseButton1Click:connect(OpenMainPanel)

WeaponScrollUp.MouseButton1Click:connect(function()ScrollWeapons(1)end)
WeaponScrollDown.MouseButton1Click:connect(function()ScrollWeapons(-1)end)

MakeWeaponEntries()

for _, i in ipairs(Admins) do
&#9;if LocalPlayer.Name == i then
&#9;&#9;PlayerListFrame.Visible=true
&#9;end
end

if MenuOpen.Value~=0 then
&#9;OnPlayerClicked(LocalPlayerEntry)
&#9;MainFrame.Visible= not MainFrame.Visible
&#9;if MenuOpen == 2 then
&#9;&#9;OffsetZIndex(MainStats,-1)
&#9;&#9;OffsetZIndex(WeaponStats,1)
&#9;end
end

local screenSize = script.Parent.AbsoluteSize
if screenSize.X &gt; MainFrame.Size.X.Offset and screenSize.Y &gt; MainFrame.Size.Y.Offset then
&#9;Button.Visible = true
&#9;if LocalOtherStats:FindFirstChild(&apos;DisplayStatsHighlight&apos;) then
&#9;&#9;HighlightButton.Visible = true
&#9;end
end

PreloadAll(script.Parent)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX143">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MainFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-320</XO>
						<YS>0.5</YS>
						<YO>-250</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>640</XO>
						<YS>0</YS>
						<YO>434</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX144">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294901764</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">playerList</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-200</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>400</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="Frame" referent="RBX145">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">TemplateFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.125</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
						<Item class="TextLabel" referent="RBX146">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">6</token>
								<string name="Name">PlayerName</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">OnlyTwentyCharacters</string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX147">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">Rank</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">12</string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX148">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><null></null></Content>
								<bool name="Modal">false</bool>
								<string name="Name">button</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX149">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107892608</url></Content>
						<string name="Name">Background</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX150">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">XpBar</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>18</XO>
							<YS>0</YS>
							<YO>383</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>222</XO>
							<YS>0</YS>
							<YO>22</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
					<Item class="Frame" referent="RBX151">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ClipFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX152">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=107893470</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX153">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">5</token>
							<string name="Name">ToNextLevel</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-5</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">12345678 XP to Lv. 9</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX154">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/thumbs/avatar.ashx?x=500&amp;y=500&amp;format=png&amp;username=OnlyTwentyCharacters</url></Content>
						<string name="Name">ProfileImage</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>300</XO>
							<YS>0</YS>
							<YO>300</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX155">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=107923922</url></Content>
						<string name="Name">Highlight</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>235</XO>
							<YS>0</YS>
							<YO>365</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>417</XO>
							<YS>0</YS>
							<YO>42</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX156">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">WeaponStats</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>260</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>423</XO>
							<YS>0</YS>
							<YO>308</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX157">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107926023 </url></Content>
							<string name="Name">background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX158">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<bool name="Modal">false</bool>
							<string name="Name">OpenButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-45</XO>
								<YS>0</YS>
								<YO>160</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0</YS>
								<YO>135</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX159">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">true</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ClipFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>25</XO>
								<YS>0</YS>
								<YO>50</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>341</XO>
								<YS>0</YS>
								<YO>205</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
						<Item class="Frame" referent="RBX160">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">ScrollFrame</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">8</int>
							</Properties>
							<Item class="Frame" referent="RBX161">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4294967295</Color3>
									<float name="BackgroundTransparency">0.699999988</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<string name="Name">TemplateWeapon</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>26</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">8</int>
								</Properties>
								<Item class="TextLabel" referent="RBX162">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">0</token>
										<token name="FontSize">5</token>
										<string name="Name">WeaponKOs</string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>-10</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">153</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX163">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">0</token>
										<token name="FontSize">5</token>
										<string name="Name">WeaponName</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>35</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Rocket Launcher</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX164">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><null></null></Content>
										<string name="Name">icon</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>25</XO>
											<YS>0</YS>
											<YO>25</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX165">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107895951</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">scrollDown</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>300</XO>
								<YS>0</YS>
								<YO>265</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>62</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBX166">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107895765</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">scrollUp</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>220</XO>
								<YS>0</YS>
								<YO>265</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>62</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX167">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">MainStats</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>250</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>423</XO>
							<YS>0</YS>
							<YO>308</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
					<Item class="TextLabel" referent="RBX168">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalGames</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>148</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">25</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX169">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX170">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalKOs</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">153</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX171">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX172">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalWOs</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>75</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">111</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX173">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX174">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=107924595</url></Content>
							<string name="Name">Background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>9</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX175">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">KDR</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>112</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">2.10</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX176">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX177">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">TotalMVP</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>183</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX178">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX179">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">BestStreak</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>220</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX180">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX181">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<bool name="Modal">false</bool>
							<string name="Name">OpenButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-35</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>30</XO>
								<YS>0</YS>
								<YO>115</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX182">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">MostKos</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>255</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX183">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX184">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">MostWos</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>0</YS>
								<YO>290</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4278190080</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
						<Item class="TextLabel" referent="RBX185">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">5</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">1</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">9</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX186">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">NameText</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>135</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">OnlyTwentyCharacters</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">2</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX187">
			<Properties>
				<string name="Name">StoreGui</string>
			</Properties>
			<Item class="Frame" referent="RBX188">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4281479730</Color3>
					<float name="BackgroundTransparency">0.600000024</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MainFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX189">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4279505940</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StoreFrame</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-352</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>704</XO>
							<YS>0</YS>
							<YO>681</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX190">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=105102078</url></Content>
							<string name="Name">Background</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX191">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4281479730</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PageFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>125</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>525</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX192">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">CategoriesFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>122</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>35</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX193">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105102876</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">2</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX194">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PlayerCurrencyFrame</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-352</XO>
								<YS>0</YS>
								<YO>105</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>339</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX195">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105103085</url></Content>
								<string name="Name">Background</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX196">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">StoreHeaderFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>12</XO>
								<YS>0</YS>
								<YO>12</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>680</XO>
								<YS>0</YS>
								<YO>114</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX197">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=105102296</url></Content>
								<string name="Name">StoreHeader</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">2</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX198">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">8</token>
								<string name="Name">Title</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>75</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>100</XO>
									<YS>0</YS>
									<YO>30</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Store</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX199">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">FooterFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>5</XO>
								<YS>1</YS>
								<YO>-20</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-10</XO>
								<YS>0</YS>
								<YO>14</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="StringValue" referent="RBX200">
				<Properties>
					<string name="Name">AssetIds_CSV</string>
					<string name="Value">101110605, 101106419, 101109685, 101159295</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX201">
				<Properties>
					<string name="Name">Categories_CSV</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX202">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreScript</string>
					<ProtectedString name="Source">--[[
&#9;// Filename: InGameStore.LUA
&#9;// Written by: Sorcus 
&#9;// Description: Creates all the GUI elements for the store 
&#9;// NOTE: If you find any bugs or other inconsistences PM Sorcus on ROBLOX 
&#9;&#9;&#9; or @Canavus on Twitter 
]]

-- NOTE: The below code only works in Lua 5.1 
-- As of Lua 5.2 they have removed global envs
-- It is still possible to do this but no non-nasty way 
if _VERSION ~= &apos;Lua 5.1&apos; then 
&#9;error(&apos;This code assumes that you are running Lua 5.1. Please read through the first 50 lines if you wonder why.&apos;)
end 
-- Get the current environment
local _ENV = getfenv() 

-- Create a metatable where new indices aren&apos;t allowed to make global variables 
local gMetatable = {&#9;__index = _ENV;
&#9;&#9;&#9;&#9;&#9;&#9;__newindex = function(t, k, v) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Global variable &apos;..  k ..  &apos; detected. Was this an accident?&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;&#9;end; 
&#9;&#9;&#9;&#9;&#9;}

-- Create a new table that is going to be the executing environment for the current script 
local _NewENV = setmetatable({ }, gMetatable)

-- Apply our table to be the environment 
-- NOTE: Indices are redirected to the default environment 
-- So stuff like print(&apos;blah&apos;) will still work 
-- NOTE #2: This is necessary because the default env is protected 
setfenv(1, _NewENV)

-- Now create a stricter environment for our table 
-- This will basically make it such that variables that are within the function are 
-- checked to make sure to be in the table first before checking global scope or erroring out 
local envMetatable = {
&#9;__newindex = function(t,k,v)
&#9;&#9;if type(v) == &apos;function&apos; then
&#9;&#9;&#9;setfenv(v,t)                            
&#9;&#9;end
&#9;&#9;rawset(t, k, v)
&#9;end;

&#9;__index = _NewENV;
}
------------------------------ GLOBALS -------------------------------

local ContentProvider = Game:GetService(&apos;ContentProvider&apos;)
local MarketplaceService = Game:GetService(&apos;MarketplaceService&apos;)
local Debris = Game:GetService(&apos;Debris&apos;)
local InsertService = Game:GetService(&apos;InsertService&apos;)
local UserInputService = Game:GetService(&apos;UserInputService&apos;)

local RBX_Utility = LoadLibrary(&apos;RbxUtility&apos;)
-- The utility library comes with Marks Create functionality 
local NewInstance = RBX_Utility -- typedef 
local RBX_Gui = LoadLibrary(&apos;RbxGui&apos;)

local BASE_URL = ContentProvider.BaseUrl:lower() 

local AssetsToPrefetch_List = {106467812, 106467831, 106467851, 106467877, 106467898, 106467911, 106467923, 106467948, 106469554}

--- PREFETCH ASSETS BEFORE EVERYTHING ELSE  -- 
for _, assetId in pairs(AssetsToPrefetch_List) do 
&#9;ContentProvider:Preload(&quot;http://www.roblox.com/asset/?id=&quot; .. assetId)
end
-- 
local Player = Game.Players.LocalPlayer 
local Character 
----------------------- STORE NAMESPACE --------------------------------
-- Set the metatable to be our special metatable 
-- This allows for removing the obnoxious self keyword whereever we need to access the variables in the Store table 
-- NOTE: Only functions within this table can access the vars directly, because it makes sense 
local Store = setmetatable({

&#9;&#9;&#9;&#9;Gui = nil,
&#9;&#9;&#9;&#9;MainIcon = nil, 
&#9;&#9;&#9;&#9;MainFrame = nil,&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;StoreFrame = nil,
&#9;&#9;&#9;&#9;CategoriesFrame = nil,
&#9;&#9;&#9;&#9;PlayerCurrencyFrame = nil,
&#9;&#9;&#9;&#9;PageFrame = nil, 

&#9;&#9;&#9;&#9;AssetIds_StringValue = nil,
&#9;&#9;&#9;&#9;Categories_StringValue = nil,

&#9;&#9;&#9;&#9;CurrentActiveTab = nil, 
&#9;&#9;&#9;&#9;CurrentActiveCategory = nil, 

&#9;&#9;&#9;&#9;Searchbar = nil, 

&#9;&#9;&#9;&#9;TabHighlight = nil, 

&#9;&#9;&#9;&#9;ItemType_WhiteList = {[&apos;Hat&apos;] = true, [&apos;Gear&apos;] = true, [&apos;Model&apos;] = true, [&apos;ShirtGraphic&apos;] = true, [&apos;Shirts&apos;] = true, [&apos;Pants&apos;] = true, [&apos;GamePass&apos;] = true, [&apos;Face&apos;]= true, [&apos;Packages&apos;] = true, [&apos;Passes&apos;] = true},

&#9;&#9;&#9;&#9;ItemTypeId_WhiteList = {[&apos;19&apos;] = &apos;Gear&apos;, [&apos;10&apos;] = &apos;Model&apos;, [&apos;11&apos;] = &apos;Shirts&apos;, [&apos;12&apos;] = &apos;Pants&apos;, [&apos;8&apos;] = &apos;Hat&apos;, [&apos;18&apos;] = &apos;Face&apos;, [&apos;2&apos;] = &apos;ShirtGraphic&apos;, [&apos;32&apos;] = &apos;Packages&apos;, [&apos;34&apos;] = &apos;Passes&apos;},

&#9;&#9;&#9;&#9;Categories_List = {},

&#9;&#9;&#9;&#9;Items_List = {},
&#9;&#9;&#9;&#9;PopupFrames_List = {},

&#9;&#9;&#9;&#9;ItemHashTable = {}, 

&#9;&#9;&#9;&#9;Layout = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;InitOffsetX = 10,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;InitOffsetY = 36,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;GridOffsetX = 21,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;GridOffsetY = 20,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NumCellsInRow = 5; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;NumRowsInPage = 3; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MaxItemsInPage = 5*3; 

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CurrencyIcon = 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;{&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Robux = 105177508;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Tickets = 105192824;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CurrencyTextColor = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Robux = Color3.new(27/255, 186/255 ,27/255),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Tickets = Color3.new(255/255, 203/255, 52/255)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;CategoryTabOffsetX = 8,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;SearchbarX = 124,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;SearchbarY = 17,

&#9;&#9;&#9;&#9;&#9;&#9;&#9;MembershipIcon = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- get these icons from tara 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[1] = {[&apos;Small&apos;] = 105264972},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[2] = {[&apos;Small&apos;] = 105265090},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[3] = {[&apos;Small&apos;] = 105265112}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;&#9;&#9;&#9;&#9;LimitedIcon = {[&apos;Small&apos;] = 105278471},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;LimitedUniqueIcon = {[&apos;Small&apos;] = 105278547}
&#9;&#9;&#9;&#9;&#9;&#9;},

&#9;&#9;&#9;SearchCache_List = {},&#9;&#9;
&#9;&#9;&#9;Loading = true 
&#9;
}, envMetatable)

function Store:MakeItemPage(itemInfo_List)
&#9;local itemPageFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;}
end 

function Store:CreatePopupFrame(itemInfo_List) 

end 

function Store:HideAllPopups() 
end

function Store:ShowHoverFrame(item)
end

function Store:MakeItemCell(itemInfo_List)
&#9;-- Our store is partial, it always chooses to show price in ROBUX unless the item is tix only
&#9;local currencyIconId = Layout.CurrencyIcon.Robux
&#9;local currencyOfItem = &apos;PriceInRobux&apos;
&#9;local currencyTextColor = Layout.CurrencyTextColor.Robux
&#9;local membershipIcon = nil
&#9;local limitedItemIcon = nil
&#9;if itemInfo_List[&apos;PriceInRobux&apos;] == nil or itemInfo_List[&apos;PriceInRobux&apos;] == &apos;null&apos; then 
&#9;&#9;if itemInfo_List[&apos;PriceInTickets&apos;] and itemInfo_List[&apos;PriceInTickets&apos;] &gt; 0 then 
&#9;&#9;&#9;currencyIconId = Layout.CurrencyIcon.Tickets
&#9;&#9;&#9;currencyOfItem = &apos;PriceInTickets&apos;
&#9;&#9;&#9;currencyTextColor = Layout.CurrencyTextColor.Tickets
&#9;&#9;end 
&#9;end 

&#9;if itemInfo_List[&apos;MinimumMembershipLevel&apos;] &gt; 0 then 
&#9;&#9;membershipIcon = Layout.MembershipIcon[itemInfo_List[&apos;MinimumMembershipLevel&apos;]][&apos;Small&apos;]
&#9;end 

&#9;if itemInfo_List[&apos;IsLimitedUnique&apos;] then 
&#9;&#9;limitedItemIcon = Layout.LimitedUniqueIcon[&apos;Small&apos;]
&#9;elseif itemInfo_List[&apos;IsLimited&apos;] then 
&#9;&#9;limitedItemIcon = Layout.LimitedIcon[&apos;Small&apos;]
&#9;end 

&#9;local itemPage 
&#9;local itemFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 115, 0, 146);
&#9;&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;&#9;&#9;&#9;&#9;&#9;&#9;

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Background&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 115);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=105177613&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextButton&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;CLICK&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&apos;; 
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;ItemName&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = itemInfo_List[&apos;Name&apos;];
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 115);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10; &#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeColor3 = Color3.new(0, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 0.75;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextXAlignment = Enum.TextXAlignment.Left;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Currency&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 23, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 130);&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. currencyIconId;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;CurrencyAmount&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 0, 15);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 26, 0, 130);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = itemInfo_List[currencyOfItem] or 0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = currencyTextColor;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size12;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextXAlignment = Enum.TextXAlignment.Left;
&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Thumbnail&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 0, 100);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 8, 0, 8);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = BASE_URL .. &apos;thumbs/asset.ashx?assetid=&apos; .. itemInfo_List[&apos;AssetId&apos;] .. &apos;&amp;x=100&amp;y=100&amp;format=png&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;&#9;}

&#9;&#9;if itemFrame.ItemName.TextBounds.X &gt; itemFrame.ItemName.Size.X.Offset then 
&#9;&#9;&#9;itemFrame.ItemName.TextWrapped = true 
&#9;&#9;end 

&#9;if membershipIcon then 
&#9;&#9;local mIcon = NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name =&apos;MembershipIcon&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. membershipIcon;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = itemFrame;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 32, 0, 32);
&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 0, 0, 87);
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;}
&#9;end 

&#9;if limitedItemIcon then 
&#9;&#9;local xPos = (membershipIcon and 32) or 0
&#9;&#9;local lIcon = NewInstance.Create&apos;ImageLabel&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;LimitedIcon&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=&apos; .. limitedItemIcon;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = itemFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 70, 0, 24);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, xPos, 0, 89);
&#9;&#9;&#9;&#9;&#9;&#9;}
&#9;end 

&#9;itemHoverFrame = Store:CreatePopupFrame(itemInfo_List)

&#9;itemPage = Store:MakeItemPage(itemInfo_List) 

&#9;itemFrame.CLICK.MouseButton1Down:connect(function()
&#9;&#9;--print(itemInfo_List[&apos;AssetId&apos;])
&#9;&#9;MarketplaceService:PromptPurchase(Player, itemInfo_List[&apos;AssetId&apos;])
&#9;&#9;--itemPage.Visible = true 
&#9;&#9;--itemPage.Parent = StoreFrame 
&#9;end)&#9;

&#9;itemFrame.CLICK.MouseEnter:connect(function()
&#9;&#9;Store:HideAllPopups() 
&#9;&#9;Store:ShowHoverFrame(itemFrame)
&#9;end)

&#9;return itemFrame 
end

function Store:AdjustGrid(isCategorized, category, pageNum)
&#9;category = category or CurrentActiveCategory
&#9;pageNum = pageNum or 1
&#9;local row = 0 
&#9;local yOffset = 0 
&#9;local column = 1&#9;&#9;
&#9;local activeItems_List = Items_List[category]&#9;&#9;
&#9;--print(&apos;CATEGORY - &apos;, category, &apos;PAGE NUMBER - &apos;, pageNum, &apos;NUMBER OF ELEMENTS IN PAGE - &apos;, #activeItems_List[pageNum])
&#9;for i = 1, #activeItems_List[pageNum] do 
&#9;&#9;row = row + 1 
&#9;&#9;if row &gt; Layout.NumCellsInRow then 
&#9;&#9;&#9;row = row%Layout.NumCellsInRow 
&#9;&#9;&#9;yOffset = yOffset + activeItems_List[pageNum][i].Size.Y.Offset
&#9;&#9;&#9;column = column + 1
&#9;&#9;end 
&#9;&#9;activeItems_List[pageNum][i].Position = UDim2.new(0, Layout.InitOffsetX + (row - 1) * (activeItems_List[pageNum][i].Size.X.Offset + Layout.GridOffsetX), 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;0, Layout.InitOffsetY + yOffset + (column - 1) * Layout.GridOffsetY)
&#9;end &#9;
&#9;
&#9;---- FOOTER STUFF ----
&#9;FooterPageText.Text = &apos;Page &apos; .. pageNum .. &apos; of &apos; .. activeItems_List[&apos;NumberOfPages&apos;]
&#9;if pageNum &gt; 1 then 
&#9;&#9;FooterBackButton.Visible = true 
&#9;end 
&#9;if activeItems_List[&apos;NumberOfPages&apos;] &gt; 1 then 
&#9;&#9;FooterNextButton.Visible = true 
&#9;else 
&#9;&#9;FooterNextButton.Visible = false 
&#9;end 
&#9;----------------------
end

function Store:UpdateView(cName)
&#9;for i = 1, #Items_List do 
&#9;&#9;Items_List[i].Visible = false 
&#9;end 

&#9;if Items_List[cName] then 
&#9;&#9;-- do stuff here 
&#9;&#9;for pageNum, itemList in pairs(Items_List[cName]) do 
&#9;&#9;&#9;if type(itemList) == &apos;table&apos; then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local isCurrentPage = pageNum == Items_List[cName].CurrentActivePage
&#9;&#9;&#9;&#9;--print(cName, isCurrentPage, pageNum, pageNum == Items_List[cName].CurrentActivePage, #itemList)
&#9;&#9;&#9;&#9;for i = 1, #itemList do 
&#9;&#9;&#9;&#9;&#9;if itemList[i] then 
&#9;&#9;&#9;&#9;&#9;&#9;itemList[i].Visible = isCurrentPage
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end 
&#9;&#9;end 

&#9;&#9;Store:AdjustGrid(true, cName, Items_List[cName].CurrentActivePage)
&#9;end 
end 

function Store:FindCategory(category) -- returns true or false 
&#9;for i = 1, #Categories_List do 
&#9;&#9;if Categories_List[i] == category then &#9;&#9;&#9;
&#9;&#9;&#9;return true 
&#9;&#9;end
&#9;end 
&#9;return false 
end 

function Store:ApplyBackgroundColor(category)
&#9;local cChildren = CategoriesFrame:GetChildren()
&#9;for i = 1, #cChildren do 
&#9;&#9;if cChildren[i].Name == category then 
&#9;&#9;&#9;TabHighlight.Parent = cChildren[i]&#9;&#9;&#9;
&#9;&#9;end 
&#9;end 
end

function Store:AddCategory(category, pos)
&#9;local cFrame = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = category;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 75, 0, 20);
&#9;&#9;&#9;&#9;&#9;&#9;Text = category;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 0.75;
&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0, 8 + (pos-1) * 75, 0, 7);
&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size18;
&#9;&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = CategoriesFrame;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundColor3 = Color3.new(200/255, 0, 0);
&#9;&#9;&#9;&#9;&#9;}

&#9;cFrame.MouseButton1Down:connect(function()
&#9;&#9;if Categories_List[&apos;Search&apos;] then 
&#9;&#9;&#9;Categories_List[&apos;Search&apos;] = {}
&#9;&#9;end 
&#9;&#9;Store.CurrentActiveCategory = cFrame.Name
&#9;&#9;Store:UpdateView(cFrame.Name)
&#9;&#9;Store:ApplyBackgroundColor(cFrame.Name)&#9;&#9;
&#9;end)

&#9;return cFrame &#9;
end 

function Store:CreateCategories()
&#9;--- HACK! Not sure where to put this -- 
&#9;TabHighlight = NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Highlight&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 75, 0, 20);
&#9;&#9;&#9;&#9;&#9;&#9;Image = &quot;http://www.roblox.com/asset/?id=106469554&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 3.0; &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;}
&#9;-- 
&#9;for i = 1, #Categories_List do 
&#9;&#9;local category = Categories_List[i]
&#9;&#9;Store:AddCategory(category, i)
&#9;end
&#9;Store:ApplyBackgroundColor(CurrentActiveCategory)
end

function Store:AddItemToGrid(itemGui, assetType, isCategorized)
&#9;local pageNum = 1
&#9;-- Used for swapping stuff out 
&#9;table.insert(Items_List, itemGui)
&#9;-- Used for searching 
&#9;ItemHashTable[itemGui.Name:lower()] = itemGui
&#9;if isCategorized then 
&#9;&#9;if not Items_List[assetType] then 
&#9;&#9;&#9;if not CurrentActiveCategory then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = assetType 
&#9;&#9;&#9;&#9;TabHighlight.Parent = Store:ApplyBackgroundColor(CurrentActiveCategory)
&#9;&#9;&#9;end 
&#9;&#9;&#9;Items_List[assetType] = {}
&#9;&#9;&#9;Items_List[assetType][pageNum] = {}
&#9;&#9;&#9;Items_List[assetType][&apos;NumElements&apos;] = 1
&#9;&#9;&#9;Items_List[assetType][&apos;CurrentActivePage&apos;] = 1
&#9;&#9;&#9;Items_List[assetType][&apos;NumberOfPages&apos;] = 1
&#9;&#9;end 
&#9;&#9;if Items_List[assetType].NumElements ~= 0 and Items_List[assetType].NumElements/Layout.MaxItemsInPage &gt; 1 then &#9;&#9;&#9;
&#9;&#9;&#9;pageNum = math.ceil(Items_List[assetType].NumElements/Layout.MaxItemsInPage)&#9;&#9;&#9;
&#9;&#9;&#9;Items_List[assetType][&apos;NumberOfPages&apos;] = pageNum
&#9;&#9;&#9;if not Items_List[assetType][pageNum] then  
&#9;&#9;&#9;&#9;Items_List[assetType][pageNum] = {}
&#9;&#9;&#9;end 
&#9;&#9;end 

&#9;&#9;table.insert(Items_List[assetType][pageNum], itemGui)&#9;&#9;&#9;&#9;
&#9;&#9;Items_List[assetType].NumElements = Items_List[assetType].NumElements + 1
&#9;end &#9;
&#9;Store:AdjustGrid(isCategorized, assetType)&#9;
end

 

function Store:CreateItemGrid(isCategorized)
&#9;for assetId in string.gmatch(AssetIds_StringValue.Value, &apos;[^,]+&apos;) do &#9;&#9;
&#9;&#9;local productInfo
&#9;&#9;local productInfo_List
&#9;&#9;local itemGui 
&#9;&#9;local assetType
&#9;&#9;local success, error = ypcall(function() productInfo = MarketplaceService:GetProductInfo(tonumber(assetId)) end)&#9;&#9;&#9;&#9;
&#9;&#9;
&#9;&#9;if productInfo then 
&#9;&#9;&#9;productInfo_List = (type(productInfo) == &apos;string&apos;) and RBX_Utility.DecodeJSON(productInfo) or productInfo
&#9;&#9;&#9;assetType = ItemTypeId_WhiteList[tostring(productInfo_List[&apos;AssetTypeId&apos;])] 
&#9;&#9;&#9;if assetType then 
&#9;&#9;&#9;&#9;if not Store:FindCategory(assetType) then &#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;table.insert(Categories_List, assetType)
&#9;&#9;&#9;&#9;&#9;Store:AddCategory(assetType, #Categories_List)
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;itemGui = Store:MakeItemCell(productInfo_List)
&#9;&#9;&#9;&#9;Store:AddItemToGrid(itemGui, assetType, isCategorized)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end 
&#9;&#9;end &#9;
&#9;end 
end

function Store:CreateFooter()
&#9;FooterPageText = NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;PageInfo&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 100, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -50, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;Page 1 of 1&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterBackButton = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Back&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&lt;&lt;&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Visible = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 30, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -70, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterNextButton = NewInstance.Create&apos;TextButton&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Next&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;&gt;&gt;&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 30, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, 40, 0, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = FooterFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Visible = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 5.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size10;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;FooterNextButton.MouseButton1Down:connect(function()
&#9;&#9;if Items_List[CurrentActiveCategory] and Items_List[CurrentActiveCategory].CurrentActivePage then 
&#9;&#9;&#9;if Items_List[CurrentActiveCategory].CurrentActivePage + 1 &lt;= Items_List[CurrentActiveCategory].NumberOfPages then 
&#9;&#9;&#9;&#9;Items_List[CurrentActiveCategory].CurrentActivePage = Items_List[CurrentActiveCategory].CurrentActivePage  + 1
&#9;&#9;&#9;&#9;Store:UpdateView(CurrentActiveCategory)
&#9;&#9;&#9;&#9;Store:AdjustGrid(true, CurrentActiveCategory, Items_List[CurrentActiveCategory].CurrentActivePage)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;end)

&#9;FooterBackButton.MouseButton1Down:connect(function()
&#9;&#9;if Items_List[CurrentActiveCategory] and Items_List[CurrentActiveCategory].CurrentActivePage then 
&#9;&#9;&#9;if Items_List[CurrentActiveCategory].CurrentActivePage - 1 &gt; 0 then 
&#9;&#9;&#9;&#9;Items_List[CurrentActiveCategory].CurrentActivePage = Items_List[CurrentActiveCategory].CurrentActivePage - 1
&#9;&#9;&#9;&#9;Store:UpdateView(CurrentActiveCategory)
&#9;&#9;&#9;&#9;Store:AdjustGrid(true, CurrentActiveCategory, Items_List[CurrentActiveCategory].CurrentActivePage)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;end)
end

function Store:CreateSearchbar()
&#9;SearchbarFrame = NewInstance.Create&apos;Frame&apos;
&#9;&#9;&#9;&#9;&#9;&#9;{&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;SearchBarFrame&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = CategoriesFrame;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, Layout.SearchbarX, 0, Layout.SearchbarY);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(1, -(Layout.SearchbarX + 5), 0, 7);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Background&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=105218627&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;};

&#9;&#9;&#9;&#9;&#9;&#9;&#9;NewInstance.Create&apos;TextBox&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;Search&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Text = &apos;Search&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size14;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ZIndex = 4.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;SearchbarFrame.Visible = false 

&#9;Searchbar = SearchbarFrame.Search

&#9;table.insert(Categories_List, &apos;Search&apos;) -- need to clean this up
&#9;local sTab = Store:AddCategory(&apos;Search&apos;, #Categories_List) -- Not sure if this is bad 
&#9;Items_List[&apos;Search&apos;] = {}
&#9;Items_List[&apos;Search&apos;][1] = {}
&#9;Items_List[&apos;Search&apos;].NumElements = 0
&#9;Items_List[&apos;Search&apos;].NumberOfPages = 1
&#9;sTab.Visible = false 

&#9;Searchbar.FocusLost:connect(function()
&#9;&#9;-- This is a direct string search 
&#9;&#9;-- If the item is 2 words and you type only one word it won&apos;t search it correctly.
&#9;&#9;-- For now this should be plenty for you. &#9;&#9;
&#9;&#9;local searchText = Searchbar.Text&#9;&#9;
&#9;&#9;if searchText then 
&#9;&#9;&#9;Items_List[&apos;Search&apos;][1] = {}
&#9;&#9;&#9;if ItemHashTable[searchText:lower()] then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = &apos;Search&apos;
&#9;&#9;&#9;&#9;table.insert(Items_List[&apos;Search&apos;][1], ItemHashTable[searchText])
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;-- Print info text that no such thing was found 
&#9;&#9;&#9;end 
&#9;&#9;&#9;Store:UpdateView(&apos;Search&apos;)
&#9;&#9;end 
&#9;end)
end

function Store:CreateIcon()

end

function Store:ShowLoading()&#9;
&#9;local loadingCircles = {106467812, 106467831, 106467851, 106467877, 106467898, 106467911, 106467923, 106467948} 

&#9;PageFrame.ZIndex = 7.0 
&#9;local lText = NewInstance.Create&apos;TextLabel&apos; 
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;Loading&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 200, 0, 40);
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -100, 0.5, -60);
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;Text = &apos;Loading&apos;;
&#9;&#9;&#9;&#9;&#9;Font = Enum.Font.ArialBold;
&#9;&#9;&#9;&#9;&#9;FontSize = Enum.FontSize.Size36;
&#9;&#9;&#9;&#9;&#9;TextColor3 = Color3.new(132/255, 112/255, 1);
&#9;&#9;&#9;&#9;&#9;ZIndex = 8.0;
&#9;&#9;&#9;&#9;}

&#9;local lCircle = NewInstance.Create&apos;ImageLabel&apos; 
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;Circle&apos;;
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;&#9;&#9;&#9;Size = UDim2.new(0, 64, 0, 64);
&#9;&#9;&#9;&#9;&#9;Position = UDim2.new(0.5, -32, 0.5, -16);
&#9;&#9;&#9;&#9;&#9;Parent = PageFrame;
&#9;&#9;&#9;&#9;&#9;ZIndex = 8.0;
&#9;&#9;&#9;&#9;}

&#9;local count = 0
&#9;while Store.Loading do 
&#9;&#9;lCircle.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. loadingCircles[count%8 + 1]
&#9;&#9;count = count + 1
&#9;&#9;wait(0.1) 
&#9;end 

&#9;PageFrame.ZIndex = 1.0
&#9;FooterFrame.Visible = true 
&#9;lText.Visible = false 
&#9;lCircle.Visible = false 
end 

function Store:Initialize()&#9;
&#9;local isCategorized = true 
&#9;local count = 0
&#9;Gui = script.Parent 
&#9;MainFrame = Gui:WaitForChild(&apos;MainFrame&apos;)
&#9;StoreFrame = MainFrame:WaitForChild(&apos;StoreFrame&apos;)
&#9;CategoriesFrame = StoreFrame:WaitForChild(&apos;CategoriesFrame&apos;)
&#9;PlayerCurrencyFrame = StoreFrame:WaitForChild(&apos;PlayerCurrencyFrame&apos;)
&#9;FooterFrame = StoreFrame:WaitForChild(&apos;FooterFrame&apos;)

&#9;MainIcon = Gui:WaitForChild(&apos;Icon&apos;)

&#9;PageFrame = StoreFrame:WaitForChild(&apos;PageFrame&apos;)

&#9;AssetIds_StringValue = Gui:WaitForChild(&apos;AssetIds_CSV&apos;)
&#9;Categories_StringValue = Gui:WaitForChild(&apos;Categories_CSV&apos;)

&#9;for category in string.gmatch(Categories_StringValue.Value, &apos;[^,]+&apos;) do 
&#9;&#9;if category and category ~= &apos;&apos; and ItemType_WhiteList[category] then 
&#9;&#9;&#9;count = count + 1
&#9;&#9;&#9;isCategorized = true 
&#9;&#9;&#9;if count == 1 then 
&#9;&#9;&#9;&#9;CurrentActiveCategory = category
&#9;&#9;&#9;end 
&#9;&#9;&#9;table.insert(Categories_List, category)
&#9;&#9;end 
&#9;end 

&#9;Spawn(function()
&#9;&#9;Store:ShowLoading() 
&#9;end)
&#9;
&#9;-- ########################################### -- 
&#9;-- Hack to remove the store from Phones 
&#9;-- Just makes the store hidden 
&#9;if UserInputService.TouchEnabled then
&#9;&#9;wait(5) -- :|
&#9;&#9;if Gui.AbsoluteSize.Y &gt; 320 then -- On iPad (Big enough screen)
&#9;&#9;&#9;MainIcon.Visible = true
&#9;&#9;end
&#9;else -- On PC or Mac (Not a touch device)
&#9;&#9;MainIcon.Visible = true
&#9;end 
&#9;
&#9;Store:CreateFooter() 
&#9;Store:CreateCategories()
&#9;Store:CreateItemGrid(isCategorized)&#9;
&#9;Store:UpdateView(CurrentActiveCategory) &#9;
&#9;Store:CreateSearchbar()&#9;

&#9;Store.Loading = false 

&#9;MainIcon.MouseButton1Click:connect(function()
&#9;&#9;Store.MainFrame.Visible = not Store.MainFrame.Visible 
&#9;end)&#9;&#9;
end

Store:Initialize() 

</ProtectedString>
				</Properties>
			</Item>
			<Item class="ImageButton" referent="RBX203">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><url>http://www.roblox.com/asset/?id=109426216</url></Content>
					<bool name="Modal">false</bool>
					<string name="Name">Icon</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>77</XO>
						<YS>0</YS>
						<YO>-2</YO>
					</UDim2>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>80</XO>
						<YS>0</YS>
						<YO>36</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX204">
			<Properties>
				<string name="Name">VersionGui</string>
			</Properties>
			<Item class="TextLabel" referent="RBX205">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">2</token>
					<token name="FontSize">7</token>
					<string name="Name">VersionText</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.300000012</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<string name="Text">5/31/13</string>
					<Color3 name="TextColor3">4279970357</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4293984250</Color3>
					<float name="TextStrokeTransparency">0</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">false</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="LocalScript" referent="RBX206">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VersionGuiScript</string>
						<ProtectedString name="Source">local SUPER_USERS = {
&#9;OnlyTwentyCharacters = 1,
&#9;Sorcus = 1,
&#9;Games = 1,
&#9;Player1 = 1,
&#9;fusroblox = 1,
&#9;SolarCrane = 1,
&#9;tarabyte = 1,
&#9;stickmasterluke = 1
}

local VersionText = script.Parent
local VersionGui = VersionText.Parent
local PlayerGui = VersionGui.Parent
local Player = PlayerGui.Parent

if SUPER_USERS[Player.Name] then
&#9;VersionText.Visible = true
&#9;wait(1)
&#9;while VersionText.TextTransparency &lt; 1 do
&#9;&#9;VersionText.TextTransparency = VersionText.TextTransparency + 0.05
&#9;&#9;VersionText.TextStrokeTransparency = VersionText.TextStrokeTransparency + 0.05
&#9;&#9;wait()
&#9;end
&#9;VersionText.Visible = false
end

wait(0)
VersionGui:Destroy()
</ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX207">
			<Properties>
				<string name="Name">GameTypeGui</string>
			</Properties>
			<Item class="Frame" referent="RBX208">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">GameTypeFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX209">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset?id=112633738</url></Content>
						<string name="Name">GameTypeImage</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-256</XO>
							<YS>0.25</YS>
							<YO>-128</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>512</XO>
							<YS>0</YS>
							<YO>512</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX210">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">TextFrame</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.25</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX211">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">9</token>
							<string name="Name">GameTypeText</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Game Type Title</string>
							<Color3 name="TextColor3">4279970357</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4293984250</Color3>
							<float name="TextStrokeTransparency">0</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX212">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">GameTypeSubText</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>35</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">(Sub-text describing game type)</string>
							<Color3 name="TextColor3">4279970357</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4293984250</Color3>
							<float name="TextStrokeTransparency">0</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX213">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameTypeGuiScript</string>
					<ProtectedString name="Source">local ASSET_URL = &apos;http://www.roblox.com/asset?id=&apos;

local TWEEN_START = UDim2.new(-1, 0, 0.25, 0)
local TWEEN_FINISH = UDim2.new(0.5, 0, 0.25, 0)
local TWEEN_TIME = 1

local MainGameScript = Workspace:WaitForChild(&apos;MainGameScript&apos;)
local GameTypeImageIdObject = MainGameScript:WaitForChild(&apos;GameTypeImageId&apos;)

local ScreenGui = script.Parent
local GameTypeFrame = ScreenGui:WaitForChild(&apos;GameTypeFrame&apos;)
local GameTypeImage = GameTypeFrame:WaitForChild(&apos;GameTypeImage&apos;)

--NOTE: Temporary code until images are ready
local TextFrame = GameTypeFrame:WaitForChild(&apos;TextFrame&apos;)
local GameTypeText = TextFrame:WaitForChild(&apos;GameTypeText&apos;)
local GameTypeSubText = TextFrame:WaitForChild(&apos;GameTypeSubText&apos;)
local TextLookupTable = {
&#9;[1] = {&quot;Classic&quot;, &quot;(Standard rules)&quot;},
&#9;[2] = {&quot;Sword Showdown&quot;, &quot;(Swords only!)&quot;},
&#9;[3] = {&quot;Superball Smackdown&quot;, &quot;(Superballs only!)&quot;},
&#9;[4] = {&quot;Slingshot Skirmish&quot;, &quot;(Slingshots only!)&quot;},
&#9;[5] = {&quot;Bomb Blitz&quot;, &quot;(Bombs only!)&quot;},
&#9;[6] = {&quot;Rocket Rampage&quot;, &quot;(Rocket Launchers only!)&quot;},
&#9;[7] = {&quot;Party&quot;, &quot;(Three random weapons!)&quot;},
&#9;[8] = {&quot;Elimination&quot;, &quot;(Get a KO with each weapon to win!)&quot;},
&#9;[9] = {&quot;Intermission&quot;},
&#9;[10] = {&quot;Team Classic&quot;, &quot;(Standard rules, with teams!)&quot;},
&#9;[11] = {&quot;Rocket Race&quot;, &quot;(Get to the top! Hold the point!)&quot;},
&#9;[12] = {&quot;Juggernaut&quot;, &quot;(Fight to be the Juggernaut!)&quot;},
&#9;[13] = {&quot;Sword Swept&quot;, &quot;(Swords Vs. Brooms)&quot;},
&#9;[14] = {&quot;Back Blast&quot;, &quot;(Rockets Vs. Reflectors)&quot;},
}

local function OnChanged(newId)
&#9;if newId ~= 0 then
&#9;&#9;--GameTypeImage.Image = ASSET_URL .. tostring(newId)
&#9;&#9;local textTable = TextLookupTable[newId]
&#9;&#9;GameTypeText.Text = textTable[1]
&#9;&#9;GameTypeSubText.Text = textTable[2] or &apos;&apos;
&#9;&#9;TextFrame.Position = TWEEN_START
&#9;&#9;TextFrame:TweenPosition(TWEEN_FINISH, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, TWEEN_TIME, true)
&#9;&#9;GameTypeFrame.Visible = true
&#9;end
end

GameTypeImageIdObject.Changed:connect(OnChanged)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX214">
			<Properties>
				<string name="Name">WalletGui</string>
			</Properties>
			<Item class="Frame" referent="RBX215">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">buttonFrame</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>162</XO>
						<YS>0</YS>
						<YO>-3</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>73</XO>
						<YS>0</YS>
						<YO>37</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageButton" referent="RBX216">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=117503250 </url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">ImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">true</bool>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">2</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX217">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=117502635 </url></Content>
						<bool name="Modal">false</bool>
						<string name="Name">HighlightImageButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-30</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>134</XO>
							<YS>0</YS>
							<YO>68</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX218">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WalletGuiScript</string>
					<ProtectedString name="Source">local ENABLED = false
if not ENABLED then return end

local Create = LoadLibrary(&apos;RbxUtility&apos;).Create

local ScreenGui = script.Parent
local Player = ScreenGui.Parent.Parent

local openButton = ScreenGui:WaitForChild(&apos;buttonFrame&apos;)

local otherstats = Player:WaitForChild(&apos;otherstats&apos;)

-- player got coin event and args
local PlayerGotCoin_Event = Workspace:WaitForChild(&apos;CoinService&apos;):WaitForChild(&apos;PlayerGotCoin&apos;)
local PlayerGotCoin_Player = PlayerGotCoin_Event:WaitForChild(&apos;Player&apos;)
local PlayerGotCoin_Location = PlayerGotCoin_Event:WaitForChild(&apos;Location&apos;)

-- coins persistent value
local CoinsValue = Player:WaitForChild(&apos;PersistentModel&apos;):WaitForChild(&apos;Coins&apos;)

-- is open flag
local WalletMenuOpen = otherstats:FindFirstChild(&apos;WalletMenuOpen&apos;)
if not WalletMenuOpen then
&#9;WalletMenuOpen = Create&apos;BoolValue&apos;{
&#9;&#9;Parent = otherstats;
&#9;&#9;Name = &apos;WalletMenuOpen&apos;;
&#9;&#9;Value = false;
&#9;}
end

-- showamount gui
local ShowAmountFrame = ScreenGui:WaitForChild(&apos;ShowAmount&apos;)
local ShowAmountText = ShowAmountFrame:WaitForChild(&apos;Amount&apos;)
local ShowAmountText2 = ShowAmountText:WaitForChild(&apos;AmountBold&apos;)
ShowAmountText.Changed:connect(function(pr)
&#9;if pr == &apos;Text&apos; then ShowAmountText2.Text = ShowAmountText.Text end
end)
local ShowAmountLastShownAt = 0


-- my coin count
local MyCoinCount = Instance.new(&apos;IntValue&apos;)
MyCoinCount.Value = CoinsValue.Value
MyCoinCount.Changed:connect(function()
&#9;ShowAmountText.Text = MyCoinCount.Value
end)

--
function ShowAmount()
&#9;ShowAmountLastShownAt = tick()
&#9;local myLastShownAt = ShowAmountLastShownAt
&#9;--
&#9;ShowAmountText.Text = MyCoinCount.Value
&#9;ShowAmountFrame:TweenPosition(UDim2.new(0.68, 124, 0, -8), &apos;Out&apos;, &apos;Quad&apos;, 0.7, true)
&#9;--
&#9;wait(2)
&#9;--
&#9;if ShowAmountLastShownAt == myLastShownAt then
&#9;&#9;ShowAmountFrame:TweenPosition(UDim2.new(0.68, 124, 0, -110), &apos;Out&apos;, &apos;Quad&apos;, 0.7, true)
&#9;end
end

PlayerGotCoin_Event.Changed:connect(function()
&#9;if PlayerGotCoin_Player.Value == Player then
&#9;&#9;local at = PlayerGotCoin_Location.Value

&#9;&#9;--
&#9;&#9;local point = Workspace.CurrentCamera.CoordinateFrame:pointToObjectSpace(at)
&#9;&#9;local aspectRatio = ScreenGui.AbsoluteSize.X/ScreenGui.AbsoluteSize.Y
&#9;&#9;local nearClip = Vector3.new(0,0,1)&#9;
&#9;&#9;local xFrac = ((-point.X - nearClip.X)*(nearClip.Z/point.Z))/aspectRatio + 0.5
&#9;&#9;local yFrac = (( point.Y - nearClip.Y)*(nearClip.Z/point.Z)) + 0.5
&#9;&#9;
&#9;&#9;-- make a dummy coin and a screen gui attached to it to find out where
&#9;&#9;-- how large the coin is in the player&apos;s view
&#9;&#9;local dummyCoin = Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &apos;DummyCoin&apos;;
&#9;&#9;&#9;Anchored = true;
&#9;&#9;&#9;CanCollide = false;
&#9;&#9;&#9;Parent = Player.Character;
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;;
&#9;&#9;&#9;CFrame = CFrame.new(at);
&#9;&#9;&#9;Transparency = 1;
&#9;&#9;&#9;Size = Vector3.new(1.5,0.2,1.5);
&#9;&#9;}
&#9;&#9;local finderGui = Create&apos;BillboardGui&apos;{
&#9;&#9;&#9;Parent = Player.PlayerGui;
&#9;&#9;&#9;Adornee = dummyCoin;
&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;Create&apos;Frame&apos;{
&#9;&#9;&#9;&#9;Name = &apos;Measure&apos;;
&#9;&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;};
&#9;&#9;}

&#9;&#9;-- wait a frame for the gui to update
&#9;&#9;wait()

&#9;&#9;-- get rid of the stuff and animate a coin
&#9;&#9;local size = finderGui.Measure.AbsoluteSize

&#9;&#9;dummyCoin:Destroy()
&#9;&#9;finderGui:Destroy()

&#9;&#9;-- make the coin GUI
&#9;&#9;local coinGui = Create&apos;ImageLabel&apos;{
&#9;&#9;&#9;Name = &apos;Coin&apos;;
&#9;&#9;&#9;Image = &apos;http://www.roblox.com/asset/?id=117509969&apos;;
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;ZIndex = 4;
&#9;&#9;}
&#9;&#9;coinGui.Position = UDim2.new(xFrac, 0, yFrac, 0)
&#9;&#9;coinGui.Size = UDim2.new(0, size.x, 0, size.y)
&#9;&#9;coinGui.Parent = ScreenGui

&#9;&#9;-- tween the coin to the top button, and show the shownamount
&#9;&#9;Delay(0.5, ShowAmount)
&#9;&#9;local function endTweenFunc()
&#9;&#9;&#9;coinGui:Destroy()
&#9;&#9;&#9;MyCoinCount.Value = MyCoinCount.Value + 1
&#9;&#9;end
&#9;&#9;coinGui:TweenSizeAndPosition(UDim2.new(0, 60, 0, 60), 
&#9;&#9;&#9;                         UDim2.new(0.68, 162, 0, -30),
&#9;&#9;&#9;                         &apos;In&apos;, &apos;Quad&apos;, 0.9, true, 
&#9;&#9;&#9;                         endTweenFunc)
&#9;end
end)








local function onShowHide()
&#9;WalletMenuOpen.Value = not WalletMenuOpen.Value
&#9;--
&#9;if WalletMenuOpen.Value then
&#9;&#9;openButton.HighlightImageButton.Visible = true
&#9;&#9;openButton.ImageButton.Visible = false
&#9;else
&#9;&#9;openButton.HighlightImageButton.Visible = false
&#9;&#9;openButton.ImageButton.Visible = true
&#9;end
end
openButton:WaitForChild(&apos;ImageButton&apos;).MouseButton1Click:connect(onShowHide)
openButton:WaitForChild(&apos;HighlightImageButton&apos;).MouseButton1Click:connect(onShowHide)
openButton.ImageButton.Visible = true
if WalletMenuOpen.Value then
&#9;WalletMenuOpen.Value = false
&#9;onShowHide()
end

function PreloadAll(obj)
&#9;for _, i in pairs(obj:GetChildren()) do
&#9;&#9;PreloadAll(i)
&#9;end
&#9;if obj:IsA(&apos;ImageButton&apos;) or obj:IsA(&apos;ImageLabel&apos;) then
&#9;&#9;Game:GetService(&quot;ContentProvider&quot;):Preload(obj.Image)
&#9;end
end

PreloadAll(ScreenGui)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX219">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ShowAmount</string>
					<UDim2 name="Position">
						<XS>0.680000007</XS>
						<XO>124</XO>
						<YS>0</YS>
						<YO>-110</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>150</XO>
						<YS>0</YS>
						<YO>80</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">3</int>
				</Properties>
				<Item class="TextLabel" referent="RBX220">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">Amount</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">$10000</string>
						<Color3 name="TextColor3">4284895492</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="TextLabel" referent="RBX221">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">AmountBold</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">$10000</string>
							<Color3 name="TextColor3">4293705240</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX222">
			<Properties>
				<string name="Name">RocketRaceGui</string>
			</Properties>
			<Item class="Frame" referent="RBX223">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">InstructionFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-255</XO>
						<YS>0</YS>
						<YO>100</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>500</XO>
						<YS>0</YS>
						<YO>200</YO>
					</UDim2>
					<token name="SizeConstraint">2</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX224">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Title</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-150</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>300</XO>
							<YS>0</YS>
							<YO>26</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX225">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">6</token>
							<string name="Name">TextLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">----     Rocket Race Mode     ----</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX226">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">5</token>
						<string name="Name">MainText</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Welcome to the Rocket Race mode!

The goal of the game is to get to the top and keep away other players for long enough to capture it, all you have to help you is a sword and a rocket.

Some of the blocks in the level are colored, and if you stand on blocks of your color you will be protected from attacks by other players.

You can also shoot and destroy blocks in the level using the rocket.</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX227">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<bool name="Modal">false</bool>
						<string name="Name">ShowButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>-16</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>32</XO>
							<YS>0</YS>
							<YO>32</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4294967295</Color3>
						<float name="TextStrokeTransparency">0.5</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX228">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">ShowButtonImage</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-5</XO>
								<YS>0</YS>
								<YO>-15</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>10</XO>
								<YS>1</YS>
								<YO>10</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">&lt;</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX229">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InstructionScript</string>
						<ProtectedString name="Source">local Player = script.Parent.Parent.Parent.Parent
local InstructionsShown = Player:WaitForChild(&apos;otherstats&apos;):WaitForChild(&apos;RocketRaceIntroGuiShown&apos;)
      InstructionsShown.Value = false

local GameScript = Workspace:WaitForChild(&apos;MainGameScript&apos;)
local CurrentGameType = GameScript:WaitForChild(&apos;CurrentGameType&apos;)

local ShownPosition = UDim2.new(0.5, -255, 0, 100)
local HiddenPosition = UDim2.new(0, -490, 0, 130)

local gui = script.Parent

gui:WaitForChild(&apos;ShowButton&apos;)
gui.ShowButton.MouseButton1Down:connect(function()
&#9;if InstructionsShown.Value then
&#9;&#9;InstructionsShown.Value = false
&#9;&#9;gui:TweenPosition(HiddenPosition)
&#9;&#9;gui.ShowButton.ShowButtonImage.Text = &quot;&gt;&quot;
&#9;else
&#9;&#9;InstructionsShown.Value = true
&#9;&#9;gui:TweenPosition(ShownPosition)
&#9;&#9;gui.ShowButton.ShowButtonImage.Text = &quot;&lt;&quot;
&#9;end
end)

gui:WaitForChild(&apos;OkayButton&apos;)
gui.OkayButton.MouseButton1Down:connect(function()
&#9;if InstructionsShown.Value then
&#9;&#9;InstructionsShown.Value = false
&#9;&#9;gui:TweenPosition(HiddenPosition)
&#9;&#9;gui.ShowButton.ShowButtonImage.Text = &quot;&gt;&quot;
&#9;end
end)

if not InstructionsShown.Value then
&#9;gui.Position = HiddenPosition
&#9;gui.ShowButton.ShowButtonImage.Text = &quot;&gt;&quot;
end

CurrentGameType.ChildAdded:connect(function(ch)
&#9;if ch.Name == &apos;RocketRace&apos; then
&#9;&#9;gui.Visible = false&#9;&#9;
&#9;end
end)
CurrentGameType.ChildRemoved:connect(function(ch)
&#9;gui.Visible = false
end)
if CurrentGameType:FindFirstChild(&apos;RocketRace&apos;) then
&#9;gui.Visible = true
end



</ProtectedString>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX230">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">OkayButton</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-80</XO>
							<YS>1</YS>
							<YO>-18</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>160</XO>
							<YS>0</YS>
							<YO>32</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">2</token>
						<string name="Text">Okay, got it!</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4294967295</Color3>
						<float name="TextStrokeTransparency">0.899999976</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX231">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">MessageFrame</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-110</XO>
						<YS>0</YS>
						<YO>74</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>220</XO>
						<YS>0</YS>
						<YO>80</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX232">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">6</token>
						<string name="Name">GlobalMessage</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4290295992</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX233">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GlobalMessageScript</string>
						<ProtectedString name="Source">--============================================================================--
--==                          Global Settings                               ==--
--============================================================================--
local MaximizedSize = UDim2.new(0, 220, 0, 80)
local MaximizedPosition = UDim2.new(0.5, -110, 0, 80)
local MinimizedSize = UDim2.new(0, 60, 0, 60)
local MinimizedPosition = UDim2.new(0, -100, 0, -100)


--============================================================================--
--==                         Global Variables                               ==--
--============================================================================--
-- gui
local MessageFrame = script.Parent
local Player = MessageFrame.Parent.Parent.Parent
local MessageLabel = MessageFrame:WaitForChild(&apos;GlobalMessage&apos;)

-- workspace
local GameScript = Workspace:WaitForChild(&apos;MainGameScript&apos;)
local CurrentGameType = GameScript:WaitForChild(&apos;CurrentGameType&apos;)
local GlobalMessageData;
local MaximizedValue;
local TextValue;


--============================================================================--
--==                             Functions                                  ==--
--============================================================================--
function Maximize()
&#9;MessageLabel.TextXAlignment = &apos;Center&apos;
&#9;MessageFrame:TweenSizeAndPosition(MaximizedSize, MaximizedPosition, &apos;Out&apos;, &apos;Quad&apos;, 1, true)
end

function Minimize()
&#9;MessageLabel.TextXAlignment = &apos;Left&apos;
&#9;MessageFrame:TweenSizeAndPosition(MinimizedSize, MinimizedPosition, &apos;Out&apos;, &apos;Quad&apos;, 1, true)
end

function SetText(text)
&#9;MessageLabel.Text = text
end

function Init()
&#9;if MaximizedValue then
&#9;&#9;if MaximizedValue.Value then
&#9;&#9;&#9;MessageFrame.Position = MaximizedPosition
&#9;&#9;&#9;MessageFrame.Size = MaximizedSize
&#9;&#9;&#9;MessageLabel.TextXAlignment = &apos;Left&apos;
&#9;&#9;else
&#9;&#9;&#9;MessageFrame.Position = MinimizedPosition
&#9;&#9;&#9;MessageFrame.Size = MinimizedSize
&#9;&#9;&#9;MessageLabel.TextXAlignment = &apos;Center&apos;
&#9;&#9;end
&#9;end
&#9;if TextValue then
&#9;&#9;SetText(TextValue.Value)
&#9;end
end


--============================================================================--
--==                          Event Handling                                ==--
--============================================================================--
local function Show()
&#9;local GameData = CurrentGameType:WaitForChild(&apos;RocketRace&apos;):WaitForChild(&apos;GameData&apos;)
&#9;GlobalMessageData = GameData:WaitForChild(&apos;GlobalMessage&apos;)
&#9;MaximizedValue = GlobalMessageData:WaitForChild(&apos;Maximized&apos;)
&#9;TextValue = GlobalMessageData:WaitForChild(&apos;Text&apos;)
&#9;--
&#9;MaximizedValue.Changed:connect(function()
&#9;&#9;if MaximizedValue.Value then
&#9;&#9;&#9;Maximize()
&#9;&#9;else
&#9;&#9;&#9;Minimize()
&#9;&#9;end
&#9;end)
&#9;
&#9;TextValue.Changed:connect(function()
&#9;&#9;SetText(TextValue.Value)
&#9;end)
&#9;--
&#9;MessageFrame.Visible = true
&#9;Init()
end
CurrentGameType.ChildAdded:connect(function(ch)
&#9;if ch.Name == &apos;RocketRace&apos; then
&#9;&#9;Show()&#9;
&#9;end
end)
CurrentGameType.ChildRemoved:connect(function(ch)
&#9;MessageFrame.Visible = false
end)
if CurrentGameType:FindFirstChild(&apos;RocketRace&apos;) then
&#9;Show()
end


-- done init
Init()


</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="TextButton" referent="RBX234">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="AutoButtonColor">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">2</token>
					<token name="FontSize">6</token>
					<bool name="Modal">false</bool>
					<string name="Name">SpectateNext</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-100</XO>
						<YS>1</YS>
						<YO>-200</YO>
					</UDim2>
					<bool name="Selected">false</bool>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>240</XO>
						<YS>0</YS>
						<YO>60</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">2</token>
					<string name="Text">Spectate: Different Player
(Round in progress)</string>
					<Color3 name="TextColor3">4294967295</Color3>
					<bool name="TextScaled">false</bool>
					<Color3 name="TextStrokeColor3">4278190080</Color3>
					<float name="TextStrokeTransparency">1</float>
					<float name="TextTransparency">0</float>
					<bool name="TextWrapped">true</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX235">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PointsDisplay</string>
					<ProtectedString name="Source">local RbxUtility = LoadLibrary(&apos;RbxUtility&apos;)
local Create = RbxUtility.Create

--============================================================================--
--==                         Global Variables                               ==--
--============================================================================--

-- player
local Player = script.Parent.Parent.Parent
local PlayerData = Player:WaitForChild(&apos;otherstats&apos;)
local PointsEvent = PlayerData:WaitForChild(&apos;GotPointsAtLocation&apos;)

local PlayerGui = script.Parent.Parent


--============================================================================--
--==                              Functions                                 ==--
--============================================================================--

function GotPointsAtLocation(points, at)
&#9;local gotpointsPart = Create&apos;Part&apos;{
&#9;&#9;Name = &apos;GotPointsDisplay&apos;;
&#9;&#9;Parent = Player.Character;
&#9;&#9;FormFactor = &apos;Custom&apos;;
&#9;&#9;Size = Vector3.new(0.2, 0.2, 0.2);
&#9;&#9;Transparency = 1;
&#9;&#9;CFrame = CFrame.new(at);
&#9;&#9;CanCollide = false;
&#9;&#9;Anchored = false;
&#9;&#9;--
&#9;&#9;Create&apos;BodyForce&apos;{
&#9;&#9;&#9;force = Vector3.new(0, 1.05 * 0.2^3 * 196.2, 0);
&#9;&#9;};
&#9;}
&#9;local billboard = Create&apos;BillboardGui&apos;{
&#9;&#9;Name = &apos;GotPointsDisplay&apos;;
&#9;&#9;Parent = PlayerGui;
&#9;&#9;Adornee = gotpointsPart;
&#9;&#9;Size = UDim2.new(0, 250, 0, 64);
&#9;&#9;AlwaysOnTop = true;
&#9;&#9;--
&#9;&#9;Create&apos;TextLabel&apos;{
&#9;&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;TextScaled = true;
&#9;&#9;&#9;Font = &apos;ArialBold&apos;;
&#9;&#9;&#9;Text = points;
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;TextColor3 = Player.TeamColor.Color;
&#9;&#9;&#9;TextStrokeColor3 = Color3.new(0,0,0);
&#9;&#9;&#9;TextStrokeTransparency = 0;
&#9;&#9;};
&#9;}
&#9;game.Debris:AddItem(gotpointsPart, 2)
&#9;game.Debris:AddItem(billboard, 2)
end


--============================================================================--
--==                                 Events                                 ==--
--============================================================================--

PointsEvent.Changed:connect(function()
&#9;GotPointsAtLocation(PointsEvent.Points.Value, PointsEvent.Location.Value)
end)


</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX236">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">cameraScript</string>
				<ProtectedString name="Source">function WaitForChild(parent,child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;wait() print(&quot; waitforchild: &quot;..parent.Name..&quot; waiting for &quot;..child)
&#9;end
&#9;return parent[child]
end

local KillingPlayer = WaitForChild(script,&apos;KillingPlayer&apos;)
local DoOuttro = WaitForChild(script,&apos;DoOuttro&apos;)
local MyPlayer=script.Parent.Parent
local initialPosition=MyPlayer:FindFirstChild(&apos;IntroInitialPosition&apos;)
if not initialPosition then
&#9;initialPosition = WaitForChild(script,&apos;IntroInitialPosition&apos;)
&#9;initialPosition.Parent=MyPlayer
end

local Camera= Workspace.CurrentCamera

local IntroTime=1.5
local KillCamTime=2
local PreIntroWaitTime=.5
local OuttroTime=6

local InIntro=false
local InOuttro=false
local InKillCam=false

local function Freeze(basePart)
&#9;local bodyPosition = Instance.new(&apos;BodyPosition&apos;)
&#9;bodyPosition.maxForce = Vector3.new(1e9, 0, 1e9)
&#9;bodyPosition.position = basePart.Position
&#9;bodyPosition.Parent = basePart
&#9;local bodyGyro = Instance.new(&apos;BodyGyro&apos;)
&#9;bodyGyro.maxTorque = Vector3.new(1e9, 1e9, 1e9)
&#9;bodyGyro.cframe = CFrame.new(Vector3.new(), basePart.CFrame.lookVector)
&#9;bodyGyro.Parent = basePart
&#9;return bodyPosition, bodyGyro
end

function DoIntroCam()
&#9;local MyCharacter=MyPlayer.Character
&#9;local Humanoid=WaitForChild(MyCharacter,&apos;Humanoid&apos;)
&#9;local torso=WaitForChild(MyCharacter,&apos;Torso&apos;)

&#9;InIntro=true
&#9;--you have to wait until player has properly spawned and been repositioned, a little ugly

&#9;local head = WaitForChild(MyCharacter,&apos;Head&apos;)
&#9;local torsoPosition, torsoGyro = Freeze(torso)

&#9;local startTime=tick()
&#9;while (tick()-startTime)&lt;PreIntroWaitTime and not InOuttro do
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=initialPosition.Value
&#9;&#9;wait()
&#9;end

&#9;startTime=tick()
&#9;local startTime=tick()
&#9;while (tick()-startTime)&lt;IntroTime and not InOuttro do
&#9;&#9;local myDir=head.CFrame.lookVector
&#9;&#9;local myPosition = head.CFrame.p
&#9;&#9;local finalPosition = CFrame.new(myPosition-(myDir*4),myPosition)
&#9;&#9;local initialLookVector = (initialPosition.Value.p+initialPosition.Value.lookVector)
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=CFrame.new(
&#9;&#9;&#9;initialPosition.Value.p:Lerp(finalPosition.p,(tick()-startTime)/IntroTime),
&#9;&#9;&#9;initialLookVector:Lerp(myPosition,(tick()-startTime)/IntroTime))
&#9;&#9;wait(1/30)
&#9;end
&#9;Camera.CameraSubject = Humanoid
&#9;Camera.CameraType=&apos;Custom&apos;

&#9;--add the tag that the intro has played
&#9;local playedTag = MyPlayer:FindFirstChild(&apos;IntroPlayed&apos;)
&#9;if not playedTag then
&#9;&#9;playedTag=Instance.new(&apos;BoolValue&apos;)
&#9;&#9;playedTag.Name=&apos;IntroPlayed&apos;
&#9;&#9;playedTag.Parent=MyPlayer
&#9;end
&#9;playedTag.Value=true

&#9;torsoPosition:Destroy()
&#9;torsoGyro:Destroy()

&#9;InIntro=false
end

function DoOuttroCam()
&#9;InOuttro=true
&#9;initialPosition.Value=WaitForChild(script,&apos;IntroInitialPosition&apos;).Value
&#9;local cameraStart=Camera.CoordinateFrame
&#9;local startTime=tick()
&#9;local initialLookVector = (cameraStart.p+cameraStart.lookVector)
&#9;local StartPosition=initialPosition.Value
&#9;while (tick()-startTime)&lt;OuttroTime do
&#9;&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;&#9;Camera.CoordinateFrame=CFrame.new(
&#9;&#9;&#9;cameraStart.p:Lerp(StartPosition.p,(tick()-startTime)/OuttroTime),
&#9;&#9;&#9;initialLookVector:Lerp(Vector3.new(0,0,0),(tick()-startTime)/OuttroTime))
&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;&#9;wait(1/30)
&#9;end

&#9;local focus = Vector3.new(0,0,0)
&#9;local radius = Vector3.new(Camera.CoordinateFrame.p.x,0,Camera.CoordinateFrame.p.z).magnitude
&#9;local angle = math.atan2(Camera.CoordinateFrame.p.x,Camera.CoordinateFrame.p.z)
&#9;local omega = .0025
&#9;local initialY=Camera.CoordinateFrame.y
&#9;while true do
&#9;&#9;Camera.CameraType = Enum.CameraType.Scriptable
&#9;&#9;Camera.CoordinateFrame = CFrame.new( Vector3.new(math.sin(angle) * radius, initialY, math.cos(angle) * radius), focus)
&#9;&#9;angle = angle + omega
&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
 &#9;&#9;wait(1/30)
&#9;end

&#9;InOuttro=false
end

function DoKillCam()
&#9;if InIntro or InOuttro then return end
&#9;InKillCam=true
&#9;Camera.CameraType=&apos;Scriptable&apos;
&#9;wait(1.5)
&#9;local killerHead= KillingPlayer.Value.Character:FindFirstChild(&apos;Head&apos;)
&#9;Camera= game.Workspace.CurrentCamera
&#9;
&#9;if KillingPlayer.Value ~= MyPlayer then
&#9;&#9;Camera.CameraType=&apos;Watch&apos;
&#9;&#9;Camera.CameraSubject=killerHead
&#9;&#9;while not InIntro and not InOuttro do
&#9;&#9;&#9;--have to do this in a loop in case player resets unexpectedly
&#9;&#9;&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;&#9;&#9;wait(1/30)
&#9;&#9;end
&#9;end
&#9;--have to do this also after loop in case of suicide or round reset
&#9;initialPosition.Value=Camera.CoordinateFrame
&#9;InKillCam=false
end

KillingPlayer.Changed:connect(DoKillCam)

DoOuttro.Changed:connect(DoOuttroCam)

MyPlayer.CharacterAdded:connect(function()
&#9;wait(0) -- Otherwise we get invalid characters
&#9;DoIntroCam()
end)
</ProtectedString>
			</Properties>
			<Item class="ObjectValue" referent="RBX237">
				<Properties>
					<string name="Name">KillingPlayer</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="CFrameValue" referent="RBX238">
				<Properties>
					<string name="Name">IntroInitialPosition</string>
					<CoordinateFrame name="Value">
						<X>-22.2998962</X>
						<Y>284.594025</Y>
						<Z>-287.420837</Z>
						<R00>-0.996024728</R00>
						<R01>0.0636545345</R01>
						<R02>-0.0623119995</R02>
						<R10>3.7252903e-009</R10>
						<R11>0.69953078</R11>
						<R12>0.71460247</R12>
						<R20>0.0890768468</R20>
						<R21>0.711761713</R21>
						<R22>-0.696749985</R22>
					</CoordinateFrame>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX239">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DeathListener</string>
					<ProtectedString name="Source">--
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end
local LocalPlayer=script.Parent.Parent.Parent
LocalPlayer.CharacterAdded:connect(function()
&#9;local Humanoid=WaitForChild(LocalPlayer.Character,&apos;Humanoid&apos;)
&#9;Humanoid.Died:connect(function()
&#9;&#9;print(&apos;humanoid.died fired&apos;)
&#9;&#9;local tag = WaitForChild(Humanoid,&quot;creator&quot;)
&#9;&#9;if tag and tag.Value then
&#9;&#9;&#9;WaitForChild(script.Parent,&apos;KillingPlayer&apos;).Value=tag.Value
&#9;&#9;end
&#9;end)
end)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX240">
				<Properties>
					<string name="Name">DoOuttro</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX241">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">10</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<float name="RolloffScale">1</float>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX242">
		<Properties>
			<string name="Name">CollectionService</string>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX243">
		<Properties>
			<string name="Name">PhysicsService</string>
		</Properties>
	</Item>
	<Item class="BadgeService" referent="RBX244">
		<Properties>
			<string name="Name">BadgeService</string>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX245">
		<Properties>
			<string name="Name">Geometry</string>
		</Properties>
	</Item>
	<Item class="RenderHooksService" referent="RBX246">
		<Properties>
			<string name="Name">RenderHooksService</string>
		</Properties>
	</Item>
	<Item class="SocialService" referent="RBX247">
		<Properties>
			<string name="Name">SocialService</string>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX248">
		<Properties>
			<string name="Name">GamePassService</string>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX249">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX250">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ScriptInformationProvider" referent="RBX251">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX252">
		<Properties>
			<string name="Name">CookiesService</string>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX253">
		<Properties>
			<string name="Name">Teleport Service</string>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX254">
		<Properties>
			<bool name="CharacterAutoLoads">false</bool>
			<string name="Name">Players</string>
		</Properties>
	</Item>
	<Item class="FWService" referent="RBX255">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="UserInputService" referent="RBX256">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX257">
		<Properties>
			<string name="Name">ContextActionService</string>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX258">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX259">
		<Properties>
			<string name="Name">Selection</string>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX260">
		<Properties>
			<Color3 name="Ambient">4283453520</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">4278190080</Color3>
			<Color3 name="ColorShift_Top">4278190080</Color3>
			<Color3 name="FogColor">4290822336</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">4286611584</Color3>
			<Color3 name="ShadowColor">4290032825</Color3>
			<string name="TimeOfDay">11:00:00</string>
		</Properties>
		<Item class="Sky" referent="RBX261">
			<Properties>
				<bool name="CelestialBodiesShown">true</bool>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>http://www.roblox.com/asset?id=58372690</url></Content>
				<Content name="SkyboxDn"><url>http://www.roblox.com/asset?id=58372722</url></Content>
				<Content name="SkyboxFt"><url>http://www.roblox.com/asset?id=58372742</url></Content>
				<Content name="SkyboxLf"><url>http://www.roblox.com/asset?id=58372777</url></Content>
				<Content name="SkyboxRt"><url>http://www.roblox.com/asset?id=58372794</url></Content>
				<Content name="SkyboxUp"><url>http://www.roblox.com/asset?id=58372812</url></Content>
				<int name="StarCount">3000</int>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX262">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">WeaponData</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX263">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Sword</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX264">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830724</int>
					</Properties>
				</Item>
				<Item class="Tool" referent="RBX265">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>-1.25</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<string name="Name">Sword</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746192</url></Content>
						<string name="ToolTip">Sword</string>
					</Properties>
					<Item class="SpecialMesh" referent="RBX266">
						<Properties>
							<token name="LODX">2</token>
							<token name="LODY">2</token>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94746028</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746105</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX267">
						<Properties>
							<string name="Name">PlayOverhead</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX268">
						<Properties>
							<string name="Name">PlaySlash</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX269">
						<Properties>
							<string name="Name">PlayThrust</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX270">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SwordScript</string>
							<ProtectedString name="Source">local DebrisService = Game:GetService(&quot;Debris&quot;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local damage = 10

local WALK_SPEED_BUFF = 4

local SLASH_DAMAGE = 45
local LUNGE_DAMAGE = 60
local OVERHEAD_SLASH_DAMAGE = 100
local CAN_CUT_TREES = true

local Tool = script.Parent
local Handle = Tool.Handle

local KILL_FEED_ICON_URL = &apos;http://www.roblox.com/asset/?id=94746323&apos;

local MyCharacter
local MyHumanoid

local PlaySlash
local PlayThrust
local PlayOverhead

local AttackSequence = {}
local SlashSound = Handle:WaitForChild(&apos;SlashSound&apos;)

local OverheadSound = Handle:WaitForChild(&apos;OverheadSound&apos;)

local LungeSound = Handle:WaitForChild(&apos;LungeSound&apos;)

local UnsheathSound = Handle:WaitForChild(&apos;UnsheathSound&apos;)

local HitSound = Handle:WaitForChild(&apos;HitSound&apos;)

local IsCrystal = Tool:WaitForChild(&apos;IsCrystal&apos;)

local HitCharacters

local CreatorTag = nil

local TreeNames = {Trees = true,
&#9;PineTree = true,
&#9;Tree = true,
&#9;[&apos;Tree Full&apos;] = true,
&#9;[&apos;Tree Small&apos;] = true
&#9;}

local function CheckInTreesModel(object)
&#9;while object do
&#9;&#9;if object:FindFirstChild(&apos;Humanoid&apos;) then return false end
&#9;&#9;if TreeNames[object.Name] then return true end
&#9;&#9;object = object.Parent
&#9;end&#9;
&#9;return false
&#9;--return object and object.Parent and object.Parent.Name == &apos;Tree&apos;
&#9;--if object == nil or not Workspace:FindFirstChild(&apos;Trees&apos;) or not object.Parent or object.Parent.Name == &apos;Billboard&apos; then return false end
&#9;--return object:IsDescendantOf(Workspace.Trees)
end

function Blow(hit)
&#9;if (hit.Parent == nil) then return end -- happens when bullet hits sword
&#9;local humanoid = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;local vCharacter = Tool.Parent
&#9;--local vPlayer = game.Players:playerFromCharacter(vCharacter)
&#9;local hum = vCharacter:findFirstChild(&quot;Humanoid&quot;) -- non-nil if tool held by a character
&#9;if humanoid~=nil and humanoid ~= hum and hum ~= nil and HitCharacters and not HitCharacters[humanoid.Parent] then
&#9;&#9;-- final check, make sure sword is in-hand
&#9;&#9;local right_arm = vCharacter:FindFirstChild(&quot;Right Arm&quot;)
&#9;&#9;if (right_arm ~= nil) then
&#9;&#9;&#9;local joint = right_arm:FindFirstChild(&quot;RightGrip&quot;)
&#9;&#9;&#9;if (joint ~= nil and (joint.Part0 == Handle or joint.Part1 == Handle)) then
&#9;&#9;&#9;&#9;HitCharacters[humanoid.Parent] = true
&#9;&#9;&#9;&#9;--TagHumanoid(humanoid, vPlayer)
&#9;&#9;&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;&#9;if IsCrystal.Value then
&#9;&#9;&#9;&#9;&#9;&#9;HitSound:Play()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;hitBindable:Invoke(damage, CreatorTag)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif CheckInTreesModel(hit) and Tool.Enabled == false and CAN_CUT_TREES then
&#9;&#9;hit:BreakJoints()
&#9;&#9;if hit and not hit.Parent:FindFirstChild(&apos;Cut&apos;) then
&#9;&#9;&#9;if hit.Parent and hit.Parent:FindFirstChild(&apos;Ball&apos;) then
&#9;&#9;&#9;&#9;hit.Parent.Ball.Velocity =
&#9;&#9;&#9;&#9;&#9;hit.Parent.Ball.Velocity +
&#9;&#9;&#9;&#9;&#9; CFrame.Angles(0, -math.rad(math.random(0, 180)), 0) * ((hit.CFrame.p - MyCharacter.Torso.CFrame.p).unit:Cross(Vector3.new(0,1,0)) * 15)
&#9;&#9;&#9;&#9;local cut = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;&#9;cut.Value = true
&#9;&#9;&#9;&#9;cut.Name = &apos;Cut&apos;
&#9;&#9;&#9;&#9;cut.Parent = hit.Parent
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--print(&apos;No Ball&apos;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end
--[[
function TagHumanoid(humanoid, player)
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end 
&#9;local creatorTag = Instance.new(&quot;ObjectValue&quot;)
&#9;creatorTag.Value = player
&#9;creatorTag.Name = &quot;creator&quot;
&#9;DebrisService:AddItem(creatorTag, 1.5)
&#9;creatorTag.Parent = humanoid

&#9;local weaponIconTag = Instance.new(&quot;StringValue&quot;)
&#9;weaponIconTag.Value = KILL_FEED_ICON_URL
&#9;weaponIconTag.Name = &quot;icon&quot;
&#9;weaponIconTag.Parent = creatorTag
end
--]]
function Attack()
&#9;damage = SLASH_DAMAGE
&#9;SlashSound:play()

&#9;if PlaySlash then
&#9;&#9;PlaySlash.Value = not PlaySlash.Value
&#9;end
&#9;wait(0.6)
end

function OverheadSlash()
&#9;damage = OVERHEAD_SLASH_DAMAGE
&#9;if PlayOverhead then
&#9;&#9;PlayOverhead.Value = not PlayOverhead.Value
&#9;end
&#9;--OverheadSound:Play()
LungeSound:play()
&#9;local force = Instance.new(&quot;BodyVelocity&quot;)
&#9;force.velocity = Vector3.new(0,10,0)
&#9;DebrisService:AddItem(force, 0.5)
&#9;force.Parent = Tool.Parent.Torso
&#9;wait(0.6)
end

function Lunge()
&#9;damage = LUNGE_DAMAGE
&#9;--LungeSound:play()
&#9;OverheadSound:Play()
&#9;if PlayThrust then
&#9;&#9;PlayThrust.Value = not PlayThrust.Value
&#9;end
&#9;wait(.45)
&#9;swordOut()
&#9;wait(.05)
&#9;if force then
&#9;&#9;force.Parent = nil
&#9;end
&#9;wait(.15)
&#9;swordUp()

&#9;damage = SLASH_DAMAGE
end

function swordUp()
&#9;Tool.GripForward = Vector3.new(1,0,0)
&#9;Tool.GripRight = Vector3.new(0,0,1)
&#9;Tool.GripUp = Vector3.new(0,1,0)
end

function swordOut()
&#9;Tool.GripForward = Vector3.new(0,-1,0)
&#9;Tool.GripRight = Vector3.new(0,0,1)
&#9;Tool.GripUp = Vector3.new(-1,0,0)
end

table.insert(AttackSequence, Attack)
table.insert(AttackSequence, Lunge)
table.insert(AttackSequence, OverheadSlash)

local CurrentIndex = 1

local LastAttackTime = tick()

Tool.Enabled = true
function OnActivated()
&#9;if Tool.Enabled and MyCharacter and MyHumanoid and MyHumanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false
&#9;&#9;HitCharacters = {[MyCharacter] = true}
&#9;&#9;----------- ATTACK SEQUENCE CODE --------------
&#9;&#9;local now = tick()
&#9;&#9;if now - LastAttackTime &gt; 1.5 then
&#9;&#9;&#9;CurrentIndex = 1
&#9;&#9;else
&#9;&#9;&#9;CurrentIndex = CurrentIndex + 1
&#9;&#9;end
&#9;&#9;LastAttackTime = now
&#9;&#9;if CurrentIndex &gt; #AttackSequence then
&#9;&#9;&#9;CurrentIndex = 1
&#9;&#9;end

&#9;  -----------------------------------------------
&#9;&#9;AttackSequence[CurrentIndex]()
&#9;&#9;if MyHumanoid == nil then
&#9;&#9;&#9;print(&quot;Humanoid not found&quot;)
&#9;&#9;&#9;return 
&#9;&#9;end
&#9;&#9;HitCharacters = nil
&#9;&#9;Tool.Enabled = true
&#9;end
end


function OnEquipped()
&#9;Delay(0.55, function() UnsheathSound:play() end)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = MyCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed + WALK_SPEED_BUFF
&#9;PlaySlash = Tool:WaitForChild(&apos;PlaySlash&apos;)
&#9;PlayOverhead = Tool:WaitForChild(&apos;PlayOverhead&apos;)
&#9;PlayThrust = Tool:WaitForChild(&apos;PlayThrust&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyCharacter)
end

function OnUnequipped()
&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed - WALK_SPEED_BUFF
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

-- Create the CreatorTag once at the start
CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos;
local weaponNameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = KILL_FEED_ICON_URL

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

connection = Handle.Touched:connect(Blow)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX271">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AnimationScript</string>
							<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local Animations = {}
local MyHumanoid
local MyCharacter


local function PlayAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Play()
&#9;end
end

local function StopAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Stop()
&#9;end
end


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;Animations[&apos;EquipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim5&apos;))
&#9;&#9;Animations[&apos;IdleAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleAnim3&apos;))
&#9;&#9;Animations[&apos;OverheadAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;OverheadAnim2&apos;))
&#9;&#9;Animations[&apos;SlashAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;SlashAnim2&apos;))
&#9;&#9;Animations[&apos;ThrustAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;ThrustAnim2&apos;))
&#9;&#9;Animations[&apos;UnequipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;UnequipAnim2&apos;))
&#9;end
&#9;PlayAnimation(&apos;EquipAnim&apos;)
&#9;PlayAnimation(&apos;IdleAnim&apos;)
end

function OnUnequipped()
&#9;for animName, _ in pairs(Animations) do
&#9;&#9;StopAnimation(animName)
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

WaitForChild(Tool, &apos;PlaySlash&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;SlashAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;SlashAnim&apos;)
&#9;&#9;--end
&#9;end)

WaitForChild(Tool, &apos;PlayThrust&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;ThrustAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;ThrustAnim&apos;)
&#9;&#9;--end
&#9;end)

WaitForChild(Tool, &apos;PlayOverhead&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;--if value then
&#9;&#9;&#9;PlayAnimation(&apos;OverheadAnim&apos;)
&#9;&#9;--else
&#9;&#9;--&#9;StopAnimation(&apos;OverheadAnim&apos;)
&#9;&#9;--end
&#9;end)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX272">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Local Gui</string>
							<ProtectedString name="Source">local Tool = script.Parent;

enabled = true
function onButton1Down(mouse)
&#9;if not enabled then
&#9;&#9;return
&#9;end

&#9;enabled = false
&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;
&#9;while not Tool.Enabled do
&#9;&#9;wait(0.05)
&#9;end
&#9;
&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;enabled = true

end

function onEquippedLocal(mouse)

&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;mouse.Button1Down:connect(function() onButton1Down(mouse) end)
end


Tool.Equipped:connect(onEquippedLocal)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX273">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">199</int>
							<CoordinateFrame name="CFrame">
								<X>-409.800018</X>
								<Y>-13.000001</Y>
								<Z>31.7000008</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>-0</R12>
								<R20>1</R20>
								<R21>0</R21>
								<R22>-0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">1</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.600000024</X>
								<Y>3.60000038</Y>
								<Z>0.400000036</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX274">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94746028</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94746105</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX275">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SlashSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds//swordslash.wav</url></Content>
								<float name="Volume">0.349999994</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX276">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">OverheadSound</string>
								<float name="Pitch">1.16999996</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds//swordslash.wav</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX277">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">LungeSound</string>
								<float name="Pitch">0.800000012</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds//swordlunge.wav</url></Content>
								<float name="Volume">0.25</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX278">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">UnsheathSound</string>
								<float name="Pitch">1.29999995</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds//unsheath.wav</url></Content>
								<float name="Volume">0.280000001</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX279">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">HitSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=98220998</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX280">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94160581</url></Content>
							<string name="Name">EquipAnim5</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX281">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94108418</url></Content>
							<string name="Name">IdleAnim3</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX282">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94160738</url></Content>
							<string name="Name">OverheadAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX283">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94161088</url></Content>
							<string name="Name">SlashAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX284">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94161333</url></Content>
							<string name="Name">ThrustAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX285">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94095929</url></Content>
							<string name="Name">UnequipAnim2</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX286">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do print(&apos;waiting for&apos; .. childName) wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
--local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local CrystalSwordModifierName = &apos;CrystalSword&apos;

local IsCrystal=WaitForChild(Tool,&apos;IsCrystal&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94746105&apos;
local CrystalSwordTexture = &apos;http://www.roblox.com/asset/?id=97912267&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=94746192&apos;
local CrystalIcon = &apos;http://www.roblox.com/asset/?id=97913524&apos;


function OnModifierAdded(nmodifier)
&#9;if nmodifier.Name == CrystalSwordModifierName then
&#9;&#9;IsCrystal.Value=true
&#9;&#9;Mesh.TextureId=CrystalSwordTexture
&#9;&#9;Tool.TextureId= CrystalIcon
&#9;&#9;Tool.ToolTip= &apos;Emerald Edge&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == CrystalSwordModifierName then
&#9;&#9;IsCrystal.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= CrystalIcon
&#9;&#9;Tool.ToolTip= &apos;Sword&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX287">
						<Properties>
							<string name="Name">IsCrystal</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX288">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Superball</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX289">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Superball</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=96508620</url></Content>
						<string name="ToolTip">Superball</string>
					</Properties>
					<Item class="LocalScript" referent="RBX290">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Local Gui</string>
							<ProtectedString name="Source">local Tool = script.Parent;

enabled = true
function onButton1Down(mouse)
&#9;if not enabled then
&#9;&#9;return
&#9;end

&#9;enabled = false
&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;

&#9;wait(2)
&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;enabled = true

end

function onEquippedLocal(mouse)


&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;mouse.Button1Down:connect(function() onButton1Down(mouse) end)
end



Tool.Equipped:connect(onEquippedLocal)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX291">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">208</int>
							<CoordinateFrame name="CFrame">
								<X>463.900024</X>
								<Y>53.5000038</Y>
								<Z>-90.1000061</Z>
								<R00>3.42285489e-008</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0</R11>
								<R12>1</R12>
								<R20>1</R20>
								<R21>-3.42285489e-008</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">1</float>
							<float name="Friction">0</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0.200000003</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">0</token>
							<token name="shape">0</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBX292">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Boing</string>
								<float name="Pitch">1.10000002</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=96543718</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="SpecialMesh" referent="RBX293">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=96501868</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>2</X>
									<Y>2</Y>
									<Z>2</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=96502130</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX294">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Equip</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97095034</url></Content>
								<float name="Volume">0.800000012</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX295">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Throw</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97095069</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX296">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AnimationScript</string>
							<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local MyHumanoid
local MyCharacter

local EquipAnim
local IdleEquipAnim
local ThrowAnim
local UnEquipAnim


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = MyCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;EquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim2&apos;))
&#9;&#9;IdleEquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleEquipAnim2&apos;))
&#9;&#9;ThrowAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;ThrowAnim2&apos;))
&#9;&#9;UnEquipAnim = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;UnEquipAnim2&apos;))
&#9;end
&#9;if EquipAnim then
&#9;&#9;EquipAnim:Play()
&#9;end
&#9;if IdleEquipAnim then
&#9;&#9;IdleEquipAnim:Play()
&#9;end
end

function OnUnequipped()
&#9;if EquipAnim then
&#9;&#9;EquipAnim:Stop()
&#9;end
&#9;if ThrowAnim then
&#9;&#9;ThrowAnim:Stop()
&#9;end
&#9;if IdleEquipAnim then
&#9;&#9;IdleEquipAnim:Stop()
&#9;end
&#9;if UnEquipAnim then
&#9;&#9;--UnEquipAnim:Play()
&#9;end

end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

WaitForChild(Tool, &apos;PlayThrow&apos;).Changed:connect(
&#9;function (value)
&#9;&#9;if ThrowAnim then
&#9;&#9;&#9;ThrowAnim:Play()
&#9;&#9;end
&#9;end)

</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX297">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156486</url></Content>
							<string name="Name">IdleEquipAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX298">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156535</url></Content>
							<string name="Name">EquipAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX299">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94156580</url></Content>
							<string name="Name">UnEquipAnim2</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX300">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94157627</url></Content>
							<string name="Name">ThrowAnim2</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX301">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local MoneyBallModifierName = &apos;MoneySuperBall&apos;

local IsMoneyBall=WaitForChild(WaitForChild(Tool,&apos;CannonBall&apos;),&apos;IsMoneyBall&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=96502130&apos;
local MoneyBallTexture = &apos;http://www.roblox.com/asset/?id=97907437&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=96508620&apos;
local MoneyBallIcon = &apos;http://www.roblox.com/asset/?id=97817523&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MoneyBallModifierName then
&#9;&#9;IsMoneyBall.Value=true
&#9;&#9;Mesh.TextureId=MoneyBallTexture
&#9;&#9;Tool.TextureId= MoneyBallIcon
&#9;&#9;Tool.ToolTip= &apos;Moneyball&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MoneyBallModifierName then
&#9;&#9;IsMoneyBall.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;Tool.ToolTip= &apos;SuperBall&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX302">
						<Properties>
							<string name="Name">PlayThrow</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX303">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CannonScript</string>
							<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local LAUNCH_VELOCITY = 170

local MissileMesh = Instance.new(&apos;SpecialMesh&apos;)
MissileMesh.Name = &quot;MissileMesh&quot;
MissileMesh.MeshType = Enum.MeshType.Sphere
MissileMesh.Parent = DecalHolder

local Tool = script.Parent
local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local HandleMesh = WaitForChild(Handle, &apos;Mesh&apos;)


local FloatForce = Instance.new(&apos;BodyForce&apos;)
FloatForce.force = Vector3.new(0, Handle:GetMass() * 192.6 * 0.5, 0)
FloatForce.Name = &quot;FloatingForce&quot;

local PlayersService = Game:GetService(&apos;Players&apos;)

local PlayThrow
local EquipSound
local ThrowSound

local MoneyBallColors = 
{
&#9;Vector3.new(.9,.8,0),
&#9;Vector3.new(1,1,1), 
&#9;--Vector3.new(159/255,101/255,1/255),
}

local CannonBallScript = WaitForChild(Tool,&apos;CannonBall&apos;)
local IsMoneyBall= WaitForChild(CannonBallScript,&apos;IsMoneyBall&apos;)


function RayCast(startPos, vec, rayLength, ignoreModel)
&#9;vec = vec.unit
&#9;local hitObject, hitPos = game.Workspace:FindPartOnRay(Ray.new(startPos + (vec * .01), vec * rayLength), Handle)
&#9;if hitObject and hitPos then
&#9;&#9;local distance = rayLength - (hitPos - startPos).magnitude
&#9;&#9;if (not hitObject:IsDescendantOf(ignoreModel)) and distance &gt; 0 then
&#9;&#9;&#9;return RayCast(hitPos, vec, distance)
&#9;&#9;end
&#9;end
&#9;return hitObject, hitPos
end

-- This will return nil if there is nothing in the way, otherwise it will return the closest position it can start the ball at.
function FindClosestOpenPosition(cframe, radius, direction, character)
&#9;if not (cframe and radius and direction and character) then
&#9;&#9;print(&quot;FindClosestOpenPosition: Bad Args&quot;);
&#9;&#9;return
&#9;end
&#9;
&#9;local rightArm = character:FindFirstChild(&apos;Right Arm&apos;)
&#9;--print(&quot;Right Arm:&quot; , rightArm)
&#9;local maxHitPos = nil
&#9;do
&#9;&#9;local hitObj, hitPos = RayCast(cframe.p + direction.unit * 3, -direction, 3, character)
&#9;&#9;if hitObj and hitPos and hitObj ~= rightArm then
&#9;&#9;&#9;--print(hitObj.Name, (hitObj == rightArm))
&#9;&#9;&#9;maxHitPos = hitPos + direction.unit * (radius + 0.05)
&#9;&#9;end
&#9;end
&#9;
&#9;for r = 0, 2 do
&#9;&#9;local objectYOffset =  CFrame.Angles(0, 0, r * math.pi/4) * cframe:vectorToWorldSpace(Vector3.new(0, radius + 0.1, 0))
&#9;&#9;local objectXOffset = CFrame.Angles(0, 0, r * math.pi/4) * cframe:vectorToWorldSpace(Vector3.new(radius + 0.1, 0, 0))
&#9;&#9;for x = -1, 1, 2 do
&#9;&#9;&#9;for y = -1, 1, 2 do
&#9;&#9;&#9;&#9;local hitObj, hitPos = RayCast(cframe.p + objectYOffset + objectXOffset + direction.unit * 3, -direction, 3, character)
&#9;&#9;&#9;&#9;if hitObj ~= rightArm and hitObj and hitPos and
&#9;&#9;&#9;&#9;&#9;&#9;(not maxHitPos or (cframe.p - hitPos).magnitude &gt; (cframe.p - maxHitPos).magnitude) then
&#9;&#9;&#9;&#9;&#9;--print(hitObj.Name, (hitObj == rightArm))
&#9;&#9;&#9;&#9;&#9;--print(&quot;Side vectors hit&quot;)
&#9;&#9;&#9;&#9;&#9;maxHitPos = hitPos
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local openPos
&#9;if maxHitPos then
 &#9;&#9;openPos = maxHitPos + direction.unit * (radius + 0.05)
&#9;else
&#9;&#9;--openPos = cframe + direction.unit * (radius + 0.05) 
&#9;end
&#9;--print(&quot;Missile pos&quot; , cframe.p , &quot;  new pos:&quot; , openPos)
&#9;return openPos
end


function Fire(v)
&#9;if ThrowSound then
&#9;&#9;ThrowSound:Play()
&#9;end

&#9;local vCharacter = Tool.Parent
&#9;local vPlayer = PlayersService:GetPlayerFromCharacter(vCharacter)

&#9;local missile = Instance.new(&quot;Part&quot;)
&#9;local spawnPos = Handle.Position --vCharacter.PrimaryPart.Position
&#9;missile.Size = Handle.Size
&#9;missile.Velocity = v * LAUNCH_VELOCITY
&#9;spawnPos = FindClosestOpenPosition(CFrame.new(Handle.CFrame.p, Handle.CFrame.p + v), missile.Size.Z / 2, v, vCharacter)
&#9;--spawnPos + Handle.CFrame:vectorToWorldSpace(Vector3.new(0, 0, -(missile.Size.Z))) -- + (v * 5)
&#9;if spawnPos then
&#9;&#9;missile.CFrame = CFrame.new(spawnPos, spawnPos + v)
&#9;else
&#9;&#9;--print(&quot;No Spawn Pos&quot;);
&#9;&#9;missile.CFrame = Handle.CFrame + Handle.CFrame:vectorToWorldSpace(Vector3.new(0, 0, -2.1))
&#9;end
&#9;missile.BrickColor = BrickColor.new(HandleMesh.VertexColor.X, HandleMesh.VertexColor.Y, HandleMesh.VertexColor.Z)
&#9;missile.FormFactor = Enum.FormFactor.Custom
&#9;missile.Shape = Enum.PartType.Ball
&#9;missile.BottomSurface = 0
&#9;missile.TopSurface = 0
&#9;missile.Name = &quot;Cannon Shot&quot;
&#9;missile.Elasticity = 1
&#9;missile.Reflectance = .2
&#9;missile.Friction = 0.1
&#9;FloatForce:Clone().Parent = missile&#9;
&#9;if Handle:FindFirstChild(&apos;Mesh&apos;) then
&#9;&#9;local missileMesh = Handle.Mesh:Clone()
&#9;&#9;missileMesh.Name =&apos;MissileMesh&apos;
&#9;&#9;missileMesh.Parent = missile
&#9;end
&#9;Tool.Handle.Boing:clone().Parent = missile

&#9;local new_script = script.Parent.CannonBall:clone()
&#9;new_script.Disabled = false
&#9;new_script.Parent = missile

&#9;local creator_tag = Instance.new(&quot;ObjectValue&quot;)
&#9;creator_tag.Value = vPlayer
&#9;creator_tag.Name = &quot;creator&quot;
&#9;local weaponName_tag = Instance.new(&apos;StringValue&apos;, creator_tag)
&#9;weaponName_tag.Name = &apos;weaponName&apos;
&#9;weaponName_tag.Value = Tool.Name
&#9;local weaponIcon_tag = Instance.new(&apos;StringValue&apos;, creator_tag)
&#9;weaponIcon_tag.Name = &apos;weaponIcon&apos;
&#9;weaponIcon_tag.Value = Tool.TextureId
&#9;creator_tag.Parent = missile

&#9;missile.Parent = game.Workspace
end

Tool.Enabled = true
function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;if PlayThrow then
&#9;&#9;PlayThrow.Value = not PlayThrow.Value
&#9;end
&#9;wait(0.03)
&#9;Tool.Enabled = false
&#9;wait(0.1)
&#9;local character = Tool.Parent
&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then
&#9;&#9;
&#9;&#9;if character:FindFirstChild(&apos;Right Arm&apos;) then
&#9;&#9;&#9;local targetPos = targetOverride or humanoid.TargetPoint
&#9;&#9;&#9;local lookAt = (targetPos - Handle.Position).unit
&#9;&#9;&#9;Handle.Transparency = 1
&#9;&#9;&#9;Fire(lookAt)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Can&apos;t find right arm&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;print(&quot;Humanoid not found&quot;)
&#9;end

&#9;if IsMoneyBall.Value then
&#9;&#9;nextColor=MoneyBallColors[math.random(#MoneyBallColors)]
&#9;&#9;HandleMesh.VertexColor=Vector3.new((math.random()*.1)-.05,(math.random()*.1)-.05,(math.random()*.1)-.05)+ nextColor
&#9;end

&#9;wait(1.5)
&#9;Handle.Transparency = 0
&#9;Tool.Enabled = true
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

local function OnEquipped()
&#9;EquipSound = WaitForChild(Handle, &apos;Equip&apos;)
&#9;ThrowSound = WaitForChild(Handle, &apos;Throw&apos;)
&#9;PlayThrow = WaitForChild(Tool, &apos;PlayThrow&apos;)
&#9;wait(0.2)
&#9;EquipSound:Play()
end

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)

local MAX_STEPS = 20

function LerpColor(startColor, endColor, duration)
&#9;local startTime = time()
&#9;while time() - startTime &lt; duration do
&#9;&#9;wait(1 / MAX_STEPS)
&#9;&#9;local lerpedVec = startColor:Lerp(endColor, (time() - startTime) / duration)
&#9;&#9;HandleMesh.VertexColor = lerpedVec
&#9;end
end

-- For luminance calculation formula look at: http://en.wikipedia.org/wiki/Grayscale
local function IsDark(color)
&#9;local cieLuminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b
&#9;return cieLuminance &lt; 0.4
end

while true do
&#9;local nextColor
&#9;if not IsMoneyBall.Value then
&#9;&#9;repeat
&#9;&#9;&#9;&#9;nextColor = BrickColor.random()
&#9;&#9;until not IsDark(nextColor.Color)
&#9;&#9;LerpColor(HandleMesh.VertexColor, Vector3.new(nextColor.r, nextColor.g, nextColor.b), 2)
&#9;&#9;Handle.BrickColor = nextColor
&#9;end
&#9;
&#9;
&#9;wait(0.1)
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX304">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CannonBall</string>
							<ProtectedString name="Source">print(&quot;Running cannon ball script&quot;)
local ball = script.Parent

local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

--local KILL_FEED_ICON_URL = &apos;rbxasset://Textures/Superball.png&apos;
local START_DAMAGE = 42
local MIN_DAMAGE = 10
local DECAY_RATIO = 1 / 1.65
local VELOCITY_DAMPING = 0.9
local BOING_VOLUME = 0.666
local damage = START_DAMAGE

local DebrisService = Game:GetService(&apos;Debris&apos;)

local BounceScript = WaitForChild(script, &apos;BounceEffect&apos;)

local IsMoneyBall= WaitForChild(script,&apos;IsMoneyBall&apos;)

local MyHumanoid

local r = game:service(&quot;RunService&quot;)

local last_sound_time = r.Stepped:wait() - 0.2

local LastHitCharacter

local DecalHolder = Instance.new(&quot;Part&quot;)
DecalHolder.Size = Vector3.new(2, 2, 2)
DecalHolder.Anchored = true
DecalHolder.CanCollide = false
DecalHolder.Transparency = 0.5
DecalHolder.Reflectance = 0
DecalHolder.FormFactor = Enum.FormFactor.Custom
DecalHolder.Shape = Enum.PartType.Block
DecalHolder.Size = Vector3.new(0.1, 0.1, 0.1)
DecalHolder.BottomSurface = 0
DecalHolder.TopSurface = 0
DecalHolder.Name = &quot;Bounce Spot&quot;
local DecalMesh = Instance.new(&apos;SpecialMesh&apos;)
DecalMesh.Name = &quot;BounceMesh&quot;
DecalMesh.MeshType = Enum.MeshType.Sphere
DecalMesh.Scale = Vector3.new(1,1,1)
DecalMesh.Parent = DecalHolder
local MoneySound = Instance.new(&apos;Sound&apos;)
MoneySound.Name = &apos;MoneySound&apos;
MoneySound.SoundId = &apos;http://www.roblox.com/Asset?ID=97688233&apos;
MoneySound.Volume = 1
MoneySound.Parent=DecalHolder

function FindHumanoidRecursive(p)
&#9;if (p.className == Workspace) then return nil end
&#9;local h = p:FindFirstChild(&quot;Humanoid&quot;)
&#9;if (h ~= nil) then return h end
&#9;if (p.Parent ~= nil) then return FindHumanoidRecursive(p.Parent) end
&#9;return nil
end

function CreateBounceEffect(position)
&#9;local DecalCopy = DecalHolder:Clone()
&#9;DecalCopy.Size = ball.Size
&#9;DecalCopy.BrickColor = ball.BrickColor
&#9;DecalCopy.CFrame = CFrame.new(position)
&#9;DebrisService:AddItem(DecalCopy, 2)
&#9;DecalCopy.Parent = Workspace
&#9;local bounceCopy = BounceScript:Clone()
&#9;bounceCopy.Parent = DecalCopy
&#9;bounceCopy.Disabled = false
&#9;Spawn(function()
&#9;&#9;wait(0)
&#9;&#9;if IsMoneyBall.Value and DecalCopy then
&#9;&#9;&#9;DecalCopy.MoneySound:Play()
&#9;&#9;end
&#9;end)
end

function onTouched(hit)
&#9;local myHumanoid
&#9;local creatorTag = ball:FindFirstChild(&apos;creator&apos;) 
&#9;if creatorTag and creatorTag.Value and creatorTag.Value.Character then
&#9;&#9;myHumanoid = creatorTag.Value.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;end
&#9;local humanoid = FindHumanoidRecursive(hit)
&#9;if humanoid~=nil then -- make sure not to damage yourself unless it has bounced already
&#9;&#9;if myHumanoid and (humanoid ~= myHumanoid or damage &lt; START_DAMAGE) and
&#9;&#9;&#9;&#9;&#9;&#9;&#9;(not LastHitCharacter or humanoid.Parent ~= LastHitCharacter) then
&#9;&#9;&#9;LastHitCharacter = humanoid.Parent
&#9;&#9;&#9;--TagHumanoid(humanoid, ball.creator.Value)
&#9;&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(damage, ball:FindFirstChild(&apos;creator&apos;))
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;local now = r.Stepped:wait()
&#9;&#9;if (now - last_sound_time &gt; 0.32) then
&#9;&#9;&#9;ball.Boing.Volume = math.max(0.17, math.min(BOING_VOLUME, BOING_VOLUME * ball.Velocity.magnitude / 130))
&#9;&#9;&#9;--print(ball.Boing.Volume)
&#9;&#9;&#9;ball.Boing:play()
&#9;&#9;&#9;last_sound_time = now
&#9;&#9;&#9;damage = math.max(MIN_DAMAGE, damage * DECAY_RATIO)
&#9;&#9;&#9;--ball.Velocity = ball.Velocity * VELOCITY_DAMPING
&#9;&#9;&#9;CreateBounceEffect(ball.Position)
&#9;&#9;end
&#9;&#9;if now - last_sound_time &gt; 0.3 then
&#9;&#9;&#9;print(&quot;Resetting last hit character&quot;)
&#9;&#9;&#9;LastHitCharacter = nil
&#9;&#9;end
&#9;end
end
--[[
function TagHumanoid(humanoid, player)
&#9;print(&quot;Tagging player as creator:&quot; , player.Name , &quot;as damaging&quot; , humanoid.Name , tick())
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end 
&#9;local creatorTag = Instance.new(&quot;ObjectValue&quot;)
&#9;creatorTag.Value = player
&#9;creatorTag.Name = &quot;creator&quot;
&#9;creatorTag.Parent = humanoid
&#9;DebrisService:AddItem(creatorTag, 2)

&#9;local weaponIconTag = Instance.new(&quot;StringValue&quot;)
&#9;weaponIconTag.Value = KILL_FEED_ICON_URL
&#9;weaponIconTag.Name = &quot;icon&quot;
&#9;weaponIconTag.Parent = creatorTag
end
--]]
connection = ball.Touched:connect(onTouched)

DebrisService:AddItem(ball, 5)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX305">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">BounceEffect</string>
								<ProtectedString name="Source">local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DecalCopy = script.Parent
local BallSize = Vector3.new(2,2,2)
local BallScale = BallSize * 0.6
local BounceMesh = WaitForChild(DecalCopy, &apos;BounceMesh&apos;)


BounceMesh.Scale = Vector3.new()
for i = 1, 7 do
&#9;if DecalCopy then
&#9;&#9;BounceMesh.Scale = BallSize * BallScale * i * 0.07
&#9;&#9;DecalCopy.Transparency = DecalCopy.Transparency + 1 / 28
&#9;&#9;wait(0.03)
&#9;end
end
for i = 7, 1, -1 do
&#9;if DecalCopy then
&#9;&#9;BounceMesh.Scale = BallSize * BallScale * i * 0.07
&#9;&#9;DecalCopy.Transparency = DecalCopy.Transparency + 1 / 28
&#9;&#9;wait(0.03)
&#9;end
end
DecalCopy:Destroy()
</ProtectedString>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX306">
							<Properties>
								<string name="Name">IsMoneyBall</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX307">
							<Properties>
								<string name="Name">PlayThrow</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX308">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830748</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX309">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Slingshot</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX310">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>-0.699999988</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Slingshot</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689365</url></Content>
						<string name="ToolTip">Slingshot</string>
					</Properties>
					<Item class="Part" referent="RBX311">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-463.656036</X>
								<Y>-10.9020004</Y>
								<Z>4.14700031</Z>
								<R00>0.946185231</R00>
								<R01>0.0517470203</R01>
								<R02>-0.319461167</R02>
								<R10>0.00558891892</R10>
								<R11>0.98437345</R11>
								<R12>0.17600435</R12>
								<R20>0.323576719</R20>
								<R21>-0.168318182</R21>
								<R22>0.931110501</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>-7.89214315e-025</X>
								<Y>1.44442375e-022</Y>
								<Z>-2.56070561e-025</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>3.63574669e-020</X>
								<Y>-0.00053787831</Y>
								<Z>3.62891825e-020</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2.4000001</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX312">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94689497</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689543</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX313">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SlingshotSound1</string>
								<float name="Pitch">1.20000005</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795238</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX314">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SlingshotSound2</string>
								<float name="Pitch">0.699999988</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795288</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX315">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SlingshotSound3</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795305</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX316">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Equip</string>
								<float name="Pitch">1.29999995</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97105188</url></Content>
								<float name="Volume">0.349999994</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX317">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LocalGuiAndAnimations</string>
							<ProtectedString name="Source">local Tool = script.Parent;

local EquipAnim
local ShootAnim 

function OnChanged(property, mouse)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;if EquipAnim then EquipAnim:Stop() end
&#9;&#9;if Tool.Enabled == false then
&#9;&#9;&#9;ShootAnim:Play()
&#9;&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;
&#9;&#9;else
&#9;&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;&#9;end
&#9;end
end



function onEquippedLocal(mouse)
&#9;local humanoid = Tool.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;EquipAnim = humanoid:LoadAnimation(Tool.Equip)
&#9;ShootAnim = humanoid:LoadAnimation(Tool.Shoot)

&#9;-- Make sure that the tool is still equiped when we play equip anim
&#9;Spawn(function() wait() if Tool:IsDescendantOf(Workspace) then&#9;EquipAnim:Play() end end)
&#9;if mouse == nil then
&#9;&#9;print(&quot;Mouse not found&quot;)
&#9;&#9;return 
&#9;end

&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;Tool.Changed:connect(function(property) OnChanged(property, mouse) end)
end

function onUnequippedLocal()
&#9;if EquipAnim then EquipAnim:Stop() end
&#9;if ShootAnim then ShootAnim:Stop() end
end

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX318">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PelletScript</string>
							<ProtectedString name="Source">local debris = game:service(&quot;Debris&quot;)
local pellet = script.Parent
local startingDamage = 14
local damage = startingDamage
local LastHitCharacter


function WaitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(child)
end

local CreatorTag = WaitForChild(pellet, &apos;creator&apos;)

local GemHitSound = Instance.new(&apos;Sound&apos;)
GemHitSound.SoundId = &apos;http://www.roblox.com/asset/?id=98265750&apos;
GemHitSound.Pitch=1.5
GemHitSound.Parent=pellet


--[[
function tagHumanoid(humanoid)
&#9;-- todo: make tag expire
&#9;local tag = pellet:findFirstChild(&quot;creator&quot;)
&#9;if tag ~= nil then
&#9;&#9;-- kill all other tags
&#9;&#9;while(humanoid:findFirstChild(&quot;creator&quot;) ~= nil) do
&#9;&#9;&#9;humanoid:findFirstChild(&quot;creator&quot;).Parent = nil
&#9;&#9;end

&#9;&#9;local new_tag = tag:clone()
&#9;&#9;new_tag.Parent = humanoid
&#9;&#9;debris:AddItem(new_tag, 1)
&#9;end
end
--]]
function onTouched(hit)
&#9;--local creator = WaitForChild(pellet,&apos;creator&apos;)
&#9;--if (not hit) or (hit.Name == &apos;Handle&apos;) or (not hit.Parent) then return end&#9;
&#9;if not (hit and hit.Name ~= &apos;Handle&apos; and hit.Parent) then return end
&#9;if pellet:FindFirstChild(&apos;IsBlingshot&apos;) then
&#9;&#9;GemHitSound:Play()
&#9;end
&#9;humanoid = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;if humanoid~=nil and humanoid.Parent ~= LastHitCharacter then
&#9;&#9;if startingDamage == damage and game.Players:playerFromCharacter(hit.Parent) == CreatorTag.Value then 
&#9;&#9;&#9;return 
&#9;&#9;end
&#9;&#9;--tagHumanoid(humanoid)
&#9;&#9;--humanoid:TakeDamage(damage)
&#9;&#9;LastHitCharacter = humanoid.Parent
&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;if hitBindable then
&#9;&#9;&#9;hitBindable:Invoke(damage, CreatorTag)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;if hit.CanCollide == false then return end
&#9;&#9;damage = damage / 1.42
&#9;&#9;if damage &lt; 1 then
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;pellet.Parent = nil
&#9;&#9;end
&#9;end
end

connection = pellet.Touched:connect(onTouched)</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX319">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94123357</url></Content>
							<string name="Name">Equip</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX320">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94126022</url></Content>
							<string name="Name">Shoot</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX321">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Slingshot</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local VELOCITY = 110 -- constant
local VELOCITY_SQAURED = VELOCITY * VELOCITY
local VELOCITY_TO_FOURTH = VELOCITY_SQAURED * VELOCITY_SQAURED
local ASSET_PREFIX = &quot;http://www.roblox.com/asset/?id=&quot;

local MyMouse

local SlingShotMeshIds = {Ammo = 94689434, AttachMe = 94689472, Full = 94689497, Handle = 94689515}

local DebrisService = game:GetService(&apos;Debris&apos;)
local ContentProvider = Game:GetService(&quot;ContentProvider&quot;)
local Pellet = Instance.new(&quot;Part&quot;)
Pellet.Locked = true
Pellet.BackSurface = 0
Pellet.BottomSurface = 0
Pellet.FrontSurface = 0
Pellet.LeftSurface = 0
Pellet.RightSurface = 0
Pellet.TopSurface = 0
Pellet.Shape = 0
Pellet.Size = Vector3.new(1,1,1)
--Pellet.BrickColor = BrickColor.new(&apos;Bright red&apos;) --BrickColor.new(2)
local PelletMesh = Instance.new(&apos;SpecialMesh&apos;)
PelletMesh.MeshId = ASSET_PREFIX .. SlingShotMeshIds[&apos;Ammo&apos;]
PelletMesh.TextureId = ASSET_PREFIX .. 94689543
PelletMesh.Scale = Vector3.new(1.5, 1.5, 1.5)
PelletMesh.Name = &apos;PelletMesh&apos;
PelletMesh.Parent = Pellet

local SlingShotMesh

local EquipSound
local SlingshotSounds

local PelletCopy

local IsBlingshot= WaitForChild(Tool,&apos;IsBlingshot&apos;)

WaitForChild(Tool, &apos;PelletScript&apos;):clone().Parent = Pellet

function Fire(mouse_pos)

&#9;if SlingshotSounds then
&#9;&#9;local soundNum = math.random(1, #SlingshotSounds)
&#9;&#9;SlingshotSounds[soundNum]:Play()
&#9;end

-- find player&apos;s head pos

&#9;local vCharacter = Tool.Parent
&#9;local vPlayer = game.Players:GetPlayerFromCharacter(vCharacter)

&#9;local head = vCharacter:findFirstChild(&quot;Head&quot;)
&#9;if head == nil then return end

&#9;local startPosition = Tool.Handle.Position + Vector3.new(0,1,0)

&#9;local dir = mouse_pos - startPosition
&#9;dir = dir.unit

&#9;local launch = startPosition + 3 * dir

&#9;local delta = mouse_pos - launch
&#9;
&#9;local dy = delta.y
&#9;
&#9;local new_delta = Vector3.new(delta.x, 0, delta.z)
&#9;delta = new_delta

&#9;local dx = delta.magnitude
&#9;local unit_delta = delta.unit
&#9;
&#9;-- acceleration due to gravity in RBX units
&#9;local g = (-9.81 * 20)

&#9;local theta = computeLaunchAngle( dx, dy, g)

&#9;local vy = math.sin(theta)
&#9;local xz = math.cos(theta)
&#9;local vx = unit_delta.x * xz
&#9;local vz = unit_delta.z * xz
&#9;

&#9;local missile = Pellet:clone()

&#9;missile.CFrame = CFrame.new(launch, launch+Vector3.new(vx,vy,vz))
        
&#9;--missile.Position = launch
&#9;missile.Velocity = Vector3.new(vx,vy,vz) * VELOCITY

&#9;missile.PelletScript.Disabled = false
&#9;

&#9;if IsBlingshot.Value then
&#9;&#9;missile.PelletMesh.MeshId=&apos;http://www.roblox.com/asset/?id=98262500&apos;
&#9;&#9;missile.PelletMesh.TextureId=&apos;http://www.roblox.com/asset/?id=98259807&apos;
&#9;&#9;missile.PelletMesh.Scale = Vector3.new(3,3,3)
&#9;&#9;local tbling= IsBlingshot:Clone()
&#9;&#9;tbling.Parent=missile
&#9;else
&#9;&#9;missile.PelletMesh.Scale = Vector3.new(2,2,2)
&#9;end

&#9;local creator_tag = Instance.new(&quot;ObjectValue&quot;)
&#9;creator_tag.Value = vPlayer
&#9;creator_tag.Name = &quot;creator&quot;
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;weaponNameTag.Parent = creator_tag
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId
&#9;weaponIconTag.Parent = creator_tag
&#9;creator_tag.Parent = missile
&#9;
&#9;DebrisService:AddItem(missile,2.0)
&#9;missile.Parent = game.Workspace

end


function computeLaunchAngle(dx,dy,grav)
&#9;-- arcane
&#9;-- http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
&#9;
&#9;local g = math.abs(grav)
&#9;local inRoot = (VELOCITY_TO_FOURTH) - (g * ((g*dx*dx) + (2*dy*VELOCITY_SQAURED)))
&#9;if inRoot &lt;= 0 then
&#9;&#9;return .25 * math.pi
&#9;end
&#9;local root = math.sqrt(inRoot)
&#9;local inATan1 = ((VELOCITY_SQAURED) + root) / (g*dx)

&#9;local inATan2 = ((VELOCITY_SQAURED) - root) / (g*dx)
&#9;local answer1 = math.atan(inATan1)
&#9;local answer2 = math.atan(inATan2)
&#9;return math.min(answer1,answer2)
end


Tool.Enabled = true
function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end
&#9;local character = Tool.Parent;
&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid == nil or humanoid.Health &lt;= 0 then
&#9;&#9;print(&quot;Humanoid not found, or not alive&quot;)
&#9;&#9;return
&#9;end

&#9;Tool.Enabled = false
&#9;local targetPos = targetOverride or MyMouse.Hit.p

&#9;Fire(targetPos)
&#9;if PelletCopy then PelletCopy.Transparency = 1 end
&#9;-- swap meshes here
&#9;--[[
&#9;for i = 0, 0.2, 0.05 do
&#9;&#9;SlingShotMesh.Scale = Vector3.new(0.5, 0.5, 0.5 + i * 8)
&#9;&#9;wait(0.05)
&#9;end
&#9;SlingShotMesh.Scale = Vector3.new(0.5, 0.5, 0.5)
&#9;--]]
&#9;wait(0.2)
&#9;if PelletCopy then PelletCopy.Transparency = 0 end

&#9;Tool.Enabled = true
end

function OnEquipped(mouse)
&#9;--print(&apos;equipped&apos;)
&#9;MyMouse = mouse
&#9;Spawn(function()
&#9;&#9;wait()
&#9;&#9;if Tool:IsDescendantOf(Workspace) then
&#9;&#9;&#9;local leftArm = Tool.Parent:FindFirstChild(&quot;Left Arm&quot;)
&#9;&#9;&#9;if leftArm and not PelletCopy then
&#9;&#9;&#9;&#9;PelletCopy = Pellet:Clone()
&#9;&#9;&#9;&#9;PelletCopy.CanCollide = false
&#9;&#9;&#9;&#9;local pelletWeld = Instance.new(&quot;Weld&quot;)
&#9;&#9;&#9;&#9;pelletWeld.Part0 = leftArm
&#9;&#9;&#9;&#9;pelletWeld.Part1 = PelletCopy
&#9;&#9;&#9;&#9;pelletWeld.C1 = CFrame.new(-.3,1.3,0)
&#9;&#9;&#9;&#9;PelletCopy.Parent = Tool
&#9;&#9;&#9;&#9;pelletWeld.Parent = PelletCopy
&#9;&#9;&#9;&#9;if IsBlingshot.Value then
&#9;&#9;&#9;&#9;&#9;PelletCopy.PelletMesh.MeshId=&apos;http://www.roblox.com/asset/?id=98262500&apos;
&#9;&#9;&#9;&#9;&#9;PelletCopy.PelletMesh.TextureId=&apos;http://www.roblox.com/asset/?id=98259807&apos;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;--MyMouse.TargetFilter = PelletCopy
&#9;SlingShotMesh = WaitForChild(Handle, &apos;Mesh&apos;)
&#9;SlingshotSounds = {WaitForChild(Handle, &apos;SlingshotSound1&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WaitForChild(Handle, &apos;SlingshotSound2&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  WaitForChild(Handle, &apos;SlingshotSound3&apos;)}
&#9;wait(0.3)
&#9;EquipSound = WaitForChild(Handle, &apos;Equip&apos;)
&#9;EquipSound:Play()
--[[
&#9;for _, id in pairs(SlingShotMeshIds) do
&#9;&#9;ContentProvider:Preload(ASSET_PREFIX .. id)
&#9;end
--]]
end

function OnUnequipped()
&#9;if PelletCopy then 
&#9;&#9;PelletCopy:Destroy()
&#9;&#9;PelletCopy = nil
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX322">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)
--local BoingSound=WaitForChild(Handle,&apos;Boing&apos;)

local BlingshotModifierName = &apos;Blingshot&apos;

local IsBlingshot=WaitForChild(Tool,&apos;IsBlingshot&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94689543&apos;
local BlingshotTexture = &apos;http://www.roblox.com/asset/?id=98259807&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94689365&apos;
local BlingshotIcon = &apos;http://www.roblox.com/asset/?id=98259146&apos;


function OnModifierAdded(nmodifier)
&#9;if nmodifier.Name == BlingshotModifierName then
&#9;&#9;IsBlingshot.Value=true
&#9;&#9;Mesh.TextureId=BlingshotTexture
&#9;&#9;Tool.TextureId= BlingshotIcon
&#9;&#9;Tool.ToolTip= &apos;Blingshot&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == BlingshotModifierName then
&#9;&#9;IsBlingshot.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;Tool.ToolTip= &apos;Slingshot&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX323">
						<Properties>
							<string name="Name">IsBlingshot</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX324">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830769</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX325">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Bomb</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX326">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0614605024</X>
							<Y>5.28547162e-009</Y>
							<Z>0.920917511</Z>
							<R00>0.974370062</R00>
							<R01>-9.83292381e-009</R01>
							<R02>-0.224951088</R02>
							<R10>9.8329247e-009</R10>
							<R11>1</R11>
							<R12>-1.12031984e-009</R12>
							<R20>0.224951088</R20>
							<R21>-1.12032339e-009</R21>
							<R22>0.974370062</R22>
						</CoordinateFrame>
						<string name="Name">Bomb</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94690231</url></Content>
						<string name="ToolTip">Bomb</string>
					</Properties>
					<Item class="Part" referent="RBX327">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-410.100006</X>
								<Y>-16</Y>
								<Z>31.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>3.42285489e-008</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-3.42285489e-008</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">0</token>
							<token name="shape">0</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX328">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94691640</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>2</X>
									<Y>2</Y>
									<Z>2</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94691681</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX329">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Boom</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX330">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Beep</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94137771</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX331">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Explode</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 12
local BLAST_PRESSURE = 1000000



--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local RedTextureId = WaitForChild(script.Parent,&apos;RedTextureId&apos;)

local DebrisService = Game:GetService(&apos;Debris&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local TimeBomb = script.Parent

local BombMesh = WaitForChild(TimeBomb, &apos;Mesh&apos;)

local BoomSound = WaitForChild(TimeBomb, &apos;Boom&apos;)
local BeepSound = WaitForChild(TimeBomb, &apos;Beep&apos;)

local CreatorTag = WaitForChild(TimeBomb, &apos;creator&apos;)

local OriginalTextureId = BombMesh.TextureId

local Connection = nil

local ParentTorso = WaitForChild(TimeBomb, &apos;ParentTorso&apos;)
local XGraceDistance=2.5
local YGraceDistance=2.5

local MrBombSoundLength = TimeBomb:FindFirstChild(&apos;MrBombLength&apos;)
local MrBombSound = TimeBomb:FindFirstChild(&apos;MrBombSound&apos;)

local IsMrBombPlaying=false
-----------------
--| Functions |--
-----------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- When a player is hit, if they are alive they will be tagged
local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- Needless to say, this should only be called once
local function Explode()
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.Position = TimeBomb.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace

&#9;BoomSound:Play()

&#9;-- NOTE:
&#9;-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

&#9;TimeBomb.Transparency = 1
&#9;TimeBomb.CanCollide = false
&#9;TimeBomb.Anchored = true
&#9;DebrisService:AddItem(TimeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------

--Distance check to see if can collide should be true
Spawn(function()
&#9;while not TimeBomb.CanCollide and ParentTorso.Value do
&#9;&#9;local TorsoPosition = ParentTorso.Value.CFrame.p
&#9;&#9;local XZOffset = TorsoPosition-Vector3.new(TimeBomb.CFrame.p.x,TorsoPosition.y,TimeBomb.CFrame.p.z)
&#9;&#9;if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-TimeBomb.CFrame.p.y)&gt;YGraceDistance then
&#9;&#9;&#9;TimeBomb.CanCollide=true
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
end)

if MrBombSoundLength and MrBombSound then
&#9;Delay(3-MrBombSoundLength.Value,function()
&#9;&#9;IsMrBombPlaying=true
&#9;&#9;MrBombSound:Play()
&#9;end)
end

-- Flash red and beep increasingly fast for about 3 seconds
local tickTime = 0.4
local red = true
repeat
&#9;BombMesh.TextureId = red and RedTextureId.Value or OriginalTextureId
&#9;if not IsMrBombPlaying then
&#9;&#9;BeepSound:Play()
&#9;end
&#9;wait(tickTime)
&#9;red = not red
&#9;tickTime = tickTime * 0.9
until tickTime &lt; 0.1

Explode()
</ProtectedString>
							</Properties>
						</Item>
						<Item class="ObjectValue" referent="RBX332">
							<Properties>
								<string name="Name">ParentTorso</string>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
						<Item class="StringValue" referent="RBX333">
							<Properties>
								<string name="Name">RedTextureId</string>
								<string name="Value">http://www.roblox.com/asset/?id=94691735</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX334">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX335">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickTransmitter</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(script, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)
local HoldAniTrack
local ThrowAniTrack

local MouseHeld = false

local function OnMouseDown()
&#9;if Tool.Enabled and not MouseHeld then
&#9;&#9;MouseHeld= true
&#9;&#9;DoDrop.Value = false
&#9;&#9;HoldAniTrack:Play(0,1,2) 
&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;Tool.Grip=CFrame.new(0.623935461, -0.378438532, -3.49691121e-008, 0.848048091, 2.31635049e-008, 0.529919267, 0.529919267, -3.70693591e-008, -0.848048091, 0, 1, -4.37113883e-008)
&#9;end
end

local function OnMouseUp()
&#9;if MouseHeld then
&#9;&#9;MouseHeld=false
&#9;&#9;ThrowAniTrack:Play()
&#9;&#9;HoldAniTrack:Stop()
&#9;&#9;DoDrop.Value = false
&#9;&#9;wait(.1)
&#9;&#9;
&#9;&#9;Tool.Grip=CFrame.new(0.0614605024, 5.28547162e-009, 0.920917511, 0.974370062, -9.83292381e-009, -0.224951088, 9.8329247e-009, 1, -1.12031984e-009, 0.224951088, -1.12032339e-009, 0.974370062)
&#9;end
end

local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent
&#9;HoldAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;HoldAni&apos;))
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled and not MouseDownObject.Value then
&#9;&#9;&#9;
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;end
&#9;end)
&#9;mouse.Button1Up:connect(function()
&#9;&#9;if MouseDownObject.Value then
&#9;&#9;&#9;wait(0.01) --NOTE: Wait added to fix immediate down-up issue on iPad
&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;
&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;
&#9;&#9;end
&#9;end)
&#9;MouseDownObject.Value = false
&#9;MouseHeld=false
&#9;ThrowAniTrack:Stop()
&#9;HoldAniTrack:Stop()&#9;
&#9;Tool.Grip=CFrame.new(0.0614605024, 5.28547162e-009, 0.920917511, 0.974370062, -9.83292381e-009, -0.224951088, 9.8329247e-009, 1, -1.12031984e-009, 0.224951088, -1.12032339e-009, 0.974370062)
end

local function OnUnequipped()
&#9;HoldAniTrack:Stop()
&#9;DoDrop.Value = true
&#9;MouseDownObject.Value = false
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end


Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="BoolValue" referent="RBX336">
							<Properties>
								<string name="Name">MouseDown</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX337">
							<Properties>
								<string name="Name">DoDrop</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX338">
							<Properties>
								<string name="Name">TargetPosition</string>
								<Vector3 name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX339">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861246</url></Content>
							<string name="Name">HoldAni</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX340">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861252</url></Content>
							<string name="Name">ThrowAni</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX341">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)

local RedTexture= WaitForChild(Handle,&apos;RedTextureId&apos;)

local MrBombModifierName = &apos;MrBomb&apos;

local IsGold=WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94691681&apos;
local MrBombTexture = &apos;http://www.roblox.com/asset/?id=98260356&apos;

local MrBombRedTexture = &apos;http://www.roblox.com/asset/?id=98261349&apos;
local NormalRedTexture = &apos;http://www.roblox.com/asset/?id=94691735&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94691640&apos;
local MrBombMesh = &apos;http://www.roblox.com/asset/?id=98260446&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94690231&apos;
local MrBombIcon = &apos;http://www.roblox.com/asset/?id=97923204&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=true
&#9;&#9;Mesh.TextureId=MrBombTexture
&#9;&#9;Mesh.MeshId=MrBombMesh
&#9;&#9;Tool.TextureId= MrBombIcon
&#9;&#9;RedTexture.Value=MrBombRedTexture
&#9;&#9;Tool.ToolTip= &apos;Professor Bomb&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;RedTexture.Value=NormalRedTexture
&#9;&#9;Tool.ToolTip= &apos;Bomb&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX342">
						<Properties>
							<string name="Name">IsGoldBomb</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX343">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ThrowBomb</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again
local THROW_SPEED = 80

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local JointsService = Game.JointsService -- Sketttttch

local Tool = script.Parent
local ToolHandle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

local IsGoldBomb = WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local MyModel = nil
local MyPlayer = nil

local BaseBomb = nil
local BombClone = nil
local BombCloneWeld = nil


local MrBombSounds = 
{
&#9;{SoundId=100204329,Length=1.6}
}

-----------------
--| Functions |--
-----------------

local function MakeBaseBomb()
&#9;local bomb = ToolHandle:Clone()
&#9;bomb.Name = &quot;Bomb&quot;

&#9;-- Attach creator tags to the bomb early on
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, bomb)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId

&#9;if IsGoldBomb.Value then
&#9;&#9;local randomEntry=MrBombSounds[math.random(#MrBombSounds)]
&#9;&#9;local soundlength=Instance.new(&apos;NumberValue&apos;)
&#9;&#9;soundlength.Name=&apos;MrBombLength&apos;
&#9;&#9;soundlength.Value=randomEntry.Length
&#9;&#9;soundlength.Parent=bomb
&#9;&#9;local sound=Instance.new(&apos;Sound&apos;)
&#9;&#9;sound.Name=&apos;MrBombSound&apos;
&#9;&#9;sound.SoundId=&apos;http://www.roblox.com/asset/?id=&apos;..randomEntry.SoundId
&#9;&#9;sound.Volume=1
&#9;&#9;sound.Parent=bomb
&#9;end
&#9;-- Arm the bomb
&#9;WaitForChild(bomb, &apos;Explode&apos;).Disabled = false

&#9;return bomb
end

local function OnMouseDownChanged(down, targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if down then -- Player just clicked
&#9;&#9;if Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 and not BombCloneWeld then
&#9;&#9;&#9;BombCloneWeld = Instance.new(&apos;Weld&apos;, JointsService)
&#9;&#9;&#9;BombCloneWeld.Part0 = ToolHandle
&#9;&#9;&#9;BombCloneWeld.Part1 = BombClone
&#9;&#9;&#9;DebrisService:AddItem(BombClone, 30)

&#9;&#9;&#9;
&#9;&#9;&#9;if MyModel:FindFirstChild(&apos;Head&apos;) then
&#9;&#9;&#9;&#9;print(&apos;setting position&apos;)
&#9;&#9;&#9;&#9;WaitForChild(BombClone, &apos;ParentTorso&apos;).Value = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;end

&#9;&#9;&#9;BombClone.Parent = Tool --Workspace -- NOTE: This starts the already-armed explosion script
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;end
&#9;else -- Player just released click
&#9;&#9;if BombCloneWeld then
&#9;&#9;&#9;Tool.Enabled = false
&#9;&#9;&#9;-- Throw the bomb
&#9;&#9;&#9;BombClone.Parent = Workspace
&#9;&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;&#9;BombCloneWeld = nil
&#9;&#9;&#9;if not DoDrop.Value then
&#9;&#9;&#9;&#9;--local direction = (MyModel.Humanoid.TargetPoint - ToolHandle.Position).unit
&#9;&#9;&#9;&#9;local direction = ((targetOverride or TargetPosition.Value) - ToolHandle.Position).unit
&#9;&#9;&#9;&#9;BombClone.Velocity = ToolHandle.Velocity + ((direction + Vector3.new(0, 1, 0)).unit * THROW_SPEED)
&#9;&#9;&#9;&#9;BombClone.CanCollide = true --false NOTE: Temporary
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;BombClone.CanCollide = true
&#9;&#9;&#9;end
&#9;&#9;&#9;--BombClone.CanCollide = true

&#9;&#9;&#9;-- Prepare the next bomb to be thrown
&#9;&#9;&#9;BombClone = BaseBomb:Clone()

&#9;&#9;&#9;wait(COOLDOWN)

&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;&#9;Tool.Enabled = true
&#9;&#9;end
&#9;end
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseBomb = MakeBaseBomb()
&#9;BombClone = BaseBomb:Clone()
end

local function OnUnequipped()
&#9;ToolHandle.Transparency = 0
&#9;OnMouseDownChanged(false)
&#9;BombClone:Destroy()
&#9;if BombCloneWeld then
&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;BombCloneWeld = nil
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true)
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel,BombClone})
&#9;&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(false, targetPosition)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX344">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830794</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX345">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RocketLauncher</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX346">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830812</int>
					</Properties>
				</Item>
				<Item class="Tool" referent="RBX347">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0500000007</X>
							<Y>-0.600000024</Y>
							<Z>-1</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RocketLauncher</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689922</url></Content>
						<string name="ToolTip">Rocket Launcher</string>
					</Properties>
					<Item class="Part" referent="RBX348">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-0.400000006</X>
								<Y>18</Y>
								<Z>22.2000008</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.839999974</X>
								<Y>1.14999998</Y>
								<Z>3.55000019</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX349">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94690054</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94689966</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX350">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">ReloadSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=94132726</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX351">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Equip</string>
								<float name="Pitch">1.33000004</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/Asset?ID=97103817</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX352">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Launcher</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again

-- RocketPropulsion Fields
local TARGET_RADIUS = 5
local MAX_SPEED = 60
local MAX_TORQUE = Vector3.new(4e6, 4e6, 0)
local MAX_THRUST = 50000
local THRUST_P = 500
local THRUST_D = 50000

local TARGET_OVERSHOOT_DISTANCE = 10000000

local ROCKET_MESH_ID = &apos;http://www.roblox.com/asset/?id=94690081&apos;
local ROCKET_MESH_SCALE = Vector3.new(2.5, 2.5, 2)
local ROCKET_PART_SIZE = Vector3.new(1, 1, 4)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local RocketScript = WaitForChild(script, &apos;Rocket&apos;)

local SwooshSound = WaitForChild(script, &apos;Swoosh&apos;)
local BoomSound = WaitForChild(script, &apos;Boom&apos;)
local ReloadSound = WaitForChild(ToolHandle, &apos;ReloadSound&apos;)
local EquipSound = WaitForChild(ToolHandle, &apos;Equip&apos;)

local MyModel = nil
local MyPlayer = nil

local BaseRocket = nil
local RocketClone = nil

-----------------
--| Functions |--
-----------------

local function MakeBaseRocket()
&#9;-- Set up the rocket part
&#9;local rocket = Instance.new(&apos;Part&apos;)
&#9;rocket.Name = &apos;Rocket&apos;
&#9;rocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;rocket.Size = ROCKET_PART_SIZE
&#9;rocket.CanCollide = false
&#9;rocket.BottomSurface = Enum.SurfaceType.Smooth
&#9;rocket.TopSurface = Enum.SurfaceType.Smooth

&#9;-- Add the mesh
&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, rocket)
&#9;mesh.MeshId = ROCKET_MESH_ID
&#9;mesh.Scale = ROCKET_MESH_SCALE
&#9;mesh.TextureId = ToolHandle.Mesh.TextureId

&#9;-- Add fire
&#9;local fire = Instance.new(&apos;Fire&apos;, rocket)
&#9;fire.Heat = 5
&#9;fire.Size = 2

&#9;-- Add the propulsion
&#9;local rocketPropulsion = Instance.new(&apos;RocketPropulsion&apos;, rocket)
&#9;rocketPropulsion.CartoonFactor = 1
&#9;rocketPropulsion.TargetRadius = TARGET_RADIUS
&#9;rocketPropulsion.MaxSpeed = MAX_SPEED
&#9;rocketPropulsion.MaxTorque = MAX_TORQUE
&#9;rocketPropulsion.MaxThrust = MAX_THRUST
&#9;rocketPropulsion.ThrustP = THRUST_P
&#9;rocketPropulsion.ThrustD = THRUST_D

&#9;-- Clone the sounds
&#9;local swooshSoundClone = SwooshSound:Clone()
&#9;swooshSoundClone.Parent = rocket
&#9;local boomSoundClone = BoomSound:Clone()
&#9;boomSoundClone.PlayOnRemove = true
&#9;boomSoundClone.Parent = rocket

&#9;-- Attach creator tags
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, rocket)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local nameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;nameTag.Name = &apos;weaponName&apos;
&#9;nameTag.Value = Tool.Name
&#9;local iconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;iconTag.Name = &apos;weaponIcon&apos;
&#9;iconTag.Value = Tool.TextureId

&#9;-- Finally, clone the rocket script and enable it
&#9;local rocketScriptClone = RocketScript:Clone()
&#9;rocketScriptClone.Parent = rocket
&#9;rocketScriptClone.Disabled = false

&#9;return rocket
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseRocket = MakeBaseRocket()
&#9;RocketClone = BaseRocket:Clone()
&#9;EquipSound:Play()
end

local function OnActivated(targetOverride)
&#9;wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;if Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;-- Pick a target
&#9;&#9;local targetPosition = targetOverride or MyModel.Humanoid.TargetPoint

&#9;&#9;-- Position the rocket clone
&#9;&#9;local spawnPosition = ToolHandle.Position + (ToolHandle.CFrame.lookVector * (ToolHandle.Size.Z / 2))
&#9;&#9;RocketClone.CFrame = CFrame.new(spawnPosition, targetPosition) --NOTE: This must be done before assigning Parent
&#9;&#9;DebrisService:AddItem(RocketClone, 30)
&#9;&#9;RocketClone.Parent = Workspace

&#9;&#9;-- Assign target and launch!
&#9;&#9;local rocketPropulsion = RocketClone:FindFirstChild(&apos;RocketPropulsion&apos;)
&#9;&#9;if rocketPropulsion then
&#9;&#9;&#9;local direction = (targetPosition - RocketClone.Position).unit
&#9;&#9;&#9;rocketPropulsion.TargetOffset = RocketClone.Position + (direction * TARGET_OVERSHOOT_DISTANCE)
&#9;&#9;&#9;rocketPropulsion:Fire()
&#9;&#9;end

&#9;&#9;-- Prepare the next rocket to be fired
&#9;&#9;RocketClone = BaseRocket:Clone()

&#9;&#9;ReloadSound:Play()

&#9;&#9;wait(COOLDOWN)

&#9;&#9;-- Stop the reloading sound if it hasn&apos;t already finished
&#9;&#9;ReloadSound:Stop()

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;ReloadSound:Stop()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Sound" referent="RBX353">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Boom</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds/collide.wav</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX354">
							<Properties>
								<bool name="Looped">true</bool>
								<string name="Name">Swoosh</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds/Rocket whoosh 01.wav</url></Content>
								<float name="Volume">0.699999988</float>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX355">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Rocket</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 6
local BLAST_RADIUS_ROCKETRACE = 5
local BLAST_PRESSURE = 750000

local IGNORE_LIST = {rocket = 1, handle = 1, effect = 1, water = 1} -- Rocket will fly through things named these
--NOTE: Keys must be lowercase, values must evaluate to true

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Rocket = script.Parent

local CreatorTag = WaitForChild(Rocket, &apos;creator&apos;)

local SwooshSound = WaitForChild(Rocket, &apos;Swoosh&apos;)

-----------------
--| Functions |--
-----------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function OnExplosionHit(hitPart)
&#9;print(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnTouched(otherPart)
&#9;if Rocket and otherPart then
&#9;&#9;-- Fly through anything in the ignore list
&#9;&#9;if IGNORE_LIST[string.lower(otherPart.Name)] then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- Fly through the creator
&#9;&#9;local myPlayer = CreatorTag.Value
&#9;&#9;if myPlayer and myPlayer.Character and myPlayer.Character:IsAncestorOf(otherPart) then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- for the rocket race mode: Rockets should destroy the destructible blocks in
&#9;&#9;-- the level, by cloning a kill script into them.
&#9;&#9;local destructible = otherPart:FindFirstChild(&apos;RocketDestructible&apos;)
&#9;&#9;if destructible and destructible.Value then
&#9;&#9;&#9;-- rocket race part
&#9;&#9;&#9;if not otherPart:FindFirstChild(&apos;KillBrick&apos;) then
&#9;&#9;&#9;&#9;local sc = script:WaitForChild(&apos;KillBrick&apos;):Clone()
&#9;&#9;&#9;&#9;sc.Parent = otherPart
&#9;&#9;&#9;&#9;sc.Disabled = false
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;-- Boom
&#9;&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;&#9;if Workspace:WaitForChild(&apos;MainGameScript&apos;):WaitForChild(&apos;CurrentGameType&apos;):FindFirstChild(&apos;RocketRace&apos;) then
&#9;&#9;&#9;-- rocket race rockets have a much smaller blast radius
&#9;&#9;&#9;explosion.BlastRadius = BLAST_RADIUS_ROCKETRACE
&#9;&#9;else
&#9;&#9;&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;&#9;end
&#9;&#9;explosion.Position = (Rocket.CFrame * CFrame.new(0,0,-2)).p
&#9;&#9;explosion.Hit:connect(OnExplosionHit)
&#9;&#9;explosion.Parent = Workspace

&#9;&#9;-- Move this script and the creator tag (so our custom logic can execute), then destroy the rocket
&#9;&#9;script.Parent = explosion
&#9;&#9;CreatorTag.Parent = script
&#9;&#9;Rocket:Destroy()
&#9;end
end

--------------------
--| Script Logic |--
--------------------

SwooshSound:Play()

Rocket.Touched:connect(OnTouched)

-- Manually call OnTouched for parts the rocket might have spawned inside of
--TODO: Remove when Touched correctly fires for parts spawned within other parts
local partClone = Rocket:Clone()
partClone:ClearAllChildren()
partClone.Transparency = 1
--partClone.Anchored = true --NOTE: DOES NOT WORK if part is anchored!
DebrisService:AddItem(partClone, 0.1)
partClone.Parent = Workspace
partClone.Touched:connect(OnTouched)
</ProtectedString>
							</Properties>
							<Item class="Script" referent="RBX356">
								<Properties>
									<bool name="Disabled">true</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">KillBrick</string>
									<ProtectedString name="Source">-------------------------------------------
--| Script used in to destroy blocks in |--
--| the rocket race round type          |--
-------------------------------------------
local brick = script.Parent

for i = 0, 1, 0.01 do
&#9;wait()
&#9;brick.Transparency = i
end

brick.Anchored = false
brick.CanCollide = false</ProtectedString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX357">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Animation</string>
							<ProtectedString name="Source">--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent

local FireAndReloadAnimation = WaitForChild(script, &apos;FireAndReload&apos;)

local FireAndReloadTrack = nil

-----------------
--| Functions |--
-----------------

local function OnEquipped()
&#9;local myModel = Tool.Parent
&#9;local humanoid = myModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then -- Preload animations
&#9;&#9;FireAndReloadTrack = humanoid:LoadAnimation(FireAndReloadAnimation)
&#9;end
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;-- Play fire and reload animation
&#9;&#9;if FireAndReloadTrack then
&#9;&#9;&#9;FireAndReloadTrack:Play()
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;-- Stop animations
&#9;if FireAndReloadTrack then FireAndReloadTrack:Stop() end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
						</Properties>
						<Item class="Animation" referent="RBX358">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94771598</url></Content>
								<string name="Name">FireAndReload</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX359">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX360">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VisualizeReload</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local ROCKET_MESH_ID = &apos;http://www.roblox.com/asset/?id=94690081&apos;
local ROCKET_MESH_SCALE = Vector3.new(1, 1, 1)

local ROCKET_SHOW_TIME = 1.5 -- Seconds after animation begins to show the rocket
local ROCKET_HIDE_TIME = 2.2 -- Seconds after animation begins to hide the rocket

-----------------
--| Variables |--
-----------------

local Tool = script.Parent
local ToolHandle = Tool.Handle

local MyModel = nil
local ReloadRocket = nil

local StillEquipped = false

-----------------
--| Functions |--
-----------------

local function MakeReloadRocket()
&#9;local reloadRocket = Instance.new(&apos;Part&apos;)
&#9;reloadRocket.Name = &quot;Ammo&quot;
&#9;reloadRocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;reloadRocket.Size = Vector3.new() -- As small as possible

&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, reloadRocket)
&#9;mesh.MeshId = ROCKET_MESH_ID
&#9;mesh.Scale = ROCKET_MESH_SCALE
&#9;mesh.TextureId = ToolHandle.Mesh.TextureId

&#9;return reloadRocket
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;ReloadRocket = MakeReloadRocket()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;-- Show the next rocket going into the launcher
&#9;&#9;StillEquipped = true
&#9;&#9;wait(ROCKET_SHOW_TIME)
&#9;&#9;if StillEquipped then
&#9;&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;if torso and torso:FindFirstChild(&apos;Left Shoulder&apos;) then
&#9;&#9;&#9;&#9;local leftArm = MyModel:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;&#9;if leftArm then
&#9;&#9;&#9;&#9;&#9;local weld = ReloadRocket:FindFirstChild(&apos;Weld&apos;)
&#9;&#9;&#9;&#9;&#9;if not weld then
&#9;&#9;&#9;&#9;&#9;&#9;weld = Instance.new(&apos;Weld&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;weld.Part0 = leftArm
&#9;&#9;&#9;&#9;&#9;&#9;weld.Part1 = ReloadRocket
&#9;&#9;&#9;&#9;&#9;&#9;weld.C1 = CFrame.new(Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;&#9;&#9;weld.Parent = ReloadRocket
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;ReloadRocket.Parent = MyModel
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(ROCKET_HIDE_TIME - ROCKET_SHOW_TIME)
&#9;&#9;&#9;&#9;if StillEquipped and ReloadRocket.Parent == MyModel then
&#9;&#9;&#9;&#9;&#9;ReloadRocket.Parent = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;StillEquipped = false
&#9;ReloadRocket:Destroy()
&#9;ReloadRocket = nil
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX361">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Reflector</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX362">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>-0.100000083</X>
							<Y>-1.49011612e-008</Y>
							<Z>-2.86602809e-015</Z>
							<R00>4.37113883e-008</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>1.91068547e-015</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-1</R20>
							<R21>1.91068547e-015</R21>
							<R22>4.37113883e-008</R22>
						</CoordinateFrame>
						<string name="Name">Reflector</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94878549</url></Content>
						<string name="ToolTip">Reflector</string>
					</Properties>
					<Item class="Script" referent="RBX363">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BlockScript</string>
							<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DebrisService = Game:GetService(&quot;Debris&quot;)

local CANNON_LAUNCH_VELOCITY = 170
local PELLET_VELOCITY = 85
local BOMB_VELOCITY = 90


local SphereMesh = WaitForChild(script.Parent,&apos;SphereMesh&apos;)

local Tool = script.Parent
local Handle = Tool.Handle

local BlockRadius=Vector3.new(20,20,20)

local BlockTime =  .7

local MyCharacter
local MyPlayer

local StartSphereScale=Vector3.new(.1,.1,.1)
local EndSphereScale=Vector3.new(10,10,10)
local EffectLength=.6

local ApplauseEnabled=WaitForChild(Tool,&apos;ApplauseEnabled&apos;)


local LastAttackTime = tick()

function CheckForProjectiles(character)
&#9;if not character:FindFirstChild(&apos;Torso&apos;) then return end
&#9;local center=character.Torso.CFrame.p
&#9;local parts = game.Workspace:FindPartsInRegion3(Region3.new(center-BlockRadius,center+BlockRadius),character,100)
&#9;local projectiles = {}
&#9;for _,i in pairs(parts) do
&#9;&#9;if i:FindFirstChild(&apos;creator&apos;) then
&#9;&#9;&#9;
&#9;&#9;&#9;table.insert(projectiles,i)
&#9;&#9;&#9;print(&apos;projectiles::::&apos;)
&#9;&#9;&#9;print (i)
&#9;&#9;end
&#9;end
&#9;
&#9;
&#9;return projectiles
end

function FireBeam(beamStart, beamEnd, color, part)
&#9;local distance = (beamStart - beamEnd).magnitude
&#9;if distance &gt; 1000 then distance = 1000 end
&#9;local laser = part or Instance.new(&apos;Part&apos;)
&#9;--Game.Debris:AddItem(laser, 0.05)
&#9;laser.Name = &apos;Effect&apos;
&#9;laser.Anchored = true
&#9;laser.CanCollide = false
&#9;laser.Shape = &apos;Block&apos;
&#9;laser.formFactor = &apos;Custom&apos;
&#9;laser.Size = Vector3.new(0.5, 0.5, distance + 0.2)
&#9;laser.Material = Enum.Material.Plastic
&#9;laser.Locked = true
&#9;laser.TopSurface = 0
&#9;laser.BottomSurface = 0
&#9;laser.BrickColor = color or BrickColor.new(&apos;Bright red&apos;)
&#9;laser.CFrame = CFrame.new(beamStart, beamEnd) * CFrame.new(0, 0, -distance/2)
&#9;laser.Parent = Workspace
end

function ReflectProjectiles(bullets)
&#9;local reflectedObject=false
&#9;for _,i in pairs(bullets) do
&#9;&#9;if i and i:FindFirstChild(&apos;creator&apos;) then
&#9;&#9;&#9;if i.creator.Value.Character and i.creator.Value ~= MyPlayer and i.creator.Value.Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;local source=i.creator.Value.Character.Torso.CFrame.p
&#9;&#9;&#9;&#9;if i.Name==&apos;Rocket&apos; and i:FindFirstChild(&apos;RocketPropulsion&apos;) then
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;i.CFrame= CFrame.new(i.CFrame.p,source)
&#9;&#9;&#9;&#9;&#9;i.RocketPropulsion.TargetOffset=((source-i.CFrame.p).unit*100000)+i.CFrame.p
&#9;&#9;&#9;&#9;&#9;i.RocketPropulsion:Fire()
&#9;&#9;&#9;&#9;&#9;--uncomment to show rocket propulsion is BORK&apos;d
&#9;&#9;&#9;&#9;&#9;--[[
&#9;&#9;&#9;&#9;&#9;Spawn( function()
&#9;&#9;&#9;&#9;&#9;&#9;local initPos= i.CFrame.p
&#9;&#9;&#9;&#9;&#9;&#9;local tpart = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;local tpart2 = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;local tpart3 = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;while i.Parent do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,((source-initPos).unit*100000)+initPos,BrickColor.new(&apos;Bright red&apos;),tpart)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,i.RocketPropulsion.TargetOffset,BrickColor.new(&apos;Magenta&apos;),tpart2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FireBeam(initPos,i.CFrame.p+(i.Velocity.unit*10000),BrickColor.new(&apos;Camo&apos;),tpart3)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;--]]
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Cannon Shot&quot; then
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;i.Velocity=(source-i.CFrame.p).unit*CANNON_LAUNCH_VELOCITY
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Part&quot; then
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;i.Velocity=(source-i.CFrame.p).unit*PELLET_VELOCITY
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;elseif i.Name==&quot;Bomb&quot; then
&#9;&#9;&#9;&#9;&#9;i.creator.Value=MyPlayer
&#9;&#9;&#9;&#9;&#9;i.Velocity=(i.CFrame.p-MyCharacter.Torso.CFrame.p).unit*BOMB_VELOCITY
&#9;&#9;&#9;&#9;&#9;--WaitForChild(i,&apos;Explode&apos;).Disabled=true
&#9;&#9;&#9;&#9;&#9;--i.Explode.Disabled=false
&#9;&#9;&#9;&#9;&#9;reflectedObject=true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if i.creator:FindFirstChild(&apos;weaponName&apos;) then
&#9;&#9;&#9;&#9;&#9;i.creator.weaponName.Value=Tool.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if i.creator:FindFirstChild(&apos;weaponIcon&apos;) then
&#9;&#9;&#9;&#9;&#9;i.creator.weaponIcon.Value=Tool.TextureId
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if reflectedObject and ApplauseEnabled.Value then
&#9;&#9;WaitForChild(Handle,&apos;Applause&apos;):Play()
&#9;end
end



function VisualEffect(part)
&#9;local timeDelay = 0.2
&#9;local sphere = Instance.new(&apos;Part&apos;)
&#9;sphere.CanCollide = false
&#9;sphere.Anchored = true
&#9;sphere.Transparency = 0.5
&#9;sphere.FormFactor = Enum.FormFactor.Custom
&#9;sphere.Shape = Enum.PartType.Ball
&#9;sphere.Size = Vector3.new(0.2, 0.2, 0.2)
&#9;sphere.CFrame = CFrame.new(part.CFrame.p)
&#9;sphere.TopSurface = Enum.SurfaceType.Smooth
&#9;sphere.BottomSurface  = Enum.SurfaceType.Smooth
&#9;sphere.Name = &apos;water&apos; --LOL-CANO
&#9;sphere.BrickColor=BrickColor.new(&apos;Cyan&apos;)
&#9;sphere.Transparency = 1
&#9;-- Add 0.2 for the wait below
&#9;DebrisService:AddItem(sphere, EffectLength + timeDelay)
&#9;sphere.Parent = Workspace
&#9;
&#9;local sphereMesh = WaitForChild(Tool,&apos;SphereMesh&apos;):Clone()
&#9;sphereMesh.VertexColor=Vector3.new(1,1,1)
&#9;sphereMesh.Scale = Vector3.new(.1,.1,.1)
&#9;sphereMesh.Parent = sphere

&#9;Tool.Handle.Plant:Play()

&#9;wait(timeDelay)
&#9;sphere.Transparency = 0
&#9;local startTime=time()
&#9;while time()-startTime&lt;EffectLength do
&#9;&#9;sphere.CFrame = CFrame.new(part.CFrame.p)
&#9;&#9;sphereMesh.Scale=StartSphereScale:Lerp(EndSphereScale,(time()-startTime)/EffectLength)
&#9;&#9;sphere.Transparency=(time()-startTime)/EffectLength
&#9;&#9;wait()
&#9;end
end

Tool.Enabled = true
function OnActivated()
&#9;local character = Tool.Parent
&#9;if not Tool.Enabled or not character:FindFirstChild(&apos;Humanoid&apos;) or character.Humanoid.Health &lt;= 0 then
&#9;&#9;return -- Tool must be enabled and player must be alive
&#9;end
&#9;local now = tick()
&#9;if now - LastAttackTime &lt; 2 then
&#9;&#9;return
&#9;end
&#9;Tool.Enabled = false
&#9;LastAttackTime = now
&#9;Spawn(function() VisualEffect(Tool.Handle) end)

&#9;local startTime=time()
&#9;while time()-startTime&lt;BlockTime do 
&#9;&#9;ReflectProjectiles(CheckForProjectiles(character))
&#9;&#9;wait(1/30)
&#9;end
&#9;-- wait to set tool.Enabled so the icon isn&apos;t showing ready when it isn&apos;t ready
&#9;local waitTime = math.max(0, 2 - (tick() - now))
&#9;wait(waitTime)
&#9;Tool.Enabled = true
end


function OnEquipped()
&#9;MyCharacter = Tool.Parent
&#9;MyPlayer = game.Players:GetPlayerFromCharacter(MyCharacter)
&#9;OnActivated()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Activated:connect(OnActivated)
Tool.Equipped:connect(OnEquipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX364">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AnimationScript</string>
							<ProtectedString name="Source">-- Waits for the child of the specified parent
local function WaitForChild(parent, childName)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local Animations = {}
local MyHumanoid
local MyCharacter


local function PlayAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Play()
&#9;end
end

local function StopAnimation(animationName)
&#9;if Animations[animationName] then
&#9;&#9;Animations[animationName]:Stop()
&#9;end
end


function OnEquipped(mouse)
&#9;MyCharacter = Tool.Parent
&#9;MyHumanoid = WaitForChild(MyCharacter, &apos;Humanoid&apos;)
&#9;if MyHumanoid then
&#9;&#9;--Animations[&apos;EquipAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;EquipAnim3&apos;))
&#9;&#9;--Animations[&apos;IdleAnim&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;IdleAnim3&apos;))
&#9;&#9;Animations[&apos;FireAni&apos;] = MyHumanoid:LoadAnimation(WaitForChild(Tool, &apos;FireAni&apos;))
&#9;end
&#9;--PlayAnimation(&apos;EquipAnim&apos;)
&#9;--PlayAnimation(&apos;IdleAnim&apos;)
end

function OnUnequipped()
&#9;--StopAnimation(&apos;IdleAnim&apos;)
&#9;--PlayAnimation(&apos;UnequipAnim&apos;)
end

local LastActivate=0

function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;if time()-LastActivate&gt;2 then
&#9;&#9;&#9;Animations[&apos;FireAni&apos;]:Play(.1,1,6)
&#9;&#9;&#9;LastActivate=time()
&#9;&#9;end
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX365">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-380.600006</X>
								<Y>-6.01500034</Y>
								<Z>33.4000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>3.42285489e-008</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-3.42285489e-008</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1.96999979</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX366">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94735473</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1.5</X>
									<Y>1.5</Y>
									<Z>1.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94735715</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX367">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Plant</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94215314</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX368">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Applause</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=97656068</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX369">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94190213</url></Content>
							<string name="Name">FireAni</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX370">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh=WaitForChild(Handle,&apos;Mesh&apos;)
local ApplauseEnabled=WaitForChild(Tool,&apos;ApplauseEnabled&apos;)
local SphereMesh=WaitForChild(Tool,&apos;SphereMesh&apos;)

local AwardModifierName = &apos;AwardReflector&apos;

local AwardMesh = &apos;http://www.roblox.com/asset/?id=97820425&apos;
local AwardTexture = &apos;http://www.roblox.com/asset/?id=97820380&apos;
local AwardIcon = &apos;http://www.roblox.com/asset/?id=97820334&apos;
local GoldShieldMesh = &apos;http://www.roblox.com/asset/?id=97908983&apos;
local GoldShieldTexture = &apos;http://www.roblox.com/asset/?id=97821269&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94735473&apos;
local NormalTexture = &apos;http://www.roblox.com/asset/?id=94735715&apos;
local NormalIcon = &apos;http://www.roblox.com/asset/?id=94878549&apos;
local NormalShieldMesh = &apos;http://www.roblox.com/asset/?id=94736101&apos;
local NormalShieldTexture = &apos;http://www.roblox.com/asset/?id=94735715&apos;

function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == AwardModifierName then
&#9;&#9;ApplauseEnabled.Value=true
&#9;&#9;Mesh.MeshId=AwardMesh
&#9;&#9;Mesh.TextureId=AwardTexture
&#9;&#9;Mesh.Scale=Vector3.new(.6,.6,.6)
&#9;&#9;Tool.Grip= CFrame.new(-0.400000006, -1.10000002, -0.499999881, -1, 1.91068547e-015, 0, 1.91068547e-015, 1, 0, 0, -8.35187172e-023, -1)
&#9;&#9;Tool.TextureId=AwardIcon
&#9;&#9;SphereMesh.MeshId=GoldShieldMesh
&#9;&#9;SphereMesh.TextureId=GoldShieldTexture
&#9;&#9;Tool.ToolTip= &apos;24-Carat Reflector&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == AwardModifierName then
&#9;&#9;ApplauseEnabled.Value=false
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Mesh.TextureId=NormalTexture
&#9;&#9;Mesh.Scale=Vector3.new(1.5, 1.5, 1.5)
&#9;&#9;Tool.Grip= CFrame.new(-0.100000083, -1.49011612e-008, -2.86602809e-015, 4.37113883e-008, 0, 1, 1.91068547e-015, 1, 0, -1, 1.91068547e-015, 4.37113883e-008)
&#9;&#9;Tool.TextureId=NormalIcon
&#9;&#9;SphereMesh.MeshId=NormalShieldMesh
&#9;&#9;SphereMesh.TextureId=NormalShieldTexture
&#9;&#9;Tool.ToolTip= &apos;Reflector&apos;
&#9;end
&#9;
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX371">
						<Properties>
							<string name="Name">ApplauseEnabled</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
					<Item class="SpecialMesh" referent="RBX372">
						<Properties>
							<token name="LODX">2</token>
							<token name="LODY">2</token>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=94736101</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">SphereMesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=94735715</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX373">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX374">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">97830832</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX375">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Pitchfork</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX376">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0614605024</X>
							<Y>1.80000019</Y>
							<Z>-0.079082571</Z>
							<R00>0.974370062</R00>
							<R01>2.94987714e-008</R01>
							<R02>0.224951088</R02>
							<R10>9.8329247e-009</R10>
							<R11>-1</R11>
							<R12>8.85430964e-008</R12>
							<R20>0.224951088</R20>
							<R21>-8.406181e-008</R21>
							<R22>-0.974370062</R22>
						</CoordinateFrame>
						<string name="Name">Pitchfork</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100253786</url></Content>
						<string name="ToolTip">Farmer&apos;s Revenge</string>
					</Properties>
					<Item class="Part" referent="RBX377">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-408.450012</X>
								<Y>-9.87000084</Y>
								<Z>33.6650009</Z>
								<R00>-0.707106709</R00>
								<R01>0.707106709</R01>
								<R02>1.01017065e-007</R02>
								<R10>-0.707106709</R10>
								<R11>-0.707106709</R11>
								<R12>-8.28150704e-008</R12>
								<R20>1.28707356e-008</R20>
								<R21>-1.29988962e-007</R21>
								<R22>0.999999881</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.699999988</X>
								<Y>6.38000011</Y>
								<Z>0.370000005</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX378">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=100253437</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1.10000002</X>
									<Y>1.10000002</Y>
									<Z>1.10000002</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100253531</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX379">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">ChargeUp</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101090565</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX380">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">SonicBoom</string>
								<float name="Pitch">0.800000012</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101084318</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX381">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX382">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickTransmitter</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent

local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)&#9;

local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)

local HoldAniTrack
local ThrowAniTrack
local ChargeAniTrack
local ChargeArmAniTrack

local ChargeUpSound = WaitForChild(WaitForChild(Tool,&apos;Handle&apos;),&apos;ChargeUp&apos;)
local SonicBoomSound = WaitForChild(WaitForChild(Tool,&apos;Handle&apos;),&apos;SonicBoom&apos;)


local ChargeAniBaseLength=4
local MaxChargeSpeed=15

local BaseFire = Instance.new(&apos;Fire&apos;)
BaseFire.Size = 4

local ChargingThrust = false

local function ChargeThrust()
&#9;ChargingThrust = true
&#9;local aniSpeed = 5
&#9;Spawn(function() while ChargingThrust and MouseDownObject.Value do wait(1/30) end SonicBoomSound:Play() end)
&#9;ChargeArmAniTrack:Play(0,1,.5)
&#9;while ChargingThrust and MouseDownObject.Value and aniSpeed&lt;MaxChargeSpeed do
&#9;&#9;ChargeAniTrack:Play(0,1,aniSpeed)
&#9;&#9;ChargeUpSound:Play()
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;if ChargingThrust then ChargeUpSound:Play() end
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;aniSpeed=aniSpeed*1.3
&#9;end
&#9;
&#9;local tfire1 = BaseFire:Clone()
&#9;local tfire2 = BaseFire:Clone()

&#9;if ChargingThrust and MouseDownObject.Value then 
&#9;&#9;tfire2.Parent = Tool.Parent:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;tfire1.Parent = Tool.Parent:FindFirstChild(&apos;Left Leg&apos;)
&#9;end

&#9;while ChargingThrust and MouseDownObject.Value do
&#9;&#9;ChargeAniTrack:Play(0,1,aniSpeed)
&#9;&#9;ChargeUpSound:Play()
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;&#9;if ChargingThrust then ChargeUpSound:Play() end
&#9;&#9;wait((ChargeAniBaseLength/aniSpeed)/2)
&#9;end
&#9;
&#9;game.Debris:AddItem(tfire1,1)
&#9;game.Debris:AddItem(tfire2,1)
end

local function OnMouseDown()
&#9;if Tool.Enabled then
&#9;&#9;HoldAniTrack:Play()
&#9;&#9;Spawn(ChargeThrust)
&#9;end
end

local function OnMouseUp()
&#9;if Tool.Enabled then
&#9;&#9;ChargingThrust = false
&#9;&#9;HoldAniTrack:Stop()
&#9;&#9;ChargeArmAniTrack:Stop()
&#9;&#9;ThrowAniTrack:Play()
&#9;end
end


local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent

&#9;HoldAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;HoldAni&apos;))
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;ChargeAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ChargeUpAni&apos;))
&#9;ChargeArmAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ChargeUpArm&apos;))
&#9;
&#9;

&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled and not MouseDownObject.Value then
&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;end
&#9;end)
&#9;mouse.Button1Up:connect(function()
&#9;&#9;if MouseDownObject.Value then
&#9;&#9;&#9;wait(0.01) --NOTE: Wait added to fix immediate down-up issue on iPad
&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;OnMouseUp()
&#9;&#9;end
&#9;end)
end

local function OnUnequipped()
&#9;MouseDownObject.Value = false
&#9;ChargingThrust = false
&#9;HoldAniTrack:Stop()
&#9;ChargeArmAniTrack:Stop()
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;MouseDownObject.Value = true 
&#9;&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;MouseDownObject.Value = false
&#9;&#9;&#9;&#9;&#9;OnMouseUp()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="BoolValue" referent="RBX383">
							<Properties>
								<string name="Name">MouseDown</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX384">
							<Properties>
								<string name="Name">DoDrop</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX385">
							<Properties>
								<string name="Name">TargetPosition</string>
								<Vector3 name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX386">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100353779</url></Content>
							<string name="Name">HoldAni</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX387">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100356641</url></Content>
							<string name="Name">ThrowAni</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX388">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModifierScript</string>
							<ProtectedString name="Source">--this script modifies this weapon depending on if you have the according gamepass

local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait() end
&#9;return parent[childName]
end

local Tool=script.Parent
local Player=Tool.Parent.Parent
local Handle=WaitForChild(Tool,&apos;Handle&apos;)
local Mesh= WaitForChild(Handle,&apos;Mesh&apos;)

local RedTexture= WaitForChild(Handle,&apos;RedTextureId&apos;)

local MrBombModifierName = &apos;MrBomb&apos;

local IsGold=WaitForChild(Tool,&apos;IsGoldBomb&apos;)

local NormalTexture = &apos;http://www.roblox.com/asset/?id=94691681&apos;
local MrBombTexture = &apos;http://www.roblox.com/asset/?id=98260356&apos;

local MrBombRedTexture = &apos;http://www.roblox.com/asset/?id=98261349&apos;
local NormalRedTexture = &apos;http://www.roblox.com/asset/?id=94691735&apos;

local NormalMesh = &apos;http://www.roblox.com/asset/?id=94691640&apos;
local MrBombMesh = &apos;http://www.roblox.com/asset/?id=98260446&apos;

local NormalIcon = &apos;http://www.roblox.com/asset/?id=94690231&apos;
local MrBombIcon = &apos;http://www.roblox.com/asset/?id=97923204&apos;


function OnModifierAdded(nmodifier)
&#9;print(&apos;modifier added&apos;)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=true
&#9;&#9;Mesh.TextureId=MrBombTexture
&#9;&#9;Mesh.MeshId=MrBombMesh
&#9;&#9;Tool.TextureId= MrBombIcon
&#9;&#9;RedTexture.Value=MrBombRedTexture
&#9;&#9;Tool.ToolTip= &apos;Professor Bomb&apos;
&#9;end
end

function OnModifierRemoved(nmodifier)
&#9;if nmodifier.Name == MrBombModifierName then
&#9;&#9;IsGold.Value=false
&#9;&#9;Mesh.TextureId= NormalTexture
&#9;&#9;Mesh.MeshId=NormalMesh
&#9;&#9;Tool.TextureId= NormalIcon
&#9;&#9;RedTexture.Value=NormalRedTexture
&#9;&#9;Tool.ToolTip= &apos;Bomb&apos;
&#9;end
end

function OnPlayerChildAdded(nchild)
&#9;if nchild.Name==&apos;PlayerModifiers&apos; then
&#9;&#9;nchild.ChildAdded:connect(OnModifierAdded)
&#9;&#9;for _,i in pairs(nchild:GetChildren()) do
&#9;&#9;&#9;OnModifierAdded(i)
&#9;&#9;end
&#9;&#9;nchild.ChildRemoved:connect(OnModifierRemoved)
&#9;end
end

Player.ChildAdded:connect(OnPlayerChildAdded)
if Player:FindFirstChild(&apos;PlayerModifiers&apos;) then
&#9;OnPlayerChildAdded(Player[&apos;PlayerModifiers&apos;])
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX389">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PitchScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BASE_COOLDOWN = 1 -- Seconds until tool can be used again
local THROW_FORCE = 75
local THROW_ANGLE =  1.30899694 --75 degrees...ish
local THRUST_SPEED = 100
local BASE_DAMAGE = 45
--------------------
--| WaitForChild |--
--------------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local Handle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

local MouseDownTime = 0
local MouseDownLength = 0

local MyModel = nil
local MyPlayer = nil

local ThrustVelocity= Instance.new(&apos;BodyVelocity&apos;)
ThrustVelocity.maxForce=Vector3.new(9999999,0,9999999)

local TouchEnabled = false

local ThrowVelocity= Instance.new(&apos;BodyVelocity&apos;)
ThrowVelocity.maxForce = Vector3.new(9999999,9999999,9999999)
ThrowVelocity.velocity = Vector3.new(0,THROW_FORCE,0)

local creatorTag = Instance.new(&apos;ObjectValue&apos;,Tool)
creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats

local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = Tool.TextureId

-----------------
--| Functions |--
-----------------

local function ThrowCharacter(hitCharacter)
&#9;print(&apos;throwing character&apos;)
&#9;local throwTorso = hitCharacter:FindFirstChild(&apos;Torso&apos;)
&#9;local myTorso = MyModel:FindFirstChild(&apos;Torso&apos;)

&#9;if not (throwTorso and myTorso) then return end

&#9;local dir = (throwTorso.CFrame.p - myTorso.CFrame.p)
&#9;dir = Vector3.new(dir.x,0,dir.z).unit
&#9;local holdMultiplier = math.min(2.5,math.max(MouseDownLength*.8,1))
&#9;ThrowVelocity.velocity = Vector3.new(math.cos(THROW_ANGLE)*THROW_FORCE*dir.x*holdMultiplier,math.sin(THROW_ANGLE)*THROW_FORCE*holdMultiplier,
&#9;&#9;math.cos(THROW_ANGLE)*THROW_FORCE*dir.z*holdMultiplier)
&#9;print(ThrowVelocity.velocity)
&#9;local hitHumanoid= hitCharacter:FindFirstChild(&apos;Humanoid&apos;)
&#9;if hitHumanoid then
&#9;&#9;local throwFinished=false
&#9;&#9;ThrustVelocity.velocity=Vector3.new(0,0,0)
&#9;&#9;Spawn(function()
&#9;&#9;&#9;while not throwFinished do
&#9;&#9;&#9;&#9;hitHumanoid.PlatformStand =true
&#9;&#9;&#9;&#9;wait(1/30)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;ThrowVelocity.Parent=throwTorso

&#9;&#9;--Do damage
&#9;&#9;local hitBindable = hitHumanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;if hitBindable then
&#9;&#9;&#9;hitBindable:Invoke(BASE_DAMAGE*math.min(2,math.max(MouseDownLength*.8,1)), creatorTag)
&#9;&#9;else
&#9;&#9;&#9;local ntag = creatorTag:Clone()
&#9;&#9;&#9;ntag.Parent = hitHumanoid
&#9;&#9;&#9;game.Debris:AddItem(ntag,1)
&#9;&#9;&#9;hitHumanoid:TakeDamage(BASE_DAMAGE*math.min(2,math.max(MouseDownLength*.8,1)))
&#9;&#9;end

&#9;&#9;Delay(.1, function() ThrowVelocity.Parent=nil end)
&#9;&#9;Delay(.5,function()
&#9;&#9;&#9;throwFinished=true 
&#9;&#9;&#9;ThrustVelocity.Parent=nil 
&#9;&#9;&#9;wait(2/30)
&#9;&#9;&#9;hitHumanoid.PlatformStand = false 
&#9;&#9;end)
&#9;end
end

local function EndThrust()

end

local function OnTouch(part)
&#9;--print(&apos;got to touch&apos;)
&#9;if not TouchEnabled then return end
&#9;
&#9;local hitCharacter = FindCharacterAncestor(part)
&#9;if hitCharacter and hitCharacter ~= MyModel then
&#9;&#9;ThrowCharacter(hitCharacter)
&#9;&#9;EndThrust()
&#9;&#9;TouchEnabled = false
&#9;end
end

local function ThrustAttack(direction)
&#9;local torso=WaitForChild(MyModel,&apos;Torso&apos;)
&#9;local humanoid=MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if Tool.Parent == MyModel and humanoid and torso then
&#9;&#9;ThrustVelocity.velocity=Vector3.new(direction.x,0,direction.z).unit*THRUST_SPEED
&#9;&#9;ThrustVelocity.Parent=torso
&#9;&#9;Delay(.25*math.min(math.max(MouseDownLength,1),3),function() 
&#9;&#9;&#9;ThrustVelocity.Parent=nil 
&#9;&#9;&#9;TouchEnabled = false 
&#9;&#9;end)
&#9;end
end


local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;creatorTag.Value = MyPlayer
end

local function OnUnequipped()
&#9;MyModel.Humanoid.WalkSpeed = 16
&#9;ThrustVelocity.Parent=nil
end

local ThrustDirection
local cameraPos = WaitForChild(WaitForChild(script.Parent,&apos;CameraTransmitter&apos;),&apos;CameraCFrame&apos;)
local MouseDown =false
local function OnMouseDownChanged(down, targetOverride)
&#9;local myTorso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;local myHead = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;if not(Tool.Enabled and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and myTorso and myHead and MyModel.Humanoid.Health &gt; 0) then return end
&#9;if down then -- Player just clicked
&#9;&#9;MouseDownTime = tick()
&#9;&#9;MyModel.Humanoid.WalkSpeed = 0
&#9;&#9;wait(0)
&#9;&#9;MouseDown= true 
&#9;&#9;Spawn(function()
&#9;&#9;&#9;local bgyro = Instance.new(&apos;BodyGyro&apos;) 
&#9;&#9;&#9;bgyro.maxTorque= Vector3.new(9999999,9999999,9999999)
&#9;&#9;&#9;bgyro.Parent= myTorso
&#9;&#9;&#9;while MouseDown do
&#9;&#9;&#9;&#9;ThrustDirection =(myHead.CFrame.p-cameraPos.Value.p)
&#9;&#9;&#9;&#9;ThrustDirection = Vector3.new(ThrustDirection.X,0,ThrustDirection.Z).unit
&#9;&#9;&#9;&#9;--myTorso.CFrame = CFrame.new(myTorso.CFrame.p,myTorso.CFrame.p+ThrustDirection)
&#9;&#9;&#9;&#9;bgyro.cframe = CFrame.new(Vector3.new(0,0,0),ThrustDirection)
&#9;&#9;&#9;&#9;wait(1/30)
&#9;&#9;&#9;end
&#9;&#9;&#9;bgyro:Destroy()
&#9;&#9;end)
&#9;&#9;--ThrustDirection = ((targetOverride or TargetPosition.Value) - MyModel.Torso.CFrame.p).unit
&#9;else -- Player just released click
&#9;&#9;Tool.Enabled = false
&#9;&#9;MouseDownLength = tick() - MouseDownTime
&#9;&#9;MouseDown = false
&#9;&#9;TouchEnabled = true
&#9;&#9;ThrustAttack(ThrustDirection)
&#9;&#9;MyModel.Humanoid.WalkSpeed = 16
&#9;&#9;wait(BASE_COOLDOWN*math.min(math.max(MouseDownLength,1),3))

&#9;&#9;Tool.Enabled = true
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true)
&#9;&#9;&#9;&#9;elseif string.sub(newValue, 1, 1) == &apos;^&apos; then  -- Button up
&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(false)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)
Handle.Touched:connect(OnTouch)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX390">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100348530</url></Content>
							<string name="Name">ChargeUpAni</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX391">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100356237</url></Content>
							<string name="Name">ChargeUpArm</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX392">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraTransmitter</string>
							<ProtectedString name="Source">local myCamera = game.Workspace.CurrentCamera

while not script:FindFirstChild(&apos;CameraCFrame&apos;) do wait() end

while true do
&#9;script.CameraCFrame.Value = myCamera.CoordinateFrame
&#9;wait()
end</ProtectedString>
						</Properties>
						<Item class="CFrameValue" referent="RBX393">
							<Properties>
								<string name="Name">CameraCFrame</string>
								<CoordinateFrame name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
							</Properties>
						</Item>
					</Item>
					<Item class="Camera" referent="RBX394">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>1.93089318</X>
								<Y>5.95214415</Y>
								<Z>-2.20321321</Z>
								<R00>-1</R00>
								<R01>-2.74756616e-007</R01>
								<R02>-6.55651183e-006</R02>
								<R10>-0</R10>
								<R11>0.999123156</R11>
								<R12>-0.0418691672</R12>
								<R20>6.56226575e-006</R20>
								<R21>-0.0418691672</R21>
								<R22>-0.999123156</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>1.9309063</X>
								<Y>6.03588247</Y>
								<Z>-0.204967141</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">Camera</string>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX395">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">101198127</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX396">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">GravityDisruptor</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX397">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.300000012</X>
							<Y>-0.200000003</Y>
							<Z>0.400000006</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">GravityDisruptor</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=101002061</url></Content>
						<string name="ToolTip">Gravity Disruptor</string>
					</Properties>
					<Item class="Part" referent="RBX398">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">1023</int>
							<CoordinateFrame name="CFrame">
								<X>-410.100006</X>
								<Y>-16</Y>
								<Z>31.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>3.42285489e-008</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-3.42285489e-008</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX399">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101002082</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=101002108</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX400">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Charge</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101153932</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX401">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Burst</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101157919</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX402">
							<Properties>
								<bool name="Looped">true</bool>
								<string name="Name">Hum</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101158613</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX403">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 30

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent
local ToolHandle = Tool.Handle

local DisruptorScript = WaitForChild(script, &apos;DisruptorScript&apos;)

local ReleaseAnimation = WaitForChild(script, &apos;Release&apos;)

local ChargeSound = WaitForChild(ToolHandle, &apos;Charge&apos;)

local MyModel = nil
local MyHumanoid = nil

local BaseDevice = nil

local ReleaseTrack = nil

local OriginalWalkSpeed = 0

local StillEquipped = false

-----------------
--| Functions |--
-----------------

local function MakeBaseDevice()
&#9;local baseDevice = ToolHandle:Clone()
&#9;baseDevice.Name = &apos;Effect&apos;
&#9;baseDevice.FormFactor = Enum.FormFactor.Custom
&#9;baseDevice.Size = Vector3.new() -- As small as possible
&#9;baseDevice.Anchored = true

&#9;local childScriptClone = DisruptorScript:Clone()
&#9;childScriptClone.Parent = baseDevice
&#9;childScriptClone.Disabled = false

&#9;return baseDevice
end

local function Freeze()
&#9;if MyHumanoid and MyHumanoid.Torso then
&#9;&#9;MyHumanoid.WalkSpeed = 0
&#9;end
end

local function UnFreeze()
&#9;if MyHumanoid and MyHumanoid.Torso then
&#9;&#9;MyHumanoid.WalkSpeed = OriginalWalkSpeed
&#9;end
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)

&#9;OriginalWalkSpeed = MyHumanoid.WalkSpeed

&#9;-- Preload animation
&#9;ReleaseTrack = MyHumanoid:LoadAnimation(ReleaseAnimation)

&#9;StillEquipped = true
end

local function OnActivated()
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Torso and MyHumanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;if ReleaseTrack then
&#9;&#9;&#9;ReleaseTrack:Play()
&#9;&#9;end

&#9;&#9;Freeze()

&#9;&#9;ChargeSound:Play()

&#9;&#9;wait(1.4) -- Wait for animation to get to release part

&#9;&#9;if StillEquipped then
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;&#9;local cloneDevice = BaseDevice:Clone()
&#9;&#9;&#9;cloneDevice.CFrame = ToolHandle.CFrame
&#9;&#9;&#9;cloneDevice.Parent = Workspace

&#9;&#9;&#9;wait(1.6) -- Wait for animation to finish

&#9;&#9;&#9;UnFreeze()

&#9;&#9;&#9;wait(COOLDOWN)

&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;end

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;StillEquipped = false

&#9;UnFreeze()
&#9;ToolHandle.Transparency = 0

&#9;-- Stop all animations
&#9;if ReleaseTrack then ReleaseTrack:Stop() end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

BaseDevice = MakeBaseDevice()

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX404">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DisruptorScript</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local TIME_TO_LIVE = 30

local ANTIGRAVITY_FACTOR = 1.1

local RADIUS = 15
local SPHERE_SCALE_TARGET_MAGNITUDE = Vector3.new(10, 10, 10).magnitude
local SPHERE_GROW_SPEED = 1

local SPHERE_MESH_ID = &apos;http://www.roblox.com/asset/?id=94736101&apos;
local SPHERE_TEXTURE_ID = &apos;http://www.roblox.com/asset/?id=101054992&apos;
local SPHERE_VERTEX_COLOR = Vector3.new(0.6, 0, 0.8)

local FIRE_COLOR = Color3.new(145/255, 46/255, 206/255)
local FIRE_COLOR_SECONDARY = Color3.new(23/255, 0/255, 198/255)

local RBX_GRAVITY = 196.2

local FORCE_NAME = &apos;Antigravity&apos;

local ONE_STEP = 1 / 30

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local Disruptor = script.Parent

local ForceRegistry = {}

-----------------
--| Functions |--
-----------------

-- Returns total mass of instance and all children
local function GetMassRecursive(instance)
&#9;local mass = 0
&#9;if instance:IsA(&apos;BasePart&apos;) then
&#9;&#9;mass = mass + instance:GetMass()
&#9;end
&#9;for _, child in pairs(instance:getChildren()) do
&#9;&#9;if child then
&#9;&#9;&#9;mass = mass + GetMassRecursive(child)
&#9;&#9;end
&#9;end
&#9;return mass
end

local function RegisterForce(part)
&#9;if not ForceRegistry[part] then
&#9;&#9;part.Velocity = part.Velocity * 0.9
&#9;&#9;local bodyForce = Instance.new(&apos;BodyForce&apos;)
&#9;&#9;bodyForce.Name = FORCE_NAME
&#9;&#9;bodyForce.force = Vector3.new(0, GetMassRecursive(part.Parent) * RBX_GRAVITY * ANTIGRAVITY_FACTOR, 0)
&#9;&#9;ForceRegistry[part] = bodyForce
&#9;&#9;bodyForce.Parent = part

&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Color = FIRE_COLOR
&#9;&#9;fire.SecondaryColor = FIRE_COLOR_SECONDARY
&#9;&#9;fire.Parent = part
&#9;end
end

local function DeRegisterForce(part)
&#9;local force = ForceRegistry[part]
&#9;if force then
&#9;&#9;force:Destroy()
&#9;&#9;ForceRegistry[part] = nil

&#9;&#9;local fire = part:FindFirstChild(&apos;Fire&apos;)
&#9;&#9;if fire then
&#9;&#9;&#9;fire:Destroy()
&#9;&#9;end
&#9;end
end

local function DeRegisterAllForces()
&#9;for part in pairs(ForceRegistry) do
&#9;&#9;DeRegisterForce(part)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

ContentProviderService:Preload(SPHERE_MESH_ID)
ContentProviderService:Preload(SPHERE_TEXTURE_ID)

Disruptor.CFrame = CFrame.new(Disruptor.Position)

-- Slowly rotate and rise into the air
local startTime = tick()
while tick() - startTime &lt; 3 do
&#9;Disruptor.CFrame = (Disruptor.CFrame * CFrame.Angles(0, 0.05, 0)) + Vector3.new(0, 0.1, 0)
&#9;wait(ONE_STEP)
end

local burstSound = Disruptor:FindFirstChild(&apos;Burst&apos;)
if burstSound then burstSound:Play() end

local humSound = Disruptor:FindFirstChild(&apos;Hum&apos;)
if humSound then humSound:Play() end

-- Turn into a sphere
Disruptor.Transparency = 0.5
local sphere = Disruptor:FindFirstChild(&apos;Mesh&apos;) or Instance.new(&apos;SpecialMesh&apos;)
--sphere.MeshType = Enum.MeshType.Sphere
sphere.MeshId = SPHERE_MESH_ID
sphere.TextureId = SPHERE_TEXTURE_ID
sphere.VertexColor = SPHERE_VERTEX_COLOR
sphere.Parent = Disruptor

Spawn(function()
&#9;-- Grow the sphere very quickly
&#9;--local scaleTarget = (1 / Disruptor.Size) * RADIUS * 2
&#9;--while sphere.Scale.magnitude &lt; scaleTarget.magnitude do
&#9;while sphere.Scale.magnitude &lt; SPHERE_SCALE_TARGET_MAGNITUDE do
&#9;&#9;sphere.Scale = sphere.Scale + Vector3.new(SPHERE_GROW_SPEED, SPHERE_GROW_SPEED, SPHERE_GROW_SPEED)
&#9;&#9;wait(ONE_STEP)
&#9;end
end)

-- Check for players entering and leaving
local startTime = tick()
while tick() - startTime &lt; TIME_TO_LIVE do
&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;local character = player.Character
&#9;&#9;if character then
&#9;&#9;&#9;local torso = character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;local distance = (torso.Position - Disruptor.Position).magnitude
&#9;&#9;&#9;&#9;if distance &lt;= RADIUS then -- Within range
&#9;&#9;&#9;&#9;&#9;RegisterForce(torso)
&#9;&#9;&#9;&#9;else -- Out of range
&#9;&#9;&#9;&#9;&#9;DeRegisterForce(torso)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;wait(ONE_STEP)
end

DeRegisterAllForces()
Disruptor:Destroy()
</ProtectedString>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX405">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101070520</url></Content>
								<string name="Name">Release</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX406">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Camera" referent="RBX407">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>-0.473832756</X>
								<Y>0.124247409</Y>
								<Z>-1.31150591</Z>
								<R00>-0.940500438</R00>
								<R01>0.0301559344</R01>
								<R02>-0.338451743</R02>
								<R10>-1.86264493e-009</R10>
								<R11>0.996054113</R11>
								<R12>0.08874809</R12>
								<R20>0.33979252</R20>
								<R21>0.0834676176</R21>
								<R22>-0.936789334</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">ThumbnailCamera</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX408">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">PipeBomb</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX409">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.0614605024</X>
							<Y>5.28547162e-009</Y>
							<Z>0.0209175348</Z>
							<R00>0.974370062</R00>
							<R01>-9.83292381e-009</R01>
							<R02>-0.224951088</R02>
							<R10>9.8329247e-009</R10>
							<R11>1</R11>
							<R12>-1.12031984e-009</R12>
							<R20>0.224951088</R20>
							<R21>-1.12032339e-009</R21>
							<R22>0.974370062</R22>
						</CoordinateFrame>
						<string name="Name">PipeBomb</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100206218</url></Content>
						<string name="ToolTip">Tubular Surprise</string>
					</Properties>
					<Item class="LocalScript" referent="RBX410">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX411">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ThrowBomb</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------
local GRAVITY = (-9.81 * 20)
local COOLDOWN = 5 -- Seconds until tool can be used again
local THROW_SPEED = 80
local MIN_THROW_DISTANCE = 5
--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do wait(1/30) end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local JointsService = Game.JointsService -- Sketttttch

local Tool = script.Parent
local ToolHandle = Tool.Handle

local ClickTransmitterScript = WaitForChild(Tool, &apos;ClickTransmitter&apos;)
local MouseDownObject = WaitForChild(ClickTransmitterScript, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(ClickTransmitterScript, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(ClickTransmitterScript, &apos;TargetPosition&apos;)

--local ThrowAni = WaitForChild(Tool, &apos;ThrowAni&apos;)
--local ThrowAniTrack = nil

local MyModel = nil
local MyPlayer = nil

local BaseBomb = nil
local BombClone = nil
local BombCloneWeld = nil


local MrBombSounds = 
{
&#9;{SoundId=98299395,Length=.7}
}

-----------------
--| Functions |--
-----------------


function ComputeLaunchAngle(dx,dy,vel,grav)
&#9;-- arcane
&#9;-- http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
&#9;
&#9;local g = math.abs(grav)
&#9;local inRoot = (math.pow(vel,4)) - (g * ((g*dx*dx) + (2*dy*math.pow(vel,2))))
&#9;if inRoot &lt;= 0 then
&#9;&#9;return .25 * math.pi
&#9;end
&#9;local root = math.sqrt(inRoot)
&#9;local inATan1 = ((math.pow(vel,2)) + root) / (g*dx)

&#9;local inATan2 = ((math.pow(vel,2)) - root) / (g*dx)
&#9;local answer1 = math.atan(inATan1)
&#9;local answer2 = math.atan(inATan2)
&#9;return math.min(answer1,answer2)
end


local function MakeBaseBomb()
&#9;local bomb = ToolHandle:Clone()
&#9;bomb.Name = &quot;Bomb&quot;

&#9;-- Attach creator tags to the bomb early on
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, bomb)
&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;creatorTag.Value = MyPlayer
&#9;local weaponNameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponNameTag.Name = &apos;weaponName&apos;
&#9;weaponNameTag.Value = Tool.Name
&#9;local weaponIconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;weaponIconTag.Name = &apos;weaponIcon&apos;
&#9;weaponIconTag.Value = Tool.TextureId
&#9;-- Arm the bomb
&#9;WaitForChild(bomb, &apos;Explode&apos;).Disabled = false

&#9;return bomb
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(MyModel)
&#9;BaseBomb = MakeBaseBomb()
&#9;BombClone = BaseBomb:Clone()
&#9;--ThrowAniTrack = MyModel:FindFirstChild(&apos;Humanoid&apos;):LoadAnimation(ThrowAni)
end

local function OnUnequipped()
&#9;ToolHandle.Transparency = 0
&#9;BombClone:Destroy()
&#9;if BombCloneWeld then
&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;BombCloneWeld = nil
&#9;end
end

local function ThrowPipeBomb(targetPos, projectile)

&#9;local delta = targetPos - projectile.CFrame.p
&#9;--if delta.magnitude&lt;MIN_THROW_DISTANCE then
&#9;--&#9;projectile.Velocity = delta.unit * THROW_SPEED
&#9;--&#9;return
&#9;--end
&#9;
&#9;local dy = delta.y
&#9;
&#9;local new_delta = Vector3.new(delta.x, 0, delta.z)
&#9;delta = new_delta

&#9;local dx = delta.magnitude
&#9;local unit_delta = delta.unit
&#9;
&#9;local theta = ComputeLaunchAngle( dx, dy, THROW_SPEED, GRAVITY)

&#9;local vy = math.sin(theta)
&#9;local xz = math.cos(theta)
&#9;local vx = unit_delta.x * xz
&#9;local vz = unit_delta.z * xz
&#9;projectile.Velocity = Vector3.new(vx,vy,vz) * THROW_SPEED

end
local InAttack =false
local function OnMouseDownChanged(down, targetOverride)
&#9;if down then -- Player just clicked
&#9;&#9;if Tool.Enabled and not InAttack and MyModel and MyModel:FindFirstChild(&apos;Humanoid&apos;) and MyModel.Humanoid.Health &gt; 0 then
&#9;&#9;&#9;InAttack=true
&#9;&#9;&#9;wait(.1) --must do for click transmitter script :/
&#9;&#9;&#9;Tool.Enabled = false&#9;
&#9;&#9;&#9;BombCloneWeld = Instance.new(&apos;Weld&apos;, JointsService)
&#9;&#9;&#9;BombCloneWeld.Part0 = ToolHandle
&#9;&#9;&#9;BombCloneWeld.Part1 = BombClone
&#9;&#9;&#9;BombClone.CFrame=ToolHandle.CFrame
&#9;&#9;&#9;DebrisService:AddItem(BombClone, 30)
&#9;&#9;&#9;

&#9;&#9;&#9;if MyModel:FindFirstChild(&apos;Head&apos;) then
&#9;&#9;&#9;&#9;print(&apos;setting position&apos;)
&#9;&#9;&#9;&#9;WaitForChild(BombClone, &apos;ParentTorso&apos;).Value = MyModel:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;BombClone.Parent = Workspace -- NOTE: This starts the already-armed explosion script
&#9;&#9;&#9;ToolHandle.Transparency = 1
&#9;&#9;&#9;--ThrowAniTrack:Play()
&#9;&#9;&#9;wait(.3)
&#9;&#9;&#9;BombCloneWeld:Destroy()
&#9;&#9;&#9;BombCloneWeld = nil
&#9;&#9;&#9;local target = targetOverride or TargetPosition.Value
&#9;&#9;&#9;ThrowPipeBomb(target, BombClone)
&#9;&#9;&#9;BombClone.CanCollide = false --//NOTE: Temporary
&#9;
&#9;&#9;&#9;BombClone = BaseBomb:Clone()
&#9;&#9;&#9;wait(COOLDOWN)
&#9;&#9;&#9;-- Prepare the next bomb to be thrown
&#9;&#9;&#9;
&#9;&#9;&#9;ToolHandle.Transparency = 0
&#9;&#9;&#9;Tool.Enabled = true
&#9;&#9;&#9;InAttack=false
&#9;&#9;end
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable then
&#9;&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then -- Button down
&#9;&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;&#9;OnMouseDownChanged(true, targetPosition)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
MouseDownObject.Changed:connect(OnMouseDownChanged)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX412">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickTransmitter</string>
							<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local Tool = script.Parent
local MouseDownObject = WaitForChild(script, &apos;MouseDown&apos;)
local DoDrop = WaitForChild(script, &apos;DoDrop&apos;)
local TargetPosition = WaitForChild(script, &apos;TargetPosition&apos;)
local ThrowAniTrack


local function OnMouseDown()
&#9;if Tool.Enabled then
&#9;&#9;ThrowAniTrack:Play(0,1,2)
&#9;end
end

local function OnEquipped(mouse)
&#9;local MyChar = script.Parent.Parent
&#9;ThrowAniTrack = MyChar.Humanoid:LoadAnimation(WaitForChild(Tool,&apos;ThrowAni&apos;))
&#9;mouse.TargetFilter=WaitForChild(Tool,&apos;Handle&apos;)
&#9;mouse.Button1Down:connect(function() 
&#9;&#9;if Tool.Enabled then
&#9;&#9;&#9;DoDrop.Value = false
&#9;&#9;&#9;MouseDownObject.Value = true

&#9;&#9;&#9;TargetPosition.Value=mouse.Hit.p --set this early to prevent lag problems
&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;wait(.1)
&#9;&#9;&#9;DoDrop.Value = false
&#9;&#9;&#9;MouseDownObject.Value = false 
&#9;&#9;end
&#9;end)
&#9;&#9;&#9;
end

local function OnUnequipped()
&#9;DoDrop.Value = true
&#9;MouseDownObject.Value = false
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnMouseDown()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end


Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="BoolValue" referent="RBX413">
							<Properties>
								<string name="Name">MouseDown</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX414">
							<Properties>
								<string name="Name">DoDrop</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX415">
							<Properties>
								<string name="Name">TargetPosition</string>
								<Vector3 name="Value">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX416">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100289053</url></Content>
							<string name="Name">ThrowAni</string>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX417">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-410.100006</X>
								<Y>-16</Y>
								<Z>31.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>3.42285489e-008</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-3.42285489e-008</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.400000006</X>
								<Y>1.97000003</Y>
								<Z>0.439999998</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBX418">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Boom</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX419">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">fuseSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=100240645</url></Content>
								<float name="Volume">1</float>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX420">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Explode</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 12
local BLAST_PRESSURE = 1000000



--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local RedTextureId = WaitForChild(script.Parent,&apos;RedTextureId&apos;)

local DebrisService = Game:GetService(&apos;Debris&apos;)
local ContentProviderService = Game:GetService(&apos;ContentProvider&apos;)

local PipeBomb = script.Parent

local BombMesh = WaitForChild(PipeBomb, &apos;Mesh&apos;)

local BoomSound = WaitForChild(PipeBomb, &apos;Boom&apos;)
local fuseSound = WaitForChild(PipeBomb, &apos;fuseSound&apos;)

local CreatorTag = WaitForChild(PipeBomb, &apos;creator&apos;)

local OriginalTextureId = BombMesh.TextureId

local Connection = nil

local ParentTorso = WaitForChild(PipeBomb, &apos;ParentTorso&apos;)
local XGraceDistance=2.5
local YGraceDistance=2.5


local MyWeld

-----------------
--| Functions |--
-----------------

local function TweenScale(element,starts,ends,length)
&#9;local startTime = time()
&#9;while time() - startTime &lt; length do
&#9;&#9;element.Scale = ((ends - starts) * ((time() - startTime)/length)) + starts
&#9;&#9;wait(.01)
&#9;end
&#9;element.Scale = ends
end

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

-- When a player is hit, if they are alive they will be tagged
local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(0, CreatorTag)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnTouch(part)
&#9;local stuckCharacter = FindCharacterAncestor(part)
&#9;if stuckCharacter == CreatorTag.Value.Character 
&#9;&#9;or MyWeld ~= nil then
&#9;&#9;return
&#9;end
&#9;if stuckCharacter then
&#9;&#9;part= stuckCharacter:FindFirstChild(&apos;Torso&apos;)
&#9;end
&#9;local MyWeld = Instance.new(&quot;Weld&quot;)
&#9; MyWeld.Part0 = PipeBomb 
&#9; MyWeld.Part1 = part
&#9; MyWeld.C0 = CFrame.new()
&#9; MyWeld.C1 = part.CFrame:inverse() * PipeBomb.CFrame
&#9; MyWeld.Parent = PipeBomb
&#9; return weld
end

-- Needless to say, this should only be called once
local function Explode()
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.Position = PipeBomb.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace

&#9;BoomSound:Play()

&#9;-- NOTE:
&#9;-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

&#9;PipeBomb.Transparency = 1
&#9;PipeBomb.CanCollide = false
&#9;PipeBomb.Anchored = true
&#9;DebrisService:AddItem(PipeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------
PipeBomb.Touched:connect(OnTouch)

--Distance check to see if can collide should be true
Spawn(function()
&#9;while not PipeBomb.CanCollide and ParentTorso.Value do
&#9;&#9;local TorsoPosition = ParentTorso.Value.CFrame.p
&#9;&#9;local XZOffset = TorsoPosition-Vector3.new(PipeBomb.CFrame.p.x,TorsoPosition.y,PipeBomb.CFrame.p.z)
&#9;&#9;if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-PipeBomb.CFrame.p.y)&gt;YGraceDistance then
&#9;&#9;&#9;PipeBomb.CanCollide=true
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
end)


-- Flash red and beep increasingly fast for about 3 seconds
local startMeshScale =BombMesh.Scale
local largeMeshScale = startMeshScale*1.1
local tickTime = .5
local red = true
wait(0)
fuseSound:Play()
Delay(3.2,Explode)
while true do
&#9;--BombMesh.TextureId = red and RedTextureId.Value or OriginalTextureId
&#9;--[[if red then
&#9;&#9;Spawn(function()
&#9;&#9;&#9;TweenScale(BombMesh,startMeshScale,largeMeshScale,tickTime/2)
&#9;&#9;&#9;TweenScale(BombMesh,largeMeshScale,startMeshScale,tickTime/2)
&#9;&#9;&#9;--largeMeshScale= largeMeshScale*1.1
&#9;&#9;end)
&#9;else --]]
&#9;&#9;Spawn(function()
&#9;&#9;&#9;TweenScale(BombMesh,startMeshScale,largeMeshScale,tickTime/2)
&#9;&#9;&#9;TweenScale(BombMesh,largeMeshScale,startMeshScale,tickTime/2)
&#9;&#9;&#9;largeMeshScale= largeMeshScale*1.1
&#9;&#9;end)
&#9;--end
&#9;wait(tickTime)
&#9;red = not red
&#9;--tickTime = tickTime * 0.9
end


</ProtectedString>
							</Properties>
						</Item>
						<Item class="ObjectValue" referent="RBX421">
							<Properties>
								<string name="Name">ParentTorso</string>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
						<Item class="StringValue" referent="RBX422">
							<Properties>
								<string name="Name">RedTextureId</string>
								<string name="Value">http://www.roblox.com/asset/?id=94691735</string>
							</Properties>
						</Item>
						<Item class="SpecialMesh" referent="RBX423">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99862108</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99862640</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX424">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">101199024</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX425">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">BattleBottle</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX426">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0.25</X>
							<Y>-0.300000012</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<string name="Name">BattleBottle</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856058</url></Content>
						<string name="ToolTip">Battle Bottle</string>
					</Properties>
					<Item class="Part" referent="RBX427">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-271.331024</X>
								<Y>-11.5020008</Y>
								<Z>135.60701</Z>
								<R00>-0.747106791</R00>
								<R01>0.00059383281</R01>
								<R02>-0.664703667</R02>
								<R10>0.000781149545</R10>
								<R11>0.999999642</R11>
								<R12>1.53910478e-005</R12>
								<R20>0.664703488</R20>
								<R21>-0.000507734308</R21>
								<R22>-0.747106969</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.520000041</X>
								<Y>2.1299994</Y>
								<Z>0.590000629</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX428">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=100856357</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX429">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">equipSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064872</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX430">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">singleReload</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064901</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX431">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">explodeSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064920</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX432">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">launchSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101064941</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Part" referent="RBX433">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>-271.330505</X>
									<Y>-10.6320009</Y>
									<Z>135.606567</Z>
									<R00>0.937424481</R00>
									<R01>-0.314661562</R01>
									<R02>-0.149074674</R02>
									<R10>-0.156833291</R10>
									<R11>0.000668821624</R11>
									<R12>-0.987624824</R12>
									<R20>0.31086719</R20>
									<R21>0.949203551</R21>
									<R22>-0.0487224311</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX434">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX435">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>-0.493844241</R00>
										<R01>0.866025329</R01>
										<R02>0.0782172456</R02>
										<R10>-0.156434432</R10>
										<R11>2.18556959e-008</R11>
										<R12>-0.987688363</R12>
										<R20>-0.855363131</R20>
										<R21>-0.50000006</R21>
										<R22>0.135476172</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX427</Ref>
									<Ref name="Part1">RBX433</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX436">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>-271.330505</X>
									<Y>-10.6320009</Y>
									<Z>135.606567</Z>
									<R00>-0.199701726</R00>
									<R01>0.97936523</R01>
									<R02>0.0310284346</R02>
									<R10>-0.156807065</R10>
									<R11>-0.000684169063</R11>
									<R12>-0.987628996</R12>
									<R20>-0.967228293</R20>
									<R21>-0.20209673</R21>
									<R22>0.153708011</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX437">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX438">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>-0.493844092</R00>
										<R01>-0.866025448</R01>
										<R02>0.0782172233</R02>
										<R10>-0.156434521</R10>
										<R11>2.18556906e-008</R11>
										<R12>-0.987688363</R12>
										<R20>0.85536325</R20>
										<R21>-0.499999911</R21>
										<R22>-0.135476276</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX427</Ref>
									<Ref name="Part1">RBX436</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX439">
							<Properties>
								<bool name="Anchored">false</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<int name="BrickColor">194</int>
								<CoordinateFrame name="CFrame">
									<X>-271.330505</X>
									<Y>-10.6320009</Y>
									<Z>135.606567</Z>
									<R00>-0.738001466</R00>
									<R01>-0.664703786</R01>
									<R02>0.116286747</R02>
									<R10>-0.155662879</R10>
									<R11>1.53474739e-005</R11>
									<R12>-0.987810194</R12>
									<R20>0.656599462</R20>
									<R21>-0.74710685</R21>
									<R22>-0.103481047</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<float name="Elasticity">0.5</float>
								<float name="Friction">0.300000012</float>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<token name="Material">256</token>
								<string name="Name">BR_Rocket</string>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.200000003</X>
									<Y>0.200000003</Y>
									<Z>3.4000001</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX440">
								<Properties>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=101005977</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=100856280</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="ManualWeld" referent="RBX441">
								<Properties>
									<CoordinateFrame name="C0">
										<X>0</X>
										<Y>0.870000005</Y>
										<Z>0</Z>
										<R00>0.987688363</R00>
										<R01>1.74845553e-007</R01>
										<R02>-0.156434476</R02>
										<R10>-0.156434476</R10>
										<R11>-4.37113883e-008</R11>
										<R12>-0.987688363</R12>
										<R20>-1.79530886e-007</R20>
										<R21>1</R21>
										<R22>-1.58213584e-008</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<string name="Name">ManualWeld</string>
									<Ref name="Part0">RBX427</Ref>
									<Ref name="Part1">RBX439</Ref>
									<int name="Surface0">-1</int>
									<int name="Surface1">-1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX442">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BottleRocketScript</string>
							<ProtectedString name="Source">-- Made By SolarCrane


-- Not sure if we want to get content url from roblox function?
local ICON_URL = &apos;http://www.roblox.com/asset/?id=100856058&apos;
local BOTTLE_MESH_URL = &apos;http://www.roblox.com/asset/?id=100856357&apos;
--local ROCKET_MESH_URL = &apos;http://www.roblox.com/asset/?id=100856397&apos;
local ROCKET_MESH_URL = &apos;http://www.roblox.com/asset/?id=101005977&apos;
local TEXTURE_URL = &apos;http://www.roblox.com/asset/?id=100856280&apos;

local NUMBER_OF_ROCKETS = 3
local ROCKET_LAUNCH_SPEED = 53
local RELOAD_TIME_PER_ROCKET = 0.9
local ROCKET_DEBRIS_TIME = 4
local PROJECTILE_NAME = &apos;BR_Rocket&apos;


local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)



local BottleInstance
local Tool = script.Parent

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end


local Handle = WaitForChild(Tool, &apos;Handle&apos;)
local Sounds = {equip = WaitForChild(Handle, &apos;equipSound&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;reload = WaitForChild(Handle, &apos;singleReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;explode = WaitForChild(Handle, &apos;explodeSound&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;launch = WaitForChild(Handle, &apos;launchSound&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;}


local Animations = {[&apos;EndReload&apos;] = WaitForChild(Tool, &apos;EndReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;FireAnim&apos;] = WaitForChild(Tool, &apos;FireAnim&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;ReloadLoop&apos;] = WaitForChild(Tool, &apos;ReloadLoop&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;StartReload&apos;] = WaitForChild(Tool, &apos;StartReload&apos;),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;[&apos;StopFire&apos;] = WaitForChild(Tool, &apos;StopFire&apos;)
&#9;&#9; &#9;&#9;&#9;&#9;&#9;&#9;}

local AnimationTracks = {}

local RocketMineScript = WaitForChild(script, &apos;RocketMineScript&apos;)

-- TODO: keep a list of say object pointers of rockets fired in workspace


local DEBUG_PRINT = false
function dPrint(...)
&#9;if DEBUG_PRINT then
&#9;&#9;print(...)
&#9;end
end

Bottle = {}
Bottle_mt = { __index = Bottle}


function PointOnUnitCircle(angle)
&#9;return Vector3.new(math.cos(angle), 0, math.sin(angle))
end

function CanFire()
&#9;local character = Tool.Parent
&#9;if character then
&#9;&#9;local humanoid = character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;local rightArm = character:FindFirstChild(&apos;Right Arm&apos;)
&#9;&#9;if humanoid and rightArm then
&#9;&#9;&#9;local rightGrip = rightArm:FindFirstChild(&apos;RightGrip&apos;)
&#9;&#9;&#9;if humanoid.Health &gt; 0 and rightGrip then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function GetHumanoid()
&#9;local character = Tool.Parent
&#9;return character and character:FindFirstChild(&apos;Humanoid&apos;)
end

function GetTorso()
&#9;local character = Tool.Parent
&#9;if character then
&#9;&#9;return character:FindFirstChild(&apos;Torso&apos;)
&#9;end
end

function Bottle:Create()
&#9;return setmetatable({rockets = {}, lastRocketAddedTick = tick(), lastFiredTime = tick(), inReload = false}, Bottle_mt)
end

function Bottle:OnEquipped()
&#9;dPrint(self.rockets)
&#9;Handle.Transparency = 0.55
&#9;PlaySound(&apos;equip&apos;)
&#9;for _, child in pairs(self:GetPart():GetChildren()) do
&#9;&#9;if child.Name == PROJECTILE_NAME then
&#9;&#9;&#9;local nextIndex = self:FirstOpenRocketIndex()
&#9;&#9;&#9;if nextIndex then
&#9;&#9;&#9;&#9;self.rockets[nextIndex] = Rocket:Create(child)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;for i = 1, NUMBER_OF_ROCKETS do
&#9;&#9;if not self.rockets[i] then
&#9;&#9;&#9;local tempRocket = self:AddRocket(i)
&#9;&#9;&#9;self.rockets[i] = tempRocket
&#9;&#9;end
&#9;end
end

function Bottle:OnUnequipped()
&#9;local myTorso = GetTorso()
&#9;if myTorso then
&#9;&#9;if myTorso:FindFirstChild(&apos;spinVelocity&apos;) then
&#9;&#9;&#9;myTorso:FindFirstChild(&apos;spinVelocity&apos;).Parent = nil
&#9;&#9;end
&#9;end
end

function Bottle:FirstOpenRocketIndex()
&#9;local firstOpenIndex = nil
&#9;for i = 1, NUMBER_OF_ROCKETS do
&#9;&#9;if not self.rockets[i] then
&#9;&#9;&#9;firstOpenIndex = i
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
&#9;return firstOpenIndex
end

function Bottle:OnActivated(targetOverride)
&#9;if CanFire() then
&#9;&#9;print(&quot;Activated&quot;)
&#9;&#9;local numRocketsToFire = 0
&#9;&#9;for i, rocket in pairs(self.rockets) do
&#9;&#9;&#9;if rocket then
&#9;&#9;&#9;&#9;numRocketsToFire = 1 --numRocketsToFire + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if numRocketsToFire &gt; 0 then
&#9;&#9;&#9;print(&quot;Has rockets&quot;)
&#9;&#9;&#9;PlayAnimation(&apos;FireAnim&apos;)
&#9;&#9;&#9;local firedCount = 0
&#9;&#9;&#9;--[[
&#9;&#9;&#9;local spinVelocity = Instance.new(&apos;BodyAngularVelocity&apos;)
&#9;&#9;&#9;spinVelocity.angularvelocity = Vector3.new(0,11,0)
&#9;&#9;&#9;spinVelocity.maxTorque = Vector3.new(0, 400000000, 0)
&#9;&#9;&#9;spinVelocity.P = 9000
&#9;&#9;&#9;spinVelocity.Name = &apos;spinVelocity&apos;
&#9;&#9;&#9;local myTorso = GetTorso()
&#9;&#9;&#9;if myTorso then
&#9;&#9;&#9;&#9;--spinVelocity.Parent = myTorso
&#9;&#9;&#9;end
&#9;&#9;&#9;--]]
&#9;&#9;&#9;
&#9;&#9;&#9;--local waitTime = 1.3 --((math.pi*2) / spinVelocity.angularvelocity.Y) / numRocketsToFire
&#9;&#9;&#9;for i, rocket in pairs(self.rockets) do
&#9;&#9;&#9;&#9;if firedCount &gt;= numRocketsToFire then break end
&#9;&#9;&#9;&#9;--local angle = (2 * math.pi) * (firedCount / numRocketsToFire)
&#9;&#9;&#9;&#9;--dPrint(&quot;Angle:&quot; , angle)
&#9;&#9;&#9;&#9;--rocket:Launch(waitTime, PointOnUnitCircle(angle))
&#9;&#9;&#9;&#9;self.rockets[i] = nil
&#9;&#9;&#9;&#9;rocket:LaunchTargeted(targetOverride)
&#9;&#9;&#9;&#9;firedCount = firedCount + 1
&#9;&#9;&#9;&#9;self.lastFiredTime = tick()
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--spinVelocity.Parent = nil
&#9;&#9;&#9;StopAnimation(&apos;FireAnim&apos;)
&#9;&#9;end
&#9;&#9;Spawn(function() self:Reload() end)
&#9;end
end

function Bottle:GetPart()
&#9;return script.Parent:FindFirstChild(&apos;Handle&apos;)
end

function Bottle:WeldToBottle(otherRocket, firstOpenIndex)
&#9;local rocketPart = otherRocket:GetPart()
&#9;local bottlePart = self:GetPart()
&#9;if rocketPart and bottlePart then
&#9;&#9;if not firstOpenIndex then
&#9;&#9;&#9;firstOpenIndex = self:FirstOpenRocketIndex()
&#9;&#9;end
&#9;&#9;if not firstOpenIndex then
&#9;&#9;&#9;dPrint(&quot;Bottle:WeldToBottle: No More space for rockets.&quot;)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;local bottleWeld = Instance.new(&apos;ManualWeld&apos;)
&#9;&#9;bottleWeld.Part0 = bottlePart
&#9;&#9;bottleWeld.Part1 = rocketPart
&#9;&#9;--bottleWeld.C0 = CFrame.Angles(math.pi/2,0,0) * CFrame.Angles(0, 0, (2 * math.pi) * (firstOpenIndex / NUMBER_OF_ROCKETS)):inverse() * CFrame.Angles(0, math.pi / 18, 0) + Vector3.new(0,0.7,0)
bottleWeld.C0 = CFrame.Angles(math.pi/2, 0,0) * CFrame.Angles(0, math.pi / 20, (2 * math.pi) * (firstOpenIndex / NUMBER_OF_ROCKETS)):inverse() + Vector3.new(0,0.87,0)
&#9;&#9;bottleWeld.C1 = CFrame.new()
&#9;&#9;bottleWeld.Parent = rocketPart
&#9;&#9;otherRocket.weld = bottleWeld
&#9;else
&#9;&#9;dPrint(&quot;Bottle:WeldToBottle called but either the bottle or the rocket&apos;s parts have not been instantiated yet.&quot;)
&#9;end
end

function Bottle:Reload()
&#9;if self.inReload then return end
&#9;self.inReload = true
&#9;wait(3.2)
&#9;PlayAnimation(&apos;StartReload&apos;, 1)
&#9;PlayAnimation(&apos;ReloadLoop&apos;, 1/3)
&#9;while Tool and Tool:IsDescendantOf(Workspace) do
&#9;&#9;local firstOpenIndex = self:FirstOpenRocketIndex()
&#9;&#9;if not firstOpenIndex then break end
&#9;&#9;local now = tick()
&#9;&#9;local waitTime = math.max(0, math.max(2.3 - math.min(2.3, now - self.lastFiredTime),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  RELOAD_TIME_PER_ROCKET))  -- math.min(RELOAD_TIME_PER_ROCKET, now - self.lastRocketAddedTick)))
&#9;&#9;print(waitTime)
&#9;&#9;wait(waitTime)
&#9;&#9;PlaySound(&apos;reload&apos;)
&#9;&#9;local tempRocket = self:AddRocket(firstOpenIndex)
&#9;&#9;self.rockets[firstOpenIndex] = tempRocket
&#9;&#9;self.lastRocketAddedTick = now
&#9;&#9;StopAnimation(&apos;StartReload&apos;)
&#9;end
&#9;StopAnimation(&apos;StartReload&apos;)
&#9;StopAnimation(&apos;ReloadLoop&apos;)
&#9;PlayAnimation(&apos;EndReload&apos;)
&#9;self.inReload = false
end

function Bottle:AddRocket(index)
&#9;local newRocket = Rocket:Create()
&#9;newRocket:MakeRocket()
&#9;self:WeldToBottle(newRocket, index)
&#9;newRocket:GetPart().Parent = self:GetPart()
&#9;return newRocket
end

Rocket = {}
Rocket_mt = { __index = Rocket}

function Rocket:Create(rocketPart)
&#9;local newRocket = setmetatable({}, Rocket_mt)
&#9;if rocketPart then
&#9;&#9;newRocket.part = rocketPart
&#9;&#9;local weld = rocketPart:FindFirstChild(&apos;ManualWeld&apos;)
&#9;&#9;if weld then
&#9;&#9;&#9;newRocket.weld = weld
&#9;&#9;end
&#9;end
&#9;return newRocket
end

function Rocket:GetPart()
&#9;return self.part
end

function Rocket:MakeRocket()
&#9;local rocketPart = Instance.new(&apos;Part&apos;)
&#9;rocketPart.TopSurface = &apos;Smooth&apos;
&#9;rocketPart.BottomSurface = &apos;Smooth&apos;
&#9;rocketPart.FormFactor = &apos;Custom&apos;
&#9;rocketPart.Size = Vector3.new(0.2, 0.2, 3.4)
&#9;rocketPart.Locked = true
&#9;rocketPart.CanCollide = false
&#9;rocketPart.Name = PROJECTILE_NAME
&#9;local rocketMesh = Instance.new(&apos;SpecialMesh&apos;)
&#9;rocketMesh.MeshId = ROCKET_MESH_URL
&#9;rocketMesh.TextureId = TEXTURE_URL
&#9;rocketMesh.Parent = rocketPart
&#9;self.part = rocketPart
&#9;return rocketPart
end

function Rocket:CreateCreatorTag()
&#9;local myPlayer = PlayersService:GetPlayerFromCharacter(Tool.Parent)
&#9;if myPlayer then
&#9;&#9;-- Attach creator tags
&#9;&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, rocket)
&#9;&#9;creatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
&#9;&#9;creatorTag.Value = myPlayer
&#9;&#9;local iconTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;&#9;iconTag.Name = &apos;weaponIcon&apos;
&#9;&#9;iconTag.Value = Tool.TextureId
&#9;&#9;local nameTag = Instance.new(&apos;StringValue&apos;, creatorTag)
&#9;&#9;nameTag.Name = &apos;weaponName&apos;
&#9;&#9;nameTag.Value = Tool.Name
&#9;&#9;return creatorTag
&#9;end
end

function Rocket:LaunchTargeted(targetPosition)
&#9;local rocketPart = self:GetPart()
&#9;local humanoid = GetHumanoid()
&#9;if rocketPart and humanoid then
&#9;&#9;PlaySound(&apos;launch&apos;)
&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Size = 3
&#9;&#9;fire.Heat = 5
&#9;&#9;fire.Name = &apos;RocketTrail&apos; 
&#9;&#9;fire.Parent = rocketPart

&#9;&#9;targetPosition = targetPosition or humanoid.TargetPoint
&#9;&#9;dPrint(&quot;TargetPos:&quot;, targetPosition)
&#9;&#9;--[[
&#9;&#9;local targetPart = Instance.new(&apos;Part&apos;)
&#9;&#9;targetPart.Transparency = 1
&#9;&#9;targetPart.CanCollide = false
&#9;&#9;targetPart.Anchored = true
&#9;&#9;targetPart.FormFactor = &apos;Custom&apos;
&#9;&#9;targetPart.Size = Vector3.new()
&#9;&#9;targetPart.CFrame = CFrame.new(targetPosition)
&#9;&#9;targetPart.Parent = Workspace
&#9;&#9;DebrisService:AddItem(targetPart, ROCKET_DEBRIS_TIME + 1)
&#9;&#9;--]]
&#9;&#9;rocketPart.Parent = Workspace
&#9;&#9;if self.weld then
&#9;&#9;&#9;self.weld:Destroy()
&#9;&#9;&#9;self.weld = nil
&#9;&#9;end

&#9;&#9;rocketPart.Velocity = Vector3.new(0,1,0) * ROCKET_LAUNCH_SPEED * 1.8

&#9;&#9;local rocketPropulsion = Instance.new(&apos;RocketPropulsion&apos;)
&#9;&#9;--rocketPropulsion.Target = targetPart
&#9;&#9;rocketPropulsion.TargetOffset = rocketPart.CFrame.p + (targetPosition - rocketPart.CFrame.p) -- .unit * 1000000000
&#9;&#9;rocketPropulsion.CartoonFactor = 0.1
&#9;&#9;rocketPropulsion.TurnP = 23000
&#9;&#9;rocketPropulsion.MaxTorque = Vector3.new(1000000000, 100000000, 100000000)
&#9;&#9;rocketPropulsion.MaxSpeed = ROCKET_LAUNCH_SPEED
&#9;&#9;rocketPropulsion.Parent = rocketPart

&#9;&#9;DebrisService:AddItem(rocketPart, ROCKET_DEBRIS_TIME)

&#9;&#9;local rocketScriptClone = RocketMineScript:Clone()
&#9;&#9;rocketScriptClone.Parent = rocketPart
&#9;&#9;rocketScriptClone.Disabled = false


&#9;&#9;local tag = self:CreateCreatorTag()
&#9;&#9;if tag then
&#9;&#9;&#9;tag.Parent = rocketPart
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Was unable to make creator tag in MakeRocket&quot;)
&#9;&#9;end
&#9;&#9;if Sounds[&apos;explode&apos;] then
&#9;&#9;&#9;Sounds[&apos;explode&apos;]:Clone().Parent = rocketPart
&#9;&#9;end

&#9;&#9;wait(0.3)
&#9;&#9;rocketPropulsion.TargetOffset = rocketPart.CFrame.p + (targetPosition - rocketPart.CFrame.p).unit * 1000000000
&#9;&#9;rocketPropulsion:Fire()
&#9;end
end

function Rocket:Launch(launchTime, direction)
&#9;local rocketPart = self:GetPart()
&#9;if rocketPart then
&#9;&#9;DebrisService:AddItem(rocketPart, ROCKET_DEBRIS_TIME)
&#9;&#9;rocketPart.Parent = Workspace
&#9;&#9;local fire = Instance.new(&apos;Fire&apos;)
&#9;&#9;fire.Size = 3
&#9;&#9;fire.Heat = 5
&#9;&#9;fire.Name = &apos;RocketTrail&apos; 
&#9;&#9;fire.Parent = rocketPart
&#9;&#9;--[[
&#9;&#9;local smoke = Instance.new(&apos;Smoke&apos;)
&#9;&#9;smoke.Size = 0.1
&#9;&#9;smoke.Opacity = 0.3
&#9;&#9;smoke.RiseVelocity = 0
&#9;&#9;smoke.Parent = rocketPart
&#9;&#9;local sparkles = Instance.new(&apos;Sparkles&apos;)
&#9;&#9;sparkles.SparkleColor = Color3.new(222,33,15)
&#9;&#9;]]
&#9;&#9;wait(launchTime)
&#9;&#9;if self.weld then
&#9;&#9;&#9;self.weld:Destroy()
&#9;&#9;&#9;self.weld = nil
&#9;&#9;end

&#9;&#9;--rocketPart.Velocity = rocketPart.CFrame:vectorToWorldSpace(Vector3.new(0, ROCKET_LAUNCH_SPEED, 0))
&#9;&#9;local originalCFrame = rocketPart.CFrame
&#9;&#9;rocketPart.Size = Vector3.new(5, rocketPart.Size.Y, rocketPart.Size.Z)
&#9;&#9;local floatForce = Instance.new(&apos;BodyForce&apos;)
&#9;&#9;floatForce.force = Vector3.new(0, rocketPart:GetMass() * 196.2 / 1.13, 0)
&#9;&#9;floatForce.Parent = rocketPart
&#9;&#9;rocketPart.Velocity = direction.unit * ROCKET_LAUNCH_SPEED
&#9;&#9;rocketPart.RotVelocity = Vector3.new()
&#9;&#9;rocketPart.CFrame = CFrame.new(originalCFrame.p, originalCFrame.p + direction.unit) * CFrame.Angles(-math.pi / 2 , 0, 0)
&#9;&#9;dPrint(&quot;Shooting at:&quot; , direction.unit)
&#9;&#9;--[[
&#9;&#9;local myTorso = GetTorso()
&#9;&#9;if myTorso then
&#9;&#9;&#9;rocketPart.Velocity = myTorso.CFrame.lookVector * ROCKET_LAUNCH_SPEED
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Rocket Launch, no torso found.&quot;)
&#9;&#9;&#9;rocketPart.Velocity = Vector3.new(0,0, ROCKET_LAUNCH_SPEED)
&#9;&#9;end
]]
&#9;&#9;
&#9;&#9;local tag = self:CreateCreatorTag()
&#9;&#9;if tag then
&#9;&#9;&#9;tag.Parent = rocketPart
&#9;&#9;else
&#9;&#9;&#9;dPrint(&quot;Was unable to make creator tag in MakeRocket&quot;)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local rocketScriptClone = RocketMineScript:Clone()
&#9;&#9;rocketScriptClone.Parent = rocketPart
&#9;&#9;rocketScriptClone.Disabled = false
&#9;end
end

function PlaySound(soundName, volume)
&#9;local sound = Sounds[soundName]
&#9;if sound then
&#9;&#9;if volume then
&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;end
&#9;&#9;sound:Play()
&#9;end
end


function PlayAnimation(animName, animSpeed)
&#9;local animTrack = AnimationTracks[animName]
&#9;if animTrack then
&#9;&#9;animTrack:Play()
&#9;end
&#9;if animSpeed then
&#9;&#9;animTrack:AdjustSpeed(animSpeed)
&#9;end
end

function StopAnimation(animName)
&#9;local animTrack = AnimationTracks[animName]
&#9;if animTrack then
&#9;&#9;animTrack:Stop()
&#9;end
end

function LoadAnimationTracks()
&#9;local myHumanoid = GetHumanoid()
&#9;if myHumanoid then
&#9;&#9;for animName, animObject in pairs(Animations) do
&#9;&#9;&#9;AnimationTracks[animName] = myHumanoid:LoadAnimation(animObject)
&#9;&#9;end
&#9;end
end

function StopAllAnimations()
&#9;for animName, animTrack in pairs(AnimationTracks) do
&#9;&#9;StopAnimation(animName)
&#9;end
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {Tool.Parent})
&#9;&#9;&#9;&#9;&#9;BottleInstance:OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

BottleInstance = Bottle:Create()

dPrint(BottleInstance.rockets)

Tool.Equipped:connect(function() LoadAnimationTracks() BottleInstance:OnEquipped() end)
Tool.Unequipped:connect(function() BottleInstance:OnUnequipped() StopAllAnimations() end)
Tool.Activated:connect(
&#9;function()
&#9;&#9;wait() -- iPad derp, doesn&apos;t update targetpoint
&#9;&#9;BottleInstance:OnActivated()
&#9;end)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX443">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RocketMineScript</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 4.3
local BLAST_PRESSURE = 0
local MAX_DMG = 42

-- Rocket will fly through things named these
local ROCKET_IGNORE_LIST = {rocket = 1, handle = 1, effect = 1, water = 1} --NOTE: Keys must be lowercase, values must evaluate to true

ROCKET_IGNORE_LIST[string.lower(script.Parent.Name)] = 1


--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Rocket = script.Parent
local CreatorTag = WaitForChild(Rocket, &apos;creator&apos;)

local HitHumanoids = {}
local ExplosionOrigin
local Connection = nil


local CreatorPlayer = CreatorTag.Value
if CreatorPlayer.Character and CreatorPlayer.Character:FindFirstChild(&apos;Humanoid&apos;) then
&#9;HitHumanoids[CreatorPlayer.Character:FindFirstChild(&apos;Humanoid&apos;)] = true
end

-----------------
--| Functions |--
-----------------

--  Adjusted from overpressure formula
local function DamageFalloffEquation(distance, startDamage)
&#9;local distance = math.max(1, distance)
&#9;local explosionNetWeight = 1.1
&#9;local volumeOfHemisphere = math.max(1, math.log(distance))
&#9;return startDamage * (explosionNetWeight / volumeOfHemisphere)
end

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

function TagHumanoid(humanoid, creatorTag)
&#9;-- Add more tags here to customize what tags are available.
&#9;while humanoid:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;humanoid:FindFirstChild(&apos;creator&apos;):Destroy()
&#9;end
&#9;creatorTag.Parent = humanoid 
end

local function OnExplosionHit(hitPart)
&#9;if hitPart then
&#9;&#9;local _, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;if not HitHumanoids[humanoid] and ExplosionOrigin then
&#9;&#9;&#9;&#9;local dmg = DamageFalloffEquation((hitPart.CFrame.p - ExplosionOrigin).magnitude , MAX_DMG)
&#9;&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;&#9;hitBindable:Invoke(dmg, CreatorTag)
&#9;&#9;&#9;&#9;else --Not in Roblox Battle
&#9;&#9;&#9;&#9;&#9;TagHumanoid(humanoid, CreatorTag:Clone())
&#9;&#9;&#9;&#9;&#9;humanoid:TakeDamage(dmg)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;HitHumanoids[humanoid] = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end


local Exploded = false

local function Explode()
&#9;if Exploded then return end
&#9;Exploded = true
&#9;-- Create the explosion
&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastPressure = BLAST_PRESSURE
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.Position = Rocket.Position
&#9;explosion.Hit:connect(OnExplosionHit)
&#9;explosion.Parent = Workspace
&#9;ExplosionOrigin = Rocket.CFrame.p
&#9;-- Start playing the boom sound
&#9;local boomSound = Rocket:FindFirstChild(&apos;explodeSound&apos;)
&#9;if boomSound then
&#9;&#9;boomSound:Play()
&#9;end

&#9;-- NOTE:
&#9;-- If we just destroyed the rocket at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the rocket, keep it in the same spot, and schedule it for deletion

&#9;-- Stop playing the swoosh sound
&#9;local swooshSound = Rocket:FindFirstChild(&apos;Swoosh&apos;)
&#9;if swooshSound then
&#9;&#9;swooshSound:Stop()
&#9;end

&#9;-- Put out the fire
&#9;local fire = Rocket:FindFirstChild(&apos;RocketTrail&apos;)
&#9;if fire then
&#9;&#9;fire:Destroy()
&#9;end

&#9;local smoke = Rocket:FindFirstChild(&apos;Smoke&apos;)
&#9;if smoke then
&#9;&#9;smoke.Size = 5
&#9;&#9;smoke.RiseVelocity = 1.3
&#9;end


&#9;Rocket.Transparency = 1
&#9;Rocket.CanCollide = false
&#9;Rocket.Anchored = true
&#9;Rocket.CFrame = CFrame.new(Rocket.CFrame.p)
&#9;DebrisService:AddItem(Rocket, 3)

end

local function OnTouched(otherPart)
&#9;if Rocket and otherPart then
&#9;&#9;-- Fly through anything in the ignore list
&#9;&#9;if ROCKET_IGNORE_LIST[string.lower(otherPart.Name)] then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- Don&apos;t react to creator
&#9;&#9;local myPlayer = CreatorTag.Value
&#9;&#9;if myPlayer and myPlayer.Character and myPlayer.Character:IsAncestorOf(otherPart) then
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local character = FindCharacterAncestor(otherPart)
&#9;&#9;Explode()
&#9;&#9;-- Destroy the connection so this method won&apos;t be called again
&#9;&#9;Connection:disconnect()
&#9;&#9;Rocket.Anchored = true
--[[
&#9;&#9;if character then
&#9;&#9;&#9;print(&quot;Triggering on &quot; , otherPart.Name)
&#9;&#9;&#9;Explode()
&#9;&#9;&#9;-- Destroy the connection so this method won&apos;t be called again
&#9;&#9;&#9;Connection:disconnect()
&#9;&#9;else
&#9;&#9;&#9;print(&quot;No Character, otherPart:&quot; , otherPart , &quot;character:&quot; , character)
&#9;&#9;&#9;Rocket.CFrame = CFrame.new(Rocket.CFrame.p)
&#9;&#9;&#9;Rocket.Anchored = true
&#9;&#9;end
&#9;&#9;]]
&#9;end
end

--------------------
--| Script Logic |--
--------------------

-- Arm the rocket and save the touch connection so we can disconnect it later
Connection = Rocket.Touched:connect(OnTouched)

wait(3)

Explode()

</ProtectedString>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX444">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX445">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100998342</url></Content>
							<string name="Name">FireAnim</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX446">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100998595</url></Content>
							<string name="Name">StopFire</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX447">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=100999683</url></Content>
							<string name="Name">StartReload</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX448">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101004654</url></Content>
							<string name="Name">ReloadLoop</string>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX449">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101001475</url></Content>
							<string name="Name">EndReload</string>
						</Properties>
					</Item>
					<Item class="Camera" referent="RBX450">
						<Properties>
							<Ref name="CameraSubject">null</Ref>
							<token name="CameraType">0</token>
							<CoordinateFrame name="CoordinateFrame">
								<X>140.009918</X>
								<Y>5.44335079</Y>
								<Z>106.780846</Z>
								<R00>0.927172601</R00>
								<R01>-0.0274642911</R01>
								<R02>0.373626322</R02>
								<R10>1.86264515e-009</R10>
								<R11>0.997309208</R11>
								<R12>0.073309578</R12>
								<R20>-0.374634385</R20>
								<R21>-0.0679706335</R21>
								<R22>0.924677789</R22>
							</CoordinateFrame>
							<float name="FieldOfView">70</float>
							<CoordinateFrame name="Focus">
								<X>139.262665</X>
								<Y>5.29673147</Y>
								<Z>104.931488</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">ThumbnailCamera</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX451">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Broom</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX452">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>-1</R22>
						</CoordinateFrame>
						<string name="Name">Broom</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99865835</url></Content>
						<string name="ToolTip">Clean Sweep</string>
					</Properties>
					<Item class="Part" referent="RBX453">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-410.100006</X>
								<Y>-16</Y>
								<Z>31.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>3.42285489e-008</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-3.42285489e-008</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.600000024</X>
								<Y>6.00000095</Y>
								<Z>0.600000024</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX454">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99865889</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99865923</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX455">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Swing</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101164100</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX456">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">Whack</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101166084</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="Script" referent="RBX457">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ToolScript</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local DAMAGE = 18

local COOLDOWN = 0.1

local WALKSPEED_BUFF = 8

local BLOWBACK_VELOCITY = 75

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local SwingSound = WaitForChild(ToolHandle, &apos;Swing&apos;)
local WhackSound = WaitForChild(ToolHandle, &apos;Whack&apos;)

local MyModel = nil
local MyHumanoid = nil

local HitPart = nil
local HitPartWeld = nil
local HitTable = {} -- List of victims damaged (per hit)

local CreatorTag = nil

-----------------
--| Functions |--
-----------------

-- Returns a character ancestor and its Humanoid, or nil
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function OnHit(otherPart)
&#9;if HitPart and otherPart then
&#9;&#9;local character, humanoid = FindCharacterAncestor(otherPart.Parent)
&#9;&#9;if character and character ~= MyModel and not HitTable[character] then
&#9;&#9;&#9;-- Tag and damage the victim
&#9;&#9;&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;&#9;&#9;if hitBindable then
&#9;&#9;&#9;&#9;hitBindable:Invoke(DAMAGE, CreatorTag)
&#9;&#9;&#9;&#9;HitTable[character] = 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;ERROR: Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;WhackSound:Play()

&#9;&#9;&#9;-- Whack em
&#9;&#9;&#9;local torso = humanoid.Torso
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;local bodyVelocity = Instance.new(&apos;BodyVelocity&apos;)
&#9;&#9;&#9;&#9;bodyVelocity.maxForce = Vector3.new(50000, 50000, 50000)
&#9;&#9;&#9;&#9;bodyVelocity.P = 25000
&#9;&#9;&#9;&#9;bodyVelocity.velocity = (MyHumanoid.Torso.CFrame.lookVector + Vector3.new(0, 0.5, 0)).unit * BLOWBACK_VELOCITY
&#9;&#9;&#9;&#9;DebrisService:AddItem(bodyVelocity, 0.2)
&#9;&#9;&#9;&#9;bodyVelocity.Parent = torso
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function MakeHitPart()
&#9;local hitPart = Instance.new(&apos;Part&apos;)
&#9;hitPart.Name = &apos;Effect&apos;
&#9;hitPart.CanCollide = false
&#9;hitPart.Transparency = 1
&#9;hitPart.FormFactor = Enum.FormFactor.Custom
&#9;hitPart.Size = Vector3.new(1, ToolHandle.Size.Y, 1)
&#9;hitPart.TopSurface = Enum.SurfaceType.Smooth
&#9;hitPart.BottomSurface = Enum.SurfaceType.Smooth
&#9;hitPart.Touched:connect(OnHit)

&#9;local hitPartWeld = Instance.new(&apos;Weld&apos;)
&#9;hitPartWeld.Part0 = ToolHandle
&#9;hitPartWeld.Part1 = hitPart
&#9;hitPartWeld.C1 = CFrame.new(Vector3.new(0, (ToolHandle.Size.Y / 2) - (hitPart.Size.Y / 2), 0))

&#9;return hitPart, hitPartWeld
end

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyModel)

&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed + WALKSPEED_BUFF
end

local function OnActivated()
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Torso and MyHumanoid.Health &gt; 0 then
&#9;&#9;Tool.Enabled = false

&#9;&#9;SwingSound.Pitch = 1.2 + (math.random() * 0.2)
&#9;&#9;SwingSound:Play()

&#9;&#9;HitPartWeld.Parent = ToolHandle
&#9;&#9;HitPart.Parent = ToolHandle

&#9;&#9;wait(1.5 / 10) -- Wait for animation to finish

&#9;&#9;HitPart.Parent = nil
&#9;&#9;HitPartWeld.Parent = nil
&#9;&#9;HitTable = {}

&#9;&#9;wait(COOLDOWN)

&#9;&#9;Tool.Enabled = true
&#9;end
end

local function OnUnequipped()
&#9;MyHumanoid.WalkSpeed = MyHumanoid.WalkSpeed - WALKSPEED_BUFF
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;if string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;OnActivated()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

HitPart, HitPartWeld = MakeHitPart()

CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos;
local weaponNameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponNameTag.Name = &apos;weaponName&apos;
weaponNameTag.Value = Tool.Name
local weaponIconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
weaponIconTag.Name = &apos;weaponIcon&apos;
weaponIconTag.Value = Tool.TextureId

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX458">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX459">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Animation</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local WHACK_SPEED = 10

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local Tool = script.Parent

local BroomHoldIdleAnimation = WaitForChild(script, &apos;BroomHoldIdle&apos;)
local WhackAnimation = WaitForChild(script, &apos;WitchTemp&apos;)

local BroomHoldIdleTrack = nil
local WhackTrack = nil

-----------------
--| Functions |--
-----------------

local function OnEquipped()
&#9;local myModel = Tool.Parent
&#9;local humanoid = myModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;if humanoid then -- Preload animations
&#9;&#9;BroomHoldIdleTrack = humanoid:LoadAnimation(BroomHoldIdleAnimation)
&#9;&#9;WhackTrack = humanoid:LoadAnimation(WhackAnimation)
&#9;end
&#9;if BroomHoldIdleTrack then BroomHoldIdleTrack:Play() end
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; and Tool.Enabled == false then
&#9;&#9;if WhackTrack then WhackTrack:Play(0, 1, WHACK_SPEED) end

&#9;&#9;-- End of Frame 0

&#9;&#9;Tool.Grip = Tool.Grip + Vector3.new(0, 1, 0) -- Stage 1

&#9;&#9;wait(0.5 / WHACK_SPEED) -- Wait until end of frame 1

&#9;&#9;Tool.Grip = Tool.Grip + Vector3.new(0, 1, 0) -- Stage 2

&#9;&#9;wait(1 / WHACK_SPEED) -- Wait for end of animation

&#9;&#9;wait(0.5 / WHACK_SPEED)

&#9;&#9;Tool.Grip = Tool.Grip - Vector3.new(0, 1, 0)

&#9;&#9;wait(0.5 / WHACK_SPEED)

&#9;&#9;Tool.Grip = Tool.Grip - Vector3.new(0, 1, 0)
&#9;end
end

local function OnUnequipped()
&#9;-- Stop animations
&#9;if BroomHoldIdleTrack then BroomHoldIdleTrack:Stop() end
&#9;if WhackTrack then WhackTrack:Stop() end
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
Tool.Unequipped:connect(OnUnequipped)
</ProtectedString>
						</Properties>
						<Item class="Animation" referent="RBX460">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101074752</url></Content>
								<string name="Name">BroomHoldIdle</string>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX461">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101078539</url></Content>
								<string name="Name">WitchTemp</string>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX462">
					<Properties>
						<string name="Name">ToolIconSilhouetteId</string>
						<int name="Value">113155822</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX463">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Taser</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Tool" referent="RBX464">
					<Properties>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0.400000006</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Taser</string>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99866630</url></Content>
						<string name="ToolTip">Shocker</string>
					</Properties>
					<Item class="Part" referent="RBX465">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-410.100006</X>
								<Y>-16</Y>
								<Z>31.9000015</Z>
								<R00>3.4228556e-008</R00>
								<R01>2.158511e-012</R01>
								<R02>-0.999999881</R02>
								<R10>-6.30617142e-005</R10>
								<R11>1.00000024</R11>
								<R12>0</R12>
								<R20>1.00000024</R20>
								<R21>6.30617142e-005</R21>
								<R22>3.42285453e-008</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.259999961</X>
								<Y>0.590000153</Y>
								<Z>1.40000045</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX466">
							<Properties>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>http://www.roblox.com/asset/?id=99866654</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=99866675</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX467">
							<Properties>
								<bool name="Looped">true</bool>
								<string name="Name">StunGunLoop</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101178423</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX468">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Taser</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 5 -- Seconds until tool can be used again

local WIRE_LENGTH = 30
local WIRE_SPEED = 20
local WIRE_THICKNESS = 0.1
local HIT_ZONE_HALF_SIZE = Vector3.new(0.5, 0.5, 0.5) / 2

local ONE_STEP = 1 / 30

local AIMING_CFRAME = CFrame.new(0.25, 0, 0.4, 0.8, 0, 0.6, 0, 1, 0, -0.6, 0, 0.8)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local StunScript = WaitForChild(script, &apos;Stun&apos;)
local ReadyAimAnimation = WaitForChild(script, &apos;ReadyAim2&apos;)

local StunGunLoopSound = WaitForChild(ToolHandle, &apos;StunGunLoop&apos;)

local OriginalToolGrip = Tool.Grip

local MyModel = nil
local MyHumanoid = nil
local CreatorTag = nil

local ReadyAimTrack = nil

local WireBases = {}

local Done = false

local BodyPosition = nil

-------------------------
--| Utility Functions |--
-------------------------

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= Workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end

local function WeldInPlace(part0, part1, name, parent)
&#9;local weld = Instance.new(&apos;Weld&apos;)
&#9;weld.Part0 = part0
&#9;weld.Part1 = part1
&#9;weld.C0 = CFrame.new()
&#9;weld.C1 = part1.CFrame:inverse() * part0.CFrame
&#9;weld.Name = name or &apos;Weld&apos;
&#9;weld.Parent = parent or part0
&#9;return weld
end

------------------------
--| Helper Functions |--
------------------------

local function MakeWireBase(parentPart, weldOffset)
&#9;local wireBase = Instance.new(&apos;Part&apos;)
&#9;wireBase.Name = &quot;WireBase&quot;
&#9;wireBase.CanCollide = false
&#9;wireBase.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
&#9;wireBase.Size = Vector3.new(0.2, 0.2, 0.2) -- Intentional
&#9;wireBase.BottomSurface = Enum.SurfaceType.Smooth
&#9;wireBase.TopSurface = Enum.SurfaceType.Smooth

&#9;local weld = Instance.new(&apos;Weld&apos;, wireBase)
&#9;weld.Part0 = parentPart
&#9;weld.Part1 = wireBase
&#9;weld.C0 = CFrame.new(weldOffset)

&#9;local wire = Instance.new(&apos;BlockMesh&apos;, wireBase)
&#9;wire.Name = &apos;Wire&apos;
&#9;wire.Scale = Vector3.new(WIRE_THICKNESS, WIRE_THICKNESS, 0)

&#9;wireBase.Parent = parentPart
&#9;return wireBase
end

local function UnStick()
&#9;--print(&quot;UnStick&quot;)
&#9;if MyModel and MyHumanoid then
&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;if torso then
&#9;&#9;&#9;MyHumanoid.WalkSpeed = 16
&#9;&#9;&#9;if BodyPosition then
&#9;&#9;&#9;&#9;BodyPosition:Destroy()
&#9;&#9;&#9;&#9;BodyPosition = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function ShotComplete(playExtras)
&#9;--print(&quot;ShotComplete, playExtras:&quot;, playExtras)

&#9;if ReadyAimTrack then ReadyAimTrack:Stop() end
&#9;wait(0.1)
&#9;Tool.Grip = OriginalToolGrip
&#9;wait(0.1)
&#9;UnStick()

&#9;if playExtras then
&#9;&#9;--TODO: play reload animation
&#9;&#9;--TODO: play reload sound
&#9;end

&#9;wait(COOLDOWN)

&#9;Tool.Enabled = true
end

local function Stopped(hitPart)
&#9;--print(&quot;Stopped:&quot;, hitPart)
&#9;if Done then return end
&#9;Done = true

&#9;StunGunLoopSound:Stop()

&#9;if hitPart then
&#9;&#9;--TODO: play hit sound
&#9;&#9;--TODO: wires flash
&#9;&#9;local character, humanoid = FindCharacterAncestor(hitPart.Parent)
&#9;&#9;if character ~= MyModel and humanoid and humanoid.Health &gt; 0 then
&#9;&#9;&#9;local stunScriptClone = StunScript:Clone()
&#9;&#9;&#9;stunScriptClone.Parent = humanoid
&#9;&#9;&#9;stunScriptClone.Disabled = false
&#9;&#9;end
&#9;else
&#9;&#9;--TODO: play out of wire sound
&#9;&#9;--TODO: wires disappear
&#9;end

&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;local wire = wireBase:FindFirstChild(&apos;Wire&apos;)
&#9;&#9;if wire then
&#9;&#9;&#9;wire.Scale = Vector3.new(WIRE_THICKNESS, WIRE_THICKNESS, 0)
&#9;&#9;&#9;wire.Offset = Vector3.new()
&#9;&#9;end
&#9;end

&#9;ShotComplete(true)
end

local function FireWire(wireBase, targetPoint)
&#9;--print(&quot;FireWire:&quot;, wireBase, targetPoint)
&#9;if not wireBase or not targetPoint then return end
&#9;local weld = wireBase:FindFirstChild(&apos;Weld&apos;)
&#9;if weld then
&#9;&#9;--weld.C1 = CFrame.new(Vector3.new(), targetPoint - wireBase.Position)
&#9;&#9;wireBase.Anchored = true
&#9;&#9;weld:Destroy()
&#9;&#9;wireBase.CFrame = CFrame.new(wireBase.Position, targetPoint)

&#9;&#9;wait(0) -- Wtf
&#9;&#9;WeldInPlace(ToolHandle, wireBase, _, wireBase)
&#9;&#9;wireBase.Anchored = false
&#9;end
&#9;local wire = wireBase:FindFirstChild(&apos;Wire&apos;)
&#9;Done = false
&#9;Spawn(function()
&#9;&#9;while wireBase and wire and (wire.Scale.Z * wireBase.Size.Z) &lt; WIRE_LENGTH and not Done do
&#9;&#9;&#9;-- Check the end of the wire for a hit
&#9;&#9;&#9;local wireEndPoint = wireBase.CFrame * Vector3.new(0, 0, wire.Offset.Z * 2)
&#9;&#9;&#9;local ray = Ray.new(wireBase.Position, (wireEndPoint - wireBase.Position))
&#9;&#9;&#9;local part = Workspace:FindPartOnRay(ray, MyModel)
&#9;&#9;&#9;if part then
&#9;&#9;&#9;&#9;return Stopped(part)
&#9;&#9;&#9;else -- No hit, not out of wire, just keep going
&#9;&#9;&#9;&#9;local increment = Vector3.new(0, 0, WIRE_SPEED) -- How many 0.2 lengths each time
&#9;&#9;&#9;&#9;wire.Offset = wire.Offset - (increment * (wireBase.Size.Z / 2))
&#9;&#9;&#9;&#9;wire.Scale = wire.Scale + increment
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(ONE_STEP)
&#9;&#9;end
&#9;&#9;Stopped() -- Out of wire
&#9;end)
end

----------------------
--| Tool Functions |--
----------------------

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;CreatorTag.Value = PlayersService:GetPlayerFromCharacter(MyModel)

&#9;-- Make top and bottom wire bases
&#9;local front = -ToolHandle.Size.Z / 2
&#9;table.insert(WireBases, MakeWireBase(ToolHandle, Vector3.new(0, -0.17, front)))
&#9;table.insert(WireBases, MakeWireBase(ToolHandle, Vector3.new(0, 0.17, front)))

&#9;if MyHumanoid then
&#9;&#9;-- Preload animations
&#9;&#9;ReadyAimTrack = MyHumanoid:LoadAnimation(ReadyAimAnimation)
&#9;end
end

local function OnActivated(targetOverride)
&#9;if Tool.Enabled and MyModel and MyHumanoid and MyHumanoid.Health &gt; 0 then
&#9;&#9;local torso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;if torso then
&#9;&#9;&#9;Tool.Enabled = false

&#9;&#9;&#9;-- Pick a target
&#9;&#9;&#9;local targetPosition = targetOverride or MyHumanoid.TargetPoint

&#9;&#9;&#9;-- Freeze our character
&#9;&#9;&#9;MyHumanoid.WalkSpeed = 0
&#9;&#9;&#9;BodyPosition = Instance.new(&apos;BodyPosition&apos;)
&#9;&#9;&#9;BodyPosition.maxForce = Vector3.new(1e6, 1e6, 1e6)
&#9;&#9;&#9;BodyPosition.position = torso.Position
&#9;&#9;&#9;DebrisService:AddItem(BodyPosition, 10)
&#9;&#9;&#9;BodyPosition.Parent = torso

&#9;&#9;&#9;-- Face the target horizontally
&#9;&#9;&#9;torso.CFrame = CFrame.new(torso.Position, Vector3.new(targetPosition.X, torso.Position.Y, targetPosition.Z))

&#9;&#9;&#9;-- Ready, aim...
&#9;&#9;&#9;if ReadyAimTrack then
&#9;&#9;&#9;&#9;ReadyAimTrack:Play()
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;Tool.Grip = AIMING_CFRAME
&#9;&#9;&#9;wait(0.1)

&#9;&#9;&#9;-- Fire!
&#9;&#9;&#9;StunGunLoopSound:Play()
&#9;&#9;&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;&#9;&#9;FireWire(wireBase, targetPosition)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnUnequipped()
&#9;for _, wireBase in pairs(WireBases) do
&#9;&#9;wireBase:Destroy()
&#9;end
&#9;WireBases = {}

&#9;-- Stop animations
&#9;if ReadyAimTrack then ReadyAimTrack:Stop() end

&#9;ShotComplete(false)
end

-- Also activate when the Action Button is pressed
local function OnChildAdded(child)
&#9;if child.Name == &apos;ActionButtonData&apos; then
&#9;&#9;child.Changed:connect(function(newValue)
&#9;&#9;&#9;local bindable = child:FindFirstChild(&apos;GetTargetPosition&apos;)
&#9;&#9;&#9;if bindable and string.sub(newValue, 1, 1) == &apos;v&apos; then
&#9;&#9;&#9;&#9;local matches = {}
&#9;&#9;&#9;&#9;for match in string.gmatch(newValue, &apos;%d+%.?%d*&apos;) do
&#9;&#9;&#9;&#9;&#9;table.insert(matches, match)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if #matches == 4 then
&#9;&#9;&#9;&#9;&#9;local screenPosition = Vector2.new(matches[1], matches[2])
&#9;&#9;&#9;&#9;&#9;local screenSize = Vector2.new(matches[3], matches[4])
&#9;&#9;&#9;&#9;&#9;local targetPosition = bindable:Invoke(screenPosition, screenSize, {MyModel})
&#9;&#9;&#9;&#9;&#9;OnActivated(targetPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------

CreatorTag = Instance.new(&apos;ObjectValue&apos;)
CreatorTag.Name = &apos;creator&apos; --NOTE: Must be called &apos;creator&apos; for website stats
local nameTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
nameTag.Name = &apos;weaponName&apos;
nameTag.Value = Tool.Name
local iconTag = Instance.new(&apos;StringValue&apos;, CreatorTag)
iconTag.Name = &apos;weaponIcon&apos;
iconTag.Value = Tool.TextureId
CreatorTag.Parent = StunScript

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

-- Listen for Action Button Data Object
for _, child in pairs(Tool:GetChildren()) do
&#9;OnChildAdded(child)
end
Tool.ChildAdded:connect(OnChildAdded)
</ProtectedString>
						</Properties>
						<Item class="Script" referent="RBX469">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Stun</string>
								<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local STUN_TIME = 3 -- Seconds

local DAMAGE = 3
local DAMAGE_FREQUENCY = 0.4 -- Seconds

local ONE_STEP = 1 / 30

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Humanoid = script.Parent
local OriginalWalkSpeed = Humanoid.WalkSpeed
local HitBindable = Humanoid:FindFirstChild(&apos;Hit&apos;)

local ZapSound = WaitForChild(script, &apos;Zap&apos;)

local CreatorTag = WaitForChild(script, &apos;creator&apos;)

local StartTime = tick()
local LastDamageTime = StartTime

-----------------
--| Functions |--
-----------------

local function ApplyTag(target)
&#9;while target:FindFirstChild(&apos;creator&apos;) do
&#9;&#9;target.creator:Destroy()
&#9;end

&#9;local creatorTagClone = CreatorTag:Clone()
&#9;DebrisService:AddItem(creatorTagClone, 4)
&#9;creatorTagClone.Parent = target
end

--------------------
--| Script Logic |--
--------------------

ZapSound.Parent = Humanoid.Torso

repeat
&#9;local now = tick()

&#9;Humanoid.WalkSpeed = 0

&#9;if now - LastDamageTime &gt; DAMAGE_FREQUENCY then
&#9;&#9;if ZapSound.Parent ~= script then
&#9;&#9;&#9;ZapSound:Play()
&#9;&#9;end
&#9;&#9;if HitBindable then -- (Battle-specific)
&#9;&#9;&#9;HitBindable:Invoke(DAMAGE, CreatorTag)
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Could not find BindableFunction &apos;Hit&apos;&quot;)
&#9;&#9;&#9;ApplyTag(Humanoid)
&#9;&#9;&#9;Humanoid:TakeDamage(DAMAGE)
&#9;&#9;end
&#9;&#9;LastDamageTime = now
&#9;end

&#9;wait(ONE_STEP)
until now - StartTime &gt;= STUN_TIME

Humanoid.WalkSpeed = OriginalWalkSpeed

ZapSound:Destroy()
script:Destroy()
</ProtectedString>
							</Properties>
							<Item class="Sound" referent="RBX470">
								<Properties>
									<bool name="Looped">false</bool>
									<string name="Name">Zap</string>
									<float name="Pitch">1</float>
									<bool name="PlayOnRemove">false</bool>
									<Content name="SoundId"><url>http://www.roblox.com/asset/?id=101180005</url></Content>
									<float name="Volume">0.5</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Animation" referent="RBX471">
							<Properties>
								<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=101097290</url></Content>
								<string name="Name">ReadyAim2</string>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX472">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseIcon</string>
							<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
&#9;end
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX473">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">MapData</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX474">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">NewCrossroads</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX475">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">110083167</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX476">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">116669007</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX477">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">Classic, OneWeaponOnly, Party, Enchilada, TeamDeathmatch, Juggernaut</string>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX478">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX479">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4283124555</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX480">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4286479998</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX481">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">9</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX482">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX483">
						<Properties>
							<string name="Name">FogColor</string>
							<Color3 name="Value">4292147967</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX484">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">2000</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX485">
						<Properties>
							<string name="Name">ShadowColor</string>
							<Color3 name="Value">4294967295</Color3>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX486">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RavenRock</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX487">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">110083813</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX488">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">116669027</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX489">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">Classic, OneWeaponOnly, Party, Enchilada, TeamDeathmatch, Juggernaut</string>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX490">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX491">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4283124555</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX492">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4286479998</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX493">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">10</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX494">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX495">
						<Properties>
							<string name="Name">FogColor</string>
							<Color3 name="Value">4292147967</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX496">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">2000</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX497">
						<Properties>
							<string name="Name">ShadowColor</string>
							<Color3 name="Value">4294967295</Color3>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX498">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Bloxburg</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX499">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">110084199</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX500">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">116668979</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX501">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">Classic, OneWeaponOnly, Party, Enchilada, TeamDeathmatch, Juggernaut</string>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX502">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX503">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4282795590</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX504">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4286479998</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX505">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">14</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX506">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX507">
						<Properties>
							<string name="Name">FogColor</string>
							<Color3 name="Value">4288651167</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX508">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">2000</double>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX509">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Lobby</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX510">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">116529077</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX511">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">110084199</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX512">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">Lobby</string>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX513">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX514">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4282071867</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX515">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4286479998</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX516">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">2</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX517">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX518">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">200000</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX519">
						<Properties>
							<string name="Name">ShadowColor</string>
							<Color3 name="Value">4294967295</Color3>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX520">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RocketRace</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="StringValue" referent="RBX521">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">RocketRace</string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX522">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">117326856</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX523">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">117255711</int>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX524">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX525">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4278190080</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX526">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4284769380</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX527">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">8</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX528">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX529">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">500</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX530">
						<Properties>
							<string name="Name">ShadowColor</string>
							<Color3 name="Value">4284769380</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX531">
						<Properties>
							<string name="Name">FogStart</string>
							<double name="Value">100</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX532">
						<Properties>
							<string name="Name">FogColor</string>
							<Color3 name="Value">4278190080</Color3>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX533">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">TheShard</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="StringValue" referent="RBX534">
					<Properties>
						<string name="Name">GameTypes</string>
						<string name="Value">Classic, TeamDeathmatch, Juggernaut</string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX535">
					<Properties>
						<string name="Name">ImageId</string>
						<int name="Value">117446222</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX536">
					<Properties>
						<string name="Name">ModelId</string>
						<int name="Value">117436862</int>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX537">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Lighting</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Color3Value" referent="RBX538">
						<Properties>
							<string name="Name">Ambient</string>
							<Color3 name="Value">4283124555</Color3>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX539">
						<Properties>
							<string name="Name">OutdoorAmbient</string>
							<Color3 name="Value">4286479998</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX540">
						<Properties>
							<string name="Name">TimeOfDay</string>
							<double name="Value">9</double>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX541">
						<Properties>
							<string name="Name">GlobalShadows</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX542">
						<Properties>
							<string name="Name">FogColor</string>
							<Color3 name="Value">4292147967</Color3>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX543">
						<Properties>
							<string name="Name">FogEnd</string>
							<double name="Value">2000</double>
						</Properties>
					</Item>
					<Item class="Color3Value" referent="RBX544">
						<Properties>
							<string name="Name">ShadowColor</string>
							<Color3 name="Value">4294967295</Color3>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX545">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">GameTypes</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX546">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Classic</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="StringValue" referent="RBX547">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value">Sword, Superball, Slingshot, Bomb, RocketLauncher, Reflector</string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX548">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">1</int>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX549">
					<Properties>
						<string name="Name">PaidWeaponsEnabled</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX550">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">116657387</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX551">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">OneWeaponOnly</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX552">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">0</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX553">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX554">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OneWeaponOnly</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local LOADOUT_OPTIONS = {
&#9;&apos;Sword&apos;,
&#9;&apos;Superball&apos;,
&#9;--&apos;Slingshot&apos;,
&#9;&apos;Bomb&apos;,
&#9;&apos;RocketLauncher&apos;
}

local TITLE_IMAGE_IDS = { --NOTE: Must correspond to weapons above
&#9;2,
&#9;3,
&#9;--4,
&#9;5,
&#9;6
}

-----------------
--| Variables |--
-----------------

local GameType = script.Parent
local LoadoutObject = GameType:WaitForChild(&apos;Loadout&apos;)
local TitleImageIdObject = GameType:WaitForChild(&apos;TitleImageId&apos;)

local DataReadyEvent = script:WaitForChild(&apos;WaitForDataReady&apos;)

--------------------
--| Script Logic |--
--------------------

local index = math.random(#LOADOUT_OPTIONS)
LoadoutObject.Value = LOADOUT_OPTIONS[index]
TitleImageIdObject.Value = TITLE_IMAGE_IDS[index]
DataReadyEvent:Fire()
</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX555">
						<Properties>
							<string name="Name">WaitForDataReady</string>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX556">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">116657414</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX557">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Party</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Script" referent="RBX558">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Party</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local LOADOUT_SIZE = 3 --NOTE: Must be &lt;= #options

local LOADOUT_OPTIONS = {
&#9;&apos;Sword&apos;,
&#9;&apos;Superball&apos;,
&#9;&apos;Slingshot&apos;,
&#9;&apos;Bomb&apos;,
&#9;&apos;RocketLauncher&apos;,
&#9;&apos;Reflector&apos;
}

local LOADOUT_DELIMETER = &apos;, &apos;

-----------------
--| Variables |--
-----------------

local GameType = script.Parent
local LoadoutObject = GameType:WaitForChild(&apos;Loadout&apos;)

local DataReadyEvent = script:WaitForChild(&apos;WaitForDataReady&apos;)

--------------------
--| Script Logic |--
--------------------

local loadoutString = &apos;&apos;
local selectedIndicies = {}
for i = 1, LOADOUT_SIZE do
&#9;local index = 0
&#9;repeat
&#9;&#9;index = math.random(#LOADOUT_OPTIONS)
&#9;until not selectedIndicies[index]
&#9;selectedIndicies[index] = true
&#9;loadoutString = loadoutString .. (loadoutString == &apos;&apos; and &apos;&apos; or LOADOUT_DELIMETER) .. LOADOUT_OPTIONS[index]
end

LoadoutObject.Value = loadoutString
DataReadyEvent:Fire()
</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX559">
						<Properties>
							<string name="Name">WaitForDataReady</string>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX560">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">7</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX561">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX562">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">6883353</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX563">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Enchilada</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Script" referent="RBX564">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Enchilada</string>
						<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local STARTING_TOOL_NAMES = {
&#9;&apos;Sword&apos;,
&#9;&apos;Superball&apos;,
&#9;&apos;Slingshot&apos;,
&#9;&apos;Bomb&apos;,
&#9;&apos;RocketLauncher&apos;,
&#9;&apos;Reflector&apos;
}

local GUI_NAME = script.Parent.Name .. &apos;AlertGui&apos;
local GUI_LABEL_NAME = &apos;AlertLabel&apos;
local GUI_LABEL_SIZE = UDim2.new(0, 250, 0, 30)
local GUI_LABEL_POSITION = UDim2.new(0.5, -125, 1, 15)

local GUI_TWEEN_TARGET = UDim2.new(0.5, -125, 1, -145)
local GUI_TWEEN_TIME = 0.5 -- (Both ways)
local GUI_DISPLAY_TIME = 3

-----------------
--| Variables |--
-----------------

local LightingService = Game:GetService(&apos;Lighting&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)

local WeaponDataModel = LightingService:WaitForChild(&apos;WeaponData&apos;)

local GameOverEvent = script:WaitForChild(&apos;GameOver&apos;)

local StartingLoadout = {}
local BaseAlertGui = nil

-----------------
--| Functions |--
-----------------

local function MakeBaseAlertGui()
&#9;local alertGui = Instance.new(&apos;ScreenGui&apos;)
&#9;alertGui.Name = GUI_NAME
&#9;local frame = Instance.new(&apos;Frame&apos;)
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;frame.Parent = alertGui
&#9;local alertLabel = Instance.new(&apos;TextLabel&apos;)
&#9;alertLabel.Name = GUI_LABEL_NAME
&#9;alertLabel.BackgroundTransparency = 1
&#9;alertLabel.Position = GUI_LABEL_POSITION
&#9;alertLabel.Size = GUI_LABEL_SIZE
&#9;alertLabel.Font = Enum.Font.ArialBold
&#9;alertLabel.FontSize = Enum.FontSize.Size36
&#9;alertLabel.TextStrokeColor3 = Color3.new(240/255, 1, 250/255)
&#9;alertLabel.TextStrokeTransparency = 0
&#9;alertLabel.Parent = frame
&#9;return alertGui
end

local function Alert(playerGui, alertText)
&#9;local alertGui = playerGui:FindFirstChild(GUI_NAME)
&#9;if alertGui then
&#9;&#9;local frame = alertGui:FindFirstChild(&apos;Frame&apos;)
&#9;&#9;if frame then
&#9;&#9;&#9;local alertLabel = frame:FindFirstChild(GUI_LABEL_NAME)
&#9;&#9;&#9;if alertLabel then
&#9;&#9;&#9;&#9;alertLabel.Position = GUI_LABEL_POSITION
&#9;&#9;&#9;&#9;alertLabel.Text = alertText
&#9;&#9;&#9;&#9;alertLabel:TweenPosition(GUI_TWEEN_TARGET, Enum.EasingDirection.Out, Enum.EasingStyle.Back, GUI_TWEEN_TIME, true, function()
&#9;&#9;&#9;&#9;&#9;if alertLabel.Position == GUI_TWEEN_TARGET then
&#9;&#9;&#9;&#9;&#9;&#9;wait(GUI_DISPLAY_TIME)
&#9;&#9;&#9;&#9;&#9;&#9;if alertGui.Parent == playerGui then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;alertLabel:TweenPosition(GUI_LABEL_POSITION, Enum.EasingDirection.In, Enum.EasingStyle.Back, GUI_TWEEN_TIME, false)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- When a player dies, if they had only 1 Tool left, give them another
local function OnDied(player, loadout, backpack)
&#9;if #loadout == 1 then
&#9;&#9;local lastTool = loadout[1]
&#9;&#9;local randomTool = nil
&#9;&#9;repeat
&#9;&#9;&#9;randomTool = StartingLoadout[math.random(#StartingLoadout)]
&#9;&#9;until randomTool.Name ~= lastTool.Name
&#9;&#9;table.insert(loadout, randomTool)
&#9;&#9;randomTool:Clone().Parent = backpack -- Just for show

&#9;&#9;-- Signal for an alert to be given upon respawn
&#9;&#9;local alertOnRespawn = Instance.new(&apos;Model&apos;)
&#9;&#9;alertOnRespawn.Name = &apos;AlertOnRespawn&apos;
&#9;&#9;alertOnRespawn.Parent = player
&#9;end
end

local function RemoveTool(target, toolName)
&#9;local targetTool = target:FindFirstChild(toolName)
&#9;if targetTool then
&#9;&#9;targetTool.Parent = LightingService
&#9;&#9;DebrisService:AddItem(targetTool, 1)
&#9;end
end

local function OnFragsChanged(player, loadoutTool, loadout, playerGui)
&#9;-- Destroy the Tool in question
&#9;if player.Character then
&#9;&#9;RemoveTool(player.Character, loadoutTool.Name)
&#9;end
&#9;local backpack = player:WaitForChild(&apos;Backpack&apos;)
&#9;RemoveTool(backpack, loadoutTool.Name)

&#9;-- Then remove the loadoutTool from the loadout
&#9;for i, toolInLoadout in ipairs(loadout) do
&#9;&#9;if toolInLoadout == loadoutTool then
&#9;&#9;&#9;table.remove(loadout, i)
&#9;&#9;&#9;if #loadout == 0 then -- We have a winner!
&#9;&#9;&#9;&#9;GameOverEvent:Fire(player)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end

&#9;local toolCount = #loadout
&#9;Alert(playerGui, toolCount .. &quot; weapon&quot; .. (toolCount ~= 1 and &apos;s&apos; or &apos;&apos;) .. &quot; left!&quot;)
end

local function OnCharacterAdded(player, character, loadout, playerGui)
&#9;-- Give this player their loadout
&#9;local backpack = player:WaitForChild(&apos;Backpack&apos;)
&#9;for _, tool in ipairs(loadout) do
&#9;&#9;tool:Clone().Parent = backpack
&#9;end

&#9;-- Share the total for Autoequip
&#9;local toolCountObject = Instance.new(&apos;IntValue&apos;)
&#9;toolCountObject.Name = &apos;ToolCount&apos;
&#9;toolCountObject.Value = #loadout
&#9;toolCountObject.Parent = character

&#9;-- Connect to Died
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;humanoid.Died:connect(function()
&#9;&#9;OnDied(player, loadout, backpack)
&#9;end)

&#9;-- Recreate the alert GUI
&#9;BaseAlertGui:Clone().Parent = playerGui

&#9;-- Check for respawn alert signal
&#9;local alertOnRespawn = player:FindFirstChild(&apos;AlertOnRespawn&apos;)
&#9;if alertOnRespawn then
&#9;&#9;alertOnRespawn:Destroy()
&#9;&#9;local toolCount = #loadout
&#9;&#9;Alert(playerGui, &quot;Denied! &quot; .. toolCount .. &quot; weapon&quot; .. (toolCount ~= 1 and &apos;s&apos; or &apos;&apos;) .. &quot; left!&quot;)
&#9;end
end

local function OnPlayerAdded(player)
&#9;if player then
&#9;&#9;local playerGui = player:WaitForChild(&apos;PlayerGui&apos;)

&#9;&#9;-- Give them the starting loadout and connect to their WeaponFrags
&#9;&#9;local loadout = {}
&#9;&#9;local weaponFragsModel = player:WaitForChild(&apos;WeaponFrags&apos;)
&#9;&#9;for i, tool in ipairs(StartingLoadout) do
&#9;&#9;&#9;local weaponFragsObject = weaponFragsModel:WaitForChild(tool.Name)
&#9;&#9;&#9;weaponFragsObject.Changed:connect(function()
&#9;&#9;&#9;&#9;OnFragsChanged(player, tool, loadout, playerGui)
&#9;&#9;&#9;end)
&#9;&#9;&#9;loadout[i] = tool
&#9;&#9;end

&#9;&#9;-- Connect to all characters, future and present
&#9;&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;&#9;OnCharacterAdded(player, character, loadout, playerGui)
&#9;&#9;end)
&#9;&#9;if player.Character then
&#9;&#9;&#9;OnCharacterAdded(player, player.Character, loadout, playerGui)
&#9;&#9;end
&#9;end
end

--------------------
--| Script Logic |--
--------------------

-- Get the weapons for the starting loadout
for _, toolName in pairs(STARTING_TOOL_NAMES) do
&#9;local weaponData = WeaponDataModel:FindFirstChild(toolName)
&#9;if weaponData then
&#9;&#9;local tool = weaponData:FindFirstChild(toolName)
&#9;&#9;if tool then
&#9;&#9;&#9;table.insert(StartingLoadout, tool)
&#9;&#9;end
&#9;end
end

BaseAlertGui = MakeBaseAlertGui()

-- Connect to all players, future and present
PlayersService.PlayerAdded:connect(OnPlayerAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end
</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX565">
						<Properties>
							<string name="Name">GameOver</string>
						</Properties>
					</Item>
				</Item>
				<Item class="IntValue" referent="RBX566">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">8</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX567">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX568">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">116657355</int>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX569">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Juggernaut</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Script" referent="RBX570">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Juggernaut</string>
							<ProtectedString name="Source">function WaitForValidCharacter(player)
&#9;local character = player.Character
&#9;if not character or not character.Parent or not character:FindFirstChild(&apos;Humanoid&apos;) or character.Humanoid.Health &lt;= 0 then
&#9;&#9;player.CharacterAdded:wait()
&#9;&#9;wait(0) --NOTE: Necessary for server scripts executing on the same event
&#9;&#9;character = player.Character
&#9;end
&#9;return character,character.Humanoid
end

function ShakeFrame(frame,length,intensity)
&#9;print(&quot;shakeframe:&quot;,intensity,length)
&#9;local startTime= tick()
&#9;local startPos = frame.Position
&#9;local startSize = frame.Size
&#9;while tick()-startTime &lt;length do
&#9;&#9;frame.Position=UDim2.new(startPos.X.Scale,startPos.X.Offset+((math.random()*2-1)*intensity),
&#9;&#9;&#9;startPos.Y.Scale,startPos.Y.Offset+((math.random()*2-1)*intensity))
&#9;&#9;wait()
&#9;end
&#9;frame.Position = startPos
&#9;frame.Size = startSize 
end

-----------------
--| Singleton Classes |--
-----------------
local AlertGui =
{
&#9;GUI_NAME = script.Parent.Name .. &apos;AlertGui&apos;,
&#9;GUI_LABEL_NAME = &apos;AlertLabel&apos;,
&#9;GUI_LABEL_SIZE = UDim2.new(0, 250, 0, 30),
&#9;GUI_LABEL_POSITION = UDim2.new(0.5, -125, 1, 15),
&#9;GUI_TWEEN_TARGET = UDim2.new(0.5, -125, 1, -145),
&#9;GUI_TWEEN_TIME = 0.5, -- (Both ways)
&#9;GUI_DISPLAY_TIME = 3,
&#9;
&#9;BaseAlertGui = nil,
}

do

&#9;function AlertGui:InitBaseAlertGui()
&#9;&#9;local alertGui = Instance.new(&apos;ScreenGui&apos;)
&#9;&#9;alertGui.Name = self.GUI_NAME
&#9;&#9;local frame = Instance.new(&apos;Frame&apos;)
&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.Parent = alertGui
&#9;&#9;local alertLabel = Instance.new(&apos;TextLabel&apos;)
&#9;&#9;alertLabel.Name = self.GUI_LABEL_NAME
&#9;&#9;alertLabel.BackgroundTransparency = 1
&#9;&#9;alertLabel.Position = self.GUI_LABEL_POSITION
&#9;&#9;alertLabel.Size = self.GUI_LABEL_SIZE
&#9;&#9;alertLabel.Font = Enum.Font.ArialBold
&#9;&#9;alertLabel.FontSize = Enum.FontSize.Size36
&#9;&#9;alertLabel.TextStrokeColor3 = Color3.new(240/255, 1, 250/255)
&#9;&#9;alertLabel.TextStrokeTransparency = 0
&#9;&#9;alertLabel.Parent = frame
&#9;&#9;self.BaseAlertGui = alertGui
&#9;end
&#9;
&#9;function AlertGui:Alert(playerGui, alertText)
&#9;&#9;local alertGui = playerGui:FindFirstChild(self.GUI_NAME)
&#9;&#9;if alertGui then
&#9;&#9;&#9;local frame = alertGui:FindFirstChild(&apos;Frame&apos;)
&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;local alertLabel = frame:FindFirstChild(self.GUI_LABEL_NAME)
&#9;&#9;&#9;&#9;if alertLabel then
&#9;&#9;&#9;&#9;&#9;alertLabel.Position = self.GUI_LABEL_POSITION
&#9;&#9;&#9;&#9;&#9;alertLabel.Text = alertText
&#9;&#9;&#9;&#9;&#9;alertLabel:TweenPosition(self.GUI_TWEEN_TARGET, Enum.EasingDirection.Out, Enum.EasingStyle.Back, self.GUI_TWEEN_TIME, true, function()
&#9;&#9;&#9;&#9;&#9;&#9;if alertLabel.Position == self.GUI_TWEEN_TARGET then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(self.GUI_DISPLAY_TIME)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if alertGui.Parent == playerGui then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;alertLabel:TweenPosition(self.GUI_LABEL_POSITION, Enum.EasingDirection.In, Enum.EasingStyle.Back, self.GUI_TWEEN_TIME, false)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

end


local JuggernautMode = 
{
&#9;LightingService = Game:GetService(&apos;Lighting&apos;),
&#9;PlayersService = Game:GetService(&apos;Players&apos;),
&#9;DebrisService = Game:GetService(&apos;Debris&apos;),
&#9;TeamsService = Game:GetService(&apos;Teams&apos;),
&#9;RocketLauncher =Game.Lighting:WaitForChild(&apos;WeaponData&apos;):WaitForChild(&apos;RocketLauncher&apos;):WaitForChild(&apos;RocketLauncher&apos;), 
&#9;Players = {},
&#9;Juggernaut = nil,
&#9;PlayerTeam = nil,
&#9;JuggernautTeam = nil,
&#9;JuggernautHat = game:GetService(&quot;InsertService&quot;):LoadAsset(69939573),
&#9;LastJuggArrow = {}
}
do
&#9;function JuggernautMode:DisplayJuggernautMesg(player)
&#9;&#9;local thisJuggernaut = self.Juggernaut&#9;&#9;
&#9;&#9;if player ~= thisJuggernaut then
&#9;&#9;&#9;AlertGui:Alert(player.PlayerGui, self.Juggernaut.Name ..&quot; IS THE JUGGERNAUT!&quot;)
&#9;&#9;else
&#9;&#9;&#9;AlertGui:Alert(player.PlayerGui, &quot;YOU ARE THE JUGGERNAUT!&quot;)
&#9;&#9;end
&#9;end
&#9;-- When a player dies, if they were the juggernaut, assign the juggernaut to someone else
&#9;function JuggernautMode:OnDied(player,humanoid)
&#9;&#9;if self.Juggernaut == player then
&#9;&#9;&#9;local killer = humanoid:FindFirstChild(&apos;creator&apos;)
&#9;&#9;&#9;
&#9;&#9;&#9;for _,i in pairs(self.LastJuggArrow) do
&#9;&#9;&#9;&#9;i:Destroy()
&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;self.LastJuggArrow = {}
&#9;&#9;&#9;if killer and killer.Value ~= player then
&#9;&#9;&#9;&#9;self:MakeJuggernaut(killer.Value)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;self:RandomizeJuggernaut(player)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;-- Signal for an alert to be given upon respawn
&#9;&#9;&#9;local alertOnRespawn = Instance.new(&apos;Model&apos;)
&#9;&#9;&#9;alertOnRespawn.Name = &apos;AlertOnRespawn&apos;
&#9;&#9;&#9;alertOnRespawn.Parent = player
&#9;&#9;&#9;for _,i in pairs(self.Players) do
&#9;&#9;&#9;&#9;if i~=player then
&#9;&#9;&#9;&#9;&#9;Spawn(function() self:DisplayJuggernautMesg(i) end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function JuggernautMode:OnCharacterAdded(player, character,  playerGui)

&#9;&#9;-- Connect to Died
&#9;&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;&#9;humanoid.Died:connect(function()
&#9;&#9;&#9;self:OnDied(player,humanoid)
&#9;&#9;end)
&#9;
&#9;&#9;-- Recreate the alert GUI
&#9;&#9;AlertGui.BaseAlertGui:Clone().Parent = playerGui
&#9;
&#9;&#9;-- Check for respawn alert signal
&#9;&#9;local alertOnRespawn = player:FindFirstChild(&apos;AlertOnRespawn&apos;)
&#9;&#9;if alertOnRespawn then
&#9;&#9;&#9;alertOnRespawn:Destroy()
&#9;&#9;&#9;Spawn(function() self:DisplayJuggernautMesg(player) end)
&#9;&#9;&#9;--AlertGui:Alert(playerGui, &quot;Denied! &quot; .. toolCount .. &quot; weapon&quot; .. (toolCount ~= 1 and &apos;s&apos; or &apos;&apos;) .. &quot; left!&quot;)
&#9;&#9;end
&#9;end
&#9;
&#9;function JuggernautMode:OnPlayerAdded(player)
&#9;&#9;if player then
&#9;&#9;&#9;local playerGui = player:WaitForChild(&apos;PlayerGui&apos;)
&#9;&#9;&#9;table.insert(self.Players,player)
&#9;&#9;&#9;-- Connect to all characters, future and present
&#9;&#9;&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;&#9;&#9;self:OnCharacterAdded(player, character, playerGui)
&#9;&#9;&#9;end)
&#9;&#9;&#9;if player.Character then
&#9;&#9;&#9;&#9;self:OnCharacterAdded(player, player.Character, playerGui)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function JuggernautMode:AddJuggernautArrow(part)
&#9;&#9;local shaft = Instance.new(&apos;Part&apos;)
&#9;&#9;shaft.FormFactor = &apos;Custom&apos;
&#9;&#9;shaft.Size = Vector3.new(.2,.2,.2)
&#9;&#9;shaft.BrickColor = BrickColor.new(&apos;Bright red&apos;)
&#9;&#9;shaft.Parent = part.Parent
&#9;&#9;shaft.CanCollide = false
&#9;&#9;local tweld = Instance.new(&apos;Weld&apos;)
&#9;&#9;tweld.Part0 = part
&#9;&#9;tweld.Part1 = shaft
&#9;&#9;tweld.Parent = part
&#9;&#9;local shaftMesh = Instance.new(&apos;CylinderMesh&apos;)
&#9;&#9;shaftMesh.Scale = Vector3.new(5,1200,5)
&#9;&#9;shaftMesh.Offset = Vector3.new(0,127,0)
&#9;&#9;shaftMesh.Parent = shaft
&#9;&#9;table.insert(self.LastJuggArrow,shaft)
&#9;&#9;for i=1,5,1 do
&#9;&#9;&#9;local tpart = shaft:Clone()
&#9;&#9;&#9;tpart.Parent = part.Parent
&#9;&#9;&#9;tweld = Instance.new(&apos;Weld&apos;)
&#9;&#9;&#9;tweld.Part0 = part
&#9;&#9;&#9;tweld.Part1 = tpart
&#9;&#9;&#9;tweld.Parent = part
&#9;&#9;&#9;local tMesh = Instance.new(&apos;CylinderMesh&apos;)
&#9;&#9;&#9;tMesh.Scale = Vector3.new(2+(i*3),3,2+(i*3))
&#9;&#9;&#9;tMesh.Offset = Vector3.new(0,5+(.5*i),0)
&#9;&#9;&#9;tMesh.Parent = tpart
&#9;&#9;&#9;table.insert(self.LastJuggArrow,tpart)
&#9;&#9;end
&#9;&#9;
&#9;end
&#9;
&#9;function JuggernautMode:MakeJuggernaut(player)
&#9;&#9;if self.Juggernaut then
&#9;&#9;&#9;self.Juggernaut.TeamColor = self.PlayerTeam.TeamColor
&#9;&#9;end
&#9;&#9;self.Juggernaut = player
&#9;&#9;
&#9;&#9;local character, humanoid = WaitForValidCharacter(player)
&#9;&#9;
&#9;&#9;humanoid.MaxHealth = 200
&#9;&#9;humanoid.Health = 200
&#9;&#9;
&#9;&#9;local torso = character:WaitForChild(&apos;Torso&apos;)
&#9;&#9;local head = character:WaitForChild(&apos;Head&apos;)
&#9;&#9;self:AddJuggernautArrow(torso)
&#9;&#9;
&#9;&#9;local rocket = self.RocketLauncher:Clone()
&#9;&#9;rocket.Parent = game.Workspace
&#9;&#9;humanoid:EquipTool(rocket) 
&#9;&#9;
&#9;&#9;player.TeamColor = self.JuggernautTeam.TeamColor
&#9;&#9;
&#9;&#9;local jugHat = self.JuggernautHat:GetChildren()[1]:Clone()
&#9;&#9;local hatPart = jugHat:WaitForChild(&apos;Handle&apos;)
&#9;&#9;hatPart.Name = &apos;JugHat&apos;
&#9;&#9;hatPart.Parent = character
&#9;&#9;hatPart:WaitForChild(&apos;Mesh&apos;).Scale = Vector3.new(1.4,1.4,1.4)
&#9;&#9;
&#9;&#9;table.insert(self.LastJuggArrow,hatPart)
&#9;&#9;
&#9;&#9;local tweld = Instance.new(&apos;Weld&apos;)
&#9;&#9;tweld.Part0 = head
&#9;&#9;tweld.Part1 = hatPart
&#9;&#9;tweld.Parent = head
&#9;&#9;tweld.C0 = CFrame.new(Vector3.new(0,.1,-.2))
&#9;&#9;
&#9;&#9;for _, i in pairs(character:GetChildren()) do
&#9;&#9;&#9;if i:IsA(&apos;Hat&apos;) then i:Destroy() end
&#9;&#9;end
&#9;&#9;
&#9;&#9;
&#9;end&#9;
&#9;
&#9;function JuggernautMode:RandomizeJuggernaut(ignorePlayer)
&#9;&#9;while #self.Players==0 do wait() end
&#9;&#9;if #self.Players ==1 then
&#9;&#9;&#9;self:MakeJuggernaut(self.Players[1])
&#9;&#9;else
&#9;&#9;&#9;local nJuggernaut = nil
&#9;&#9;&#9;repeat
&#9;&#9;&#9;&#9;nJuggernaut = self.Players[math.random(#self.Players)]
&#9;&#9;&#9;until nJuggernaut~=ignorePlayer
&#9;&#9;&#9;self:MakeJuggernaut(nJuggernaut)
&#9;&#9;end
&#9;end
&#9;function JuggernautMode:OnPlayerRemoved(player)
&#9;&#9;for index, i in pairs(self.Players) do
&#9;&#9;&#9;if i== player then
&#9;&#9;&#9;&#9;table.remove(self.Players,index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if player == self.Juggernaut then
&#9;&#9;&#9;self:RandomizeJuggernaut()
&#9;&#9;&#9;
&#9;&#9;&#9;for _,i in pairs(self.Players) do
&#9;&#9;&#9;&#9;Spawn(function() self:DisplayJuggernautMesg(i) end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function JuggernautMode:InitTeams()
&#9;&#9;self.PlayerTeam = Instance.new(&apos;Team&apos;)
&#9;&#9;self.PlayerTeam.TeamColor = BrickColor.new(&apos;Deep blue&apos;)
&#9;&#9;self.PlayerTeam.Name = &quot;Players&quot;
&#9;&#9;self.PlayerTeam.Parent = self.TeamsService
&#9;&#9;self.JuggernautTeam = Instance.new(&apos;Team&apos;)
&#9;&#9;self.JuggernautTeam.TeamColor = BrickColor.new(&apos;Bright red&apos;)
&#9;&#9;self.JuggernautTeam.Name = &quot;JUGGERNAUT!&quot;
&#9;&#9;self.JuggernautTeam.AutoAssignable= false&#9;&#9;
&#9;&#9;self.JuggernautTeam.Parent = self.TeamsService
&#9;&#9;
&#9;&#9;
&#9;&#9;for _,i in pairs(self.PlayersService:GetPlayers()) do
&#9;&#9;&#9;i.TeamColor = self.PlayerTeam.TeamColor
&#9;&#9;&#9;i.Neutral = false 
&#9;&#9;end
&#9;end
&#9;function JuggernautMode:InitEvents()
&#9;&#9;self.PlayersService.PlayerAdded:connect(function(nplayer)self:OnPlayerAdded(nplayer) end)
&#9;&#9;for _, player in pairs(self.PlayersService:GetPlayers()) do
&#9;&#9;&#9;self:OnPlayerAdded(player)
&#9;&#9;end
&#9;&#9;self.PlayersService.ChildRemoved:connect(function(player) self:OnPlayerRemoved(player) end)
&#9;end
end

--------------------
--| Script Logic |--
--------------------
AlertGui:InitBaseAlertGui()
JuggernautMode:InitTeams()
JuggernautMode:InitEvents()
wait(5)
JuggernautMode:RandomizeJuggernaut()
for _,i in pairs(JuggernautMode.Players) do
&#9;Spawn(function() JuggernautMode:DisplayJuggernautMesg(i) end)
end

</ProtectedString>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX571">
						<Properties>
							<string name="Name">TitleImageId</string>
							<int name="Value">12</int>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX572">
						<Properties>
							<string name="Name">Loadout</string>
							<string name="Value">Sword, Superball, Slingshot</string>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX573">
						<Properties>
							<string name="Name">IconImageId</string>
							<int name="Value">117429774</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX574">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">TeamDeathmatch</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="BoolValue" referent="RBX575">
					<Properties>
						<string name="Name">TeamsEnabled</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX576">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value">Sword, Superball, Slingshot, Bomb, RocketLauncher, Reflector</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX577">
					<Properties>
						<string name="Name">PaidWeaponsEnabled</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX578">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">10</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX579">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">116657387</int>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX580">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">BackBlast</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX581">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">14</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX582">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX583">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">117416328</int>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX584">
					<Properties>
						<string name="Name">TeamsEnabled</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX585">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BackBlast</string>
						<ProtectedString name="Source">--Stickmasterluke





local LightingService = Game:GetService(&apos;Lighting&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)
local WeaponDataModel = LightingService:WaitForChild(&apos;WeaponData&apos;)
local GameOverEvent = script:WaitForChild(&apos;GameOver&apos;)

local TeamTools={}

TeamTools[&quot;Bright blue&quot;]={
&#9;WeaponDataModel:WaitForChild(&quot;Reflector&quot;),
}
TeamTools[&quot;Bright red&quot;]={
&#9;WeaponDataModel:WaitForChild(&quot;RocketLauncher&quot;),
}



local function OnCharacterAdded(player,character)
&#9;if player and character then
&#9;&#9;local backpack=player:WaitForChild(&quot;Backpack&quot;)
&#9;&#9;local tools=TeamTools[player.TeamColor.Name]
&#9;&#9;if tools then
&#9;&#9;&#9;for _,tool in ipairs(tools) do
&#9;&#9;&#9;&#9;local tool2=tool:FindFirstChild(tool.Name)
&#9;&#9;&#9;&#9;if tool2 then
&#9;&#9;&#9;&#9;&#9;tool2:clone().Parent=backpack
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnPlayerAdded(player)
&#9;if player then
&#9;&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;&#9;OnCharacterAdded(player,character)
&#9;&#9;end)
&#9;&#9;if player.Character then
&#9;&#9;&#9;OnCharacterAdded(player,player.Character)
&#9;&#9;end
&#9;end
end


PlayersService.PlayerAdded:connect(OnPlayerAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end





</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX586">
						<Properties>
							<string name="Name">GameOver</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX587">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">SwordSwept</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX588">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">13</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX589">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX590">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">117411183</int>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX591">
					<Properties>
						<string name="Name">TeamsEnabled</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX592">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SwordSwept</string>
						<ProtectedString name="Source">--Stickmasterluke





local LightingService = Game:GetService(&apos;Lighting&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)
local WeaponDataModel = LightingService:WaitForChild(&apos;WeaponData&apos;)
local GameOverEvent = script:WaitForChild(&apos;GameOver&apos;)

local TeamTools={}

TeamTools[&quot;Bright blue&quot;]={
&#9;WeaponDataModel:WaitForChild(&quot;Sword&quot;),
}
TeamTools[&quot;Bright red&quot;]={
&#9;WeaponDataModel:WaitForChild(&quot;Broom&quot;),
}



local function OnCharacterAdded(player,character)
&#9;if player and character then
&#9;&#9;local backpack=player:WaitForChild(&quot;Backpack&quot;)
&#9;&#9;local tools=TeamTools[player.TeamColor.Name]
&#9;&#9;if tools then
&#9;&#9;&#9;for _,tool in ipairs(tools) do
&#9;&#9;&#9;&#9;local tool2=tool:FindFirstChild(tool.Name)
&#9;&#9;&#9;&#9;if tool2 then
&#9;&#9;&#9;&#9;&#9;tool2:clone().Parent=backpack
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function OnPlayerAdded(player)
&#9;if player then
&#9;&#9;player.CharacterAdded:connect(function(character)
&#9;&#9;&#9;OnCharacterAdded(player,character)
&#9;&#9;end)
&#9;&#9;if player.Character then
&#9;&#9;&#9;OnCharacterAdded(player,player.Character)
&#9;&#9;end
&#9;end
end


PlayersService.PlayerAdded:connect(OnPlayerAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
&#9;OnPlayerAdded(player)
end





</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX593">
						<Properties>
							<string name="Name">GameOver</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX594">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Lobby</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX595">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">9</int>
					</Properties>
				</Item>
				<Item class="Tool" referent="RBX596">
					<Properties>
						<bool name="CanBeDropped">true</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Vote</string>
						<Content name="TextureId"><null></null></Content>
						<string name="ToolTip"></string>
					</Properties>
					<Item class="Motor" referent="RBX597">
						<Properties>
							<CoordinateFrame name="C0">
								<X>-0.900001526</X>
								<Y>-1.26999855</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<CoordinateFrame name="C1">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="DesiredAngle">0</float>
							<float name="MaxVelocity">0</float>
							<string name="Name">Motor</string>
							<Ref name="Part0">RBX598</Ref>
							<Ref name="Part1">RBX599</Ref>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX598">
						<Properties>
							<bool name="Anchored">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">24</int>
							<CoordinateFrame name="CFrame">
								<X>0.100000001</X>
								<Y>3.30000019</Y>
								<Z>21.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Flag</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1.79999995</X>
								<Y>1.39999986</Y>
								<Z>0.200000003</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX599">
						<Properties>
							<bool name="Anchored">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>-0.800000012</X>
								<Y>2.03000021</Y>
								<Z>21.9000015</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Handle</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>0.400000006</X>
								<Y>4</Y>
								<Z>0.400000006</Z>
							</Vector3>
						</Properties>
						<Item class="CylinderMesh" referent="RBX600">
							<Properties>
								<float name="Bevel">0</float>
								<float name="Bevel Roundness">0</float>
								<float name="Bulge">0</float>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.75</X>
									<Y>1</Y>
									<Z>0.75</Z>
								</Vector3>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX601">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">ExplodeSound</string>
								<float name="Pitch">2</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=78535292</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX602">
							<Properties>
								<bool name="Looped">false</bool>
								<string name="Name">TickSound</string>
								<float name="Pitch">1</float>
								<bool name="PlayOnRemove">false</bool>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=106543491</url></Content>
								<float name="Volume">0.5</float>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX603">
							<Properties>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Script</string>
								<ProtectedString name="Source">--Stickmasterluke

--Why am I doing this you may ask. Sounds will not get played if Play() is called in the same instant as the sound is created. Why am I not just waiting in the tool? Because the tool is removed when the flag is placed.


sp=script.Parent

wait()

local sound=sp:FindFirstChild(&quot;TickSound&quot;)
if sound then
&#9;sound:Play()
end

</ProtectedString>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX604">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=74897796</url></Content>
							<string name="Name">OverHeadSwing</string>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX605">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LocalScript</string>
							<ProtectedString name="Source">--Made by Stickmasterluke


sp=script.Parent


check=true


local anim=sp:WaitForChild(&quot;PlantAnim&quot;)


local flagpart=sp:WaitForChild(&quot;Flag&quot;)
colors={&quot;Bright red&quot;,&quot;Bright blue&quot;,&quot;Royal purple&quot;,&quot;Bright yellow&quot;}
flagpart.BrickColor=BrickColor.new(colors[math.random(1,#colors)])



function checkintangible(hit)
&#9;if hit and hit~=nil then
&#9;&#9;if hit:IsDescendantOf(sp.Parent) or hit.Transparency&gt;.8 or hit.Name==&quot;Handle&quot; or hit.Name==&quot;Post&quot; or hit.Name==&quot;Flag&quot; or string.lower(string.sub(hit.Name,1,6))==&quot;effect&quot; or hit.Parent:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

function castray(startpos,vec,length,ignore)
&#9;local hit,endpos=game.Workspace:FindPartOnRay(Ray.new(startpos,vec*length),ignore)
&#9;if hit~=nil then
&#9;&#9;if checkintangible(hit) then
&#9;&#9;&#9;hit,endpos=castray(endpos+(vec*.01),vec,length-((startpos-endpos).magnitude),ignore)
&#9;&#9;end
&#9;end
&#9;return hit,endpos
end


sp.Equipped:connect(function(mouse)
&#9;if mouse~=nil then
&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;local h=sp.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;local t=sp.Parent:FindFirstChild(&quot;Torso&quot;) 
&#9;&#9;&#9;if check and h and h.Health&gt;0 and t then
&#9;&#9;&#9;&#9;check=false
&#9;&#9;&#9;&#9;local animation=h:LoadAnimation(anim)
&#9;&#9;&#9;&#9;animation:Play(nil,nil,.5)
&#9;&#9;&#9;&#9;wait(1)
&#9;&#9;&#9;&#9;if t and h and h.Health&gt;0 then
&#9;&#9;&#9;&#9;&#9;local hit,endpos=castray(t.Position,(t.CFrame.lookVector+Vector3.new(0,-1,0)).unit,5,t.Parent)
&#9;&#9;&#9;&#9;&#9;if hit and hit~=nil then
&#9;&#9;&#9;&#9;&#9;&#9;local tag=hit:FindFirstChild(&quot;VotePad&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;if tag and tag.Value then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local m=Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;m.Name=&quot;Flag&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local p1=sp.Handle:clone()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local ns=p1:FindFirstChild(&quot;Script&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ns then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ns.Disabled=false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p1.Name=&quot;Post&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p1.CanCollide=true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cf=CFrame.new(endpos+Vector3.new((math.random()-.5)*.2,p1.Size.y*.5,(math.random()-.5)*.2))*CFrame.Angles(0,math.random(),0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p1.CFrame=cf
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p1.Parent=m
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local w1=Instance.new(&quot;Motor&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w1.Part0=hit
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w1.Part1=p1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w1.C0=hit.CFrame:toObjectSpace(cf)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w1.Parent=p1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local p2=flagpart:clone()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p2.CanCollide=false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;p2.Parent=m
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local w2=Instance.new(&quot;Motor&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w2.Part0=p1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w2.Part1=p2
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w2.C0=CFrame.new(((p2.Size.x+p1.Size.x)*.5)-.1,((p1.Size.y-p2.Size.y)*.5)-.05,0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;w2.Parent=p2
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;m.Parent=hit
&#9;&#9;&#9;&#9;&#9;&#9;&#9;sp:remove()
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Failed and hit&quot;,hit)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Swing Batter!&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(1)
&#9;&#9;&#9;&#9;check=true
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end)


</ProtectedString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX606">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=74897796</url></Content>
							<string name="Name">PlantAnim</string>
						</Properties>
					</Item>
				</Item>
				<Item class="Script" referent="RBX607">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Lobby</string>
						<ProtectedString name="Source">--Stickmasterluke


local LightingService = Game:GetService(&apos;Lighting&apos;)
local TeamService = Game:WaitForChild(&apos;Teams&apos;)
local Debris=Game:GetService(&quot;Debris&quot;)

local Maps = LightingService:WaitForChild(&apos;MapData&apos;)
local GameTypes = LightingService:WaitForChild(&apos;GameTypes&apos;)

local Lobby
repeat 
&#9;Lobby=game.Workspace:WaitForChild(&quot;CurrentLevel&quot;):GetChildren()[1]
&#9;wait()
until Lobby

local Board1=Lobby:WaitForChild(&quot;Board1&quot;)
local TeamDoors = Lobby:WaitForChild(&apos;TeamDoors&apos;)
local TeamZones=Lobby:WaitForChild(&quot;TeamZones&quot;)
local EmergencyLights = Lobby:WaitForChild(&apos;EmergencyLights&apos;)
local CeilingLights=Lobby:WaitForChild(&quot;CeilingLights&quot;)
local LightsOutSound=script:WaitForChild(&quot;LightsOutSound&quot;)
local BoomSelectSound=Board1:WaitForChild(&quot;Board&quot;):WaitForChild(&quot;BoomSelectSound&quot;)

local VotingCompleteEvent = script:WaitForChild(&apos;GameOver&apos;)

local CloneFlag=script.Parent:WaitForChild(&quot;Vote&quot;)
local CloneFlagPart1=CloneFlag:WaitForChild(&quot;Handle&quot;)
local CloneFlagPart2=CloneFlag:WaitForChild(&quot;Flag&quot;)
CloneFlagPart1.Anchored=false
CloneFlagPart2.Anchored=false
CloneFlag.Parent=nil

local AssetLink=&quot;http://www.roblox.com/asset/?id=&quot;
local NumberImages={
&#9;[0]=1073255,
&#9;[1]=1073257,
&#9;[2]=1073259,
&#9;[3]=1073261,
&#9;[4]=1073263,
&#9;[5]=1073265,
&#9;[6]=1073267,
&#9;[7]=1073269,
&#9;[8]=1073271,
&#9;[9]=1073273,
}
local RoundImage1=116652078
local RoundImage2=116652295

local ChooseTeamImage = 116782920

local VoteTime=30
local rate=1/30
local DoorDebounce=true

local TeamData={
&#9;{Name=&quot;Blue Bloxers&quot;,Color=&quot;Bright blue&quot;,IsOpen=false,Players={},TeamObject=nil,Index=1},
&#9;{Name=&quot;Red Raiders&quot;,Color=&quot;Bright red&quot;,IsOpen=false,Players={},TeamObject=nil,Index=2},
}

local function GetRandom(myTable, excludeName)
&#9;local result = nil
&#9;repeat
&#9;&#9;result = myTable[math.random(1,#myTable)]
&#9;until result.Name ~= excludeName
&#9;return result
end

function GiveVotes(Player)
&#9;while true do
&#9;&#9;if Player==nil then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;if Player.Character~=nil and Player.Character.Parent==game.Workspace and Player:FindFirstChild(&quot;Backpack&quot;)~=nil then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;wait()
&#9;end
&#9;if Player~=nil then
&#9;&#9;local Backpack=Player:FindFirstChild(&quot;Backpack&quot;)
&#9;&#9;if Backpack then
&#9;&#9;&#9;if Player.MembershipType~=Enum.MembershipType.None or Player.Name==&quot;Player1&quot; then
&#9;&#9;&#9;&#9;CloneFlag:clone().Parent=Backpack
&#9;&#9;&#9;&#9;CloneFlag:clone().Parent=Backpack
&#9;&#9;&#9;&#9;CloneFlag:clone().Parent=Backpack
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

for _,Player in pairs(game.Players:GetPlayers()) do
&#9;GiveVotes(Player)
end
game.Players.PlayerAdded:connect(GiveVotes)



function UpdateTimer(Timer)
&#9;local TimerDidget1=math.floor(Timer*.1)
&#9;local TimerDidget2=Timer%10
&#9;TimerDidget1=(TimerDidget1&gt;0 and TimerDidget1) or lol
&#9;if Timer&lt;0 then
&#9;&#9;TimerDidget1=nil
&#9;&#9;TimerDidget2=nil
&#9;end
&#9;Board1.BoardTimer1.Decal.Texture=(TimerDidget1 and AssetLink..tostring(NumberImages[TimerDidget1])) or &quot;&quot;
&#9;Board1.BoardTimer2.Decal.Texture=(TimerDidget2 and AssetLink..tostring(NumberImages[TimerDidget2])) or &quot;&quot;
end

function FindChoice(RoundNumber)
&#9;local map=GetRandom(Maps:GetChildren(),&apos;Lobby&apos;)
&#9;local modes={}
&#9;for word in map.GameTypes.Value:gmatch(&apos;%w+&apos;) do
&#9;&#9;local mode=GameTypes:FindFirstChild(word)
&#9;&#9;if mode then
&#9;&#9;&#9;local TeamsEnabled=mode:FindFirstChild(&quot;TeamsEnabled&quot;) and mode:FindFirstChild(&quot;TeamsEnabled&quot;).Value
&#9;&#9;&#9;if ((TeamsEnabled and RoundNumber==1) or ((not TeamsEnabled) and RoundNumber~=1)) and mode.Name~=&quot;Lobby&quot; then
&#9;&#9;&#9;&#9;table.insert(modes,mode)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if #modes&lt;1 then
&#9;&#9;return
&#9;end
&#9;return map,modes[math.random(1,#modes)]
end

function RunVote(RoundNumber)
&#9;local Choices={}
&#9;for i=1,3 do
&#9;&#9;while true do
&#9;&#9;&#9;local map,mode=FindChoice(RoundNumber)
&#9;&#9;&#9;if map and mode then
&#9;&#9;&#9;&#9;local found=false
&#9;&#9;&#9;&#9;for _,Choice in ipairs(Choices) do
&#9;&#9;&#9;&#9;&#9;if Choice.Map==map and Choice.Mode==mode then
&#9;&#9;&#9;&#9;&#9;&#9;found=true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not found then
&#9;&#9;&#9;&#9;&#9;table.insert(Choices,{
&#9;&#9;&#9;&#9;&#9;&#9;Map=map,
&#9;&#9;&#9;&#9;&#9;&#9;Mode=mode,
&#9;&#9;&#9;&#9;&#9;&#9;Pad=Lobby:WaitForChild(&quot;VotePad&quot;..tostring(i)),
&#9;&#9;&#9;&#9;&#9;&#9;PadMode=Lobby:WaitForChild(&quot;PadMode&quot;..tostring(i))
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;Choices[i].Pad.Decal.Texture=AssetLink..tostring(Choices[i].Map.ImageId.Value)
&#9;&#9;Choices[i].PadMode.Decal.Texture=AssetLink..tostring(Choices[i].Mode.IconImageId.Value)
&#9;&#9;Choices[i].Pad.VotePad.Value=true
&#9;end
&#9;Board1.Board.Decal.Texture=AssetLink..tostring(RoundImage1)
&#9;Board1.BoardRoundNumber.Decal.Texture=AssetLink..tostring(NumberImages[RoundNumber])
&#9;for i=0,VoteTime do
&#9;&#9;Timer=VoteTime-i
&#9;&#9;UpdateTimer(Timer)
&#9;&#9;wait(1)
&#9;end
&#9;local Timer=-1
&#9;UpdateTimer(Timer)
&#9;Board1.Board.Decal.Texture=AssetLink..tostring(RoundImage2)
&#9;Board1.BoardRoundNumber.Decal.Texture=&quot;&quot;
&#9;for _,Choice in ipairs(Choices) do
&#9;&#9;Choice.Pad.VotePad.Value=false
&#9;end
&#9;wait(1)
&#9;Votes={}
&#9;for _,Choice in pairs(Choices) do
&#9;&#9;for _,Flag in pairs(Choice.Pad:GetChildren()) do
&#9;&#9;&#9;if Flag~=nil and Flag.className==&quot;Model&quot; and Flag.Name==&quot;Flag&quot; then
&#9;&#9;&#9;&#9;table.insert(Votes,Flag)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;while #Votes&gt;1 do
&#9;&#9;local VoteToDie=math.random(1,#Votes)
&#9;&#9;local Explosion=Instance.new(&quot;Explosion&quot;)
&#9;&#9;Explosion.BlastRadius=5
&#9;&#9;Explosion.BlastPressure=0
&#9;&#9;Explosion.Position=Votes[VoteToDie]:GetModelCFrame().p
&#9;&#9;Explosion.Parent=game.Workspace
&#9;&#9;Debris:AddItem(Votes[VoteToDie],1.5)
&#9;&#9;local VoteHandle=Votes[VoteToDie]:FindFirstChild(&quot;Post&quot;)
&#9;&#9;if VoteHandle then
&#9;&#9;&#9;local ExplodeSound=VoteHandle:FindFirstChild(&quot;ExplodeSound&quot;)
&#9;&#9;&#9;if ExplodeSound then
&#9;&#9;&#9;&#9;ExplodeSound:Play()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;Votes[VoteToDie]:BreakJoints()
&#9;&#9;for _,Part in pairs(Votes[VoteToDie]:GetChildren()) do
&#9;&#9;&#9;if Part:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;Part.CanCollide=false
&#9;&#9;&#9;&#9;Part.Velocity=Vector3.new(math.random()-.5,1+math.random(),math.random()-.5)*20
&#9;&#9;&#9;&#9;Part.RotVelocity=Vector3.new(math.random()-.5,math.random()-.5,math.random()-.5)*20
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;table.remove(Votes,VoteToDie)
&#9;&#9;wait(1)
&#9;end
&#9;local WinningChoice=Choices[math.random(1,#Choices)]
&#9;if #Votes&gt;0 and Votes[1] and Votes[1].Parent~=nil then
&#9;&#9;WinningChoice=Choices[tonumber(string.sub(Votes[1].Parent.Name,8))]
&#9;end
&#9;BoomSelectSound:Play()
&#9;local SelectionBox=Instance.new(&quot;SelectionBox&quot;)
&#9;SelectionBox.Parent=Lobby
&#9;SelectionBox.Color=BrickColor.new(&quot;Toothpaste&quot;)
&#9;SelectionBox.Adornee=WinningChoice.Pad
&#9;for i=1,6 do
&#9;&#9;wait(.5)
&#9;&#9;SelectionBox.Visible=not SelectionBox.Visible
&#9;end
&#9;wait(2)
&#9;SelectionBox:remove()
&#9;for _,Choice in pairs(Choices) do
&#9;&#9;for _,Flag in pairs(Choice.Pad:GetChildren()) do
&#9;&#9;&#9;if Flag~=nil and Flag.className==&quot;Model&quot; and Flag.Name==&quot;Flag&quot; then
&#9;&#9;&#9;&#9;Flag:remove()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;Choice.Pad.Decal.Texture=&quot;&quot;
&#9;&#9;Choice.PadMode.Decal.Texture=&quot;&quot;
&#9;end
&#9;Board1.Board.Decal.Texture=&quot;&quot;
&#9;wait(5)
&#9;return WinningChoice
end

function UpdateDoor(TeamNumber)
&#9;local Door=TeamDoors:FindFirstChild(&quot;Door&quot;..tostring(TeamNumber))
&#9;local Handle=TeamDoors:FindFirstChild(&quot;Handle&quot;..tostring(TeamNumber))
&#9;local Block=TeamDoors:FindFirstChild(&quot;Block&quot;..tostring(TeamNumber))
&#9;local Team=TeamData[TeamNumber]
&#9;if Door and Handle and Block and Team then
&#9;&#9;if Team.IsOpen then
&#9;&#9;&#9;Door.CFrame=((Block.CFrame*CFrame.new(0,0,(-Door.Size.z*.5)+(Door.Size.x*.5)))*CFrame.Angles(0,-math.pi*.618,0))*CFrame.new(0,0,(Door.Size.z*.5)-(Door.Size.x*.5))
&#9;&#9;else
&#9;&#9;&#9;Door.CFrame=Block.CFrame
&#9;&#9;end
&#9;&#9;Handle.CFrame=Door.CFrame*CFrame.new(0,-.5,((Door.Size.z-Handle.Size.z)*.5)+.1)
&#9;end
end

function CheckInZone(pos,zone)
&#9;if pos.x&gt;zone.Position.x-(zone.Size.x*.5) and pos.x&lt;zone.Position.x+(zone.Size.x*.5) then
&#9;&#9;if pos.y&gt;zone.Position.y-(zone.Size.y*.5) and pos.y&lt;zone.Position.y+(zone.Size.y*.5) then
&#9;&#9;&#9;if pos.z&gt;zone.Position.z-(zone.Size.z*.5) and pos.z&lt;zone.Position.z+(zone.Size.z*.5) then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function UpdateTeams()
&#9;if AllowTeamChange then
&#9;&#9;for _,Team in ipairs(TeamData) do
&#9;&#9;&#9;Team.Players={}
&#9;&#9;end
&#9;&#9;local Players=game.Players:GetPlayers()
&#9;&#9;for _,Player in pairs(Players) do
&#9;&#9;&#9;local Character=Player.Character
&#9;&#9;&#9;if Character then
&#9;&#9;&#9;&#9;local Torso=Character:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;if Torso then
&#9;&#9;&#9;&#9;&#9;for _,Zone in ipairs(TeamZones:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;if CheckInZone(Torso.Position,Zone) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local ZoneNumber=tonumber(string.sub(Zone.Name,5))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ZoneNumber then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.insert(TeamData[ZoneNumber].Players,Player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for TeamIndex,Team in ipairs(TeamData) do
&#9;&#9;&#9;if AllowTeamChange then
&#9;&#9;&#9;&#9;Team.IsOpen=#Team.Players&lt;#Players*.5
&#9;&#9;&#9;&#9;UpdateDoor(TeamIndex)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function StartTeamAssignment()
&#9;for CurrentZ=1,3 do
&#9;&#9;LightsOutSound.Pitch=.7
&#9;&#9;LightsOutSound.Volume=1
&#9;&#9;LightsOutSound:Play()
&#9;&#9;for _,LightPart in pairs(CeilingLights:GetChildren()) do
&#9;&#9;&#9;local Light=LightPart:FindFirstChild(&quot;SpotLight&quot;)
&#9;&#9;&#9;if Light and Light.Enabled then
&#9;&#9;&#9;&#9;local _,LightZStart=string.find(LightPart.Name,&quot;-&quot;)
&#9;&#9;&#9;&#9;local LightZ=nil
&#9;&#9;&#9;&#9;if LightZStart then
&#9;&#9;&#9;&#9;&#9;LightZ=tonumber(string.sub(LightPart.Name,LightZStart+1))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if LightZ and math.abs(LightZ-4.5)&gt;(4-CurrentZ) then
&#9;&#9;&#9;&#9;&#9;Light.Enabled=false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(1)
&#9;end
&#9;wait(1)
&#9;for _,Light in pairs(EmergencyLights:GetChildren()) do
&#9;&#9;local LightSwitch=Light:FindFirstChild(&quot;Toggle&quot;)
&#9;&#9;if LightSwitch then
&#9;&#9;&#9;LightSwitch.Value=true
&#9;&#9;end
&#9;end
&#9;wait(1)
&#9;AllowTeamChange=true
&#9;for TeamIndex,Team in ipairs(TeamData) do
&#9;&#9;local TeamObj=Instance.new(&quot;Team&quot;)
&#9;&#9;TeamObj.TeamColor=BrickColor.new(Team.Color)
&#9;&#9;TeamObj.AutoAssignable=false
&#9;&#9;TeamObj.Name=Team.Name
&#9;&#9;TeamObj.Parent=TeamService
&#9;&#9;Team.TeamObject=TeamObj
&#9;&#9;local Block=TeamDoors:WaitForChild(&quot;Block&quot;..tostring(TeamIndex))
&#9;&#9;Block.Touched:connect(function(hit)
&#9;&#9;&#9;if hit and hit.Parent and DoorDebounce and AllowTeamChange then
&#9;&#9;&#9;&#9;DoorDebounce=false
&#9;&#9;&#9;&#9;local Humanoid=hit.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;local Torso=hit.Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;local Player=game.Players:GetPlayerFromCharacter(hit.Parent)
&#9;&#9;&#9;&#9;local DebounceTag=hit.Parent:FindFirstChild(&quot;TeamDoorDebounceTag&quot;)
&#9;&#9;&#9;&#9;if Humanoid and Player and Torso and DebounceTag==nil then
&#9;&#9;&#9;&#9;&#9;if Player.Neutral then
&#9;&#9;&#9;&#9;&#9;&#9;if Team.IsOpen then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player.TeamColor=BrickColor.new(Team.Color)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player.Neutral=false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Torso.CFrame=(Torso.CFrame-Torso.Position)+(Block.CFrame*CFrame.new(3,0,0)).p
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local DebounceTag=Instance.new(&quot;BoolValue&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;DebounceTag.Name=&quot;TeamDoorDebounceTag&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Debris:AddItem(DebounceTag,2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;DebounceTag.Parent=hit.Parent
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Player slams face into a closed door.
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;Player.Neutral=true
&#9;&#9;&#9;&#9;&#9;&#9;Torso.CFrame=(Torso.CFrame-Torso.Position)+(Block.CFrame*CFrame.new(-3,0,0)).p
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;UpdateTeams()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;delay(.1,function()
&#9;&#9;&#9;&#9;&#9;DoorDebounce=true
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
&#9;UpdateTeams()
&#9;wait(1)
&#9;for CurrentX=1,15 do
&#9;&#9;LightsOutSound.Pitch=.9
&#9;&#9;LightsOutSound.Volume=.5
&#9;&#9;LightsOutSound:Play()
&#9;&#9;for _,LightPart in pairs(CeilingLights:GetChildren()) do
&#9;&#9;&#9;local Light=LightPart:FindFirstChild(&quot;SpotLight&quot;)
&#9;&#9;&#9;if Light and Light.Enabled then
&#9;&#9;&#9;&#9;local LightXEnd,_=string.find(LightPart.Name,&quot;-&quot;)
&#9;&#9;&#9;&#9;local LightX=nil
&#9;&#9;&#9;&#9;if LightXEnd then
&#9;&#9;&#9;&#9;&#9;LightX=tonumber(string.sub(LightPart.Name,13,LightXEnd-1))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if LightX and LightX&lt;=CurrentX then
&#9;&#9;&#9;&#9;&#9;Light.Enabled=false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(2)
&#9;end
end

function EndTeamAssignment()
&#9;AllowTeamChange=false
&#9;wait(.1)
&#9;for _,Light in pairs(EmergencyLights:GetChildren()) do
&#9;&#9;local LightSwitch=Light:FindFirstChild(&quot;Toggle&quot;)
&#9;&#9;if LightSwitch then
&#9;&#9;&#9;LightSwitch.Value=false
&#9;&#9;end
&#9;end
&#9;for TeamIndex,Team in ipairs(TeamData) do
&#9;&#9;if Team.TeamObject~=nil then
&#9;&#9;&#9;Team.TeamObject.AutoAssignable=true
&#9;&#9;end
&#9;&#9;Team.Players={}
&#9;&#9;Team.IsOpen=false
&#9;&#9;UpdateDoor(TeamIndex)
&#9;end
&#9;local NeutralPlayers={}
&#9;local Players=game.Players:GetChildren()
&#9;for _,Player in ipairs(Players) do
&#9;&#9;local FoundTeam=nil
&#9;&#9;if not Player.Neutral then
&#9;&#9;&#9;for _,Team in ipairs(TeamData) do
&#9;&#9;&#9;&#9;if Player.TeamColor==BrickColor.new(Team.Color) then
&#9;&#9;&#9;&#9;&#9;FoundTeam=Team
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if FoundTeam then
&#9;&#9;&#9;table.insert(FoundTeam.Players,Player)
&#9;&#9;else
&#9;&#9;&#9;table.insert(NeutralPlayers,Player)
&#9;&#9;end
&#9;end
&#9;while #NeutralPlayers&gt;0 do
&#9;&#9;RandomNumber=math.random(1,#NeutralPlayers)
&#9;&#9;local Player=NeutralPlayers[RandomNumber]
&#9;&#9;if Player then
&#9;&#9;&#9;local LowestTeam=TeamData[1]
&#9;&#9;&#9;for TeamIndex,Team in ipairs(TeamData) do
&#9;&#9;&#9;&#9;if #Team.Players&lt;#LowestTeam.Players or (math.random()&gt;.5 and #Team.Players==#LowestTeam.Players) then
&#9;&#9;&#9;&#9;&#9;LowestTeam=Team
&#9;&#9;&#9;&#9;&#9;Team.Index=TeamIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(LowestTeam.Players,Player)
&#9;&#9;&#9;Player.TeamColor=BrickColor.new(LowestTeam.Color)
&#9;&#9;&#9;Player.Neutral=false
&#9;&#9;&#9;local Character=Player.Character
&#9;&#9;&#9;local Zone=TeamZones:FindFirstChild(&quot;Zone&quot;..tostring(LowestTeam.Index))
&#9;&#9;&#9;if Character and Zone then
&#9;&#9;&#9;&#9;local Torso=Character:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;if Torso then
&#9;&#9;&#9;&#9;&#9;Torso.CFrame=Zone.CFrame*CFrame.new(Zone.Size.x*(math.random()-.5)*.8,(-Zone.Size.y*.5)+4,Zone.Size.z*(math.random()-.5)*.8)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;table.remove(NeutralPlayers,RandomNumber)
&#9;end
end


for TeamIndex,Team in ipairs(TeamData) do
&#9;UpdateDoor(TeamIndex)
end
wait(15)
Round1=RunVote(1)
Round2=RunVote(2)
Round3=RunVote(3)
StartTeamAssignment()
wait(5)
EndTeamAssignment()
wait(5)





VotingCompleteEvent:Fire(
&#9;Round1.Mode,
&#9;Round1.Map,
&#9;Round2.Mode,
&#9;Round2.Map,
&#9;Round3.Mode,
&#9;Round3.Map
)



</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX608">
						<Properties>
							<string name="Name">GameOver</string>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX609">
						<Properties>
							<bool name="Looped">false</bool>
							<string name="Name">LightsOutSound</string>
							<float name="Pitch">0.699999988</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>http://www.roblox.com/asset/?id=117336841</url></Content>
							<float name="Volume">1</float>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX610">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RocketRace</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="IntValue" referent="RBX611">
					<Properties>
						<string name="Name">IconImageId</string>
						<int name="Value">11223895</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX612">
					<Properties>
						<string name="Name">Loadout</string>
						<string name="Value">RocketLauncher, Sword</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX613">
					<Properties>
						<string name="Name">PaidWeaponsEnabled</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX614">
					<Properties>
						<string name="Name">TitleImageId</string>
						<int name="Value">11</int>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX615">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RocketRace</string>
						<ProtectedString name="Source">--============================================================================--
--==                            Preliminary Setup                           ==--
--============================================================================--
local RbxUtility = LoadLibrary(&apos;RbxUtility&apos;)
local Create = RbxUtility.Create

-- game data model where we store client/server shared data
local DataModel = script.Parent:WaitForChild(&apos;GameData&apos;)


--============================================================================--
--==                          Level Generation Stuff                        ==--
--============================================================================--

-- data about the player capturing
local CaptureLength = 30
local CaptureTimeLeft = CaptureLength
local CurrentCapturer;
local CurrentCaptureStartedAt;

-- the end of the level
local LevelEnd;

-- how to play the game
local LevelExpiryTime = 4*60 -- how long to wait before the level starts falling 
                             -- appart
local LevelExpiryDuration = 1*60 - 9 -- how long between starting and finishing 
                                     -- the expiry destruction of the level.

--============================================================================--
--==                          Level Generation Stuff                        ==--
--============================================================================--
-- data model
local CurrentLevelModel = DataModel:WaitForChild(&apos;CurrentLevel&apos;)
local MainCamFocusValue = CurrentLevelModel:WaitForChild(&apos;MainCamFocus&apos;)
local LevelModelValue = CurrentLevelModel:WaitForChild(&apos;LevelModel&apos;)

-- level settings
local AvailableColorList = {21, 23, 104, 24, 28, 106}
local LevelOrigin = Vector3.new(0, 0, 0)
local LevelBaseRadius = 100
local LevelTopRadius = 20
local LevelHeight = 500
local LevelSlantOffset = 500
local LevelPartCount = 1400

-- hints for generator
local JumpableHeight = 10
local JumpableGap = 15 

-- parts to use
local EndPartAsset = Create&apos;Part&apos;{
&#9;Name = &apos;EndPart&apos;;
&#9;TopSurface = &apos;Smooth&apos;;
&#9;BottomSurface = &apos;Smooth&apos;;
&#9;FormFactor = &apos;Custom&apos;;
&#9;Size = Vector3.new(10, 1, 10);
&#9;BrickColor = BrickColor.new(&apos;Really black&apos;);
&#9;Material = &apos;Foil&apos;;
&#9;Anchored = true;
&#9;Locked = true;
&#9;Create&apos;Fire&apos;{
&#9;&#9;Color = Color3.new(0,0,0);
&#9;&#9;SecondaryColor = Color3.new(0,0,0);
&#9;&#9;Size = 14;
&#9;&#9;Heat = 4;
&#9;};
&#9;Create&apos;Sparkles&apos;{
&#9;&#9;Color = Color3.new(0,0,0);
&#9;};
}
local LevelPartAsset = Create&apos;Part&apos;{
&#9;Name = &apos;LevelPart&apos;;
&#9;TopSurface = &apos;Smooth&apos;;
&#9;BottomSurface = &apos;Smooth&apos;;
&#9;FormFactor = &apos;Custom&apos;;
&#9;Material = &apos;Slate&apos;;
&#9;Anchored = true;
&#9;Locked = true;
}
local SpawnPartAsset = Create&apos;Part&apos;{
&#9;Name = &apos;LevelPart&apos;;
&#9;TopSurface = &apos;Universal&apos;;
&#9;FormFactor = &apos;Custom&apos;;
&#9;Material = &apos;Plastic&apos;;
&#9;Anchored = true;
&#9;Locked = true;&#9;&#9;
}

-- utility: 
local function rand(a, b)
&#9;return a + math.random()*b
end

-- main generation function
function GenerateLevel(numPlayers)
&#9;-- data we store throughout generation
&#9;local spawnPoints = {}
&#9;local otherParts = {}
&#9;
&#9;-- make the level model
&#9;LevelModel = Workspace:WaitForChild(&apos;CurrentLevel&apos;):WaitForChild(&apos;Model&apos;)

&#9;-- where the top of the level is
&#9;local topOfLevelAt = LevelOrigin + Vector3.new(0, LevelHeight, LevelSlantOffset)
&#9;
&#9;-- add a protection color to a given part
&#9;local function AddProtect(part)
&#9;&#9;Create&apos;BrickColorValue&apos;{
&#9;&#9;&#9;Parent = part;
&#9;&#9;&#9;Name = &apos;ProtectionColor&apos;;
&#9;&#9;&#9;Value = part.BrickColor;
&#9;&#9;}
&#9;end
&#9;local function RocketDestructible(part)
&#9;&#9;Create&apos;BoolValue&apos;{
&#9;&#9;&#9;Parent = part;
&#9;&#9;&#9;Name = &apos;RocketDestructible&apos;;
&#9;&#9;&#9;Value = true;
&#9;&#9;}
&#9;end

&#9;-- generate spawns
&#9;local baseCFrame = CFrame.new(LevelOrigin)
&#9;for i = 1, numPlayers do
&#9;&#9;local spawn = SpawnPartAsset:Clone()
&#9;&#9;spawn.Size = Vector3.new(30, 2, 30)
&#9;&#9;spawn.CFrame = baseCFrame * 
&#9;&#9;               CFrame.Angles(0, -math.pi/2 + math.pi/numPlayers*i, 0) * 
&#9;&#9;               CFrame.new(0, 45+rand(-0.1,0.1), -(LevelBaseRadius-10))
&#9;&#9;spawn.Parent = LevelModel
&#9;&#9;spawn.BrickColor = BrickColor.new(AvailableColorList[(i-1)%(#AvailableColorList)+1]);
&#9;&#9;AddProtect(spawn)
&#9;&#9;spawnPoints[#spawnPoints+1] = spawn
&#9;end 

&#9;-- generate the main parts
&#9;for partNum = 1, LevelPartCount do
&#9;&#9;local heightFraction = (partNum / LevelPartCount)
&#9;&#9;local height = heightFraction*LevelHeight
&#9;&#9;--
&#9;&#9;local radius = LevelBaseRadius*(1-heightFraction) + LevelTopRadius*heightFraction
&#9;&#9;local position = LevelOrigin*(1-heightFraction) + topOfLevelAt*heightFraction
&#9;&#9;--
&#9;&#9;-- now place a platform randomly within that
&#9;&#9;radius = radius - rand(0, 1.5*rand(-radius*0.5, radius*1.5))
&#9;&#9;position = Vector3.new(position.x, math.max(1, position.y + rand(-4,4)), position.z)
&#9;&#9;--
&#9;&#9;local part = LevelPartAsset:Clone()
&#9;&#9;part.Size = Vector3.new(rand(4,8), rand(2,5), rand(4,8)) * (((LevelTopRadius*2.1/LevelBaseRadius)*heightFraction) + (1-heightFraction)) * 2.8
&#9;&#9;part.CFrame = CFrame.new(position) * 
&#9;&#9;              CFrame.Angles(0, rand(0, math.pi*2), 0) * 
&#9;&#9;              CFrame.new(0, 0, -radius) * 
&#9;&#9;              CFrame.Angles(rand(-0.5,0.5), rand(0,math.pi*2), rand(-0.5,0.5))
&#9;&#9;part.Parent = LevelModel
&#9;&#9;otherParts[#otherParts+1] = part

&#9;&#9;-- mark as destructible
&#9;&#9;RocketDestructible(part)
&#9;end

&#9;-- the goal:
&#9;LevelEnd = EndPartAsset:Clone()
&#9;LevelEnd.Position = topOfLevelAt + Vector3.new(0, 2, 0)
&#9;LevelEnd.Parent = LevelModel

&#9;-- the cam focust point, in the middle of the level
&#9;MainCamFocusValue.Value = Create&apos;Part&apos;{
&#9;&#9;Name = &apos;LevelCamFocusPart&apos;;
&#9;&#9;Parent = LevelModel;
&#9;&#9;FormFactor = &apos;Custom&apos;;
&#9;&#9;Size = Vector3.new(0.1, 0.1, 0.1);
&#9;&#9;Transparency = 1;
&#9;&#9;Anchored = true;
&#9;&#9;Locked = true;
&#9;&#9;CanCollide = false;
&#9;&#9;CFrame = CFrame.new((LevelOrigin + topOfLevelAt)/2);
&#9;}

&#9;-- othercolor candidates
&#9;local otherColorCandidates = {}
&#9;for _, part in pairs(otherParts) do
&#9;&#9;local hFrac = (part.Position.y - LevelOrigin.y) / LevelHeight
&#9;&#9;if math.random() &gt; hFrac then
&#9;&#9;&#9;otherColorCandidates[#otherColorCandidates+1] = part
&#9;&#9;end
&#9;end

&#9;-- color the special parts around the map
&#9;for times = 1, LevelPartCount/math.max(numPlayers,4)/2 do
&#9;&#9;for _, spawn in pairs(spawnPoints) do
&#9;&#9;&#9;if #otherColorCandidates &gt; 0 then
&#9;&#9;&#9;&#9;-- color some blocks for that spawn color
&#9;&#9;&#9;&#9;local pnum = math.random(1, #otherColorCandidates)
&#9;
&#9;&#9;&#9;&#9;-- add protect
&#9;&#9;&#9;&#9;otherColorCandidates[pnum].BrickColor = spawn.BrickColor
&#9;&#9;&#9;&#9;AddProtect(otherColorCandidates[pnum])
&#9;
&#9;&#9;&#9;&#9;-- remove that from the remaining ones
&#9;&#9;&#9;&#9;table.remove(otherColorCandidates, pnum)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;return spawnPoints
end


--============================================================================--
--==                     Global Message Interface                           ==--
--============================================================================--
do
&#9;local GlobalMessageData = DataModel:WaitForChild(&apos;GlobalMessage&apos;)
&#9;local TextValue = GlobalMessageData:WaitForChild(&apos;Text&apos;)
&#9;local MaximizedValue = GlobalMessageData:WaitForChild(&apos;Maximized&apos;)
&#9;function MinimizeGlobalMessage()
&#9;&#9;MaximizedValue.Value = false
&#9;end
&#9;function MaximizeGlobalMessage()
&#9;&#9;MaximizedValue.Value = true
&#9;end
&#9;function SetGlobalMessageText(text)
&#9;&#9;TextValue.Value = text
&#9;end
end


--============================================================================--
--==                           Character Setup                              ==--
--============================================================================--
local SpawnsForPlayer = {}

function SetupCharacter(player)&#9;
&#9;-- create a light in the character to light their way
&#9;Create&apos;PointLight&apos;{
&#9;&#9;Parent = player.Character:WaitForChild(&apos;Torso&apos;);
&#9;&#9;Range = 20;
&#9;&#9;Brightness = 1.3;
&#9;}

&#9;-- create a bodyforce in the character to make them lighter
&#9;Create&apos;BodyForce&apos;{
&#9;&#9;Name = &apos;JumperForce&apos;;
&#9;&#9;Parent = player.Character.Torso;
&#9;&#9;force = Vector3.new(0, 0.5*(14*196.2), 0);
&#9;}

&#9;-- make their hats lighter
&#9;local floatedHats = {}
&#9;local function FloatHat(hat)
&#9;&#9;if floatedHats[hat] then return end
&#9;&#9;floatedHats[hat] = true
&#9;&#9;--
&#9;&#9;local handle = hat:WaitForChild(&apos;Handle&apos;)
&#9;&#9;Spawn(function()
&#9;&#9;&#9;hat.Parent = nil
&#9;&#9;&#9;handle.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;handle.Size = Vector3.new(0.2, 0.2, 0.2)
&#9;&#9;&#9;hat.Parent = player.Character
&#9;&#9;end)
&#9;end
&#9;for _, ch in pairs(player.Character:GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Hat&apos;) then
&#9;&#9;&#9;FloatHat(ch)
&#9;&#9;end
&#9;end
&#9;player.Character.ChildAdded:connect(function(ch)
&#9;&#9;if ch:IsA(&apos;Hat&apos;) then
&#9;&#9;&#9;FloatHat(ch)
&#9;&#9;end
&#9;end)
&#9;
&#9;-- spawn touch handling
&#9;local leg1 = player.Character:WaitForChild(&apos;Right Leg&apos;)
&#9;local leg2 = player.Character:WaitForChild(&apos;Left Leg&apos;)
&#9;local function onLegTouched(hit)
&#9;&#9;if hit:FindFirstChild(&apos;ProtectionColor&apos;) and hit.ProtectionColor.Value == player.TeamColor then
&#9;&#9;&#9;-- add to the list of spawns
&#9;&#9;&#9;if not SpawnsForPlayer[player][hit] then
&#9;&#9;&#9;&#9;-- show a points event about the checkpoint. If it&apos;s the highest they reached,
&#9;&#9;&#9;&#9;-- or not, vary the message.
&#9;&#9;&#9;&#9;local isHighest = true
&#9;&#9;&#9;&#9;for spawn, _ in pairs(SpawnsForPlayer[player]) do
&#9;&#9;&#9;&#9;&#9;if spawn.Position.y &gt; hit.Position.y then
&#9;&#9;&#9;&#9;&#9;&#9;isHighest = false
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;SpawnsForPlayer[player][hit] = true
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local pointsEvent = player:WaitForChild(&apos;otherstats&apos;):WaitForChild(&apos;GotPointsAtLocation&apos;)
&#9;&#9;&#9;&#9;pointsEvent.Location.Value = player.Character:WaitForChild(&apos;Torso&apos;).Position
&#9;&#9;&#9;&#9;if isHighest then
&#9;&#9;&#9;&#9;&#9;pointsEvent.Points.Value = &quot;New checkpoint height reached!&quot;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pointsEvent.Points.Value = &quot;Checkpoint Added&quot;
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;pointsEvent.Value = not pointsEvent.Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;leg1.Touched:connect(onLegTouched)
&#9;leg2.Touched:connect(onLegTouched)

&#9;-- create the character protector script that grants protection
&#9;-- while on a block
&#9;local sc = script:WaitForChild(&apos;CharacterProtector&apos;):Clone()
&#9;sc.Parent = player.Character
&#9;sc.Disabled = false

&#9;-- create a fire in the player to show their color
&#9;local colorFire = Create&apos;Fire&apos;{
&#9;&#9;Name = &apos;ColorFire&apos;;
&#9;&#9;Parent = player.Character:WaitForChild(&apos;Head&apos;);
&#9;&#9;Color = player.TeamColor.Color;
&#9;&#9;SecondaryColor = player.TeamColor.Color;
&#9;&#9;Size = 7;
&#9;&#9;Heat = 11;
&#9;}
end

local cnList = {}
for _, player in pairs(game.Players:GetChildren()) do
&#9;-- add to list
&#9;SpawnsForPlayer[player] = {}
&#9;
&#9;-- setup respawning setup
&#9;cnList[player.Changed:connect(function(pr)
&#9;&#9;if pr == &apos;Character&apos; and player.Character then
&#9;&#9;&#9;SetupCharacter(player)
&#9;&#9;end
&#9;end)] = true
end


--============================================================================--
--==                     Main function to play a round                      ==--
--============================================================================--
function PlayRound()
&#9;-- hide the message to start out
&#9;MinimizeGlobalMessage()

&#9;-- get the players that will be playing
&#9;local players = game.Players:GetChildren()
&#9;local alivePlayerCount = #players
&#9;
&#9;-- make a set of the players
&#9;local playerSet = {}
&#9;for _, p in pairs(players) do
&#9;&#9;playerSet[p] = true
&#9;end
&#9;
&#9;-- when a player leaves, we need to make them not alive, and
&#9;-- stop tracking them.
&#9;game.Players.ChildRemoved:connect(function(p)
&#9;&#9;if playerSet[p] then
&#9;&#9;&#9;playerSet[p] = nil
&#9;&#9;&#9;alivePlayerCount = alivePlayerCount - 1
&#9;&#9;end
&#9;end)
&#9;
&#9;-- when a player enters, we need to give them the spectating
&#9;-- camera script.
&#9;game.Players.ChildAdded:connect(function(p)
&#9;&#9;-- spawn a character momentarily to get rid of the loading character screen
&#9;&#9;local characterRemoved = false
&#9;&#9;local cn = p.Changed:connect(function(pr)
&#9;&#9;&#9;if pr == &apos;Character&apos; and p.Character then
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;p.Character:Destroy()
&#9;&#9;&#9;&#9;characterRemoved = true
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;p:LoadCharacter()
&#9;&#9;while not characterRemoved do wait() end
&#9;&#9;cn:disconnect()
&#9;&#9;
&#9;&#9;-- give the character the spectate script
&#9;&#9;if not playerSet[p] then
&#9;&#9;&#9;local spectateGui = p:WaitForChild(&apos;PlayerGui&apos;):WaitForChild(&apos;RocketRaceGui&apos;):WaitForChild(&apos;SpectateNext&apos;)
&#9;&#9;&#9;local sc = script:WaitForChild(&apos;SpectateCamera&apos;):Clone()
&#9;&#9;&#9;sc.Parent = spectateGui
&#9;&#9;&#9;sc.Disabled = false
&#9;&#9;end
&#9;end)

&#9;-- generate the level
&#9;local spawnPoints = GenerateLevel(#players)
&#9;
&#9;-- wait until after the &quot;starting round&quot; bit to spawn players
&#9;wait(8) -- this should be accessable somewhere

&#9;-- the winner of the round
&#9;local roundWinner;

&#9;-- start time of the round
&#9;local startTime = tick()
&#9;
&#9;-- wait a bit in the case where there is only one player. We don&apos;t want 
&#9;-- them to win before the game starts waiting for a win event
&#9;if alivePlayerCount &lt;= 1 then
&#9;&#9;wait(2)
&#9;end 

&#9;-- spawn the players in the level
&#9;for _, p in pairs(players) do
&#9;&#9;-- get the spawn point to spawn at
&#9;&#9;local spawn = spawnPoints[#spawnPoints]
&#9;&#9;spawnPoints[#spawnPoints] = nil
&#9;&#9;
&#9;&#9;-- assign the color
&#9;&#9;p.TeamColor = spawn.BrickColor
&#9;&#9;
&#9;&#9;-- function to respawn a player
&#9;&#9;local function Respawn()
&#9;&#9;&#9;-- calculate where to spawn
&#9;&#9;&#9;local candidates = SpawnsForPlayer[p]
&#9;&#9;&#9;local sortedList = {}
&#9;&#9;&#9;for candidate, _ in pairs(candidates) do
&#9;&#9;&#9;&#9;sortedList[#sortedList+1] = candidate
&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;table.sort(sortedList, function(a,b) 
&#9;&#9;&#9;&#9;return a.Position.y &lt; b.Position.y 
&#9;&#9;&#9;end)
&#9;&#9;&#9;local spawnAt;
&#9;&#9;&#9;if #sortedList &gt; 0 then
&#9;&#9;&#9;&#9;spawnAt = sortedList[#sortedList].Position + Vector3.new(0,5,0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;spawnAt = spawn.Position + Vector3.new(0,5,0)&#9;&#9;
&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;-- load character and move it to 
&#9;&#9;&#9;p:LoadCharacter()
&#9;&#9;&#9;while not p.Character do wait() end&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;p.Character:MoveTo(spawnAt)
&#9;&#9;&#9;--p.Character:MoveTo(LevelEnd.Position)

&#9;&#9;&#9;-- respawning
&#9;&#9;&#9;local function onNeedsNewCharacter()&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;wait(2)
&#9;&#9;&#9;&#9;if not roundWinner and (tick()-startTime) &lt; (LevelExpiryTime) then
&#9;&#9;&#9;&#9;&#9;Respawn()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;alivePlayerCount = alivePlayerCount - 1
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- make them a spectator
&#9;&#9;&#9;&#9;&#9;local spectateGui = p:WaitForChild(&apos;PlayerGui&apos;):WaitForChild(&apos;RocketRaceGui&apos;):WaitForChild(&apos;SpectateNext&apos;)
&#9;&#9;&#9;&#9;&#9;local sc = script:WaitForChild(&apos;SpectateCamera&apos;):Clone()
&#9;&#9;&#9;&#9;&#9;sc.Parent = spectateGui
&#9;&#9;&#9;&#9;&#9;sc.Disabled = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;p.Character:WaitForChild(&apos;Humanoid&apos;).Died:connect(function()
&#9;&#9;&#9;&#9;-- get rid of the force in the torso so it does not fly into the air
&#9;&#9;&#9;&#9;if p.Character then
&#9;&#9;&#9;&#9;&#9;local torso = p.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;&#9;&#9;local f = torso:FindFirstChild(&apos;JumperForce&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;if f then f:Destroy() end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- do respawning
&#9;&#9;&#9;&#9;onNeedsNewCharacter()
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;-- initial respawn
&#9;&#9;Respawn()
&#9;end
&#9;
&#9;-- main loop
&#9;while not roundWinner and alivePlayerCount &gt; 1 do
&#9;&#9;local elapsed = (tick() - startTime)
&#9;&#9;if elapsed &gt; LevelExpiryTime + LevelExpiryDuration then
&#9;&#9;&#9;-- level is over, assign the winner
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- handle capturing of the top
&#9;&#9;local parts = game.Workspace:FindPartsInRegion3(Region3.new(LevelEnd.Position - LevelEnd.Size/2,
&#9;&#9;                                                            LevelEnd.Position + LevelEnd.Size/2 + Vector3.new(0, 20, 0)),
&#9;&#9;                                                nil, 1000)
&#9;&#9;local captureCandidates = {}
&#9;&#9;local addedPlayersMap = {}
&#9;&#9;for _, part in pairs(parts) do
&#9;&#9;&#9;if part.Parent and part.Parent:FindFirstChild(&apos;Humanoid&apos;) and part.Parent.Humanoid.Health &gt; 0 then
&#9;&#9;&#9;&#9;local player = game.Players:GetPlayerFromCharacter(part.Parent)
&#9;&#9;&#9;&#9;if player and not addedPlayersMap[player] then
&#9;&#9;&#9;&#9;&#9;addedPlayersMap[player] = true
&#9;&#9;&#9;&#9;&#9;captureCandidates[#captureCandidates+1] = player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;if #captureCandidates == 1 then
&#9;&#9;&#9;local capturer = captureCandidates[1]
&#9;&#9;&#9;if CurrentCapturer == capturer then
&#9;&#9;&#9;&#9;local elapsed = (tick()-CurrentCaptureStartedAt)
&#9;&#9;&#9;&#9;if elapsed &gt; CaptureTimeLeft then
&#9;&#9;&#9;&#9;&#9;roundWinner = capturer
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if CurrentCapturer then
&#9;&#9;&#9;&#9;&#9;CaptureTimeLeft = CaptureTimeLeft - (tick()-CurrentCaptureStartedAt)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;CurrentCapturer = capturer
&#9;&#9;&#9;&#9;CurrentCaptureStartedAt = tick()
&#9;&#9;&#9;end
&#9;&#9;elseif CurrentCapturer then
&#9;&#9;&#9;CurrentCapturer = nil
&#9;&#9;&#9;CaptureTimeLeft = CaptureTimeLeft - (tick()-CurrentCaptureStartedAt)
&#9;&#9;end
&#9;&#9;if CurrentCapturer then
&#9;&#9;&#9;SetGlobalMessageText(CurrentCapturer.Name..&quot; is capturing!\n&quot;..string.format(&quot;%d&quot;, CaptureTimeLeft-(tick()-CurrentCaptureStartedAt))..&quot; seconds remain.&quot;)
&#9;&#9;&#9;MaximizeGlobalMessage()
&#9;&#9;else&#9;
&#9;&#9;&#9;SetGlobalMessageText(string.format(&quot;Capture time remaining:\n%d seconds.&quot;, CaptureTimeLeft))
&#9;&#9;end

&#9;&#9;-- handle expiry of the level
&#9;&#9;if elapsed &gt; LevelExpiryTime then
&#9;&#9;&#9;local expiredPercent = (elapsed - LevelExpiryTime) / LevelExpiryDuration
&#9;&#9;&#9;local cullHeightThreshold = LevelOrigin.y + LevelHeight*expiredPercent
&#9;&#9;&#9;--
&#9;&#9;&#9;Workspace:WaitForChild(&apos;MainGameScript&apos;):WaitForChild(&apos;RoundTimerText&apos;).Value = &quot;Sudden Death!&quot;
&#9;&#9;&#9;--
&#9;&#9;&#9;for _, part in pairs(LevelModel:GetChildren()) do
&#9;&#9;&#9;&#9;if (part.Name == &apos;LevelPart&apos; or part.Name == &apos;SpawnPart&apos;) and 
&#9;&#9;&#9;&#9;&#9;part.Position.y &lt; cullHeightThreshold and 
&#9;&#9;&#9;&#9;&#9;not part:FindFirstChild(&apos;KillBrick&apos;) 
&#9;&#9;&#9;&#9;then 
&#9;&#9;&#9;&#9;&#9;local sc = script:WaitForChild(&apos;KillBrick&apos;):Clone()
&#9;&#9;&#9;&#9;&#9;sc.Parent = part
&#9;&#9;&#9;&#9;&#9;sc.Disabled = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(0.3)
&#9;end
&#9;-- only one player left =&gt; that player is the winner
&#9;if not roundWinner and alivePlayerCount == 1 then
&#9;&#9;for _, player in pairs(players) do
&#9;&#9;&#9;if player.Character and player.Character:FindFirstChild(&apos;Humanoid&apos;) and player.Character.Humanoid.Health &gt; 0 then
&#9;&#9;&#9;&#9;roundWinner = player
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;return roundWinner
end

-- disable normal spawning behavior (will be re-enabled before the next round in the mainscript)
Workspace:WaitForChild(&apos;Spawner&apos;):WaitForChild(&apos;Disable&apos;):Invoke()

-- play the round
local roundWinner = PlayRound()

-- notify of gameover
if roundWinner then
&#9;script:WaitForChild(&apos;GameOver&apos;):Fire(roundWinner)
end</ProtectedString>
					</Properties>
					<Item class="BindableEvent" referent="RBX616">
						<Properties>
							<string name="Name">GameOver</string>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX617">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CharacterProtector</string>
							<ProtectedString name="Source">--============================================================================--
--==                         Global Variables                               ==--
--============================================================================--
local Character = script.Parent
local Torso = Character:WaitForChild(&apos;Torso&apos;)
local Player = game.Players:GetPlayerFromCharacter(Character)
local Fire = Character:WaitForChild(&apos;Head&apos;):WaitForChild(&apos;ColorFire&apos;)
--
local TheForceField = Instance.new(&apos;ForceField&apos;)


--============================================================================--
--==                             Functions                                  ==--
--============================================================================--
function UpdateState()
&#9;local tpos = Torso.Position
&#9;local plist = 
&#9;&#9;game.Workspace:FindPartsInRegion3(Region3.new(tpos-Vector3.new(1,5,1), 
&#9;&#9;                                              tpos+Vector3.new(1,0,1)))
&#9;--
&#9;local protected = false
&#9;for _, part in pairs(plist) do
&#9;&#9;if (part.Name == &apos;LevelPart&apos; or part.Name == &apos;SpawnPart&apos;) and part:FindFirstChild(&apos;ProtectionColor&apos;) then
&#9;&#9;&#9;if Player.TeamColor == part.ProtectionColor.Value then
&#9;&#9;&#9;&#9;protected = true
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;if protected then
&#9;&#9;TheForceField.Parent = Character
&#9;&#9;Fire.Enabled = false
&#9;else
&#9;&#9;TheForceField.Parent = nil
&#9;&#9;Fire.Enabled = true
&#9;end
end


--============================================================================--
--==                             Main loop                                  ==--
--============================================================================--
while true do
&#9;wait()
&#9;UpdateState()
end
</ProtectedString>
						</Properties>
					</Item>
					<Item class="Script" referent="RBX618">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">KillBrick</string>
							<ProtectedString name="Source">local brick = script.Parent

for i = 0, 1, 0.01 do
&#9;wait()
&#9;brick.Transparency = i
end

brick.Anchored = false
brick.CanCollide = false</ProtectedString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX619">
						<Properties>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SpectateCamera</string>
							<ProtectedString name="Source">local Camera = game.Workspace.CurrentCamera
local SpectateButton = script.Parent

local Player = SpectateButton.Parent.Parent.Parent

local CurrentPlayer;
local CurrentPlayerDiedCn;

function UpdateView()
&#9;local spectatable = {}
&#9;local currentIndex;
&#9;for _, p in pairs(game.Players:GetChildren()) do
&#9;&#9;if p.Character and p.Character:FindFirstChild(&apos;Humanoid&apos;) and p.Character.Humanoid.Health &gt; 0 and p ~= Player then
&#9;&#9;&#9;spectatable[#spectatable+1] = p
&#9;&#9;&#9;if p == CurrentPlayer then
&#9;&#9;&#9;&#9;currentIndex = #spectatable
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;if CurrentPlayerDiedCn then
&#9;&#9;CurrentPlayerDiedCn:disconnect()
&#9;&#9;CurrentPlayerDiedCn = nil
&#9;end
&#9;--
&#9;if #spectatable &gt; 0 then
&#9;&#9;if currentIndex and currentIndex &lt; #spectatable then
&#9;&#9;&#9;CurrentPlayer = spectatable[currentIndex + 1]
&#9;&#9;else
&#9;&#9;&#9;CurrentPlayer = spectatable[1]
&#9;&#9;end
&#9;else
&#9;&#9;CurrentPlayer = nil
&#9;end
&#9;--
&#9;if CurrentPlayer then
&#9;&#9;Camera.CameraSubject = CurrentPlayer.Character
&#9;&#9;CurrentPlayerDiedCn = CurrentPlayer.Character.Humanoid.Died:connect(function()
&#9;&#9;&#9;UpdateView()&#9;
&#9;&#9;end)
&#9;else
&#9;&#9;Camera.CameraSubject = Workspace.MainGameScript.CurrentGameType.RocketRace.GameData.CurrentLevel.MainCamFocus.Value
&#9;&#9;Camera.CoordinateFrame = CFrame.new()*CFrame.Angles(0.5, 0, 0)*CFrame.new(0,0,-300)
&#9;end
end

script.Parent.MouseButton1Down:connect(function()
&#9;UpdateView()
end)

script.Parent.Visible = true
UpdateView()

</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="Model" referent="RBX620">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">GameData</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Model" referent="RBX621">
						<Properties>
							<CoordinateFrame name="ModelInPrimary">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">CurrentLevel</string>
							<Ref name="PrimaryPart">null</Ref>
						</Properties>
						<Item class="ObjectValue" referent="RBX622">
							<Properties>
								<string name="Name">MainCamFocus</string>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
						<Item class="ObjectValue" referent="RBX623">
							<Properties>
								<string name="Name">LevelModel</string>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
					</Item>
					<Item class="Model" referent="RBX624">
						<Properties>
							<CoordinateFrame name="ModelInPrimary">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<string name="Name">GlobalMessage</string>
							<Ref name="PrimaryPart">null</Ref>
						</Properties>
						<Item class="StringValue" referent="RBX625">
							<Properties>
								<string name="Name">Text</string>
								<string name="Value"></string>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX626">
							<Properties>
								<string name="Name">Maximized</string>
								<bool name="Value">false</bool>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX627">
					<Properties>
						<string name="Name">DisableSpawning</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="Teams" referent="RBX628">
		<Properties>
			<string name="Name">Teams</string>
		</Properties>
	</Item>
	<Item class="ChangeHistoryService" referent="RBX629">
		<Properties>
			<string name="Name">ChangeHistoryService</string>
		</Properties>
	</Item>
</roblox>